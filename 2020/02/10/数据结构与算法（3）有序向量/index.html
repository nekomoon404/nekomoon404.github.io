<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://nekomoon404.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="向量这一章的内容比较多，决定分开写，本文主要介绍有序向量。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法（3）有序向量">
<meta property="og:url" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/index.html">
<meta property="og:site_name" content="nekomoon的个人小站">
<meta property="og:description" content="向量这一章的内容比较多，决定分开写，本文主要介绍有序向量。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210132545.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210113255.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210113558.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210113800.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210114155.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210141315.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210142201.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210171952.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210174237.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210182501.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210182505.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210193029.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210201438.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210201558.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210203236.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210205204.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210212554.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210215936.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210222959.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210230255.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210234026.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200212194037.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200212190744.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200212194041.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200212201351.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200212204350.png">
<meta property="article:published_time" content="2020-02-10T02:58:38.000Z">
<meta property="article:modified_time" content="2020-02-12T12:44:19.826Z">
<meta property="article:author" content="nekomoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ%E5%9B%BE%E7%89%8720200210132545.png">

<link rel="canonical" href="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>数据结构与算法（3）有序向量 | nekomoon的个人小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="nekomoon的个人小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nekomoon的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nekomoon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nekomoon的个人小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法（3）有序向量
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 10:58:38" itemprop="dateCreated datePublished" datetime="2020-02-10T10:58:38+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 20:44:19" itemprop="dateModified" datetime="2020-02-12T20:44:19+08:00">2020-02-12</time>
              </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <div class="post-description">向量这一章的内容比较多，决定分开写，本文主要介绍有序向量。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h1><p>有序向量是相对于无序向量而言，无序向量要求元素之间至少应该能比较是否相等，我们称作比对操作；而有序向量更为复杂，它需要能够判定任何一对元素孰大孰小，这叫作比较操作。元素之间可以相互比较只是有序向量的一个必要条件，如果要成为一个真正的有序向量，还必须要求其中的元素确实是按照顺序排列的，因此就存在一个如何甄别一个向量是否有序的问题。</p>
<h2 id="有序性及其甄别"><a href="#有序性及其甄别" class="headerlink" title="有序性及其甄别"></a>有序性及其甄别</h2><ul>
<li>与起泡排序算法的理解相同：</li>
</ul>
<p>​        有序序列中，任意一对相邻元素顺序；无序序列中，总有一对相邻元素逆序。</p>
<ul>
<li>因此，逆序相邻元素的数目，可用以度量向量的逆序程度。</li>
<li>无序向量经预处理转换为有序向量之后，相关算法多可优化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//返回逆序相邻元素对的总数</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;    <span class="comment">//计数器</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _sizei++)        <span class="comment">//逐一检查各对相邻元素</span></span><br><span class="line">		n += (_elem[i - <span class="number">1</span>] &gt; _elem[i]);  <span class="comment">//逆序则计数</span></span><br><span class="line">	<span class="keyword">return</span> n;   <span class="comment">//向量有序当且仅当 n = 0</span></span><br><span class="line">&#125;  <span class="comment">//若只需判断是否有序，则首次遇到逆序对之后，即可立即终止</span></span><br></pre></td></tr></table></figure>
<p>根据上面的分析可以知道，一个向量是有序的，当且仅当经过disordered()判断以后返回的值是零。实际上只要向量中的元素本身是支持大小比较的，就有一定的办法将它转化为有序向量。其中的原因在于经过这样的一个转换以后虽然我们花费了一定的成本，但此后涉及到的很多操作也就是相关算法，大多都可以优化，相应地所得要远远比转换时所花费的成本大的多。</p>
<h2 id="低效算法"><a href="#低效算法" class="headerlink" title="低效算法"></a>低效算法</h2><p>上一篇文章介绍了无序向量的去重操作，现在我们希望把这种去重操作推广到有序向量，即将一个有序向量中的重复元素（如果存在）全部剔除掉，同样地每一组重复元素只保留一个副本。有序向量其实相对于无序向量而言，具有更好的规范性。这种规范性是指在有序向量中，彼此重复的元素必然会依次相互紧邻地构成一个一个的区间，比如就下图中的例子而言，这些元素相互重复，它们彼此紧邻，会紧密地排列成一个区间，其它元素也有这种规律。所以既然我们需要从每一组元素中保留一个副本，等价于从其中找出一个代表并且保留下来。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210132545.png" style="zoom: 67%;"></p>
<p>具体到一个算法，可以大致用一个线性扫描过程来描述：每次都观察并比对一对相邻的元素，如果二者相等就将后者删除掉，并且继续比较，如果后者还相等就把它继续删除掉，直到遇到一个不相重复的元素，这个时候我们才把注意力后移，再去考虑下一对紧邻的元素，如果依然出现这种情况再删除，直到又转到下一对。这样确实可以顺利地把所有重复的元素都剔除掉，但是不倾向与使用，因为其效率低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">	<span class="keyword">int</span> oldSize = _size;  <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//从首元素开始</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; _size - <span class="number">1</span>)  <span class="comment">//从前向后，逐一比对各相邻元素</span></span><br><span class="line">		<span class="comment">//若雷同，则删除后者；否则，转至后一个元素</span></span><br><span class="line">		(_elem[i] == _elem[i + <span class="number">1</span>]) ? <span class="built_in">remove</span>(i + <span class="number">1</span>) : i++;</span><br><span class="line">	<span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：其中_size的减小，由remove()内隐式地完成</span></span><br></pre></td></tr></table></figure>
<h3 id="低效算法的复杂度"><a href="#低效算法的复杂度" class="headerlink" title="低效算法的复杂度"></a>低效算法的复杂度</h3><ul>
<li>算法的运行时间主要取决去<code>while</code>循环，次数共计: _size - 1 = n -1</li>
<li>最坏情况下：每次都需调用<code>remove()</code>，耗时$O(n-1)\sim O(1)$，累计$O(n^2)$</li>
</ul>
<p>​       尽管省去<code>fine()</code>，总体竟与无序向量的<code>deduplicate()</code>相同。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113255.png" style="zoom: 80%;"></p>
<h2 id="高效算法"><a href="#高效算法" class="headerlink" title="高效算法"></a>高效算法</h2><p>需要首先对原有的算法进行反思，我们发现造成低效率的根源在于：其中的同一个元素有可能会作为被删除元素的后继，而多次地参与前移操作，对于这样的一个元素来说虽然它每次都是向前移动，但是很可惜它的每一次移动只会移动一个单元，而不是一次性地一步到达它最终的位置。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113558.png" style="zoom:50%;"></p>
<p>反过来这就启示我们，如果能够将每一个<strong>重复的区间作为一个整体</strong>来考虑，成批地删除雷同的元素而不是像刚才那样逐个地去删除，并且逐个地移动，就有可能实现这种一步到位式的移动，从而使得整体的性能大大地改进。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113800.png" style="zoom: 80%;"></p>
<p>这个新算法的思路可以由上面的图来表示，在任何时刻我们关注的都是<code>i</code>和<code>j</code>两个元素，而且这里有一个不变性，也就是在<code>i</code>之后 <code>j</code>之前的所有这些元素都与<code>i</code>重复，这个算法一直扫描直到发现第一个与i不同的元素。如果它确实是不同的话我们就只需将<code>j</code>向前移到与<code>i</code>紧邻于右侧的这个位置，这是一个很高明的删除算法，因为在这样的一个过程中虽然没有显式地去做这些重复元素的删除，但是实际上已经无形中将它们忽略掉了，等效于做删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">	Rank i = <span class="number">0</span>, j = <span class="number">0</span>;     <span class="comment">//各对互异“相邻”元素的秩</span></span><br><span class="line">	<span class="keyword">while</span> (++j &lt; _size)    <span class="comment">//逐一扫描，直至末元素</span></span><br><span class="line">		<span class="comment">//跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧</span></span><br><span class="line">		<span class="keyword">if</span> (_elem[i] != _elem[j])  </span><br><span class="line">			_elem[++i] = _elem[j];</span><br><span class="line">	_size = ++i;  </span><br><span class="line">	shrink();      <span class="comment">//直接截除尾部多余元素</span></span><br><span class="line">	<span class="keyword">return</span> j - i;  <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：通过remove(lo,hi)批量删除，依然不能达到高效率</span></span><br></pre></td></tr></table></figure>
<h3 id="高效算法的复杂度"><a href="#高效算法的复杂度" class="headerlink" title="高效算法的复杂度"></a>高效算法的复杂度</h3><p>下面通过一个例子来分析新算法的复杂度：</p>
<ul>
<li>共计n-1次迭代，每次常数时间，累计$O(n)$时间。</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210114155.png" style="zoom:80%;"></p>
<p>算法首先考虑的<code>i</code>和<code>j</code>元素，其实就是0和1号元素，对这个例子而言它们是彼此重复的元素，所以在那个循环中将会通过那个隐藏着看不见的<code>else</code>直接将它忽略掉，并且使得<code>j</code>进而转向下一个单元，以及在接下来的一个循环中再下一个单元，以及再下一个单元。执行到3和5出现了第一次的不同，按照刚才算法的逻辑会把<code>i++</code>到1号位置，然后把第<code>j</code>号元素取出来复制到对应的1号位置上，这就是为什么变成了3和5相邻。注意，在这个过程中我们并<strong>没有做显式的删除操作</strong>。</p>
<p>接下来的操作与之类似，直到<code>j</code>第一次越过右侧的边界的时候循环退出，算法也就终止。这个时候我们已经无形中将后边的这些元素统一地给删除掉了，这种删除非常的高明，因为我们没有做任何的一次显式的删除操作，而只是通过合理的计算得知了最终的向量规模之后，对<code>_size</code>这个量重新进行了一次设置。</p>
<p>通过这个例子可以得出，算法过程中只是经过了<code>i+1</code>次的迭代，每次移动j必然总是会往后移动一位。而且在每一次过程中，所做的操作无非就是一次比对，只有在比对不同的情况下才会做一次复制，即便是最坏的情况下既比对而且也复制的话，累计起来也不过是常数的时间。所以换而言之，整个这个新的算法只需要$O(n)$线性的时间。</p>
<h1 id="二分查找（版本A）"><a href="#二分查找（版本A）" class="headerlink" title="二分查找（版本A）"></a>二分查找（版本A）</h1><p>在上一篇文章中介绍了无序向量的查找算法，它的格式为<code>Vector::find(e, lo, hi)</code>，第一个参数指明查找的对象，第二和第三个参数<code>lo</code>和<code>hi</code>指示查找的区间范围。这种算法从思路上来说大体是从一端出发不断地逐个比对，直到发现某一个特定的元素就是<code>e</code>，或者一直到<code>lo-1</code>这个位置在左侧越界，即是查找失败。所以最好情况它只需$O(1)$的时间，但是从最坏的情况以及从一般<code>e</code>的概率分布的平均情况而言，都不得不需要线性的时间。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210141315.png" style="zoom:67%;"></p>
<p>那么在进入有序向量之后，我们应该可以得到更快的一种解决方案，不妨重新起一个名字叫<code>search()</code>，以示与无序向量的那个<code>find()</code>的区别。当然从操作的参数以及接口的语义来说都是类似的，即我们同样要在<code>lo</code>到<code>hi</code>这样一个左闭右开的区间里找到一个特定的元素。</p>
<h2 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//查找算法统一接口，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::search(T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi) <span class="keyword">const</span>&#123;   </span><br><span class="line">	<span class="keyword">return</span>(rand() % <span class="number">2</span>) ?   <span class="comment">//按各50%的概率随机选用</span></span><br><span class="line">		binSearch(_elem, e, lo, hi)   <span class="comment">//二分查找算法，或者</span></span><br><span class="line">	  : fibSearch(_elem, e, lo, hi);  <span class="comment">//Fibonacci查找算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里所提供的<code>search()</code>接口从形式上看是统一的，即ADT。从内部讲，它的具体实现算法却不见得完全一样，后面的的各节将会分别介绍二分查找算法以及Fibonacci查找算法，而且对每一种算法都有不同的版本。</p>
<p>为了做测试这里采用了一个随机的方法，也就是在0和1之间随机地取一个数，从而随机地调用这两个算法。在实际应用中可以针对不同的情况在这几种算法中选择其一。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210142201.png" style="zoom: 67%;"></p>
<p><code>seach()</code>的简要的操作语义就是在<code>lo</code>和<code>hi</code>所确定的这个区间找出目标元素<code>e</code>（如果它确实存在的话）。这里需要处理很多特殊的情况，比如，目标元素并不存在与规定的区间中，这就叫失败。在此前学习的无序向量的<code>find</code>的接口中我们只是简单地返回了一个标志-1，但严格地说这样做是不够的。反过来有可能目标元素存在多个，既然作为有序向量，一旦有多个e的话，那么它肯定会连续地分布构成一个区间。在这种情况下，到底是返回最前边的一个，最后的一个？还是中间的某一个？这些都是我们需要进一步地从语义上予以约定的。</p>
<h2 id="语义约定"><a href="#语义约定" class="headerlink" title="语义约定"></a>语义约定</h2><p>在语义上的细致约定是非常有必要的，否则<code>search()</code>接口将只能作为一个孤立的功能，而不能有效地、便捷地为其它的算法，作为一个基本的部件而利用。<code>search()</code>接口至少应该<strong>使得有序向量自身的动态维护变得非常便利</strong>，比如在有序向量不断插入元素过程中，我们希望往往能够采用这样一种形式：当插入某一个元素时，首先要通过<code>search()</code>来确定一个适当的位置，例如查找返回的那个值再加1，然后再将<code>e</code>插入于这个秩所对应位置，并且同时使得这个有序向量继续是一个有序向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.insert(<span class="number">1</span> + V.search(e), e);</span><br></pre></td></tr></table></figure>
<p>幸运的是前人已经帮我们设计出了这样的<strong>语义约定</strong>，比如下面就是其中的一种约定：</p>
<ul>
<li>在有序向量区间V[lo, hi)中，确定不大于e的最后一个元素</li>
<li>-∞ &lt; e &lt; V[lo] 时，返回 lo-1 （左侧哨兵）</li>
<li>V[hi-1] &lt; e &lt; +∞ 时，返回hi-1（右侧哨兵的前一个）</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210171952.png" style="zoom:67%;"></p>
<p>按照这个约定，对于要查找的元素有重复元素的情况，即有多个元素是与目标的元素是重复的，应该返回的所谓的不大于<code>e</code>的最后一个元素，也就是这个区段的右端点。如果我们要做一个插入，把新的元素插入这个位置同加1后的位置，即重复元素区间右端点的后面，正是再合适不过的。</p>
<p>这里的合适是指：第一，它继续保持了整体的有序性；第二，它以及与它雷同的那些元素会保持它们插入到这个向量中的先后的次序。所以这种语义约定是非常好的，它涵盖了我们几乎所有的情况包括特殊情况。所以接下来我们在实现这些具体的算法的时候，必须最终落实到能够符合这种语义的要求。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个版本只是为了说明原理，从严格的意义上讲，它还不能完全地符合刚才的语义要求，在后面的小节就会对它进行改进。</p>
<ul>
<li><p>减而治之：以任一元素x = S[mi] 为界，都可将待查找的区间分为三部分</p>
<p>S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)                 // S[mi] 称作轴点</p>
</li>
<li><p>只需将目标元素e与x做比较，即可分三种情况进一步处理：</p>
<ul>
<li>e &lt; x：则e若存在，必属于左侧子区间S[lo, mi)，故可递归深入</li>
<li>x &gt; e：则e若存在，必属于右侧子区间S(mi, hi)，亦可递归深入</li>
<li>x = e：已在此处命中，可随即返回       //若有多个，返回哪个？后面会介绍</li>
</ul>
</li>
<li><p>二分（折半）策略：轴点mi总是取作中点（至少能保证不是最坏情况）</p>
<p>于是每经过至多两次比较，或者能够命中，或者将问题规模减一半</p>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210174237.png" style="zoom: 67%;"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//在有序向量区间[lo, hi)内查找元素e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (lo &lt; hi) &#123;  </span><br><span class="line">		Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;     <span class="comment">//每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line">		<span class="keyword">if</span>      (e &lt; A[mi])  hi = mi;      <span class="comment">//深入前半段[lo, hi)继续查找</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (A[mi] &lt; e)  lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)</span></span><br><span class="line">		<span class="keyword">else</span>                 <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>：这里有编写程序的一个小的习惯，可以帮助我们更好地思考问题并且写出算法，更重要的是可以让代码更加好理解，同时也减少一些不必要的失误。我们这里<strong>统一地都用了小于号</strong>，因为小于号的左右的次序和我们通常所画的这样从小到大的次序是吻合的，所以这里<code>e &lt; A[mi]</code>的解读既可以认为是<code>e</code>小于<code>mi</code>，也可以认为是<code>e</code>存在于当前这个分界点<code>mi</code>的左侧。当这样顺着读下来时，当然我们就应该深入到前半段也就是左半段去，相应地呢，我们应该修改右侧的界桩<code>hi = mi</code>。同样接下来<code>A[mi] &lt; e</code>解读也是这样与其说是<code>mi</code>小于<code>e</code>，不如更直观地说是我们的目标<code>e</code>是处于<code>mi</code>这个分界点的右侧，所以我们应该深入到右半段也就是后半段去继续搜索，相应的操作也就是去修改左侧的界桩<code>lo = mi +1</code>。</p>
<h2 id="实例与复杂度"><a href="#实例与复杂度" class="headerlink" title="实例与复杂度"></a>实例与复杂度</h2><ul>
<li><code>S.search(8, 0, 7)</code>：共经$2+1+2=5$次比较，在<code>S[4]</code>处命中</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182501.png" style="zoom:67%;"></p>
<ul>
<li><code>S.search(3, 0, 7)</code>：共经$1+1+2=4$次比较，在<code>S[1]</code>处失败</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182505.png" style="zoom:67%;"></p>
<ul>
<li><p>线性递归：$T(n)=T(n/2)+O(1)=O(logn)$，大大优于顺序查找</p>
<p>递归跟踪：轴点总取重点，递归深度$O(logn)$；各递归实例均耗时$O(1)$。</p>
</li>
</ul>
<h2 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h2><p>有序向量的查找是一种非常基本的算法，而且它存在多个版本，因此除了上面利用渐近的复杂度能够从总体上把握它的大体性能以外，我们还需要对不同版本算法的性能做更加细微的评定。具体来说就是考察渐近复杂度$logn$前面的那个常系数，而具体地在统计和分析的时候，更多的是考量关键码的比较操作次数，也就是在其中所执行的if语句的次数，我们将此称作是不同的算法在不同的情况下所对应的查找长度。</p>
<ul>
<li><p>如何更为精确地评估查找算法的性能？</p>
<p>考查关键码的比价次数，即查找长度（search length）</p>
</li>
<li><p>通常，需分别针对成功与失败查找，从最好，最坏，平均等角度评估</p>
</li>
<li><p>例如，成功、失败时的平均查找长度均大致为$O(1.50\cdot logn)$。</p>
</li>
</ul>
<p>下面是一个一个具体的实例，这是一个由七个元素构成的有序向量，其实它的数值是具体是多少我们并不在意，只要它是非降排列的就可以。如果把算法改写成递归的形式，那么整个的不同情况的递归跟踪将构成下面的递归跟踪图，每条虚线旁边的数字代表由上一步执行到下一步所增加的比较操作的次数，具体位置的方框中的数字代表查找到它所需要总的比较操作次数，即查找长度。需要注意的是，每次递归到左子区间，比较操作次数增加1，而递归到右区间，比较操作次数增加2。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210193029.png" style="zoom:80%;"></p>
<ul>
<li>n = 7时，各元素对应的成功查找长度为$\{4,3,5,2,5,4,6\}$</li>
</ul>
<p>​       在等概率情况下，平均成功查找长度$=29/7=4.14$；</p>
<ul>
<li><p>共有8中失败情况，查找长度分别为$\{3,4,4,5,4,5,5,6\}$</p>
<p>在等概率情况下，平均失败查找长度$=36/8=4.50$；</p>
</li>
<li><p>可见，成功和失败的平均查找长度大致是$1.50\cdot log_28$</p>
</li>
</ul>
<h1 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h1><h2 id="改进思路及原理"><a href="#改进思路及原理" class="headerlink" title="改进思路及原理"></a>改进思路及原理</h2><p>在上一节引入了二分查找（Binary search）这样的一个概念，并且给出了一个基本的算法的版本，这个版本的复杂度从渐近意义而言应该是logn量级的，但如果进一步地细微地来考察前面的系数大致是1.5，我们也指出这个1.5是可以改进的。我们现在就来看看，如何通过一种新的算法：fibonacci查找（fibonaccian search）来对此进行改进。</p>
<p>上一节的末尾以一个长度为7的有序向量为例，具体地给出了在成功和失败情况下平均查找长度的估算的过程。实际上通过那个实例的推而广之，如果考虑更一般的情况，不难发现此前所介绍的版本A，确实还有很大地改进余地。这样一个判断是来自于这样一个观察事实，也就是说版本A这个算法实际上从用意上讲，它是试图通过使各种情况的搜索<strong>在迭代次数上的平衡</strong>来尽可能地回避掉最坏的情况。</p>
<p>具体讲比如所有的失败情况大部分都会失败在同样深度的，也就是最深的这个位置，所以它表面上看是平衡的，但这其中却蕴涵着很大的不平衡。因为在整个这个查找的过程中我们在任何一个位置上，如果要决定是向左或者是向右深入的话，所花费的成本，也就是比较的次数是不等的。准确地说按照版本A，向左侧只需要一次比较，而向右侧却需要两次比较，所以这样一个表面上看是非常公平的一个平衡，实际上在内部却蕴涵着极大的不平衡，所以我们确实有理由怀疑算法的效率是否已经达到最优。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201438.png" style="zoom: 50%;"></p>
<p>反过来我们也可以得到改进的一个思路，具体讲就是既然我们已经看到目前的机制中，向左侧确实会成本更低，而向右侧更高。那么为什么不把这个搜索的各种情况画成类似下面的这样一个树状图，做成左侧是更深的，而右侧是相对更浅的。这样一个表面上看的不平衡，却因为它恰好和这种成本互相之间能做一个合适的补偿，反过来有可能从整体上会得到更优，也就是说使得整体的查找平均长度反而会缩短。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201558.png" style="zoom:50%;"></p>
<p>具体来讲，越是成本低的转向我们就越希望更多地做，越是成本更高的越是希望它能更少地来做，所以这样的话我们就得到了新的算法的改进的思路。那么具体这个思路怎么来兑现呢？非常有意思的是需要用到<strong>fibonacci数</strong>。不失一般性，假设有序向量的长度N，就是某个fibonacci数减1的形式。</p>
<p>如下图所示有序向量的长度<code>n = fib(k) - 1</code>，那我们就在其中选择这么样一个特定的切分点<code>mi</code>，<code>mi = fib(k-1) - 1</code>，如果以这个点为切分，那么左边子向量的长度就恰好是<code>fib(k-1) - 1</code>，而右边子向量的长度恰巧是<br><code>fib(k-2) - 1</code>。可见这样一种切分的好处就是，在任何时候只要按照这样来切分，无论是向左还是向右它都会从长度上保持某个fibonacci数再减1的形式，而这种形式实际上恰好是最优的。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210203236.png" style="zoom:67%;"></p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>首先定义一个<code>Fib</code>类，让其提供一些接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span> &#123;</span> <span class="comment">//Fibonacci数列类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> f, g; <span class="comment">//f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Fib ( <span class="keyword">int</span> n ) <span class="comment">//初始化为不小于n的最小Fibonacci项</span></span><br><span class="line">  &#123; f = <span class="number">1</span>; g = <span class="number">0</span>; <span class="keyword">while</span> ( g &lt; n ) next(); &#125; <span class="comment">//fib(-1), fib(0)，O(log_phi(n))时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> g; &#125; <span class="comment">//获取当前Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; g += f; f = g - f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至下一Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123; f = g - f; g -= f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至上一Fibonacci项，O(1)时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Fibonacci查找可以实现为下面的一段代码，可以注意到它的接口还是完全一样的，而且在其中的这个循环，大致来说也是与版本A类似的，即每次都要来判断以保证当前的<code>lo</code>和<code>hi</code>构成一个合法的区间，如果这个区间能够收缩到非法(lo == hi)，那也就意味着查找是失败的，这跟此前的版本A是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fibonacci/Fib.h"</span> <span class="comment">//引入Fib数列类</span></span></span><br><span class="line"><span class="comment">// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Fib <span class="title">fib</span><span class="params">(hi - lo)</span></span>;   <span class="comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">   <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( hi - lo &lt; fib.<span class="built_in">get</span>() ) fib.prev();   <span class="comment">//自后向前顺序查找（分摊O(1)）</span></span><br><span class="line">      Rank mi = lo + fib.<span class="built_in">get</span>() - <span class="number">1</span>;       <span class="comment">//确定形如Fib(k) - 1的轴点</span></span><br><span class="line">      <span class="keyword">if</span>      ( e &lt; S[mi] ) hi = mi;      <span class="comment">//深入前半段[lo, mi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( S[mi] &lt; e ) lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span>                  <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">   &#125; <span class="comment">//成功查找可以提前终止</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h2><ul>
<li>fibonacci查找算法的平均查找长度为$O(1.44 \cdot logn)$，略优于二分查找</li>
<li>仍以n = fib(6) -1 = 7 为例，在等概率情况下：<ul>
<li>平均成功查找长度$=(2+3+4+4+5+5+5)/7=28/7=4.00&lt;4.14$</li>
<li>平均失败查找长度$=(4+5+4+4+5+4+5+4)/7=35/7=4.38&lt;4.50$</li>
</ul>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210205204.png" style="zoom: 80%;"></p>
<h2 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h2><ul>
<li><p>通用策略：对于任何的A[0, n)，总是选取A[λn]作为轴点，$0\le \lambda &lt;1$:</p>
<p>比如二分查找对应于$\lambda=0.5$，Fibonacci查找对应于$\lambda=\phi=(\sqrt{5}-1)/2=0.6180339\dots$（黄金分割比）</p>
</li>
<li><p>在[0, 1)内，$\lambda$如何取值才能达到最优？设平均查找长度为$\alpha(\lambda)\cdot log_2n$，何时$\alpha(\lambda)$最小？</p>
</li>
<li><p>递推式：$\alpha(\lambda)\cdot log_2 n=\lambda\cdot [1+\alpha(\lambda)\cdot log_2 (\lambda n)]+(1-\lambda)\cdot [2+\alpha(\lambda)\cdot log_2 \left((1-\lambda) n \right)]$</p>
</li>
<li><p>整理后：$\frac{-ln2}{\alpha(\lambda)}=\frac{\lambda\cdot ln\lambda+(1-\lambda)\cdot ln(1-\lambda)}{2-\lambda}$，当$\lambda=\phi$时，$\alpha(\lambda)=1.440420\dots$达到最小。</p>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210212554.png" style="zoom: 80%;"></p>
<p>相对于我们上一节的二分查找$\alpha(\lambda)=1.50$，Fabonacci查找又有了一定的改进，而且从本节的分析可以看出这种改进已经达到了极限，如果我们不再改变这个算法的总体模式和框架的话。</p>
<h1 id="二分查找（改进）"><a href="#二分查找（改进）" class="headerlink" title="二分查找（改进）"></a>二分查找（改进）</h1><p>这一节将介绍另一种思路的改进，这是一种直截了当的改进思路，既然我们已经注意到了此前的版本A中造成效率略低的原因是因为左右分支的转向代价不平衡，那么可以考虑是否能将二者做成是平衡的。</p>
<h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><ul>
<li><p>二分查找中左、右分支转向代价不平衡的问题，也可直接解决</p>
</li>
<li><p>比如，每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个</p>
</li>
<li><p>同样地，轴点mi取作中点，则查找每深入一层，问题规模也缩减一半</p>
<p>1）e &lt; x：  则e若存在，必属于左侧子空间S[lo, mi)，故可递归深入</p>
<p>2）x &lt;= e：则e若存在，必属于右侧子空间S[mi, hi)，亦可递归深入</p>
</li>
<li><p>只有当元素数目hi - lo = 1时，才判断该元素是否命中，这是该算法做出的牺牲</p>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210215936.png" style="zoom:67%;"></p>
<h2 id="版本B：实现"><a href="#版本B：实现" class="headerlink" title="版本B：实现"></a>版本B：实现</h2><p>主要注意代码中与版本A不同的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找算法（改进）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo ) &#123;         <span class="comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;   <span class="comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi;     <span class="comment">//经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">  &#125;    <span class="comment">//出口时hi = lo + 1，查找区间仅含一个元素A[lo]</span></span><br><span class="line">  <span class="keyword">return</span> (e == A[lo]) ? lo : <span class="number">-1</span>; <span class="comment">//返回命中元素的秩或者-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法是封闭的，可以运转，而且可以完全实现此前一样的功能。与此前的版本A对比，它在最好情况下反而有所倒退，原因是在与即使是成功的情况它也一直要推迟到最终，只有在经过最终的这次比对之后才会确定是否成功。此前的版本A它的最好情况是非常好的，最最好的情况莫过于在第一次试图做减而治之的时候，所采用的那个切分点就成功命中，只需要$O(1)$的时间。</p>
<p>本节改进的二分查找无论如何都一直要切分到最后，所以最好的情况的时间复杂度是$O(logn)$。但是反过来最坏的情况又会更好，因为我们这里最坏的情况不会出现每一次都是向右，即每次都要花费两次比较的情况，所以最坏的情况会得到抑制。所以从总体而言此前的那个版本A如果说它在性能上好坏情况相差非常大的话，那么本节中改进的版本在整体性能上，它就会趋于更加的稳定，即差异化不是那么大，当然这还不是它的最大的优势所在。</p>
<h2 id="语义约定-1"><a href="#语义约定-1" class="headerlink" title="语义约定"></a>语义约定</h2><ul>
<li><p>以上的二分查找及Fibonacci查找算法，均未严格地兑现<code>search()</code>接口的语义约定：</p>
<p><strong>返回不大于e的最后一个元素</strong></p>
</li>
<li><p>只有兑现这一约定，才可以有效支持相关算法，比如：<code>V.insert(1 + V.search(e), e)</code></p>
<p>1）当有多个命中元素时，必须返回最靠右（秩最大）者</p>
<p>2）失败时，应返回小于e的最大者（含哨兵<code>lo-1</code>）</p>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210222959.png" style="zoom:67%;"></p>
<h2 id="版本C：实现"><a href="#版本C：实现" class="headerlink" title="版本C：实现"></a>版本C：实现</h2><p>在刚才代码的基础上，我们做进一步的调整，得到一个最终的版本，它可以严格地实现上面定义的语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) </span><br><span class="line">  &#123;   <span class="comment">//不变性：A[0,lo) &lt;= e &lt; A[hi,n)</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;    <span class="comment">//以中点为轴点</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>;    <span class="comment">//经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">  &#125; <span class="comment">//出口时，A[lo = hi]为大于e的最小元素</span></span><br><span class="line">  <span class="keyword">return</span> --lo;   <span class="comment">//故循环结束时lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125;   <span class="comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span></span><br></pre></td></tr></table></figure>
<p>就算法的结构而言，这个新的算法版本C和此前的版本A，尤其是版本B，似乎没有什么太大的区别。解读一下：当这个区间还是合法之前我们就不断地迭代，每一次也照样是取出它的中点作为轴点，并且经过一次比较从而决定到底是向左侧还是向右侧深入，那么直到区间宽度缩小到足够小的时候，才返回最终的值。</p>
<p>需要注意的是版本C和版本B，虽然在功能上是等效的，但是在很多细节上却有着本质的<strong>区别</strong>：</p>
<ul>
<li>待<strong>查找区间宽度缩短至0</strong>而非1时，算法才结束</li>
<li>转入右侧子向量时，<strong>左边界取作mi+1</strong>，而非mi                 //A[mi]会被遗漏？下一小节证明</li>
<li>无论成功与否，返回的秩严格<strong>符合接口的语义约定</strong></li>
</ul>
<h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>首先通过下面的图例来具体地了解一下版本C的工作过程，其实最主要的是它的每次迭代的过程都是类似的。如图(a)，在整个向量的区间内，我们关注的是某一个特定的从<code>lo</code>到<code>hi</code>的一个查找区间，每次在这个区间里都要考虑middle point，即图中的x。</p>
<p>我们以它为界，经过一次比较以后有可能会发现目标元素更小所以就深入到如图b所示的左侧的这个子区间；或者对称地，因为目标元素更大而深入到右侧的这个区间，如图(c)。版本C的算法中左侧子区间和右侧的子区间都没有覆盖这个middle point，而且对middle point也没有做显式地判断，所以这也是为什么有理由怀疑它有可能是这个算法的一个疏忽。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210230255.png" style="zoom:67%;"></p>
<p>接下来我们来证明这样一个模式实际上是安全的，为此同样用我们的两种技巧：第一就是给出这个算法的不变性<br>其次要给出它的一个单调性，而单调性是一目了然，就不再说明了，主要是证明它的不变性：</p>
<ul>
<li>不变性：A[0, lo) &lt;= e &lt; A[hi, n)            //A[hi] 总是大于e的最小者</li>
<li>初始时，lo = 0且 hi = n，A[0, lo) = A[hi, n) = $\varnothing$，自然成立</li>
<li>数学归纳法：假设不变性一直保持至图(a)的状态，下一步无非两种情况：</li>
</ul>
<p>第一种情况，也就是深入左侧这个分支的情况，即图(b)。那么此前的判断<code>e &lt; A[mi]</code>返回的是True，之后执行   <code>hi = mi</code>，从而使得右侧的这段区间向左拓展是安全的，因为确实可以断定这个整个区间内的这些元素都是严格地大于e的，因为它们其中最小的那个元素也就是<code>A[mi]</code>都大于<code>e</code>。而A[0, lo)保持不变,所以这种情况是没有问题的。</p>
<p>第二种情况，也就是深入右侧这个分支的情况，即图(c)。那么此前的判断<code>e &lt; A[mi]</code>返回的是False，之后执行 <code>lo = mi</code>，此时<code>e</code>是不小于<code>A[mi]</code>的，而<code>A[mi]</code>元素是左段区间中最大的，所以左段区间都是都是不大于e的。这样一个左侧区间向右拓展的动作在刚才不变性的意义上讲，依然是安全的，它使得不变性得到了延续。所以经过一次迭代以后无论是向左还是向右的深入，不变性都是成立的。</p>
<ul>
<li>单调性：显而易见，直到最后会出现一个情况，就是整个区间的宽度变成零，可以表示为下图。</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210234026.png" style="zoom:67%;"></p>
<p>从整个的原始的搜索空间开始，经过不断地压缩、压缩、压缩之后，将搜索的范围缩小到一个宽度为零的一个区间，其实它就只是一个分界。它严格地将整个区间分为了左右两部分，由不变性左侧这部分依然是不大于e，而右侧这部分是严格地&gt;e。如果查找的结果是命中的，我们只需要返回左侧这个区间的最右端的那个元素就可以了，而这个元素正是A[lo-1]。这也就是为什么我们在算法的最终返回之前要做一次<code>--lo</code>的操作。</p>
<p>这样的话我们就得到了一个从<strong>功能</strong>上、从<strong>语义</strong>上、从<strong>性能</strong>上都近乎完美的算法！</p>
<h1 id="插值插值"><a href="#插值插值" class="headerlink" title="插值插值"></a>插值插值</h1><p>插值查找（Interpolation Search）有序向量查找算法的一个另类的变种，此前所介绍的Fibonacci search或binary search包括它们的各种版本对向量只做了一个假定，即其中的元素是单调有序的，对于其中元素的分布情况并没有做任何的假设，也就是可以是完全理想任意随机的。但是在某些情况下也许不是这样，比如我们可能不仅知道向量是有序的，而且<strong>其中的元素是按照某种先验规律随机分布的</strong>。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194037.png" style="zoom: 50%;"></p>
<p>在这里我们考虑一种最常见的随机分布：<strong>均匀独立的随机分布</strong>，比如在从<code>lo</code>一直到<code>hi</code>的秩的范围之内，所有的元素都是互相不影响，各自独立的，然后从取值来看是均匀的取自于某一个区间范围。如果我们确实知道诸如此类的规律的话，就有可能实现优于此前那些算法$O(logn)$的更高的查找效率，以$o(logn)$的效率来完成一次查找。</p>
<h2 id="原理与算法"><a href="#原理与算法" class="headerlink" title="原理与算法"></a>原理与算法</h2><p>在均匀且独立的随机分布下，所有的元素在排序之后，即组织成一个有序向量之后，必然大体上是按线性增长的趋势分布的，从最小值<code>lo</code>开始大致是<strong>线性增长</strong>到最高值<code>hi</code>。这就意味着对于其中的任何一个潜在元素<code>mi</code>，都可以写出这样一个近似的线性等式，它们的秩的比与它们的数值比，二者是近似接近的。</p>
<script type="math/tex; mode=display">
\frac{mi-lo}{hi-lo}\approx \frac{e-A[lo]}{A[hi]-A[lo]}</script><p>实际上这给了我们一个启示，即在每次确定mi的时候，既不需要固定的用1/2，也不需要固定的用小写的φ（黄金分割比），甚至不需要用某一个一般的λ，而是可以动态的来猜测这样一个轴点，就是根据上面的等式。将这个等式稍微整理一下把<code>mi</code>提到左侧，我们就可以知道根据<code>lo</code>、<code>hi</code>以及它们对应的这两个元素的数值，以及每次动态要查找的那个元素的数值<code>e</code>，就可以大致的估算出<code>mi</code>，这样的话如果整个的减而治之的搜索过程可以认为是一个不断收缩包围圈逐步收敛的一个过程，那么它将会使得收敛的速度极大的加快，从而更快速的完成我们整个的查找。</p>
<script type="math/tex; mode=display">
mi\approx lo+(hi-lo)\cdot \frac{e-A[lo]}{A[hi]-A[lo]}</script><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212190744.png" style="zoom: 80%;"></p>
<p>正如这个图所画的是一本英文词典中abcd一直到z开头的单词各自起始的页码,它大致是1300多页，换而言之如果它确实是一个大致平均分布的话，每一个字母大概占50页，所以我们可以大致估算出来从1到50页大概是a，50页到100页大概是b，100页到150页大概是c，诸如此类。比如说去查binary (b)，那么因为它是第二个字母所以它大概会在整书从2/26这个位置开始，而search,s是第19个元素 所以大概它会位于19/26的位置。正因为这种算法在确定切分点也就是轴点的时候，采用的是近似的插值估算的方法，所以我们也称之为Interpolation Search插值查找，下面是一个实例。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194041.png" style="zoom: 67%;"></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>从刚才的例子我们可以看出，对于这样一个长度为19的有序向量，只用了3次比较就给出了答案，而在通常的二分查找中这是做不到的，所以我们已经看到它在某些情况下确实很快，但是它总是能很快吗？包括这种很快到底定性是多大呢？</p>
<p>我们需要做一个严格的界定，首先一个不好的消息是插值查找<strong>在某些情况下效率会很低</strong>，比如说 可能退化为与平凡的顺序查找没有什么区别，我们此前所做的那种假设也就是均匀独立的分布不满足，或者至少在某些部分不满足以致在全局或某些局部出现一些所谓的病态分布。</p>
<ul>
<li>最坏情况：$O(hi- lo)=O(n)$</li>
</ul>
<p>当然 插值查找的最好情况也是不言而喻的，和其他的查找差不多，也就是说有可能我们在某次，甚至在第一次猜测的时候就直接命中，那么这种我们也不再考虑。我们转而再考虑一般的情况，也就是平均而言会怎么样。</p>
<p>这里我们需要用到一个非常基础类似引理的结论这个结论：在插值查找算法中每经过一次迭代，或者说每经过一次比较，都可以将查找的范围也就是减而治之之后剩余的部分由原先的规模n缩减为$\sqrt{n}$。</p>
<ul>
<li>平均情况：每经过一次比较，$n$缩减至$\sqrt{n}$。</li>
<li>于是，待查找区间宽度将按一下趋势缩减：</li>
</ul>
<p>​       $n,\quad\sqrt{n},\quad \sqrt{\sqrt{n}},\quad \sqrt{\sqrt{\sqrt{n}}},\dots,\quad2$</p>
<p>​       $n,\quad n^{(1/2)},\quad n^{(1/2)^2},\dots,\quad n^{(1/2)^k},\dots,\quad2$</p>
<ul>
<li><p>经多少次比较之后，有$n^{(1/2)^k}&lt;2$？</p>
<p>$k&gt;loglogn$</p>
</li>
<li><p>插值查找的时间复杂度为：$O(loglogn)$</p>
</li>
</ul>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212201351.png" style="zoom: 67%;"></p>
<p>我们同样可以来估算：如果向量的长度或者这个区间的宽度是n的话，考虑这个n按照二进制打印出来以后的位宽就是以的2为底 logn，那么每一次将它变为根号n从二进制的打印宽度来看其实就是变成了1/2的原来那么多宽度，换而言之每一次开方其实同步的是使宽度变成了原来的1/2，这样的过程 从n的数位宽度来说是一个不断折半的过程。</p>
<p>回顾此前的二分查找，如果是对的n的数值每次折半的话，那么这里的<strong>插值查找实际上就是对n的二进制位宽度来做二分查找</strong>。二分查找所需要的迭代次数是与它的初始值呈一个对数关系的，即$O(logn)$，而插值查找的位宽的初值相当于是logn，所以其需要的迭代次数就是$O(loglogn)$。</p>
<p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212204350.png" style="zoom: 50%;"></p>
<p>从今以后也许我们应该学会忘掉这些复杂的，虽然是精确的数学，而改用这种宏观的大趋势的把握本质的习惯。</p>
<h2 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h2><p>现在将插值查找和其他的算法综合起来进行比对和考量，刚才插值查找所实现的这种改进也就是从logn到loglogn<br>虽然从数学上是一个比较大的改进，但从实际效率来看却值得商榷。</p>
<ul>
<li><p>从$O(logn)$到$O(loglogn)$，是否值得？</p>
</li>
<li><p>通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高。</p>
<p>比如，n = 2^(2 ^ 5) = 2 ^ 32 = 4G时，$log_2(n)=32,\quad log_2(log_2(n))=5$</p>
</li>
<li><p>易受小扰动的干扰和“蒙骗”，可能在局部花费非常多的时间</p>
</li>
<li>须引入乘法、除法运算，相对而言成本更高（二分查找只需加法，Fibonacci查找只需加法和减法）</li>
</ul>
<p>所以可行的查找算法也许应该将插值查找以及此前的那些查找算法各自的优势综合结合起来，比如说插值查找更善于在比较大的一个宏观的范围内，将问题的关注点尽可能快的缩小到一定的范围，即它比较擅长于处理那种极大的情况，然后一旦到了比较小的情况，这种容易受到干扰包括蒙骗尤其是乘法除法这样的一些overhead额外计算占得比重就会更大成为不可忽略的因素，而在这个时候二分查找的优势就体现出来了。</p>
<ul>
<li><p>实际可行的方法：</p>
<p>首先通过插值查找，将插值范围缩小到一定的范围，然后再进行二分查找，或者顺序查找，即：</p>
<ul>
<li>大规模：插值查找</li>
<li>中规模：折半查找</li>
<li>小规模：顺序查找</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/" rel="prev" title="数据结构与算法（2）向量">
      <i class="fa fa-chevron-left"></i> 数据结构与算法（2）向量
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/11/ML-Week1/" rel="next" title="ML:Week1">
      ML:Week1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#唯一化"><span class="nav-number">1.</span> <span class="nav-text">唯一化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性及其甄别"><span class="nav-number">1.1.</span> <span class="nav-text">有序性及其甄别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#低效算法"><span class="nav-number">1.2.</span> <span class="nav-text">低效算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#低效算法的复杂度"><span class="nav-number">1.2.1.</span> <span class="nav-text">低效算法的复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效算法"><span class="nav-number">1.3.</span> <span class="nav-text">高效算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高效算法的复杂度"><span class="nav-number">1.3.1.</span> <span class="nav-text">高效算法的复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找（版本A）"><span class="nav-number">2.</span> <span class="nav-text">二分查找（版本A）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#统一接口"><span class="nav-number">2.1.</span> <span class="nav-text">统一接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语义约定"><span class="nav-number">2.2.</span> <span class="nav-text">语义约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">2.3.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">2.4.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例与复杂度"><span class="nav-number">2.5.</span> <span class="nav-text">实例与复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找长度"><span class="nav-number">2.6.</span> <span class="nav-text">查找长度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fibonacci查找"><span class="nav-number">3.</span> <span class="nav-text">Fibonacci查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#改进思路及原理"><span class="nav-number">3.1.</span> <span class="nav-text">改进思路及原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-1"><span class="nav-number">3.2.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找长度-1"><span class="nav-number">3.3.</span> <span class="nav-text">查找长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最优性"><span class="nav-number">3.4.</span> <span class="nav-text">最优性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找（改进）"><span class="nav-number">4.</span> <span class="nav-text">二分查找（改进）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#改进思路"><span class="nav-number">4.1.</span> <span class="nav-text">改进思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版本B：实现"><span class="nav-number">4.2.</span> <span class="nav-text">版本B：实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语义约定-1"><span class="nav-number">4.3.</span> <span class="nav-text">语义约定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版本C：实现"><span class="nav-number">4.4.</span> <span class="nav-text">版本C：实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正确性"><span class="nav-number">4.5.</span> <span class="nav-text">正确性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插值插值"><span class="nav-number">5.</span> <span class="nav-text">插值插值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理与算法"><span class="nav-number">5.1.</span> <span class="nav-text">原理与算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number">5.2.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合对比"><span class="nav-number">5.3.</span> <span class="nav-text">综合对比</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nekomoon"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">nekomoon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nekomoon404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nekomoon404" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nekomoon404@163.com" title="E-Mail → mailto:nekomoon404@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020.1.12 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nekomoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">149k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


   
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200112,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

</body>
</html>
