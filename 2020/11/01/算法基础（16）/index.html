<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://nekomoon404.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础（16）">
<meta property="og:url" content="http://nekomoon404.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8816%EF%BC%89/index.html">
<meta property="og:site_name" content="nekomoon的个人小站">
<meta property="og:description" content="计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/nekomoon404/blog-img/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201101151335.png">
<meta property="og:image" content="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ%E5%9B%BE%E7%89%8720201103210738.png">
<meta property="og:image" content="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ%E5%9B%BE%E7%89%8720201103215715.png">
<meta property="og:image" content="https://gitee.com/nekomoon404/blog-img/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201104180646.png">
<meta property="article:published_time" content="2020-11-01T06:10:58.000Z">
<meta property="article:modified_time" content="2020-11-04T11:46:11.938Z">
<meta property="article:author" content="nekomoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/nekomoon404/blog-img/raw/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201101151335.png">

<link rel="canonical" href="http://nekomoon404.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8816%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>算法基础（16） | nekomoon的个人小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="nekomoon的个人小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nekomoon的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nekomoon404.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8816%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="nekomoon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nekomoon的个人小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法基础（16）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-01 14:10:58" itemprop="dateCreated datePublished" datetime="2020-11-01T14:10:58+08:00">2020-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-04 19:46:11" itemprop="dateModified" datetime="2020-11-04T19:46:11+08:00">2020-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <div class="post-description">计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-计数类DP"><a href="#1-计数类DP" class="headerlink" title="1.计数类DP"></a>1.计数类DP</h3><blockquote>
<p>例题：整数划分（Acwing 900）</p>
<p>一个正整数$n$可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k$，其中$n_1≥n_2≥…≥n_k,k≥1$。我们将这样的一种表示称为正整数$n$的一种划分。现在给定一个正整数$n$，请你求出$n$共有多少种不同的划分方法。由于答案可能很大，输出结果请对$10^9+7$取模。</p>
<p>数据范围：$1\le n \le 1000$</p>
</blockquote>
<p>因为题中的划分方案不考虑数字的顺序，因此我们可以把要划分的数$n$看作是一个体积为$n$的背包，有体积有$1,2,3,\dots,n$的物品，可取用的个数是无限个，我们要求的是恰好装满背包的方案数，即抽象成<strong>完全背包问题</strong>。</p>
<ul>
<li>状态表示<code>f(i,j)</code>：<ul>
<li>集合：所有从$1\sim i$中选，总体积恰好为$j$的选法的集合</li>
<li>属性：上述选法的数量</li>
</ul>
</li>
<li>状态计算：<ul>
<li>集合的划分：<code>f(i,j)</code>可以分为选了0个第<code>i</code>个物品<code>f(i-1,j)</code>，选了1个第<code>i</code>个物品<code>f(i-1,j-i)</code>，选了两个第<code>i</code>个物品<code>f(i-1,j-2*i)</code>，……选了s个第<code>i</code>个物品<code>f(i-1,j-s*i)</code>；</li>
<li>状态转移方程为：<code>f(i,j)=f(i-1,j)+f(i-1,j-i)+f(i-1,j-2*i)...+f(i-1,j-s*i)</code>，时间复杂度为$O(n^2 \log n)$（状态数为$n^2$，状态计算量为$\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+\dots\frac{n}{n}=\log n$。</li>
<li>按照完全背包问题的思路做进一步优化：将<code>f(i,j)</code>的方程与<code>f(i,j-i)</code>的方程作对比，<code>f(i,j-i)=f(i-1,j-i)+f(i-1,j-2*i)+...+f(i-1,j-s*i)</code>，则有：<code>f(i,j)=f(i-1,j)+f(i-1,j-i)</code>；同时可以在空间上优化，用一维数组表示，即<code>f[j]=f[j]+f[j-1]</code>，体积从小到大循环。这样时间复杂度为$O(n^2)$</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//初始化：当没有数时，j=0有一种方案，即i=0；其余f[j]都是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j ++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种解法：</p>
<ul>
<li><p>状态表示<code>f[i,j]</code>：</p>
<ul>
<li>集合：所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的选法；</li>
<li>属性：数量，上述选法的数量</li>
</ul>
</li>
<li><p>状态计算：</p>
<ul>
<li>集合划分：<code>f[i,j]</code>可以分为两大类：方案中最小值是1——若把所有方案中的最小值1去掉，就可以变成总和是<code>i-1</code>，恰好分成<code>j-1</code>个数的方案，即<code>f[i-1,j-1]</code>；方案中最小值大于1——若把方案中每个数都减去1，就可以变成总和是<code>i-j</code>，恰好分成<code>j</code>个数的方案，即<code>f[i-j,j]</code>。</li>
<li>则状态转移方程：<code>f[i,j]=f[i-1,j-1]+f[i-j,j]</code>，最后的答案是<code>ans=f[n,1]+f[n,2]+...+f[n,n]</code></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201101151335.png" style="zoom:60%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//初始化：当没有数时，j=0有一种方案，即i=0；其余f[j]都是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  res = (res + f[n][i]) % mod; </span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-数位统计DP"><a href="#2-数位统计DP" class="headerlink" title="2.数位统计DP"></a>2.数位统计DP</h3><blockquote>
<p>例题：计数问题（Acwing 338）</p>
<p>给定两个整数$a$和$b$，求$a$和$b$之间的所有数字中0~9的出现次数。例如，a=1024，b=1032，则 a 和 b 之间共有9个数如下：1024 1025 1026 1027 1028 1029 1030 1031 1032,其中‘0’出现10次，‘1’出现10次，‘2’出现7次，‘3’出现3次等等…</p>
<p>输入格式：输入包含多组测试数据。每组测试数据占一行，包含两个整数 a 和 b。当读入一行为0 0时，表示输入终止，且该行不作处理。</p>
<p>输出格式：每组数据输出一个结果，每个结果占一行。每个结果包含十个用空格隔开的数字，第一个数字表示‘0’出现的次数，第二个数字表示‘1’出现的次数，以此类推。</p>
<p>数据范围：$0&lt;a,b&lt;100000000$</p>
</blockquote>
<p>显然暴力做法是不可取的，以下做法中最重要的思路是：分情况讨论。直接求从<code>[a,b]</code>中0~9出现的次数是不好求的，我们可以先求<code>count(n,x)</code>，即$1 \sim n$中<code>x</code>出现的次数，再用求前缀和的思路来求<code>[a,b]</code>中<code>x</code>出现的次数，即<code>count(b,x)-count(a-1,x)</code>。</p>
<p>以<code>count(n,1)</code>为例，设当前数字为<code>abcdefg</code>，思路是分别求出1在每一位上出现的次数，如求1在第4位出现的次数，即有多少形如<code>xxx1yyy</code>的数，满足<code>1 &lt;= xxx1yyy &lt;= abcdedfg</code>，分情况讨论：</p>
<ol>
<li><p>前三位，<code>xxx = 000~abc-1</code>时，后三位可以取到<code>yyy=000~999</code>，一共有<code>abc * 1000</code>次数；</p>
</li>
<li><p>前三位，<code>xxx=abc</code>：</p>
<p>(2.1) <code>d &lt; 1</code>，<code>abc1yyy &gt; abc0defg</code>，共0次数；</p>
<p>(2.2) <code>d = 1</code>，后三位可以取到<code>yyy=000~efg</code>，共<code>efg+1</code>次数；</p>
<p>(2.3) <code>d &gt; 1</code>，后三位可以取到<code>yyy=000~999</code>，共1000次数</p>
</li>
</ol>
<p>把所有情况加到一起就是1出现在第4位上的次数。时间复杂度$10<em>2</em>8*10=1600$，（0~9十个数，计算2个<code>count()</code>，数字共8位，）。考虑一些边界情况：所求数字在第一位出现的次数——没有情况1；求0在某一位出现的次数，如在第4位，前三位<code>abc</code>不能取<code>000</code>，既不能有前导0，即<code>000123</code>不是一个合法的写法，应直接写成是<code>123</code>，这样就不会有0的次数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">001~abc-1, 999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">    1. num[i] &lt; x, 0</span></span><br><span class="line"><span class="comment">    2. num[i] == x, 0~efg</span></span><br><span class="line"><span class="comment">    3. num[i] &gt; x, 0~999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>    <span class="comment">//取出num中从l到r位的数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= r; i -- ) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power10</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//求10的x次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x -- ) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(n % <span class="number">10</span>);    <span class="comment">//将n的每一位存入vector num</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">get</span>(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * power10(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= power10(i);    <span class="comment">//若x是0，则有去掉前几位都是0的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += <span class="built_in">get</span>(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; x) res += power10(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b , a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; count(b, i) - count(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-状态压缩DP"><a href="#3-状态压缩DP" class="headerlink" title="3.状态压缩DP"></a>3.状态压缩DP</h3><blockquote>
<p>例题1：蒙德里安的梦想（Acwing 291）</p>
<p>求把$N<em>M$的棋盘分割成若干个1</em>2的的长方形，有多少种方案。例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。如下图所示：</p>
<p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201103210738.png" alt></p>
<p>数据范围：$1≤N,M≤11$</p>
</blockquote>
<p>上面的问题可以理解为：在下面$1*1$的网格中，我们把所有的横向长方形放完之后，纵向长方形的摆放只有一个方案，因此问题总的方案数就等于摆放横着的小长方形的方案数。</p>
<p>我们可以按列来求，每一列用一个状态<code>f[i,j]</code>来表示，第<code>i</code>列，上一列“伸出”的小长方形的行的状态用<code>j</code>表示，用二进制表示状态数，如共有5行，那<code>j</code>的状态数就是$0 \sim 31$，即<code>j</code>表示上一列有哪些行“伸出”了小长方形，如下图所示$j=(10010)_2$。</p>
<p>若当前要算的状态是第<code>i</code>列的<code>j=00001</code>，前一列<code>k=10010</code>，这两列伸出的小长方形不能冲突，即<code>(j &amp; k) == 0</code>，第<code>i-1</code>列所有空白行的个数必须是偶数，因为我们枚举完第<code>i</code>列后，第<code>i-1</code>列剩下的空白必须要用竖着的小长方形来填，其长度为2，因此<code>j | k</code>（j 或k ）不能有连续奇数个0，可以先预处理出来。</p>
<p>状态转移方程：<code>f[i,j] += f(i - 1, k)</code>，时间复杂度：$2 \times 2^{11} \times 2^{11}=4 \times 10^7 $， 满足要求。</p>
<blockquote>
<p>用二进制去表示状态，是个思维上的难点。</p>
</blockquote>
<p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201103215715.png" style="zoom:875%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;  <span class="comment">// n行，m列</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][M];  </span><br><span class="line"><span class="keyword">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)   <span class="comment">//预处理单列中所有状态是不是存在连续奇数个0，即摆放完横的了，还能不能再摆竖的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">// cnt 表示单列中连续一段的0的个数</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)    <span class="comment">//若当前这一位是1，说明这一段中横着的已经放好了，就判断一下上一段中是否有奇数个0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)  st[i] = <span class="literal">false</span>;   <span class="comment">// 如果cnt是奇数，则不行</span></span><br><span class="line">                    cnt = <span class="number">0</span>;   <span class="comment">// 遇到1了，说明连续一段结束了，cnt 归为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)  st[i] = <span class="literal">false</span>;   <span class="comment">// 最后再判断一下最后一段的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 第一列，只有j是0时，才有一种方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)   <span class="comment">//枚举第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++)    <span class="comment">//枚举第i列的所有状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++)    <span class="comment">//枚举第i - 1列的所有状态</span></span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])   <span class="comment">//如果j与上k=0，且j|k不存在连续奇数个0</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];     <span class="comment">//状态转移方程</span></span><br><span class="line">                        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//第m-1列必须没有“伸出”任何横着的小长方形，即f[m][0]就是所求方案数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题2：最短Hamilton路径</p>
<p>给定一张$ n $个点的带权无向图，点从$ 0 \sim n-1$标号，求起点$ 0 $到终点$ n-1 $的最短Hamilton路径。 Hamilton路径的定义是从$ 0 $到$ n-1 $不重不漏地经过每个点恰好一次。</p>
<p>输入格式：第一行输入整数n。接下来n行每行n个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为$a[i,j]$）。对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。</p>
<p>数据范围：$1≤n≤20, 0≤a[i,j]≤10^7$</p>
</blockquote>
<p>暴力做法：枚举要走的点的顺序，$n!$；再求路径的长度，$n$；时间复杂度就是$20!*20$，大概有20位数字，肯定不满足要求了。考虑用状态压缩DP来做：</p>
<ul>
<li>状态表示<code>f[i,j]</code>：<ul>
<li>集合：所有从0走到j，走过的所有点是<code>i</code>的所有路径；走过的点存在<code>i</code>之中，用二进制数表示所有点的状态</li>
<li>属性：MIn，求最短Hamilton路径</li>
</ul>
</li>
<li>状态计算：<ul>
<li>集合划分：以倒数第二个点来分类，分为倒数第二个点是$0,1,2,\dots,n-1$；设倒数第二个值为$k$，<code>a[k][j]</code>表示点<code>k</code>到点<code>j</code>的距离，从0走到点<code>k</code>的所有点就等于从0走到点<code>j</code>的所有点减去点<code>j</code>，即<code>i-{j}</code>；</li>
<li>则状态转移方程为：<code>f[i,j]=min(f[i,j], f[i-{j}, k]) + a[k][j]</code>，$k=0,1,2\dots,n-1$</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)   <span class="comment">//枚举所有点有没有被经过的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)    <span class="comment">//枚举路径中最后一个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)             <span class="comment">//如果i的二进制表示中的第j位是1，即当前路径中经过了j</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++)      <span class="comment">//枚举路径中倒数第二个点</span></span><br><span class="line">                    <span class="keyword">if</span>((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>)  <span class="comment">//如果当前路径经过的点的状态减去点j的状态，即从0到倒数第二个点的路径中有经过点k</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);    <span class="comment">//则可以状态转移</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//最后应该输出从0到点n-1，且所有点都有经过的路径的最短长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-树形DP"><a href="#4-树形DP" class="headerlink" title="4.树形DP"></a>4.树形DP</h3><blockquote>
<p>例题：没有上司的舞会（Acwing 285）</p>
<p>Ural大学有N名职员，编号为1~N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数$ H_i $给出，其中$ 1≤i≤N$。现在要召开一场周年庆宴会，不过，<strong>没有职员愿意和直接上司一起参会</strong>。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p>
<p>输入格式：第一行一个整数$N$。接下来$N$行，第$ i $行表示$ i $号职员的快乐指数$H_i$。接下来$N-1$行，每行输入一对整数$L, K$,表示$K$是$L$的直接上司。</p>
<p>输出格式：输出最大的快乐指数。</p>
<p>数据范围：$1≤N≤6000,−128≤H_i≤127$</p>
</blockquote>
<ul>
<li><p>状态表示：</p>
<ul>
<li>集合：<code>f[u,0]</code>表示所有从以<code>u</code>为根的子树中选择，并且不选<code>u</code>这个点的方案；<code>f[u,1]</code>表示所有从以<code>u</code>为根的子树中选，并且选择<code>u</code>这个点的方案；</li>
<li>属性：Max，求方案中点值之和的最大值</li>
</ul>
</li>
<li><p>状态计算：</p>
<ul>
<li>对于<code>f[u,0]</code>，不选点<code>u</code>，则其孩子节点可以选或者不选，则$f[u,0]=\sum \max(f[s_i,0], f[s_i,1])$；</li>
<li><p>对于<code>f[u,1]</code>，选了点<code>u</code>，则其孩子节点不可以选，则$f[u,1]=\sum \max(f[s_i,0])+h_u$  </p>
</li>
<li><p>时间复杂度：每个状态在计算时要枚举它的孩子节点，所以节点的孩子的总数就是树中边的个数，即$n-1$，因此时间复杂度为$O(n)$</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> happy[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;   <span class="comment">//用邻接表存树</span></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> has_father[N];    <span class="comment">//本题中没有告诉根节点是谁，需要自己判断，根节点即是没有父节点的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>    <span class="comment">//递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];   <span class="comment">// j是u的某一个子节点</span></span><br><span class="line">        dfs(j);</span><br><span class="line">        </span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;happy[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;   <span class="comment">// b是a的父节点</span></span><br><span class="line">        add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root])  root ++;  <span class="comment">//没有父节点的就是根节点</span></span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-记忆化搜索"><a href="#5-记忆化搜索" class="headerlink" title="5. 记忆化搜索"></a>5. 记忆化搜索</h3><p>前面求解每种状态是用到了循环，这个题来看一下怎么用递归的方法来做DP问题。</p>
<blockquote>
<p>给定一个R行C列的矩阵，表示一个矩形网格滑雪场。矩阵中第$ i $行第$ j $列的点表示滑雪场的第$ i $行第$j $列区域的高度。一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p>
<p>下面给出一个矩阵作为例子：</p>
<p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201104180646.png" style="zoom:80%;"></p>
<p>在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p>
<p>数据范围：$1≤R,C≤300,0≤$矩阵中整数$≤10000$。</p>
</blockquote>
<ul>
<li><p>状态表示<code>f[i.j]</code>：</p>
<ul>
<li>集合：<code>f[i,j]</code>表示所有从$(i,j)$开始滑的路径</li>
<li>属性：Max</li>
</ul>
</li>
<li><p>状态计算：</p>
<ul>
<li>集合划分：把<code>f[i,j]</code>的所有路径分为四类：向上，下，左，右滑，<code>f[i,j]</code>应等于四类取值的最大值；当然每一类并不一定存在，需要其高度低于当前点的高度。（图必须是拓扑图，即不存在环，本题的状态中显然是不存在环的，因为高度递减，一定是无环的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>记忆化搜索的好处是“代码复杂度”低，思路简单，代码好写。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">//上、右、下、左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[x][y];   <span class="comment">// 引用</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>)  <span class="keyword">return</span> v;   <span class="comment">// 如果dp(x,y)已经算过了，就直接返回其值就行</span></span><br><span class="line">    </span><br><span class="line">    v = <span class="number">1</span>;   <span class="comment">// v的最小值是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &gt;=<span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(v, dp(a, b) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8815%EF%BC%89/" rel="prev" title="算法基础（15）">
      <i class="fa fa-chevron-left"></i> 算法基础（15）
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-计数类DP"><span class="nav-text">1.计数类DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数位统计DP"><span class="nav-text">2.数位统计DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-状态压缩DP"><span class="nav-text">3.状态压缩DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-树形DP"><span class="nav-text">4.树形DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-记忆化搜索"><span class="nav-text">5. 记忆化搜索</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nekomoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">nekomoon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nekomoon404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nekomoon404" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nekomoon404@163.com" title="E-Mail → mailto:nekomoon404@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020.1.12 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nekomoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">665k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


   
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200112,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

</body>
</html>
