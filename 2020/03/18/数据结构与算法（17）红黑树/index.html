<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://nekomoon404.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="红黑树是针对AVL树的不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法（17）红黑树">
<meta property="og:url" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/index.html">
<meta property="og:site_name" content="nekomoon的个人小站">
<meta property="og:description" content="红黑树是针对AVL树的不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323171857.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323173038.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323180432.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323183129.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323185253.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323195423.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323195806.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323201303.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323204458.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323202625.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323202629.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323212616.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323212631.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323212700.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323212724.png">
<meta property="article:published_time" content="2020-03-18T08:24:28.000Z">
<meta property="article:modified_time" content="2020-03-23T14:01:07.310Z">
<meta property="article:author" content="nekomoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ%E5%9B%BE%E7%89%8720200323171857.png">

<link rel="canonical" href="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>数据结构与算法（17）红黑树 | nekomoon的个人小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="nekomoon的个人小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nekomoon的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="nekomoon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nekomoon的个人小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法（17）红黑树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-18 16:24:28" itemprop="dateCreated datePublished" datetime="2020-03-18T16:24:28+08:00">2020-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-23 22:01:07" itemprop="dateModified" datetime="2020-03-23T22:01:07+08:00">2020-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <div class="post-description">红黑树是针对AVL树的不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-动机"><a href="#1-1-动机" class="headerlink" title="1.1.动机"></a>1.1.动机</h2><p>平衡二叉搜索树的形式多样，如伸展树实现简便，无需修改节点结构、分摊复杂度低，但最坏情况下的单次操作需要$\Omega(n)$时间；AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识，且删除之后的重平衡可能需做多达$\Omega(\log n)$次旋转，从而频繁地导致全树整体拓扑结构的大幅度变化。</p>
<p>红黑树即是针对后一不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。尽管最怀情况下需对多达$\Omega(\log n)$个节点重染色，但就分摊意义为言仅为$O(1)$个。</p>
<p>为此需要在AVL树“适度平衡”标准的基础上，进一步放宽条件，红黑树所采用的<strong>“适度平度”标准</strong>可大致表述为：<strong>任一节点左、右子树的高度，相差不得超过两倍</strong>。</p>
<p>不论是线性的向量、列表、栈或队列，也无论半线性的树结构 以及非线性的图结构，它们大多呈现这么样一种特征：每当经过一次动态的操作 使得其中的逻辑结构发生变化之后，它都会随即完全的转入新的状态 同时将此前的状态完全的遗忘掉，这类结构也因此称作<strong>ephemeral data structure</strong>，也就是说它们都是随时变化的，每一个状态只会存在于某一个瞬间。</p>
<p>然而在实际应用中往往可能会有更高的要求，比如若将数据结构比作是人，那么它的每一个瞬间状态都相当于人一生中某一时刻的快照，我们或许会对他的历史档案感兴趣，并希望能够任意调阅甚至修改某个历史时刻的档案。因此无论静态还是动态操作，<strong>除了指定目标关键码</strong>，<strong>还需要同时指定一个版本号</strong>，用以说明我们是在这个数据结构的哪一份历史档案中去查找特定对象。如果一个数据结构能够支持这种类型的需求，就称作是<strong>一致性结构，或持久性结构（persistent structures）</strong>。</p>
<p>乍看起来任意数据结构的持久化都不是那么困难的一件事，比如一种直接了当的方法就是为数据结构的每一个所需的版本都独立的保存一份快照，同时将所有版本的入口组成一个搜索结构。这里我们针对一棵真实的BBST记录了它整个生命期内的5个版本。这样 一旦指定了版本号，我们就可以转入对应的快照，并按照常规搜索方法在其中定位需要操作的元素。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323171857.png" style="zoom: 45%;"></p>
<p>从单次访问的效率而言这个结构还可以接受，如果将整个历史快照的数目记作h，那么每次我们只需$O(\log h)$的时间便可确定版本档案的入口，接下来再花费$O(\log n)$的时间，在这份档案中进行定位和操作，即<strong>单次操作</strong>需$O(\log h+\log n)$时间。然而就空间而言这种方法是断乎不可接受的，在这样的一组历史快照中每一个元素都可能会被保存多份，渐近的来说n个元素中的每一个都有可能在这组档案中被保存多达h份，这就意味着空间复杂度将伴随着h成线性的速度增长。空间复杂度自然也构成了时间复杂度的一个下限，因此在整个历史过程中为了生成和记录所有的快照，<strong>累计</strong>所花费的时间也会多达$O(h*n)$这样一个规模，分摊下来为了生成每一组快照都大致需要花费线性的时间来创建一个完整的副本。</p>
<p>那么我们可否就此做一改进呢，比如除了所有元素各自所占用的空间，是否能够将每一个版本所消耗的均摊空间量控制在$O(\ log n)$的范围内呢，即将复杂度控制在$O(n+h<em>\log n)$内呢？答案是可以，为此我们需要<em>*利用同一数据结构相邻版本之间的关联性</em></em>。</p>
<p>对于每一组相邻的历史快照而言，后者都是在前者的基础上做过相对少量的更新而得的，即绝大部分的数据对象在二者之中都是相同的，二者的差异只是非常非常小的一部分。因此可以改用这样一种策略：大量的元素都作共享，只有发生变化的少量的数据元素才需要进行更新。</p>
<p>实际上只要实现方法得当，完全可以将相邻版本之间的差异量控制在$O(\log n)$的范围。比如对于BBST而言 下图就是一种可行的实现方法：每一条红线都对应于一个共享，蓝色的虚线所指示的是在相邻版本之间的更新量，也是我们不得不花费空间来进行存储的量，而这个量可以控制在极低的水平。在《计算几何》课程中会介绍这类高级结构。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323173038.png" style="zoom: 60%;"></p>
<p>进一步地，我们能否将BBST前后版本的空间差异控制在$O(1)$的范围呢？这样整体的<strong>空间复杂度将进一步优化至$O(n+h)$</strong> 而不是$O(h*\log n)$。答案也是可以的。</p>
<p>为此所应具备的一项必要条件是非常好理解的，即就BBST的树形拓扑结构而言，相邻版本之间的差异本身不能超过常数。然而很遗憾绝大多数的BBST，包括AVL树都不能保证这一点。所谓的拓扑结构差异无非是来自自调整过程中的旋转操作，每一次局部的旋转都意味着在结构上引入常数的差异。因此反过来如果需要保证前后版本在拓扑结构上的差异不超过常数，也就意味着在<strong>从前一版本转入后一版本的过程中所执行的旋转操作不得超过常数次</strong>。</p>
<p>反观AVL树的两个动态操作，插入操作是满足这一条的，每次插入之后一旦经过一次旋转，局部乃至全树的高度都会复原；然而删除操作却不满足，从AVL树中删除一个节点之后有可能自底而上逐层引发多达$O(\log n)$次的旋转，从而导致树形拓扑结构的剧烈变化。</p>
<p>因此为了使得上述的构思能够兑现就需要这样一种BBST，它的<strong>任何动态操作，无论插入还是删除对树形拓扑结构的影响都能控制在常数的范围之内</strong>，而<strong>红黑树（red-black tree）</strong>正是具有这一特性的一个变种。</p>
<h2 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2.结构"></a>1.2.结构</h2><p>为便于对红黑树的理解、实现与分析，不妨按照此前介绍的B-树的做法，统一地引入n+1个外部节点NULL，以保证原树中每一节点的左、右孩子均非空，如此可将二叉树扩展为真二叉树。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323180432.png" style="zoom: 33%;"></p>
<p>由红、黑两色节点组成的二叉搜索树若满足一下条件，即为<strong>红黑树（red-black tree）</strong>：</p>
<p><strong>（1）</strong>树根始终为黑色；</p>
<p><strong>（2）</strong>外部节点均为黑色；</p>
<p><strong>（3）</strong>其余节点若为红色，则其孩子节点必为黑色；</p>
<p><strong>（4）</strong>从任一外部节点到根节点的沿途，黑节点的数目相等。</p>
<p>其中，条件（1）和（2）意味着红节点均为内部节点，且其父亲点及左、右孩子必然存在。条件（3）意味着红节点之父必为黑色，因此树中任一通路都不含相邻的红节点。可见在从根节点通往任一节点的沿途，黑节点都不少于红节点，除去根节点本身，沿途所经黑节点的总数称作节点的<strong>黑深度（black depth）</strong>——根节点的黑深度为0，故条件（4）可理解为“所有外部节点的黑深度统一”。</p>
<p>由条件（4）可进一步推知，在从任一节点通往其任一后代外部节点的沿途，黑节点的总数亦必相等。除去（黑色）外部节点，沿途所经黑节点的总数称作该节点的<strong>黑高度（black height）</strong>——所有外部节点的黑高度均为0。特别地，根节点的黑高度亦称作全树的黑高度，在数值上与外部节点的黑深度相等。</p>
<h4 id="2-4-树-红黑树"><a href="#2-4-树-红黑树" class="headerlink" title="(2,4)树 == 红黑树"></a>(2,4)树 == 红黑树</h4><p>红黑树与B-树之间，存在极其密切的联系，经适当转换之后，二者相互等价。具体地，自顶而下逐层考查红黑树各节点，每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，二者之间的联边则相应地调整为横向。如此转换之后，沿水平方向相邻的边至多两条，涉及的节点至多三个，此时若将原红黑树的节点视作关键码，沿水平方向相邻的每一组（父亲至多三个）节点恰好构成4阶B-树的一个节点。</p>
<p>下图针对所有可能的情况，分别给出了具体的转换过程。按照上述对应关系，每棵红黑树都等价于一棵(2,4)-树：前者的每一节点都对应于后者的一个关键码。通往黑节点的边，对黑高度有贡献，并在(2,4)-树中得以保留；通往红节点的边对黑高度没有贡献，在(2,4)-树中对应于节点内部一对相邻的关键码。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323183129.png" style="zoom: 45%;"></p>
<p>对照红黑树的条件，(2,4)-树中的每个节点应包含且仅包含一个黑关键码，同时红关键码不得超过两个，而且若某个节点果真包含两个红关键码，则黑关键码的位置必然居中。</p>
<h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>与所有二叉搜索树一样，红黑树的性能首先取决于其平衡性。包含n个内部节点的红黑树T的高度h也不致超过$O(\log n)$，更严格地有：$\log_2(n+1)\le h\le 2 \cdot \log_2(n+1)$。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323185253.png" style="zoom:67%;"></p>
<p>若将T的黑高度记作H，则H也是T多对应(2,4)-树，故由关于B-树高度与所含关键码总数关系的结论，有：</p>
<script type="math/tex; mode=display">
H\le 1+\log_{\lceil \frac{4}{2} \rceil} \lfloor \frac{n+1}{2} \rceil \le 1+ \log_2 \lfloor \frac{n+1}{2} \rfloor \le \log _2(n+1)</script><p>既然任一通路都不含相邻的红节点，故必有：</p>
<script type="math/tex; mode=display">
h \le 2H \le 2\cdot \log_2(n+1)=O(\log n)</script><p>尽管红黑树不能如完全树那样可做到理想平衡，也不如AVL树那样可做到较严格的适度平衡，但其高度仍控制在最小高度的两倍以内，从渐进的角度看仍是$O(\log n)$，依然保证了适度平衡——这正是红黑树可高效率支持各种操作的基础。</p>
<h2 id="1-3-红黑树接口定义"><a href="#1-3-红黑树接口定义" class="headerlink" title="1.3.红黑树接口定义"></a>1.3.红黑树接口定义</h2><p>基于<code>BST</code>模板类，可派生出<code>RedBlack</code>模板类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BST/BST.h"</span> <span class="comment">//基于BST实现RedBlack</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">RedBlack</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//RedBlack树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleRed</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//双红修正</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleBlack</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//双黑修正</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateHeight</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//更新节点x的高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   BinNodePosi(T) insert ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//插入（重写）</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除（重写）</span></span><br><span class="line"><span class="comment">// BST::search()等其余接口可直接沿用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里直接沿用了BST的查找算法<code>search()</code>，并根据红黑树的重平衡规则与算法，重写了<code>insert()</code>和<code>remove()</code>接口；新加的两个内部功能接口<code>solveDoubleRed()</code>和<code>solveDoubleBlack()</code>，分别用于在节点插入或删除之后恢复全树平衡。</p>
<p>另外还需使用此前二叉树节点模板类<code>BinNode</code>中预留的两个成员变量height和color，可借助辅助宏来检查节点的颜色以及判定是否需要更新（黑）高度记录。这里的确并未真正地实现外部节点，而是将它们统一地直接判定为黑“节点”——尽管它们实际上只不过是<code>NULL</code>，其余节点则一概视作节点。下面是用以简化红黑树算法描述的宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsBlack(p) ( ! (p) || ( RB_BLACK == (p)-&gt;color ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsRed(p) ( ! IsBlack(p) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BlackHeightUpdated(x) ( <span class="comment">/* RedBlack高度更新条件 */</span> \</span></span><br><span class="line">   ( stature( (x).lc ) == stature( (x).rc ) ) &amp;&amp; \</span><br><span class="line">   ( (x).<span class="built_in">height</span> == ( IsRed( &amp;x ) ? stature( (x).lc ) : stature( (x).lc) + <span class="number">1</span> ) ) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下面是红黑树节点的黑高度更新的算法实现，此处的height已不再是指常规的树高，而是红黑树的黑高度，节点黑高度需要更新的情况共分三种：左、右孩子的黑高度不等；或者作为红节点，黑高度与其孩子不相等；或者作为黑节点，黑高度不等于孩子的黑高度加一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> RedBlack&lt;T&gt;::updateHeight ( BinNodePosi(T) x ) &#123; <span class="comment">//更新节点高度</span></span><br><span class="line">   x-&gt;<span class="built_in">height</span> = __max ( stature ( x-&gt;lc ), stature ( x-&gt;rc ) ); <span class="comment">//孩子一般黑高度相等，除非出现双黑</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 红黑树中各节点左、右孩子的黑高度通常相等</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 这里之所以取更大值，是便于在删除节点后的平衡调整过程中，正确更新被删除节点父亲的黑高度</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 否则，rotateAt()会根据被删除节点的替代者（高度小一）设置父节点的黑高度</span></span><br><span class="line">   <span class="keyword">return</span> IsBlack ( x ) ? x-&gt;<span class="built_in">height</span>++ : x-&gt;<span class="built_in">height</span>; <span class="comment">//若当前节点为黑，则计入黑深度</span></span><br><span class="line">&#125; <span class="comment">//因统一定义stature(NULL) = -1，故height比黑高度少一，好在不致影响到各种算法中的比较判断</span></span><br></pre></td></tr></table></figure>
<h1 id="2-节点插入算法"><a href="#2-节点插入算法" class="headerlink" title="2.节点插入算法"></a>2.节点插入算法</h1><h2 id="2-1-节点插入与双红现象"><a href="#2-1-节点插入与双红现象" class="headerlink" title="2.1.节点插入与双红现象"></a>2.1.节点插入与双红现象</h2><p>假定经调用接口<code>search(e)</code>做查找之后，确认目标节点尚不存在。于是，在查找终止的位置<code>x</code>处创建节点，并随机将其染成红色（除非次时全树仅含一个节点），对照红黑树的四项条件，唯有（3）未必满足——即此时x的父亲可能是红色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) RedBlack&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将e插入红黑树</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span> ); _size++; <span class="comment">//创建红节点x：以_hot为父，黑高度-1</span></span><br><span class="line">   BinNodePosi(T) xOld = x; solveDoubleRed ( x ); <span class="keyword">return</span> xOld; <span class="comment">//经双红修正后，即可返回</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure>
<p>因新节点的引入，而导致父子节点同时为红色的此类情况，称作“<strong>双红”（double red）</strong>，为修正双红缺陷，可调用<code>solveDoubleRed(x</code>)接口。每引入一个关键码，该接口都可能迭代地调用多次。在此过程红，当前节点x的兄弟及两个孩子（初始时都是外部节点），始终均为黑色。</p>
<p>将<code>x</code>的父亲与祖父分别记作<code>p</code>和<code>g</code>，既然此前的红黑树合法，故作为红节点<code>p</code>的父亲，<code>g</code>必然存在且为黑色。<code>g</code>作为内部节点，其另一孩子（即p的兄弟、x的叔父）也必然存在，将其记作<code>u</code>。以下，视节点<code>u</code>的颜色不同，分两类情况分别处置。</p>
<h2 id="2-2-双红修正"><a href="#2-2-双红修正" class="headerlink" title="2.2.双红修正"></a>2.2.双红修正</h2><h3 id="2-2-1-RR-1"><a href="#2-2-1-RR-1" class="headerlink" title="2.2.1. RR-1"></a>2.2.1. RR-1</h3><p>首先，考查<code>u</code>为黑色的情况，此时<code>x</code>的兄弟、两个孩子的黑高度，均与<code>u</code>相等。下图中的(a)和(b)即为此类情况的两种可能（另有两种对称情况）。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323195423.png" style="zoom: 80%;"></p>
<p>此时红黑树条件（3）的违反，从B-树的角度等效地看，<strong>即同一节点不应包含紧邻的红色关键码</strong>。故只需令黑色关键码与紧邻的红色关键码互换颜色，这等效于按中序遍历次序，对节点<code>x</code>、<code>p</code>和<code>g</code>及其四棵子树，<strong>做一次局部“3+4”重构</strong>。</p>
<p>如此调整之后，局部子树的黑高度将复原，这意味着全树的平衡也必然得以恢复，同时新子树的根节点b为黑色，也不致引发新的双红现象，至此整个插入操作遂告完成。</p>
<h3 id="2-2-2-RR-2"><a href="#2-2-2-RR-2" class="headerlink" title="2.2.2. RR-2"></a>2.2.2. RR-2</h3><p>再考查节点<code>u</code>为红色的情况，此时<code>u</code>的左、右孩子非空且均为黑色，其黑高度必与<code>x</code>的兄弟以及两个孩子相等。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323195806.png" style="zoom:75%;"></p>
<p>此时红黑树条件（3）的违反，从B-树角度等效地看，<strong>即该节点因超过4度而发生上溢</strong>。从图(c)红黑树的角度看，只需将红节点<code>p</code>和<code>u</code>转为黑色，黑节点<code>g</code>转为红色，<code>x</code>保持红色；从图(c’)的角度看，<strong>等效于上溢节点的一次分裂</strong>。</p>
<p>如此调整之后局部子树的黑高度复原，然而子树根节点<code>g</code>转为红色之后，有可能在更高层再次引发双红现象，对应于在关键码<code>g</code>被移出并归入上层节点之后，进而导致上层节点的上溢——即<strong>上溢的向上传播</strong>。若发生这种传播，可将<code>g</code>视作新插入的节点，同样地分以上两类情况如法处置，每经过一次这样的迭代，节点<code>g</code>都将在B-树中（作为关键码）上升一层，而在红黑树中存在双红缺陷的位置也将相应地上升两层，故累计至多迭代$O(\log n)$次。</p>
<p>特别地，若最后一步迭代之后导致原树根的分裂，并由<code>g</code>独立地构成新的树根节点，则应遵照红黑树条件（1）的要求，将其转换为黑色，如此，全树的黑高度随机增加一层。</p>
<h3 id="2-2-3-复杂度"><a href="#2-2-3-复杂度" class="headerlink" title="2.2.3. 复杂度"></a>2.2.3. 复杂度</h3><p>以上情况的处理流程可归纳为下图，其中的重构、染色等局部操作均只需常数时间、故只需统计这些操作在修正过程中被调用的总次数。可知节点插入之后的双红修正，累计耗时不会超过$O(\log n)$，即便计入此前的关键码查找预计节点接入等操作，<strong>红黑树的每次节点插入操作，都可在$O(\log n)$时间内完成</strong>。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323201303.png" style="zoom: 75%;"></p>
<p>需要指出的是，只有在<strong>RR-1</strong>修复时才需要1~2次旋转，而且一旦旋转后，修复过程必然随即完成，故<strong>就全树拓扑结构而言，每次插入后仅涉及常数次调整</strong>；下小节将要介绍的红黑树的节点删除操作也是如此，而回顾此前学过的AVL树，却只能保证前一点。</p>
<h3 id="2-2-4-实现"><a href="#2-2-4-实现" class="headerlink" title="2.2.4. 实现"></a>2.2.4. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * RedBlack双红调整算法：解决节点x与其父均为红色的问题。分为两大类情况：</span></span><br><span class="line"><span class="comment"> *    RR-1：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    RR-2：3次颜色翻转，3次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleRed ( BinNodePosi(T) x ) &#123; <span class="comment">//x当前必为红</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRoot ( *x ) ) <span class="comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span></span><br><span class="line">      &#123;  _root-&gt;color = RB_BLACK; _root-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span>;  &#125; <span class="comment">//否则，x的父亲p必存在</span></span><br><span class="line">   BinNodePosi(T) p = x-&gt;parent; <span class="keyword">if</span> ( IsBlack ( p ) ) <span class="keyword">return</span>; <span class="comment">//若p为黑，则可终止调整。否则</span></span><br><span class="line">   BinNodePosi(T) g = p-&gt;parent; <span class="comment">//既然p为红，则x的祖父必存在，且必为黑色</span></span><br><span class="line">   BinNodePosi(T) u = uncle ( x ); <span class="comment">//以下，视x叔父u的颜色分别处理</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( u ) ) &#123; <span class="comment">//u为黑色（含NULL）时 //*DSA*/printf("  case RR-1:\n");</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *x ) == IsLChild ( *p ) ) <span class="comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span></span><br><span class="line">         p-&gt;color = RB_BLACK; <span class="comment">//p由红转黑，x保持红</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span></span><br><span class="line">         x-&gt;color = RB_BLACK; <span class="comment">//x由红转黑，p保持红</span></span><br><span class="line">      g-&gt;color = RB_RED; <span class="comment">//g必定由黑转红</span></span><br><span class="line"><span class="comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span></span><br><span class="line"><span class="comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//曾祖父（great-grand parent）</span></span><br><span class="line">      BinNodePosi(T) r = FromParentTo ( *g ) = rotateAt ( x ); <span class="comment">//调整后的子树根节点</span></span><br><span class="line">      r-&gt;parent = gg; <span class="comment">//与原曾祖父联接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u为红色 //*DSA*/printf("  case RR-2:\n");</span></span><br><span class="line">      p-&gt;color = RB_BLACK; p-&gt;<span class="built_in">height</span>++; <span class="comment">//p由红转黑</span></span><br><span class="line">      u-&gt;color = RB_BLACK; u-&gt;<span class="built_in">height</span>++; <span class="comment">//u由红转黑</span></span><br><span class="line">      <span class="keyword">if</span> ( !IsRoot ( *g ) ) g-&gt;color = RB_RED; <span class="comment">//g若非根，则转红</span></span><br><span class="line">      solveDoubleRed ( g ); <span class="comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-节点删除算法"><a href="#3-节点删除算法" class="headerlink" title="3.节点删除算法"></a>3.节点删除算法</h1><h2 id="3-1-节点删除与双黑现象"><a href="#3-1-节点删除与双黑现象" class="headerlink" title="3.1. 节点删除与双黑现象"></a>3.1. 节点删除与双黑现象</h2><p>为删除关键码<code>e</code>，首先调用标准接口<code>BST::search(e)</code>进行查找，若查找成功，则调用内部接口<code>removeAt(x)</code>实施删除，按照对该接口所约定的语义，<code>x</code>为实际被摘除者，其父亲为<code>p = _hot</code>，其接替者为<code>r</code>，而<code>r</code>的兄弟为外部节点<code>w = NULL</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> RedBlack&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从红黑树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   BinNodePosi(T) r = removeAt ( x, _hot ); <span class="keyword">if</span> ( ! ( --_size ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//实施删除</span></span><br><span class="line"><span class="comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span></span><br><span class="line">   <span class="keyword">if</span> ( ! _hot ) <span class="comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span></span><br><span class="line">      &#123; _root-&gt;color = RB_BLACK; updateHeight ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）必非根，_hot必非空</span></span><br><span class="line">   <span class="keyword">if</span> ( BlackHeightUpdated ( *_hot ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若所有祖先的黑深度依然平衡，则无需调整</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRed ( r ) ) <span class="comment">//否则，若r为红，则只需令其转黑</span></span><br><span class="line">      &#123; r-&gt;color = RB_BLACK; r-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）均为黑色</span></span><br><span class="line">   <span class="comment">//*DSA*/printBinTree(_hot, 0, 0);</span></span><br><span class="line">   solveDoubleBlack ( r ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//经双黑调整后返回</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure>
<p>因随后的复衡调整位置可能逐层上升，故不妨等效地理解为：<code>w</code>系与<code>r</code>黑高度相等的子红黑树，且随其父亲<code>x</code>一并被摘除，如此可将<code>x</code>统一视作上分支节点，从而更为通用地描述以下算法。不难验证此时红黑树的前两个条件继续满足，但后两个条件却未必。</p>
<p>当然若<code>x</code>原为树根，则无论<code>r</code>颜色如何，只需将其置为黑色并更新黑高度即可，因此不妨假定<code>x</code>的父亲<code>p</code>存在。可分为下面三种情况：第一种只需进行普通的删除操作，即摘除子树<code>w</code>，并将<code>x</code>替换为<code>r</code>；第二种只需在删除操作之后将<code>r</code>转为黑色；第三种，<code>x</code>与<code>r</code>均为黑色，则在删除操作之后，局部子树的黑高度将会降低一个单位。</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323204458.png" style="zoom: 80%;"></p>
<p>被删除节点<code>x</code>以其替代者<code>r</code>同为黑色的此类情况，称作<strong>“双黑”（double black）</strong>，此时需调用<code>solveDoubleBlack(r)</code>算法予以修正。为此需考查原黑节点<code>x</code>的兄弟<code>s</code>（必然存在，但可能是外部节点），并视<code>s</code>和<code>p</code>颜色的不同组合，按四种情况分别处置。</p>
<h2 id="3-2-双黑修正"><a href="#3-2-双黑修正" class="headerlink" title="3.2. 双黑修正"></a>3.2. 双黑修正</h2><h3 id="3-2-1-BB-1-s为黑，且至少有一个红孩子t"><a href="#3-2-1-BB-1-s为黑，且至少有一个红孩子t" class="headerlink" title="3.2.1. BB-1: s为黑，且至少有一个红孩子t"></a>3.2.1. BB-1: s为黑，且至少有一个红孩子t</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323202625.png" style="zoom:80%;"></p>
<p>既然节点<code>x</code>的另一个孩子<code>w = NULL</code>，故从B-树角度看节点<code>x</code>被删除之后的情况，可等效理解为关键码<code>x</code>原所属的节点发生下溢。此时<code>t</code>和<code>s</code>必然属于B-树的同一节点，且该节点就是下溢节点的兄弟。故可参照B-树，下溢节点从父亲点借出一个关键码<code>p</code>，然后从父亲节点从下溢节点的兄弟节点借出一个关键s。</p>
<p>上述调整过程等效于，对节点<code>t</code>、<code>s</code>和<code>p</code>实施<strong>“3 + 4 重构”</strong>。若这三个节点按中序遍历次序重命名为<code>a</code>，<code>b</code>和<code>c</code>，则还需将<code>a</code>和<code>c</code>染成黑色，<code>b</code>则继承<code>p</code>此前的颜色。对上图的例子而言，就是将<code>t</code>和<code>p</code>染成黑色，<code>s</code>继承<code>p</code>此前的颜色，整个过程中节点<code>r</code>保持黑色不变。</p>
<p>经过以上处理之后，红黑树的所有条件，都在这一局部以及全局得到恢复，故删除操作遂高完成。</p>
<h3 id="3-2-2-BB-2-R：s为黑，且两个孩子均为黑；p为红"><a href="#3-2-2-BB-2-R：s为黑，且两个孩子均为黑；p为红" class="headerlink" title="3.2.2. BB-2-R：s为黑，且两个孩子均为黑；p为红"></a>3.2.2. BB-2-R：s为黑，且两个孩子均为黑；p为红</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323202629.png" style="zoom:80%;"></p>
<p>与BB-1类似，在对应的B-树中，关键码<code>x</code>的删除导致其所属的节点下溢，但因此时关键码<code>s</code>所在节点只有两个分支，故下溢节点无法从父节点借出关键码<code>p</code>。同样按照B-树平衡算法，将关键码<code>p</code>取出并下降一层，再将原左、右孩子合并为一个节点，如图（b’）。从红黑树角度看，这一过程等效为将<code>s</code>和<code>p</code>颜色互换，如图（b）。</p>
<p>经过以上处理，红黑树的所有条件都在此局部得以恢复。另外，由于关键码<code>p</code>原为红色，故在关键码p所属节点中，其左或右必然还有一个黑色关键码（不可能左右都有），这意味着在关键码<code>p</code>从其中取出之后，不致引发新的下溢。至此，红黑树条件亦必在全局得以恢复，删除操作即告完成。</p>
<h3 id="3-2-3-BB-2-B：s为黑，且两个孩子均为黑；p为黑"><a href="#3-2-3-BB-2-B：s为黑，且两个孩子均为黑；p为黑" class="headerlink" title="3.2.3. BB-2-B：s为黑，且两个孩子均为黑；p为黑"></a>3.2.3. BB-2-B：s为黑，且两个孩子均为黑；p为黑</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212616.png" style="zoom:80%;"></p>
<p>此时，与BB-2-R类似，在对应的B-树中，因关键码x的删除，导致其所属节点发生下溢。如图（b’）可将下溢节点与其兄弟合并，从红黑树的角度来看，这一过程可等效为将节点<code>s</code>转换为红色，如图（b）。</p>
<p>然后既然<code>s</code>和<code>x</code>在此之前均为黑色，故<code>p</code>原所属的B-树节点必然仅含<code>p</code>这一个关键码，于是在<code>p</code>被借出之后，该节点必将继而发生下溢，从而有待于后续的进一步修正。从红黑树的角度来看，此时的状态则可等效地理解为：节点<code>p</code>的（黑色）父亲刚被删除。</p>
<p>实际上这也是双黑修正过程中，需要再次迭代的唯一可能。而幸运的是，尽管此类情况可能持续发生，但下溢的位置必然会不断上升，故至多迭代$O(\log n)$次后必然终止。</p>
<h3 id="3-2-4-BB-3：s为红（其孩子均为黑）"><a href="#3-2-4-BB-3：s为红（其孩子均为黑）" class="headerlink" title="3.2.4. BB-3：s为红（其孩子均为黑）"></a>3.2.4. BB-3：s为红（其孩子均为黑）</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212631.png" style="zoom:80%;"></p>
<p>此时作为红节点<code>s</code>的父亲，节点<code>p</code>必为黑色，同时<code>s</code>的两个孩子也应均为黑色。从B-树的角度看，如图（b’）令关键码<code>s</code>与<code>p</code>互换颜色，即可得到一棵与之完全等价的B-树，而从红黑树的角度来看，如图（b），这一转换对应于以节点<code>p</code>为轴做一次旋转，并交换节点<code>s</code>与<code>p</code>的颜色。</p>
<p>虽然经过如此处理之后，双黑缺陷依然存在（子树<code>r</code>的黑高度并未复原），而且缺陷位置的高度也并未上升。然而实际上情况已经发生微妙而本质的变换，观察图（b）可以看到，转换之后的红黑树中，被删除节点<code>x</code>有了一个新的兄弟<code>s&#39;</code>；另外现在的节点<code>p</code>，也已经由黑色转为红色。这就意味着接下来的修正调整只会转入前两种情况：<strong>BB-1</strong>或者<strong>BB-2-R</strong>，即接下来至多再做一次迭代调整，整个双黑修正的任务即可完成。</p>
<h3 id="3-2-5-复杂度"><a href="#3-2-5-复杂度" class="headerlink" title="3.2.5. 复杂度"></a>3.2.5. 复杂度</h3><p>以上各情况的处理流程，可归纳为下图：</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212700.png" style="zoom:80%;"></p>
<p>其中涉及的重构、染色等局部操作，均可在常数时间内完成，故为了估计整个双黑修正过程的时间复杂度，也只需统计这些操作各自的累计执行次数，具体归纳为下表：</p>
<p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212724.png" style="zoom:80%;"></p>
<p>可见，前两种情况各自只需做一轮修正，最后一种情况亦不过两轮。情况BB-2-B虽可能需要反复修正，但由于待修正位置的高度严格单调上升，累计也不致过$O(\log n)$轮，故双黑修正过程总共耗时不超过$O(\log n)$。即便计入此前的关键码查找和节点删除操作，<strong>红黑树的节点删除操作总是可在$O(\log n)$时间内完成</strong>。</p>
<p>从上面的分析可知，一旦在某步迭代中做过节点的旋转调整，整个修复过程便会随机完成。因此与双红修正一样，双黑修正的整个过程，也仅涉及常数次的拓扑结构调整操作。</p>
<p>这一特性也意味着，<strong>在每次删除操作之后，拓扑联接关系有所变化的节点绝不会超过常数个</strong>——这一点<strong>与AVL树</strong>的删除操作完成不同，也是<strong>二者之间最本质的一项差异</strong>。</p>
<h3 id="3-2-6-实现"><a href="#3-2-6-实现" class="headerlink" title="3.2.6. 实现"></a>3.2.6. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * RedBlack双黑调整算法：解决节点x与被其替代的节点均为黑色的问题</span></span><br><span class="line"><span class="comment"> * 分为三大类共四种情况：</span></span><br><span class="line"><span class="comment"> *    BB-1 ：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    BB-2R：2次颜色翻转，2次黑高度更新，0次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    BB-2B：1次颜色翻转，1次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment"> *    BB-3 ：2次颜色翻转，2次黑高度更新，1次旋转，转为BB-1或BB2R</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleBlack ( BinNodePosi(T) r ) &#123;</span><br><span class="line">   BinNodePosi(T) p = r ? r-&gt;parent : _hot; <span class="keyword">if</span> ( !p ) <span class="keyword">return</span>; <span class="comment">//r的父亲</span></span><br><span class="line">   BinNodePosi(T) s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="comment">//r的兄弟</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( s ) ) &#123; <span class="comment">//兄弟s为黑</span></span><br><span class="line">      BinNodePosi(T) t = <span class="literal">NULL</span>; <span class="comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;rc ) ) t = s-&gt;rc; <span class="comment">//右子</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;lc ) ) t = s-&gt;lc; <span class="comment">//左子</span></span><br><span class="line">      <span class="keyword">if</span> ( t ) &#123; <span class="comment">//黑s有红孩子：BB-1</span></span><br><span class="line">         <span class="comment">//*DSA*/printf("  case BB-1: Child ("); print(s-&gt;lc); printf(") of BLACK sibling ("); print(s); printf(") is RED\n");</span></span><br><span class="line">         RBColor oldColor = p-&gt;color; <span class="comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span></span><br><span class="line">      <span class="comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line">         BinNodePosi(T) b = FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//旋转</span></span><br><span class="line">         <span class="keyword">if</span> ( HasLChild ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; updateHeight ( b-&gt;lc ); &#125; <span class="comment">//左子</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; updateHeight ( b-&gt;rc ); &#125; <span class="comment">//右子</span></span><br><span class="line">         b-&gt;color = oldColor; updateHeight ( b ); <span class="comment">//新子树根节点继承原根节点的颜色</span></span><br><span class="line">         <span class="comment">//*DSA*/printBinTree(b, 0, 0);</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑s无红孩子</span></span><br><span class="line">         s-&gt;color = RB_RED; s-&gt;<span class="built_in">height</span>--; <span class="comment">//s转红</span></span><br><span class="line">         <span class="keyword">if</span> ( IsRed ( p ) ) &#123; <span class="comment">//BB-2R</span></span><br><span class="line">            <span class="comment">//*DSA*/printf("  case BB-2R: Both children ("); print(s-&gt;lc); printf(") and ("); print(s-&gt;rc); printf(") of BLACK sibling ("); print(s); printf(") are BLACK, and parent ("); print(p); printf(") is RED\n"); //s孩子均黑，p红</span></span><br><span class="line">            p-&gt;color = RB_BLACK; <span class="comment">//p转黑，但黑高度不变</span></span><br><span class="line">            <span class="comment">//*DSA*/printBinTree(p, 0, 0);</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//BB-2B</span></span><br><span class="line">            <span class="comment">//*DSA*/printf("  case BB-2R: Both children ("); print(s-&gt;lc); printf(") and ("); print(s-&gt;rc); printf(") of BLACK sibling ("); print(s); printf(") are BLACK, and parent ("); print(p); printf(") is BLACK\n"); //s孩子均黑，p黑</span></span><br><span class="line">            p-&gt;<span class="built_in">height</span>--; <span class="comment">//p保持黑，但黑高度下降</span></span><br><span class="line">            <span class="comment">//*DSA*/printBinTree(p, 0, 0);</span></span><br><span class="line">            solveDoubleBlack ( p ); <span class="comment">//递归上溯</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//兄弟s为红：BB-3</span></span><br><span class="line">      <span class="comment">//*DSA*/printf("  case BB-3: sibling ("); print(s); printf(" is RED\n"); //s红（双子俱黑）</span></span><br><span class="line">      s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="comment">//s转黑，p转红</span></span><br><span class="line">      BinNodePosi(T) t = IsLChild ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="comment">//取t与其父s同侧</span></span><br><span class="line">      _hot = p; FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//对t及其父亲、祖父做平衡调整</span></span><br><span class="line">      <span class="comment">//*DSA*/printBinTree&lt;T&gt;(s, 0, 0);</span></span><br><span class="line">      solveDoubleBlack ( r ); <span class="comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/" rel="prev" title="数据结构与算法（16）B-树">
      <i class="fa fa-chevron-left"></i> 数据结构与算法（16）B-树
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/" rel="next" title="数据结构与算法（18）词典">
      数据结构与算法（18）词典 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-概述"><span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-动机"><span class="nav-text">1.1.动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-结构"><span class="nav-text">1.2.结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-树-红黑树"><span class="nav-text">(2,4)树 &#x3D;&#x3D; 红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡性"><span class="nav-text">平衡性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-红黑树接口定义"><span class="nav-text">1.3.红黑树接口定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-节点插入算法"><span class="nav-text">2.节点插入算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-节点插入与双红现象"><span class="nav-text">2.1.节点插入与双红现象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-双红修正"><span class="nav-text">2.2.双红修正</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-RR-1"><span class="nav-text">2.2.1. RR-1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-RR-2"><span class="nav-text">2.2.2. RR-2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-复杂度"><span class="nav-text">2.2.3. 复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-实现"><span class="nav-text">2.2.4. 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-节点删除算法"><span class="nav-text">3.节点删除算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-节点删除与双黑现象"><span class="nav-text">3.1. 节点删除与双黑现象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-双黑修正"><span class="nav-text">3.2. 双黑修正</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-BB-1-s为黑，且至少有一个红孩子t"><span class="nav-text">3.2.1. BB-1: s为黑，且至少有一个红孩子t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-BB-2-R：s为黑，且两个孩子均为黑；p为红"><span class="nav-text">3.2.2. BB-2-R：s为黑，且两个孩子均为黑；p为红</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-BB-2-B：s为黑，且两个孩子均为黑；p为黑"><span class="nav-text">3.2.3. BB-2-B：s为黑，且两个孩子均为黑；p为黑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-BB-3：s为红（其孩子均为黑）"><span class="nav-text">3.2.4. BB-3：s为红（其孩子均为黑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-复杂度"><span class="nav-text">3.2.5. 复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-实现"><span class="nav-text">3.2.6. 实现</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nekomoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">nekomoon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nekomoon404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nekomoon404" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nekomoon404@163.com" title="E-Mail → mailto:nekomoon404@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020.1.12 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nekomoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">365k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


   
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200112,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

</body>
</html>
