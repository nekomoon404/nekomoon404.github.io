<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://nekomoon404.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="容器是可容纳各种数据类型的数据结构，包括顺序容器和关联容器，还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器。">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp基础（14）容器">
<meta property="og:url" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="nekomoon的个人小站">
<meta property="og:description" content="容器是可容纳各种数据类型的数据结构，包括顺序容器和关联容器，还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303083205.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303084359.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303091409.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303093003.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303094230.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303094800.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303102746.png">
<meta property="og:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303103248.png">
<meta property="article:published_time" content="2020-03-03T00:21:37.000Z">
<meta property="article:modified_time" content="2020-03-03T02:41:42.312Z">
<meta property="article:author" content="nekomoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ%E5%9B%BE%E7%89%8720200303083205.png">

<link rel="canonical" href="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Cpp基础（14）容器 | nekomoon的个人小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="nekomoon的个人小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nekomoon的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="nekomoon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nekomoon的个人小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp基础（14）容器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-03 08:21:37 / 修改时间：10:41:42" itemprop="dateCreated datePublished" datetime="2020-03-03T08:21:37+08:00">2020-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">C++基础</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <div class="post-description">容器是可容纳各种数据类型的数据结构，包括顺序容器和关联容器，还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>容器</strong>是可容纳各种数据类型的数据结构</p>
<ul>
<li>包括<strong>顺序容器</strong>和<strong>关联容器</strong></li>
<li>还有一类不提供真正的用于存储元素的数据结构实现，称作<strong>容器适配器</strong></li>
<li>容器适配器不支持迭代器，由使用者选择合适的底层数据结构</li>
</ul>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303083205.png" style="zoom: 67%;"></p>
<h1 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1.顺序容器"></a>1.顺序容器</h1><p>在<strong>顺序容器</strong>中，元素的插入位置与<strong>元素的值无关</strong>：</p>
<ul>
<li><p><code>vector</code> （声明于 &lt; vector&gt;）</p>
<p><strong>顺序表</strong>：实现了一个<strong>动态数组</strong>，可以在常数时间内完成随机存取元素，可以自动调整大小，在尾端增删元素时具有较佳的性能</p>
</li>
<li><p><code>array</code> （C++11 中新增，声明于 &lt; array&gt;）<br><strong>顺序表</strong>：封装了一个<strong>静态数组</strong>，只能在初始化时指定大小</p>
</li>
<li><p><code>deque</code> （声明于 &lt; deque&gt;）<br><strong>双端队列</strong>：实现了一个<strong>动态数组</strong>，可以在常数时间内完成随机存取元素，可以快速地在数组的头尾两端增删元素</p>
</li>
<li><p><code>list</code> （声明于 &lt; list&gt;）<br><strong>双向链表</strong>：不支持随机存取，但在任何位置增删元素都能在常数时间完成</p>
</li>
<li><p><code>forward_list</code> （ C++11 中新增，声明于 <forward_list>）<br><strong>单向链表</strong>：<code>list</code> 类的单链表版，去掉了一些操作</forward_list></p>
</li>
</ul>
<h2 id="1-1-vector"><a href="#1-1-vector" class="headerlink" title="1.1. vector"></a>1.1. vector</h2><p>vector 实现了一个<strong>动态数组</strong>，在实例化 vector 模板类时，需要在 &lt;&gt; 内指定容器中元素的具体类型，元素可以是基本数据类型，也可以是自定义的类。vector 可以在常数时间内完成随机存取元素，支持随机访问迭代器。</p>
<p>vector 可以自动调整大小，在尾端增删元素时具有较佳的性能，可以视为在常数时间内完成；在其他位置增删元素时较慢，与具体的位置有关。所有 STL 算法都能对 vector 操作。</p>
<p><strong>构造</strong> vector 对象时，需要声明具体的数据类型：可以指定一个初始长度，但之后还可以通过其他成员函数改变长度；还可以传入两个参数，分别指定初始长度和元素的初始值。也可以根据一个已有的数组来构造 vector 对象，传入的两个参数分别表示数组的起始和终止位置，是个左闭右开的区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;        <span class="comment">// 长度为 0 的 int 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">5</span>);     <span class="comment">// 长度为 5 的 int 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">4</span>, <span class="number">7</span>);  <span class="comment">// 长度为 4 的 int 数组，且初值都为 7</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v4(<span class="number">3</span>, “Hi”);  <span class="comment">// 长度为 3 且值都为 Hi 的 string 数组</span></span><br><span class="line">    <span class="keyword">double</span> x[] = &#123;<span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">5.8</span>, <span class="number">13.21</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v5(x, x + <span class="number">4</span>);     <span class="comment">// 从 x[0..3] 构造一个 double 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v6(x + <span class="number">1</span>, x + <span class="number">2</span>); <span class="comment">// 从 x[1] 构造一个 double 数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问</strong>vector中的元素时，可以通过迭代器来访问或修改元素，也可以通过 <code>[]</code> 或 <code>at()</code> 成员函数访问或修改元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(p, p + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        *it = *it * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 5 7 11</span></span><br><span class="line">    v[<span class="number">3</span>] -= <span class="number">2</span>;     <span class="comment">// 修改 v[3]</span></span><br><span class="line">    v.at(<span class="number">4</span>) = <span class="number">17</span>;  <span class="comment">// 修改 v[4]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 5 7 11 13 17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector <strong>在数组尾部增删元素</strong>较快，使用 <code>push_back()</code> 在尾部增加元素，使用 <code>pop_back()</code> 在尾部删除元素。</p>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303084359.png" style="zoom:67%;"></p>
<p>可以使用 <code>insert()</code> 在任意位置<strong>插入</strong>一个或一段元素，但效率较低，插入的位置由迭代器来表示；<code>erase()</code> 则可以删除一个或一段元素，用法与 insert() 类似，效率也低。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v1, v2(<span class="number">3</span>, <span class="string">'D'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        v1.push_back(i + <span class="string">'A'</span>);</span><br><span class="line">    &#125;  <span class="comment">// 依次加入 A B C D</span></span><br><span class="line">    v1.pop_back();  <span class="comment">// 删除 D</span></span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="string">'Z'</span>);</span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 D D D A B Z C</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>resize()</code> 来<strong>修改数组的长度</strong>，若修改后的长度比现有的要小，则舍弃后面的元素，否则添加缺省元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;  <span class="comment">// 依次添加 1 至 10</span></span><br><span class="line">    v.resize(<span class="number">5</span>);      <span class="comment">// 留下 v[0..4]</span></span><br><span class="line">    <span class="comment">// 将长度扩展到 8，用 100 填充新元素</span></span><br><span class="line">    v.resize(<span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 将长度扩展到 12，用缺省值 0 填充新元素</span></span><br><span class="line">    v.resize(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 100 100 100 0 0 0 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-deque"><a href="#1-2-deque" class="headerlink" title="1.2. deque"></a>1.2. deque</h2><p>deque 实现了一个双端队列，通过动态数组来实现，可以快速地在数组的头尾两端增删元素，支持随机存储迭代器，可以在常数时间内完成随机存取元素。</p>
<p>所有适用于 vector 的操作都适用于 deque，除此之外，deque 还提供了这些成员函数：</p>
<ul>
<li><p><code>front()</code> 取第一个元素（队首）的值</p>
</li>
<li><p><code>back()</code> 取最后一个元素（队尾）的值</p>
</li>
<li><p><code>push_front()</code> 将元素插入到最前面</p>
</li>
<li><p><code>pop_front()</code> 删除第一个元素</p>
</li>
</ul>
<h2 id="1-3-list"><a href="#1-3-list" class="headerlink" title="1.3. list"></a>1.3. list</h2><p>list 实现了一个<strong>双向链表</strong>，<strong>不支持随机存取</strong>，<strong>支持双向迭代器</strong>，与 vector 相比，不支持用 [] 来访问任意位置的元素，也不支持将迭代器移动多个单位（即不支持 begin() + i 这样的操作），但<strong>支持向前或向后移动</strong>（即支持 ++ 和 — ），可以在末尾或开头快速增加或删除元素，在任何位置增删元素都能在常数时间完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p + <span class="number">1</span>, p + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 3 5 7</span></span><br><span class="line">    li.pop_back();  li.push_back(<span class="number">11</span>);</span><br><span class="line">    li.pop_front(); li.push_front(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 5 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list 的构造函数与 vector 类似，可以指定一个初始长度，还可以分别指定初始长度和元素的初始值，也可以根据一个已有的数组来构造 list 对象。与 vector 类似，可以使用 <code>insert()</code> /<code>erase()</code> 在任意位置插入/删除一个或一段元素，且效率较高；与 vector 类似，可以使用 <code>resize()</code> 修改长度。</p>
<p>可以使用成员函数 <code>reverse()</code> <strong>将整个链表反序</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) li.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 5 6</span></span><br><span class="line">    li.reverse();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 6 5 4 3 2 1 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用成员函数 <code>remove()</code> <strong>删除指定值的元素</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p, p + <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 3 6 6 6</span></span><br><span class="line">    li.<span class="built_in">remove</span>(<span class="number">3</span>);  <span class="comment">// 删除链表中所有的 3</span></span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 6 6 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用成员函数<code>unique()</code> <strong>删除所有和前一个元素相同的元素</strong>，注意删除时只与前一个元素比较是否相同，所以最后得到的链表里仍然可能有重复的元素。还可以通过函数自定义元素相同的含义，将函数值返回 true 时，就删除当前元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p[] = &#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">1.3</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; li(p, p + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it;</span><br><span class="line">    li.unique();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0.1 0.2 0.3 0.1 0.8 1.3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_near</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(d1 - d2) &lt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 相差不超过 0.5 就认为是相同的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p[] = &#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">1.3</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; li(p, p + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it;</span><br><span class="line">    li.unique(is_near);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0.1 0.8 1.3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 list 不支持随机存取，因此无法使用STL中的 sort 算法模板进行排序，只能使用 list 自己的成员函数<code>sort()</code> 来<strong>排序</strong>，缺省按照 operator <code>&lt;</code> 的含义来排序，可以重载 <code>&lt;</code> 操作符。也可以传入函数指针，通过自定义的函数来重新定义元素的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a % <span class="number">10</span> &lt; b % <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">11</span>, <span class="number">27</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p, p + <span class="number">4</span>);   <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    li.sort();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 按大小排序，输出 2 9 11 27</span></span><br><span class="line">    li.sort(cmp);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 按 % 10 之后的大小排序，输出 11 2 27 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用成员函数 <code>merge()</code> <strong>合并</strong>两个链表，<strong>并清空被合并的那个链表</strong>。合并的两个链表中的元素必须按照某种规则排好序，否则会出错，因此 <code>merge()</code> 经常配合 <code>sort()</code> 一起使用，合并后的链表也是排好序的，可以自定义排序规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li1(p, p + <span class="number">4</span>);      <span class="comment">// 2 3 5 7</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li2(p + <span class="number">2</span>, p + <span class="number">5</span>);  <span class="comment">// 5 7 11</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    li1.merge(li2);  <span class="comment">// li1 和 li2 都是按升序排列好的</span></span><br><span class="line">    <span class="keyword">for</span> (it = li1.<span class="built_in">begin</span>(); it != li1.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 5 5 7 7 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; li2.<span class="built_in">size</span>();  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用成员函数 <code>splice()</code> <strong>在指定位置前面插入另一链表中的一个或多个元素</strong>，并在另一链表中删除这些被插入的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li1(p, p + <span class="number">5</span>), li2(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = li1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) ++it;  <span class="comment">// 找到 li1 中的 7</span></span><br><span class="line">    li2.splice(li2.<span class="built_in">begin</span>(), li1, it);  <span class="comment">// 在 li2 开头插入 7</span></span><br><span class="line">    <span class="keyword">for</span> (it = li2.<span class="built_in">begin</span>(); it != li2.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 7 1 1 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; li1.<span class="built_in">size</span>();  <span class="comment">// li1 中的 7 被删除，输出 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：常用的这<strong>三种顺序容器的主要差别在于访问/修改元素与增加/删除元素的速度上</strong>，因此需要根据实际情况选用合适的容器。</p>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303091409.png" style="zoom:67%;"></p>
<h1 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2.关联容器"></a>2.关联容器</h1><p><strong>在关联容器中，元素的插入位置与元素的值有关</strong>，必须按相应的排序准则来确定，在查找元素时具有非常好的性能:</p>
<ul>
<li><p><code>set</code> / <code>multiset</code> （声明于 <code>#include&lt;set&gt;</code>）</p>
<p>集合：实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）；<code>set</code> 容器中不允许存在相同元素，<code>multiset</code> 容器中允许存在相同的元素</p>
</li>
<li><p><code>map</code> / <code>multimap</code> （声明于 <code>#include&lt;map&gt;</code>）<br>映射表：实现了一棵平衡二叉搜索树，存放的是成对的键值和数据（key / value），并根据键值对元素进行排序，可快速地根据键值来检索元素；<code>map</code> 容器中不允许存在键值相同的元素，而 <code>multimap</code> 容器中则允许</p>
</li>
<li><p>C++11 中新增的 <code>unordered_set</code> / <code>unordered_multiset</code> （声明于 &lt; unordered_set&gt;）和 <code>unordered_map</code> / <code>unordered_multimap</code> （声明于 &lt; unordered_map&gt;）<br>映射表：通过哈希表实现，功能与 <code>set</code>/<code>multiset</code> 和 <code>map</code>/<code>multimap</code> 相似，但不对键值排序</p>
</li>
</ul>
<p><strong>键值与数据（key-value pair）</strong>：在关联容器中，通过键值来查询对应的数据，对于集合容器来说，键值与数据相等。</p>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303093003.png" style="zoom:67%;"></p>
<p><strong>pair</strong>：可以使用 pair 模板来生成 key-value 对，pair 声明于 <code>&lt; utility&gt;</code> 头文件中，pair 中有两个成员变量 first 和 second：first 表示 key，second 表示 value。实例化的 pair 模板类可以用来绑定两个对象为一个新的对象。</p>
<p><strong>比较</strong>两个 pair 对象的大小：</p>
<ul>
<li><p><code>p1 &lt; p2</code>：如果 <code>p1.first &lt; p2.first</code> 或者 <code>!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second</code>，则返回 <code>true</code></p>
</li>
<li><p><code>p1 == p2</code>：如果 <code>p1.first == p2.first &amp;&amp; p1.second == p2.second</code>，则返回 <code>true</code></p>
</li>
</ul>
<p><strong>声明</strong>一个 pair 对象：</p>
<ul>
<li><p><code>pair&lt;T1, T2&gt; p</code>：创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化</p>
</li>
<li><p><code>pair&lt;T1, T2&gt; p(v1, v2)</code>：创建一个 pair 对象，它的两个元素分别是 T1 和 T2 类型，其中 first 成员初始化为 v1，second 成员初始化为 v2</p>
</li>
<li><p><code>make_pair(v1, v2)</code>：以 v1 和 v2 值创建一个新的 pair 对象，其元素类型分别是 v1 和 v2 的类型</p>
</li>
</ul>
<h2 id="2-1-set-multiset"><a href="#2-1-set-multiset" class="headerlink" title="2.1. set/multiset"></a>2.1. set/multiset</h2><p><code>set</code> / <code>multiset</code> 是集合容器，实现了一棵<strong>平衡二叉搜索树</strong>，使用元素本身作为键值（key）。<code>set</code> 容器中不允许存在相同元素，而 <code>multiset</code> 容器中允许内部元素有序排列，新元素插入的位置取决于其值。</p>
<p><strong>支持双向迭代器</strong>，不支持 <code>[]</code> 下标访问元素，但可以通过 <code>find()</code> 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为$O( \log n)$。可根据 operator <code>&lt;</code> 来比较两个元素的大小，对于自定义的类，需要重载其 <code>&lt;</code> 操作符。</p>
<h3 id="2-1-1-set"><a href="#2-1-1-set" class="headerlink" title="2.1.1. set"></a>2.1.1. set</h3><p>可使用成员函数 <code>insert()</code> 向集合中<strong>增加元素</strong>，根据元素对应的 operator <code>&lt;</code> 来确定元素应处的位置，插入容器中已有的元素时，插入操作失败（即不会插入重复的元素）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) s.insert(i);</span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        s.insert(i * <span class="number">2</span> + <span class="number">1</span>);  <span class="comment">// 想要插入 1 3 5 7 9</span></span><br><span class="line">    &#125;  <span class="comment">// 但是已经存在 1 和 3，不会重复插入</span></span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 5 7 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于自定义的类，需要重载 operator <code>&lt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer(<span class="keyword">int</span> _a, <span class="built_in">string</span> _n) : age(_a), name(_n) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp;c) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age == c.age) <span class="keyword">return</span> name &lt; c.name;</span><br><span class="line">        <span class="keyword">return</span> age &lt; c.age;</span><br><span class="line">    &#125;  <span class="comment">// 若 age 相同则比较 name，否则比较 age 的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Customer&gt; s;</span><br><span class="line">    <span class="function">Customer <span class="title">c1</span><span class="params">(<span class="number">18</span>, <span class="string">"Alice"</span>)</span></span>;  s.insert(c1);</span><br><span class="line">    <span class="function">Customer <span class="title">c2</span><span class="params">(<span class="number">37</span>, <span class="string">"Bob"</span>)</span></span>;    s.insert(c2);</span><br><span class="line">    <span class="function">Customer <span class="title">c3</span><span class="params">(<span class="number">26</span>, <span class="string">"Daisy"</span>)</span></span>;  s.insert(c3);</span><br><span class="line">    <span class="built_in">set</span>&lt;Customer&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) it-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">// 依次输出 Alice 18 、Daisy 26 和 Bob 37</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几种<strong>查找元素</strong>的接口：</p>
<p>使用成员函数 <code>find()</code> 来<strong>查找</strong>容器中的某个元素 x，若能找到，则返回指向 x 的迭代器，否则返回 <code>end()</code>，在这里，<strong>两个元素的相等是根据 operator &lt; 判断的</strong>（即同时满足 x &lt; y 为假且 x &gt; y 为假），<strong>与 operator == 运算符无关</strong>。</p>
<p>使用成员函数 <code>lower_bound()</code> 来查找容器中的某个元素 x，<strong>返回第一个大于等于 x 的元素的迭代器</strong>，若找不到则返回 <code>end()</code>。</p>
<p>使用成员函数 <code>upper_bound()</code> 来查找容器中的某个元素 x，<strong>返回第一个大于 x 的元素的迭代器</strong>，若找不到则返回 <code>end()</code>。</p>
<p>使用成员函数 <code>equal_range()</code> 来查找容器中的某个元素 x，<strong>返回一个迭代器对（pair）</strong>，其 first 值就是 <code>lower_bound()</code> ，其 second 值就是 <code>upper_bound()</code>。</p>
<p>使用成员函数 <code>count()</code> 来<strong>计算等于某个值的元素个数</strong>。</p>
<p>注意通过迭代器访问元素时，<strong>先判断迭代器是否等于 end()</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it == s.<span class="built_in">end</span>()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Find Element "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  s.insert(f, f + <span class="number">6</span>);</span><br><span class="line">    disp(s, s.<span class="built_in">find</span>(<span class="number">3</span>));  <span class="comment">// 输出 Find Element 3</span></span><br><span class="line">    disp(s, s.<span class="built_in">find</span>(<span class="number">4</span>));  <span class="comment">// 输出 Not found.</span></span><br><span class="line">    disp(s, s.lower_bound(<span class="number">8</span>));  <span class="comment">// 输出 Find Element 8</span></span><br><span class="line">    disp(s, s.upper_bound(<span class="number">8</span>));  <span class="comment">// 输出 Find Element 13</span></span><br><span class="line">    disp(s, s.lower_bound(<span class="number">20</span>)); <span class="comment">// 输出 Find Element 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303094230.png" style="zoom:67%;"></p>
<p>使用成员函数 <code>erase()</code> 来<strong>删除</strong>某个元素，传入的参数可以是元素值，若该元素不存在容器中，则删除失败；也可以是指向容器中某个元素的迭代器，迭代器必须是有效的；还可以传入两个迭代器，表示一段左闭右开的区间。</p>
<p><code>erase()</code>与 <code>find()</code> 、<code>lower_bound()</code>、<code>upper_bound()</code> 以及 <code>begin()</code>、<code>end()</code>、<code>rbegin()</code>、<code>rend()</code> 等配合使用，可以达到一些常见的效果，使用时注意 <strong>STL 中的区间一般都是左闭右开的</strong>，例如 [ begin(), end() )以及 lower_bound() 与 upper_bound() 在相等元素上的处理区别。</p>
<p>如下程序，假设普通函数 <code>disp(set&lt; int&gt;)</code> 用于输出容器中的所有元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  s.insert(f, f + <span class="number">6</span>);</span><br><span class="line">    disp(s);     <span class="comment">// 输出 2 3 5 8 13 21</span></span><br><span class="line">    s.erase(<span class="number">8</span>);  <span class="comment">// 删除值为 8 的元素</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 2 3 5 13 21</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>());  <span class="comment">// 删除第一个元素（2）</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 3 5 13 21</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    p = s.lower_bound(<span class="number">5</span>);  <span class="comment">// 找到 5</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>(), p); <span class="comment">// 删除 3</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 5 13 21</span></span><br><span class="line">    p = s.upper_bound(<span class="number">13</span>); <span class="comment">// 找到 13</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>(), p); <span class="comment">// 删除 5 和 13</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-multiset"><a href="#2-1-2-multiset" class="headerlink" title="2.1.2. multiset"></a>2.1.2. multiset</h3><p>multiset 在使用上与 set 基本一致，主要区别在于 multiset <strong>允许插入值相同的元素</strong>。在使用 <code>find()</code> 查找时，会返回第一个等于该查找值的元素，在使用 <code>erase()</code> 删除等于某个值的元素时，会删除所有等于该值的元素<br>假设 <code>multiset&lt; int&gt; s</code> 中的元素如下：</p>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303094800.png" style="zoom:67%;"></p>
<p>如下程序，假设普通函数 <code>disp()</code> 用于输出容器set&lt; int&gt;和multiset&lt; int&gt;中的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;      s1.insert(f, f + <span class="number">8</span>);</span><br><span class="line">    disp(s1);    <span class="comment">// 输出 1 2 3 6</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s2; s2.insert(f, f + <span class="number">8</span>);</span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 2 2 3 3 6</span></span><br><span class="line">    s2.erase(<span class="number">2</span>); <span class="comment">// 删除所有的 2</span></span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 3 3 6</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s2.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    s2.erase(it);  <span class="comment">// 删除第一个 3</span></span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 3 6</span></span><br><span class="line">    <span class="comment">// equal_range(1) 找到所有的 1</span></span><br><span class="line">    s2.erase((s2.equal_range(<span class="number">1</span>)).first,</span><br><span class="line">             (s2.equal_range(<span class="number">1</span>)).second);</span><br><span class="line">    disp(s2);    <span class="comment">// 输出 3 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：s1 是一个不允许重复元素的集合，且元素按降序排列，因此输出 9 7 5 3 1；s2 是一个允许有重复元素的容器，缺省将元素按升序排列，因此输出 1 3 3 5 7 9。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; s1;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator i1;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator i2;</span><br><span class="line">    s1.insert(p, p + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (i1 = s1.<span class="built_in">begin</span>(); i1 != s1.<span class="built_in">end</span>(); i1++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i1 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s2.insert(p, p + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (i2 = s2.<span class="built_in">begin</span>(); i2 != s2.<span class="built_in">end</span>(); ++i2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i2 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-map-multimap"><a href="#2-2-map-multimap" class="headerlink" title="2.2. map/multimap"></a>2.2. map/multimap</h2><p>map / multimap 是一张<strong>映射表</strong>，通过<strong>平衡二叉搜索树</strong>来实现，存放的是成对的 key-value，实例化时需要在 &lt;&gt; 中依次指定 key 和 value 的类型，根据 key 对元素进行排序，可快速地根据 key 来检索元素。map 容器中不允许存在 key 相同的元素，而 multimap 容器中则允许，用法与 set / multiset 类似。</p>
<p>支持双向迭代器，可以通过 <code>find()</code> 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为 $O(\log n)$。根据 operator <code>&lt;</code> 来比较两个元素的大小，对于自定义的类，需要重载其 <code>&lt;</code> 操作符。</p>
<h3 id="2-2-1-map"><a href="#2-2-1-map" class="headerlink" title="2.2.1. map"></a>2.2.1. map</h3><p>可以使用成员函数 <code>insert()</code> 向 map 容器中<strong>插入元素</strong>，注意插入的元素是成对的 key-value，因此是一个个的 pair。可以通过迭代器访问元素，也可以使用 [] 运算符访问容器中已有的 key 对应的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(make_pair(<span class="string">"Alice"</span>, <span class="number">18</span>));</span><br><span class="line">    m.insert(make_pair(<span class="string">"Daisy"</span>, <span class="number">26</span>));</span><br><span class="line">    m.insert(make_pair(<span class="string">"Bob"</span>, <span class="number">37</span>));</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  <span class="comment">// 依次输出 Alice-&gt;18  Bob-&gt;37  Daisy-&gt;26</span></span><br><span class="line">    <span class="keyword">int</span> p = m[<span class="string">"Alice"</span>];  <span class="comment">// p = 18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>旧一些的编译器只支持通过 <code>make_pair()</code> 的方式插入元素，新一些的编译器则可以直接通过 <code>[]</code> 来插入元素，如 <code>m[“Alice”] = 18;</code> 。因此当使用 <code>[]</code> 访问元素时，如果 <code>[]</code> 中的 key 不存在于容器中，则可能运行出错，也可能访问到一个未正确初始化的元素（其值不一定有意义）。当向容器中插入一个 key 已经存在的元素时，插入失败，但是可以通过 <code>[]</code> 来修改 key 对应的 value。</p>
<p>使用成员函数 <code>erase()</code> 删除元素，可以传入 key 作为参数，也可以传入指定元素的迭代器；还可以传入两个迭代器，表示删除一个左闭右开的区间内的所有元素。</p>
<p>使用成员函数 <code>find()</code>、<code>lower_bound()</code>、<code>upper_bound()</code> 或者 <code>begin()</code> 、<code>rbegin()</code> 等时，返回的都是 pair 迭代器，因为返回值对应于容器中的元素，而 map 容器中的元素是一个个 pair。</p>
<p>成员函数 <code>equal_range()</code> 的返回值则是一个由两个 pair 组成的 pair 迭代器，例如对于 <code>map&lt;string, int&gt;</code> 容器来说，<code>equal_range()</code> 的返回值类型为 <code>pair&lt;map&lt;string, int&gt;::iterator, map&lt;string, int&gt;::iterator&gt;</code>。因为 <code>equal_range()</code> 返回的是 <code>lower_bound()</code> 和 <code>upper_bound()</code> 构成的 pair，而 map 的 <code>lower_bound()</code> 和 <code>upper_bound()</code> 都是 pair 迭代器。</p>
<h3 id="2-2-2-multimap"><a href="#2-2-2-multimap" class="headerlink" title="2.2.2. multimap"></a>2.2.2. multimap</h3><p>multimap 在使用上与 map 基本一致，主要区别在于 multimap 允许插入 key 相同的元素。multimap 不支持使用 <code>[]</code> 运算符访问元素，因为元素的 key 可能重复，用 <code>[]</code> 访问时可能不知道应该访问哪一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        m1.insert(make_pair(i + <span class="string">'A'</span>, i));</span><br><span class="line">        m1.insert(make_pair(i + <span class="string">'A'</span>, i * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        m2.insert(make_pair(i + <span class="string">'A'</span>, i));</span><br><span class="line">        m2.insert(make_pair(i + <span class="string">'A'</span>, i * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    disp(m1); <span class="comment">// 输出 A-&gt;0 B-&gt;1 C-&gt;2 D-&gt;3</span></span><br><span class="line">    disp(m2); <span class="comment">// 输出 A-&gt;0 A-&gt;1 B-&gt;1 B-&gt;3 C-&gt;2 C-&gt;5 D-&gt;3 D-&gt;7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-容器适配器"><a href="#3-容器适配器" class="headerlink" title="3.容器适配器"></a>3.容器适配器</h1><p>在<strong>容器适配器</strong>中，不提供真正的用于存储元素的数据结构实现，<strong>不支持迭代器</strong>，由使用者选择合适的底层数据结构：</p>
<ul>
<li><p><code>stack</code> （声明于 <code>#include&lt;stack&gt;</code>）<br><strong>栈</strong>：是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则</p>
</li>
<li><p>queue （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>队列</strong>：插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即按照先进先出的原则</p>
</li>
<li><p><code>priority_queue</code> （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>优先队列</strong>：最高优先级元素总是第一个出队，可视作堆</p>
</li>
</ul>
<p>容器适配器可以用某种顺序容器来实现，即让已有的顺序容器以栈/队列的方式工作。</p>
<h2 id="3-1-stack"><a href="#3-1-stack" class="headerlink" title="3.1. stack"></a>3.1. stack</h2><p>stack 栈是一种<strong>后进先出</strong>的数据结构，<strong>只能插入、删除、访问栈顶元素</strong>。对应的操作为：</p>
<ul>
<li><p><code>push()</code> 入栈 / 插入元素</p>
</li>
<li><p><code>pop()</code> 出栈 / 删除元素</p>
</li>
<li><p><code>top()</code> 返回栈顶元素的引用 / 访问元素</p>
</li>
</ul>
<p>此外还可以通过成员函数 <code>empty()</code> 来判断栈是否为空，如果想要清空一个栈，只能通过 <code>while (!empty()) pop();</code> 这样的方式。如下图依次演示了：1 入栈、2 入栈、3 入栈、3 出栈、1 入栈、4 入栈。</p>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303102746.png" style="zoom:67%;"></p>
<p>stack 在缺省情况下用 deque 实现：<code>template&lt;class T, class Cont = deque&lt;T&gt; &gt;</code>，例如 <code>stack&lt;int&gt; s;</code> 声明了一个元素为 int 型的栈，用 deque 实现。但也可以用 vector 或 list 来实现，例如 <code>stack&lt;string, vector&lt;string&gt; &gt; s;</code> 声明了一个元素为 string 型的栈，用 vector 实现。在声明时可以同时对栈初始化，初始化方式与 vector / deque / list 类似。</p>
<h2 id="3-2-queue"><a href="#3-2-queue" class="headerlink" title="3.2. queue"></a>3.2. queue</h2><p>queue 队列是一种<strong>先进先出</strong>的数据结构，只能在<strong>队尾插入元素</strong>，只能<strong>访问或删除队首元素</strong>，对应的操作为：</p>
<ul>
<li><p><code>push()</code> 入队 / 插入元素</p>
</li>
<li><p><code>pop()</code> 出队 / 删除元素</p>
</li>
<li><p><code>front()</code> 返回队首元素的引用 / 访问元素</p>
</li>
</ul>
<p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303103248.png" style="zoom:67%;"></p>
<p>queue 在缺省情况下用 deque 实现：<code>template&lt;class T, class Cont = deque&lt;T&gt; &gt;</code>。例如 <code>queue&lt;int&gt; q;</code> 声明了一个元素为 int 型的队列，用 deque 实现。但也可以用 vector 或 list 来实现，例如 <code>queue&lt;string, vector&lt;string&gt; &gt; q;</code> 声明了一个元素为 string 型的队列，用 vector 实现。在声明时可以同时对队列初始化，初始化方式与 vector / deque / list 类似。</p>
<h2 id="3-3-priority-queue"><a href="#3-3-priority-queue" class="headerlink" title="3.3. priority_queue"></a>3.3. priority_queue</h2><p>priority_queue 是一个<strong>优先队列</strong>，也可以看做是一个<strong>堆</strong>（heap），<strong>能保证最大的元素总是在最前面</strong>，一些操作为：</p>
<ul>
<li><p><code>pop()</code> 删除的是队列中最大的元素（因为最大的元素总是在队首）</p>
</li>
<li><p>没有名叫 <code>front()</code> 成员函数，通过 <code>top()</code> 返回最大元素的引用</p>
</li>
<li><p>通过 <code>push()</code> 添加元素，每次 <code>push()</code> 之后队首元素可能发生变化</p>
</li>
</ul>
<p>priority_queue用法基本和 queue 类似，可以用 vector 和 deque 实现，缺省情况下用vector 实现。缺省情况是根据 <code>less&lt;T&gt;</code> 模板比较大小的，实例化时是个函数对象。可以使用其他的函数对象类模板来定义大小，或者重载元素的 <code>&lt;</code> 运算符，例如 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;</code> 就声明了一个将最小的元素排在队首的优先队列。</p>
<p>例如下面声明了三种队列，设 <code>disp()</code> 可以按序输出队列中的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">// 普通的队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q2;  <span class="comment">// 优先队列，降序</span></span><br><span class="line">    <span class="comment">// 优先队列，升序</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        q1.push(v[i]);</span><br><span class="line">        q2.push(v[i]);</span><br><span class="line">        q3.push(v[i]);</span><br><span class="line">    &#125;  <span class="comment">// 依次入队 1 3 7 2 6 4 5</span></span><br><span class="line">    disp(q1); <span class="comment">// 输出 1 3 7 2 6 4 5</span></span><br><span class="line">    disp(q2); <span class="comment">// 输出 7 6 5 4 3 2 1</span></span><br><span class="line">    disp(q3); <span class="comment">// 输出 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一章中各容器在数据结构与算法中有详细的介绍，包括原理，实现，效率与优化等等，可以参考我的博客中数据结构与算法categories中的相关文章(┌・ω・)┌✧</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="prev" title="数据结构与算法（13）二叉搜索树">
      <i class="fa fa-chevron-left"></i> 数据结构与算法（13）二叉搜索树
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/" rel="next" title="数据结构与算法（14）AVL树">
      数据结构与算法（14）AVL树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-顺序容器"><span class="nav-text">1.顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-vector"><span class="nav-text">1.1. vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-deque"><span class="nav-text">1.2. deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-list"><span class="nav-text">1.3. list</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-关联容器"><span class="nav-text">2.关联容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-set-multiset"><span class="nav-text">2.1. set&#x2F;multiset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-set"><span class="nav-text">2.1.1. set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-multiset"><span class="nav-text">2.1.2. multiset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-map-multimap"><span class="nav-text">2.2. map&#x2F;multimap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-map"><span class="nav-text">2.2.1. map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-multimap"><span class="nav-text">2.2.2. multimap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-容器适配器"><span class="nav-text">3.容器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-stack"><span class="nav-text">3.1. stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-queue"><span class="nav-text">3.2. queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-priority-queue"><span class="nav-text">3.3. priority_queue</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nekomoon"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">nekomoon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">72</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nekomoon404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nekomoon404" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nekomoon404@163.com" title="E-Mail → mailto:nekomoon404@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020.1.12 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nekomoon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">655k</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


   
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
<script>
  function timer() {
    var ages = moment.preciseDiff(moment(),moment(20200112,"YYYYMMDD"));
    ages = ages.replace(/years?/, "年");
    ages = ages.replace(/months?/, "月");
    ages = ages.replace(/days?/, "天");
    ages = ages.replace(/hours?/, "小时");
    ages = ages.replace(/minutes?/, "分");
    ages = ages.replace(/seconds?/, "秒");
    ages = ages.replace(/\d+/g, '<span style="color:#1890ff">$&</span>');
    div.innerHTML = `我已在此等候你 ${ages}`;
  }
  var div = document.createElement("div");
  //插入到copyright之后
  var copyright = document.querySelector(".copyright");
  document.querySelector(".footer-inner").insertBefore(div, copyright.nextSibling);
  timer();
  setInterval("timer()",1000)
</script>


 
<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)我藏好了哦~" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

</body>
</html>
