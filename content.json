{"meta":{"title":"nekomoon的个人小站","subtitle":"","description":"","author":"nekomoon","url":"http://nekomoon404.github.io","root":"/"},"pages":[{"title":"about","date":"2020-01-17T12:16:07.000Z","updated":"2020-01-17T12:45:38.714Z","comments":false,"path":"about/index.html","permalink":"http://nekomoon404.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-17T12:15:21.000Z","updated":"2020-01-17T12:45:12.630Z","comments":false,"path":"tags/index.html","permalink":"http://nekomoon404.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-17T12:15:51.000Z","updated":"2020-01-17T12:45:26.408Z","comments":false,"path":"categories/index.html","permalink":"http://nekomoon404.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Cpp基础（5）函数","slug":"Cpp基础（5）函数","date":"2020-01-30T11:41:22.000Z","updated":"2020-01-30T15:43:19.907Z","comments":true,"path":"2020/01/30/Cpp基础（5）函数/","link":"","permalink":"http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数函数基础函数的定义和声明函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）定义包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。 12345678//计算阶乘int fact(int val)&#123; int ret = 1; while (val &gt; 1) ret* = val--; return ret;&#125; 函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作函数原型（function prototype）。 建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 函数的调用函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。 123456int main()&#123; int j = fact(5); cout &lt;&lt; \"5! is\" &lt;&lt; j &lt;&lt; endl; return 0;&#125; 形参和实参实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。 函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名， 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是void，它表示函数不返回任何值。 变量的作用范围根据变量在程序中作用范围的不同，可以将变量分为： 局部变量：在函数内或块内定义，只在这个函数或块内起作用的变量； 全局变量：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量。 自动对象与局部静态对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为自动对象（automatic object）。 形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。 有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。 123456789101112//下面的函数统计它自己被调用了多少次size_t count_calls()&#123; static size_t ctr = 0; return ++ctr;&#125;int main()&#123; for (size_t i=0; i!=10; ++i) cout &lt;&lt; cout_calls() &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Cpp基础（4）字符数组与字符串","slug":"Cpp基础（4）字符数组与字符串","date":"2020-01-27T03:08:57.000Z","updated":"2020-01-27T14:29:00.012Z","comments":true,"path":"2020/01/27/Cpp基础（4）字符数组与字符串/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符数组与字符串定义字符型用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 初始化与赋值只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 字符/字符数组/字符串的输入与输出一个字符的输入直接用cin输入字符。cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; char c; cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while(cin&gt;&gt;c) //abc def g cout&lt;&lt;c; //abcdefg return 0;&#125; 用cin.get()函数输入可以用于读入一个字符；有2中形式： 无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( (c=cin.get())!= EOF ) //abc def gcout &lt;&lt; c; //abc def g 一个参数cin.get(char) 12345char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; //读取一个字符赋给字符变量cwhile( cin.get(c) ) //abc def gcout &lt;&lt; c; //abc def g 要注意的是，cin.get()遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。 123456char ch1,ch2; cout&lt;&lt;\"请输入两个字符：\"&lt;&lt;endl; cin.get(ch1);//或ch1 = cin.get(); cin.get(ch2); cout&lt;&lt;ch1&lt;&lt;\" \"&lt;&lt;ch2&lt;&lt;endl; cout&lt;&lt;(int)ch1&lt;&lt;\" \"&lt;&lt;(int)ch2&lt;&lt;endl; 输入a[Enter]，读取到结束符&#39;/n&#39;，其仍在缓冲区中被存入ch2，在输出a之后，第二次输出&#39;/n&#39;即换行，而输出的第二个ASCII码值为10，即&#39;/n&#39;的ASCII值，说明cin.get()遇到结束符并不会将之删除。 用getchar()输入字符1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( c = getchar() ) //abc def g 不跳过任何字符cout &lt;&lt; c; //abc def g 字符串的输入直接用cin输入字符123456789#include&lt;iostream&gt;using namespace std;int main() &#123; char str[10]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; while (cin &gt;&gt; str) cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; 用cin.get()函数输入有三个参数的cin.get()函数：cin.get(ch, 10, &#39;/n&#39;) 读取10-1（10减1=9，最后一个为&#39;/0&#39;）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符&#39;/n&#39;，则提前结束读取（如果第3个参数没有指定，则默认为&#39;/n&#39;），而结束符仍在缓冲区中；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。 还要一点要注意，cin.get(ch, 10, &#39;/n&#39;)，当第一个输入字符为结束符时，缓冲区将无该结束符。 1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; char ch1[20]，ch2[20]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; cin.get(ch1,10,'o'); //指定终止符为'o' cin.get(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; return 0;&#125; 输入：we are good friends[Enter]，由于遇到结束符 &#39;o&#39; ，首先读入we are g到ch1，此时ood friends仍在缓冲区，当执行cin.get(ch2,10)会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。 用cin.getline()函数输入用法与上面的cin.get()类似，但也有区别： cin.get()当输入的字符串在结束符之前的长度超过接收长度时，不会引起cin函数的错误，剩余的字符会留在缓冲区，后面若有cin操作，会继续从缓冲区读取；当cin.getline()输入超长时，会引起cin函数的错误，后面的cin操作将不再执行。 cin.get()每次读取一整行并把由Enter键生成的换行符&#39;/n&#39;留在输入队列中，然而cin.getline()每次读取一整行并把由Enter键生成的换行符抛弃。 cin.get()遇到结束符是停止读取，缓冲区指针不移动；cin.getline()遇到结束符时，缓冲区指针移到终止标志字符之后。 123456char ch1[20]，ch2[20];cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl;cin.getline(ch1,10,'o'); //指定终止符为'o' cin.getline(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; //注意与上节的区别 一个需要注意的地方：cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。而无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区， for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); //当执行cin.getline(a[1],10)时，[Enter]被读取到a[1] for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 12345678910111213#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区 cin.get(); //用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了 for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 字符串的输出用cout输出字符数组12345678#include&lt;iostream&gt;using namespace std;int main()&#123; char a[10] = \"Computer\"; cout &lt;&lt; a; return 0;&#125; 需要注意的是，cout输出有终止条件（一般是碰到&#39;\\0&#39;），当用字面值初始化字符数组时，会自动在串尾加上&#39;\\0&#39;；当用列表初始化字符数组时，若不在串尾加上’\\0’，用cout输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。 12char a[8] = &#123; 'C','o','m','p','u','t','e','r' &#125;;cout &lt;&lt; a; 例子1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main() &#123; char str[200]; while (cin.getline(str, 200)) &#123; for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == 'Z')&#123; str[i] = 'A'; continue; &#125; if (str[i] == 'z')&#123; str[i] == 'a'; continue; &#125; if (str[i] == ' ') continue; str[i]++; &#125; cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数strcat，每个输入的串的长度不超过20。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main() &#123; int len1, len2; char str1[40], str2[40]; cin.getline(str1,20); cin.getline(str2, 20); for (len1 = 0; str1[len1] != '\\0'; len1++); for (len2 = 0; str2[len2] != '\\0'; len2++); if (len1 &gt;= len2) &#123; for (len2 = 0; str2[len2] != '\\0'; len2++) str1[len1++] = str2[len2]; //后置++，先执行表达式，再len+1 str1[len1] = '\\0'; //必须要加，要不然cout&lt;&lt;str1会出错 &#125; else &#123; for (len1 = 0; str1[len1] != '\\0'; len1++) str2[len2++] = str1[len1]; str2[len2] = '\\0'; &#125; cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; str2 &lt;&lt; endl; return 0;&#125; 3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == ' ') flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125; 当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if ((str[i] &gt;= 'A'&amp;&amp; str[i] &lt;= 'Z') || (str[i] &gt;= 'a'&amp;&amp;str[i] &lt;= 'z')) flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Cpp基础（3）数组","slug":"Cpp基础（3）数组","date":"2020-01-27T03:06:06.000Z","updated":"2020-01-27T14:32:08.225Z","comments":true,"path":"2020/01/27/Cpp基础（3）数组/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 定义和初始化内置数组数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个常量表达式。 123456constexpr unsigned sz = 42; //常量表达式int arr[10];int *parr[sz];unsigned cnt = 42; // 不是常量表达式string bad[cnt]; // 错误：cnt不是常量表达式 默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。 123456const unsigned sz = 3;int ial[sz] = &#123;0, 1, 2&#125;;int a2[] = &#123;0, 1, 2&#125;;int a3[5] = &#123;0, 1, 2&#125;;string a4[3] = &#123;\"hi\", \"bye\"&#125;;int a5[2] = &#123;0, 1, 2&#125;; //错误 字符数组的特殊性当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。 复杂的数组声明数组能存放大多数类型的对象，可以定义一个存放指针的数组；又因为数组本身是对象，所以允许定义数组的指针及数组的引用。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。 12345int *ptrs[10]; //ptrs是含有10个整型指针的数组int &amp;refs[10] = /* ？ */ //错误：不存在引用的数组int (*Parray)[10] = &amp;arr; //Parray是一个指针，指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef是一个引用，引用一个含有10个整数的数组int *(&amp;arry)[10] = ptrs; //arry是一个引用，引用一个含有10个指针的数组 练习3.27 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？ 12345unsigned buf_size = 1024;int ia[buf_size]; //非法的，因为buf_size不是一个常量表达式int ia[4*7-14]; //正确，因为4*7-14是一个常量表达式int ia[txt_size()]; //非法的，因为txt_size没有被定义为常量表达式 constexprchar st[11] = \"fundamental\" //非法的，因为用字符串字面值初始化，没有空间存放空字符 访问数组元素与标准库类型vector 和string 一样，数组的元素也能使用范围for 语句或下标运算符来访问。数组的索引从0开始。 数组下标通常定义为size_t类型，size_t是一种机器相关的无符号类型，在cstddef头文件中定义。 1234567//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100unsigned scores[11] = &#123;&#125;; //列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。unsigned grade;while (cin &gt;&gt; grade) &#123; if (grade &lt;= 100) ++scores[grade/10];&#125; 与vector 和string 一样，当需要遍历数组的所有元素时，最好的办法是使用范围for语句。 1234//对于scores中的每个计数值输出当前的计数值for (auto i : scores) cout &lt;&lt; i &lt;&lt; \" \";cout&lt;&lt;endl; 必须要检查数组下标的值在合理范围内，下标越界会产生缓冲区溢出。 练习3.31编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。 123456789101112131415include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(auto val: a) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 3.32 将上一题创建的数组拷贝给另外一个数组，利用vector重写程序，实现类似的功能。 //如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。 1234567891011121314include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz], b[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(int j = 0; j &lt; sz: j++) b[j] = a[j]; return 0;&#125; //用vector重写 123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; const int sz = 10; vector&lt;int&gt; vInt, vInt2; for (int i = 0; i &lt; sz; i++) vInt.push_back(i); for (int j = 0; j &lt; sz; j++) vInt2.push_back(vInt[j]); for (auto val: vInt2) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 例子：输出100以内的所有素数。 一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足：$$1&lt;c\\le \\sqrt{n}$$循环结构的N-S图： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; bool a[100] = &#123;0&#125;; int sum = 0; for(int i=0; i&lt;100; i++) a[i] = 0; for(int i=2; i&lt;sqrt(100.0); i++)&#123; sum = i; if(a[sum]==0)&#123; while(sum&lt;100)&#123; sum = sum + i; a[sum] = 1; &#125; &#125; &#125; for(int i=0; i&lt;100; i++) if(a[i]==0) cout&lt;&lt;i&lt;&lt;\" \"; return 0;&#125; 多维数组严格来说，C++中并没有多维数组，通常所说的多维数组其实是数组的数组。按照由内而外的顺序阅读。 多维数组初始化的几种方式： 1234int ia[3][4] = &#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,10,11&#125; &#125;; //每一行分别用花括号括起来int ia[3][4] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; //不标识每行的花括号int ia[3][4] = &#123; &#123; 0 &#125;, &#123; 4 &#125;, &#123; 8 &#125; &#125;; //显示地初始每行的首元素int ia[3][4] = &#123;0,1,2,3&#125;; //只显示地初始化第1行 多维数组的下标引用：如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果是给定类型的元素；如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。 例子：某学校有1000位老师，分布在20个不同的学院中，每个学院最多有12个系，请你编写一个程序，输入每位老师的所在院、系的编号（院编号1-20，系编号1-12），打印出各个系老师的数量。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;iomainp&gt;using namespace std;int main()&#123; int teacher[21][13]; int school,department, i, j; char name[30]; for(i=0; i&lt;1000; i++) &#123; cin&gt;&gt;name&gt;&gt;school&gt;&gt;department; teacher[school][department]++; &#125; for(i=0; i&lt;21; i++) for(j=1; j&lt;13; j++) cout&lt;&lt;setw(4)&lt;&lt;teacher[i][j]; cout&lt;&lt;endl; return 0;&#125; 指针和数组数组的地址在C++语言中，指针和数组有非常紧密的联系。数组名代表数组首元素的地址：数组名是指向数组第一个元素的指针。对于数组a[10]，数组名a代表数组a[10]中第一个元素a[0]的地址，即a与&amp;a[0]等价。需要注意的是，a是地址常量，不是变量，不能给a赋值 12345int a[4] = &#123;10,11,12,13&#125;;cout &lt;&lt; a &lt;&lt; endl; //输出a[0]的地址 0017F754cout &lt;&lt; *a &lt;&lt; endl; //输出a[0]的值 10cout &lt;&lt; &amp;a[0] &lt;&lt; endl; //0017F754cout &lt;&lt; a[0] &lt;&lt; endl; //10 若a是指向数组第一个元素的指针，即a相当于&amp;a[0]。 &amp;a是”指向数组“的指针，&amp;a+1将跨越16个字节，&amp;a相当于管辖范围”上升“了一级； *a是数组的第一个元素a[0]，即 *a等价于a[0]， *a相当于管辖范围“下降”了一级。 在一些情况下数组的操作实际上是指针的操作。当使用数组作为一个auto变量的初始值时，得到的类型是指针而非数组。当使用decltype关键字时上述转换不会发生，decltyoe(ia)返回的类型是由整数构成的数组。 123int ia[] = &#123;0,1,2,3,4&#125;;auto ia2(ia); //相当于 auto ia2(&amp;ia[0]); ia2是一个整型指针decltype(ia) ia3 = &#123;0,1,2,3,4&#125;; //ia是含有整数的数组 C++11新标准引入了begin和end函数，定义在iterator头文件中，这两个函数与容器中的两个同名成员功能类似，但由于数组不是类类型，因此这两个函数不是成员函数，使用时需要将数组作为它们的参数。 123int ia[] = &#123;0,1,2,3,4&#125;;int *beg = begin(ia);int *last = end(ia); 利用指针变量引用数组元素1234567int a[10], *pointer;pointer = a; //等价于 pointer = &amp;a[0];cout &lt;&lt; pointer+i; //等价于a+i；等价于&amp;a[i]；cout &lt;&lt; *(pointer+i);//等价于*(a+i)；等价于a[i];cout &lt;&lt; pointer[i]; //等价于*(pointer+i);int *p = &amp;a[0]; 需要注意的是：a++是没有意义的，但p++会引起p的变化。p可以指向数组最后一个元素以后的元素，称为尾后指针，就像尾后迭代器，尾后指针不能执行解引用和递增操作。指针做加减运算时一定要注意有效的范围。 123456int a[5];int *iPtr = &amp;a[1];iPtr--; //iPtr指向a[0]*iPtr = 3; //a[0]=3iPtr--; //iPtr指向a[-1].dangerous*iPtr = 6; //damage 根据运算符的优先级有： *++p相当于a[++i]，先将p自加，再做*运算。 *--p相当于a[--i]，先将p自减，再做*运算。 *p++相当于a[i++]，先做*运算，再将p自加。 *p--相当于a[i--]，先做*运算，再将p自减。 例子：123456789//使用指针代替数组下标int main()&#123; int a[10], i, *p = a; for(i = 0; i&lt;10; i++) cin &gt;&gt; *p++; for(p--; p&gt;=a; ) cout &lt;&lt; setw(3) &lt;&lt; *p--; return 0;&#125; 123456789101112131415//倒置数组元素//输入：1 2 3 4 5 6 7 8 9 0//输出：0 9 8 7 6 5 4 3 2 1int main()&#123; int a[10], *p = NULL, *q = NULL, temp; for(p = a; p&lt;a+10; p++) cin &gt;&gt; *p; for(p = a, q = a+9; p&lt;q; p++, q--) &#123; temp=*p; *p=*q; *q=temp; &#125; for(p = a; p&lt;a+10; p++) cout &lt;&lt; setw(3) &lt;&lt;*p; return 0;&#125; 二维数组的地址数组名相当于指向数组第一个元素的指针。 *a等价于a[0]，相当于a下降了一级； &amp;a表示“指向二维数组”的指针，相当于上升了一级。 1234567891011121314151617181920int main()&#123; int a[3][4]=&#123; &#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125; &#125;; //a是指向数组第一个元素的指针，而数组的第一个元素是一个含有4元素的数组，即a是指向一维数组的指针， //a相当于一个“包含4个int型元素的一维数组”的地址 cout &lt;&lt; a &lt;&lt; endl; //0x0013FF50 cout &lt;&lt; &amp;a[0] &lt;&lt; endl; //0x0013FF50 cout &lt;&lt; a+1 &lt;&lt; endl; //0x0013FF60 a+1将跨越16个字节 cout &lt;&lt; &amp;a[0]+1 &lt;&lt; endl; //0x0013FF60 //*a是数组的第一个元素，而数组的第一个元素是一个数组，即*a是一个指向整数的指针， cout &lt;&lt; *a &lt;&lt; endl; //0x0013FF50 cout &lt;&lt; a[0] &lt;&lt; endl; //0x0013FF50 cout &lt;&lt; &amp;a[0][0] &lt;&lt; endl; //0x0013FF50 cout &lt;&lt; *a+1 &lt;&lt; endl; //0x0013FF54 *a+1将跨越4个字节 cout &lt;&lt; a[0]+1 &lt;&lt; endl; //0x0013FF54 cout &lt;&lt; &amp;a[0][0]+1 &lt;&lt; endl; //0x0013FF54 return 0;&#125; 例子1：遍历数组元素123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int *p; //for (p=&amp;a[0][0]; p&lt;&amp;a[0][0]+12; p++) //for (p=a[0]; p&lt;a[0]+12; p++) for (p=*a; p&lt;*a+12; p++) cout&lt;&lt;p&lt;&lt;\" \"&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 例子2：输入i，j；输出a[i] [j]123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a[3][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; int (*p)[4], i, j; p=a; cin&gt;&gt;i&gt;&gt;j; //cout &lt;&lt; setw(4) &lt;&lt; p[i][j]; cout&lt;&lt;setw(4)&lt;&lt;*(*(p+i)+j); return 0;&#125; 问题分析： 从p=a开始，a相当于指向a[3][4]的“第一个元素”的指针；所谓“第一个元素”是指一个 “包含4个int型元素的一维数组”；所以，a相当于一个 “包含4个int型元素的一维数组”的地址；因此p的基类型应该是 “包含4个int型元素的一维数组”。 如何定义一个指向 “包含4个int型元素的一维数组” 的指针变量？ ——- int (*p)[4] *(*(p+i)+j)是什么？ p指向一个“包含4个int型元素的一维数组”； p+i 是第i+1个“包含4个Int 型元素的一维数组”的地址；p+i等价于&amp;a[i]； ​ *(p+i)等价于a[i]；*(p+i)+j等价于a[i]+j； ​ 因为：a[i]+j等价于&amp;a[i][j]，所以：*(*(p+i)+j)等价于a[i][j]。 p[i][j]是什么？ p[i]等价于 *(p+i)； p[i][j] 等价于 *(*(p+i)+j)，等价于a[i][j]。 使用范围for语句处理多维数组C++11新标准中新增了范围for语句，可以使用范围for语句处理多维数组，为了避免数组被自动转成指针，处理最内层的循环外，其他所有循环的控制变量应该都是引用类型。 1234567constexpr size_t rowCnt=3. colCnt=4, cnt=0;int ia[rowCnt][colCnt];for(auto &amp;row : ia) for(auto &amp;col : row) &#123; col = cnt; ++cnt; &#125; //ia=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125; 也可以使用标准库函数begin和end。 123456for (auto p=begin(ia); p!=end(ia); ++p)&#123; for (auto q=begin(*p); q!=end(*p); ++q) cout&lt;&lt;*q&lt;&lt;' '； //依次输出ia的元素的值 cout&lt;&lt;endl；&#125; 字符串指针123456789101112131415#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; char buffer[10] = \"ABC\"; char *pc; pc = \"hello\"; cout &lt;&lt; pc &lt;&lt; endl; //输出hello pc++; cout &lt;&lt; pc &lt;&lt; endl; // ello cout &lt;&lt; *pc &lt;&lt; endl; // e pc = buffer; cout &lt;&lt; pc &lt;&lt; endl; //ABC return 0; &#125;","categories":[],"tags":[]},{"title":"Cpp基础（2）引用与指针","slug":"Cpp基础（2）引用与指针","date":"2020-01-27T03:02:17.000Z","updated":"2020-01-27T14:31:11.996Z","comments":true,"path":"2020/01/27/Cpp基础（2）引用与指针/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/","excerpt":"","text":"引用与指针复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。 一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。 引用当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成$d的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。 为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。 引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 12345678910int ival = 1024;int &amp;refVal = ival; //refVal指向ivalint &amp;refVal2; //错误。引用必须被初始化refVal = 2; //把值赋给了ivalint &amp;refVal3 = refVal; //正确：refVal3绑定到了那个与refVal绑定的对象上，即ivalint i = refVal; //相当于i = ivalint i = 1024, i2 = 2048;int &amp;r1 = i, &amp;r2 = i2; 指针指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同： （1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。 （2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。 指针运算符*，取地址符&amp; 指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 指针变量：专门用于存放指针（某个变量的地址）的变量 1234int c = 76;int *pointer; //定义名字为pointer的指针变量pointer = &amp;c; //将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c//pointer = c; //错误：因为pointer是存放地址的变量，所以只能存放地址 通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。 12345int c = 76;int *pointer = &amp;c; //*pointer为“pointer所指向的存储单元的内容\"，即是变量ccout &lt;&lt; &amp;c &lt;&lt;endl; //取变量c的地址cout &lt;&lt; &amp;pointer &lt;&lt; endl; //取指针变量c的地址 赋值和指针：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。 1234int i = 42;int *pi = 0; //pi被初始化pi = &amp;ival; //pi所存的地址改变，指向ival*pi = 0; //ival的值被改变，指针pi所存的地址没有改变 &amp;与*`的运算优先级：同级 空指针（null pointer）不指向任何对象。 123int *p1 = nullptr //C++11int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //需要首先#include&lt;cstdlib&gt; 使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。 void*指针：可用于存放任意对象的地址。利用void*指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个void*指针。不能访问其内存空间中所存的对象。 123double obj = 3.14, *pd = &amp;obj;void *pv = &amp;obj;pv = pd;","categories":[],"tags":[]},{"title":"Cpp基础（1）基础语法","slug":"Cpp基础（1）基础语法","date":"2020-01-27T02:59:54.000Z","updated":"2020-01-27T14:11:39.005Z","comments":true,"path":"2020/01/27/Cpp基础（1）基础语法/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"基础语法Hello world1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello world\" &lt;&lt; endl; //变量创建的语法： 数据类型 变量名 = 变量初始值 int a = 10; cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl; system(\"pause\"); return 0;&#125; 变量创建的语法： 数据类型 变量名 = 变量初始值 定义常量的两种方法： #define 宏常量名 常量值 const 修饰的变量 const 数据类型 常量名 = 常量值 定义变量或常量时不要用C++中已经使用的关键字 C++中给标识符（变量，常量）命名时，要注意：1.标识符不可以是关键字2.标识符只能由字母，数字，下划线组成3.标识符的第一个字母只能是字母或者下划线4.标识符中区分大小写5.给变量命名时最好能做到见名知意，方便阅读 数据类型数据类型存在的意义：给不同类型的变量分配合适的内存空间 整型的几种类型：1.短整型 short 2字节 -2^15 - 2^15-12.整型 int 4字节 -2^31 - 2^31-1 //int最常用3.长整型 long 4字节 -2^31 - 2^31-14.长长整型 long long 8字节 -2^63 - 2^63-1 sizeof 关键字可以得到数据类型所占的内存的大小语法： sizeof（数据类型/变量名） 实型/浮点型：用于表示小数1.单精度 float 4字节 7位有效数字2.双精度 double 8字节 15-16位有效数字 字符型：用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型：用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符： 用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 布尔类型bool：代表真或假的值 占用1个字节bool类型只有两个值：true（本质是1） false（本质是0） 数据的输入：用于从键盘获取数据语法：cin &gt;&gt; 变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;using namespace std;int main1() &#123; short num1 = 10; cout &lt;&lt; \"short所占的内存空间为\" &lt;&lt; sizeof(num1) &lt;&lt; endl; float f1 = 3.14f; //编译器会把小数默认为双精度数，所以要在3.14后加上f cout &lt;&lt; \"f1=\" &lt;&lt; f1 &lt;&lt; endl; double d1 = 3.1415926; cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; endl; //显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的 setprecision( ) const double value = 12.3456789; cout &lt;&lt; value &lt;&lt; endl; // 默认以6精度，所以输出为 12.3457 cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35 cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679 cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457 cout.unsetf(ios::fixed); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35 cout &lt;&lt; value &lt;&lt; endl; cout.precision(6); // 恢复成原来的样子，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; //科学计数法 float f2 = 3e2; cout &lt;&lt; \"f2=\" &lt;&lt; f2 &lt;&lt; endl; //查看字符型变量对应的ASCII码 a-97 A-65 char ch = 'a'; cout &lt;&lt; (int)ch &lt;&lt; endl; ch = 97; cout &lt;&lt; ch &lt;&lt; endl; //字符串 char str1[] = \"hello world\"; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = \"hello world\"; cout &lt;&lt; str2 &lt;&lt; endl; //布尔类型 bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; flag = false; cout &lt;&lt; flag &lt;&lt; endl; //数据的输入 string str; cout &lt;&lt; \"请输入字符串变量：\" &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; system(\"pause\"); return 0;&#125; 运算符算术运算符：加+ 减- 乘* 除/ 取模（取余）% 只有整型变量可以进行取模运算需要注意：1.进行运算的变量类型，如两个整型相除结果仍是整数2.除数不能为0，取模运算除数也不能为03.只有整型变量可以进行取模运算，小数不可以 赋值运算符：用于将表达式的值赋给变量赋值= 加等于+= 减等于-= 乘等于*= 除等于/= 模等于%= 比较运算符：用于表达式的比较，并返回一个真值或假值相等于== 不等于!= 小于&lt; 大于&gt; 小于等于&lt;= 大于等于&gt;= 逻辑运算符：用于根据表达式的值返回真值或假值非! 与&amp;&amp; 或|| 要注意运算符的优先级 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main2() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; // a2=11, b2=110 //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; // a3=11, b3=100 //比较运算符 a = 10; b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(\"pause\"); return 0;&#125; 程序流程结构C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构1.顺序结构：程序按顺序执行，不发生跳转2.选择结构：依据条件是否满足，有选择的执行相应功能3.循环结构：依据条件是否满足，循环多次执行某段代码 选择结构if语句：1.单行格式if语句：if (条件) { 条件满足执行的语句}2.多行格式if语句：if (条件) { 条件满足执行的语句} else{条件不满足执行的语句}3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}4.嵌套if语句注意：if条件后面不要加分号 三目运算符：实现简单的判断语法：表达式1 ? 表达式2 : 表达式3解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果 如果表达式1的值为假，执行表达式3，并返回表达式3的结果注意：C++中三目运算符返回的是变量，可以继续赋值 switch语句：执行多条件分支语句语法：switch(表达式){ case 结果1：执行语句;break; case 结果2：执行语句;break; … default:执行语句;break;}注意：1. switch语句中的表达式的数据类型只能是整型或字符型 2. case里如果没有break，那么程序会一直向下执行 3.对于多条件判断，switch的结构清晰，执行效率高 循环结构while循环结构：满足循环条件，执行循环结构 语法：while (循环条件) {循环结构} 注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环 do … while循环语句：满足循环条件，执行循环语句 语法：do {循环语句} while (循环条件) 注意：do…while先执行一次循环语句，再判断循环条件 for 循环语句：满足循环条件 语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句} 注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体 嵌套循环 跳转语句break 语句：用于跳出选择结构或者循环结构 使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环结构 continue语句：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 注意：continue不会使循环终止，而break会跳出循环 goto语句：可以无条件跳转语句 语法：goto 标记 如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;int main()&#123; //嵌套if语句 int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; \"我考上了北大\" &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; \"我考上了清华\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我考上了人大\" &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; \"我考上了二本大学\" &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; \"我考上了三本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上本科\" &lt;&lt; endl; &#125; //三目运算符 int a = 10, b = 20, c = 0; c = a &gt; b ? a : b; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; //b=100 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //a=10 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //b=100 cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //嵌套循环体 //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; \"*\" &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; //continue语句 for (int i = 0; i &lt; 100; i++)&#123; if (i % 2 == 0) continue; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125;","categories":[],"tags":[]},{"title":"搭建自己的博客","slug":"搭建自己的博客","date":"2020-01-18T03:08:31.000Z","updated":"2020-01-18T05:42:11.186Z","comments":true,"path":"2020/01/18/搭建自己的博客/","link":"","permalink":"http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.安装GitGIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：https://gitforwindows.org/，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。 2.安装node.js在官网选择LTS版本下载安装即可：https://nodejs.org/en/download/。 3.安装Hexo在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。 1npm install -g hexo-cli 初始化博客 1hexo init 启动服务：依次执行以下命令 12345npm stallhexo shexo chexo ghexo d 浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决： 1npm install hexo-deployer-git --save 之后每次更新博客内容后都要执行 hexo c –&gt;hexo g –&gt;hexo d，来重新部署。 4.将Hexo部署到GitHub在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式 回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 打开提示已经创建好的.ssh文件夹，其中id_rsa是私人密钥，id_rsa.pub是公共密钥。在GitHub中打开setting –&gt; New SSH key，将id_rsa.pub里面的信息复制进去。 在blog文件夹中打开博客配置文件_config.yml，将最后几行修改为： 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git branch: master 安装deploy-git 1npm install hexo-deployer-git --save 最后重新部署博客 123hexo chexo ghexo d 这样就可以在 http://yourname.github.io 访问自己的博客了。 5.设置主题我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在blog文件夹下右键GIt Bash Here，下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 打开blog目录下的博客站点配置文件_config.yml，在开头的Site中添加自己博客的信息，注意将language改为zh-CN： 123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-CNtimezone: 往下拉，将theme改为next： 1theme: next 重新部署博客即可看到主题已经替换。 接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。 设置scheme在\\blog\\themes\\next文件夹中打开主题配置文件_config.yml，找到外观scheme，想使用哪一种就把前面的注释符#去掉，我选用的是Mist。 1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单在主题配置文件_config.yml中找到菜单menu，将需要的项前的#去掉，我保留了about关于，categories分类，tags标签，archives归档。 123456789menu: home: &#x2F; || home about: &#x2F;about&#x2F; || user tags: &#x2F;tags&#x2F; || tags categories: &#x2F;categories&#x2F; || th archives: &#x2F;archives&#x2F; || archive #schedule: &#x2F;schedule&#x2F; || calendar #sitemap: &#x2F;sitemap.xml || sitemap #commonweal: &#x2F;404&#x2F; || heartbeat 创建菜单需要的页面： 123hexo new page abouthexo new page tagshexo new page categories 在\\blog\\source下就会生成对应的文件夹，打开其中的index.md文件，将type设置为相应的内容，以about为例： 1234title: aboutdate: 2020-01-17 20:16:07type: &quot;about&quot; comments: false 设置背景动画在主题配置文件_config.yml中找到Animation Settings，我使用的是Canvas-nest，将Canvas-nest下的enable状态改为true即可： 123canvas_nest: enable: true onmobile: true # Display on mobile or not —————————————————————————— 到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。 2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-12T07:14:03.207Z","updated":"2020-01-12T07:14:03.207Z","comments":true,"path":"2020/01/12/hello-world/","link":"","permalink":"http://nekomoon404.github.io/2020/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}