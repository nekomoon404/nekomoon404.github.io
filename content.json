{"meta":{"title":"nekomoon的个人小站","subtitle":"","description":"","author":"nekomoon","url":"http://nekomoon404.github.io","root":"/"},"pages":[{"title":"about","date":"2020-01-17T12:16:07.000Z","updated":"2020-01-17T12:45:38.714Z","comments":false,"path":"about/index.html","permalink":"http://nekomoon404.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-17T12:15:51.000Z","updated":"2020-01-17T12:45:26.408Z","comments":false,"path":"categories/index.html","permalink":"http://nekomoon404.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-17T12:15:21.000Z","updated":"2020-01-17T12:45:12.630Z","comments":false,"path":"tags/index.html","permalink":"http://nekomoon404.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构与算法（4）气泡排序与归并排序","slug":"数据结构与算法（4）气泡排序与归并排序","date":"2020-02-12T12:45:52.000Z","updated":"2020-02-12T15:45:44.051Z","comments":true,"path":"2020/02/12/数据结构与算法（4）气泡排序与归并排序/","link":"","permalink":"http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"通过之前的两篇文章我们可以知道有序向量相对于无序向量有着更多的优势，比如它的去重操作以及查找操作都可以更快速地完成，然而我们遗留下一个问题，就是如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法，即起泡算法与归并算法。 排序器：统一接口1234567891011template &lt;typename T&gt; void Vector&lt;T&gt;::sort ( Rank lo, Rank hi ) &#123; //向量区间[lo, hi)排序 switch ( rand() % 6 ) &#123; case 1: bubbleSort ( lo, hi ); break; //起泡排序 case 2: selectionSort ( lo, hi ); break; //选择排序（习题） case 3: mergeSort ( lo, hi ); break; //归并排序 case 4: heapSort ( lo, hi ); break; //堆排序（第12章） case 5: quickSort ( lo, hi ); break; //快速排序（第14章） default: shellSort ( lo, hi ); break; //希尔排序（第14章） &#125; //随机选择算法以充分测试。实用时可视具体问题的特点灵活确定或扩充&#125; 起泡排序1234567template &lt;typename T&gt; //向量的起泡排序（基本版）void Vector&lt;T&gt;::bubbleSort( Rank lo, Rank hi ) &#123; //assert: 0 &lt;= lo &lt; hi &lt;= size while( lo &lt; --hi ) //反复起泡扫描 for( Rank i = lo; i &lt; hi; i++ ) //逐个检查相邻元素 if( _elem[i] &gt; _elem[i + 1] ) //若逆序，则 swap( _elem[i], _elem[i + 1] ); //经交换使局部有序&#125; 在第一章曾以这个算法为例介绍过如何证明算法的正确性，这里按照刚才统一定义的形式将它整理为一个名为bubbleSort的算法接口。这个算法实际上可以认为是通过调用一个名为bubble的过程迭代地来进行，在每一迭代过程中都会考察当前介于lo和hi之间的所有相邻元素，只要有一对相邻元素是逆序的，就将它们交换，所以整个这样的一个过程也称作扫描交换。 这个算法的不变法具体来说，如果最初的这个向量是一个无序向量的话，那么每经过这样一趟对bubble的调用都会有一个新的元素就位，比如对于第一次而言就是全局最大的那个元素，这里用红色来表示就位的元素，那么当然互补地其它的部分也就是接下来要考察的问题的范围，就会相应地缩小一个单元，这也是减而治之。再接下来有序的部分会继续地拓展，而无序的部分会继续地缩减，整个呈现为一个不断此消绿色的这部分，和彼涨红色的这部分这样一个过程，直到无序的部分只剩下一个元素。 不难看出每一趟对bubble的调用所需要的时间都线性正比于绿色无序部分的宽度，整体地呈现为一个算术级数的形式，所以它的总体量与它的末项成平方关系，即$O(n^2)$。然而我们并不满足于这样的结果，至少在很多情况下都是有可能改进的。 改进可以看到这里的红色部分确实必然是有序的，但是绿色的部分未必都是无序的，事实上比如这个时候有可能其中会有一部分元素，甚至所有的元素都是有序的。那么如何尽早地判定出这种情况，从而提前结束这个算法呢？这里依赖的准则与算法最初的判定准则是一样的，也就是一个向量包括一个区间如果是完全有序的，当且仅当其中任何一对相邻的元素都是彼此顺序的，而实际上在刚刚进行完的前一次迭代中我们在某种意义上已经做过这种类似的检查了。 由此可以得出一个改进的策略：在每一次扫描交换的过程中不妨记录一下是否曾经真的存在逆序元素，如果存在的话它的充要条件是在此前做过一次交换，所以我们只要来记录一下在当下这趟扫描交换过程中是否曾经做过至少一次扫描交换，如果没有做过那么后续的各趟其实都可以省略掉，从而在实际的运行时间上有可能会有所减少，甚至大大减少。这是一个很好的策略，我们不妨把这个策略整理为下面的一段代码。 123456789101112template&lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while (!bubble(lo, hi--));&#125; //逐趟做扫描交换，直至全序template&lt;typename T&gt; void Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; bool sorted = ture; //整体有序标志 while(++lo &lt; hi)&#123; //自左向右，逐一检查各相邻元素 if (_elem[lo - 1] &gt; _elem[lo]) &#123; //若逆序，则 sorted = false; //意味着尚未整体有序，并需要 swap(_elem[lo - 1], _elem[lo]); //交换 &#125; return sorted; //返回有序标志&#125; 原算法整体运行时间确实可以度量为一个三角形的面积，那么对于新的改进的这个算法，它固然要做第一趟扫描交换也许还需进行若干次扫描交换，但是在某些情况下它有可能会发现不光此后的部分已经有序了，而且这个前缀也已经完全有序了，所以这时它就会及时地跳转到最后，聪明地绕过这些完全可以绕过的计算量。因此与刚才那样对比新的这个算法所执行的计算量可以度量为这样一个梯形，而不是原来的三角形，也就是说很多情况下都可以节省一定的甚至是相当多的时间。不过我们对这个算法的改进并不满足于此因为我们发现在一些其它或者说在更多的情况下，这个算法依然存在继续改进的空间。 再改进考察这样一个向量，假设它可以分为长度相差悬殊的一个前缀以及后缀，而且后缀中的元素都已按顺序排列并严格地就位，当然相应地所有的乱序元素都集中分布于这样一个相对更短的前缀中。对于这样的一个实例，上节中已经做过优化的起泡排序算法会如何表现呢？ 首先它需要做第一趟完整地扫描交换，并且确认在最后这个位置有一个元素就位，虽然它原本就是就位的。请注意虽然这个时候在这个后缀中，存在着大量的就位元素，但因为在前缀中刚才存在交换，bubble算法会返回false，那么算法接下来还会继续下去。尽管能够判定的就位元素数目会继续增加，但是与刚才同理，我们依然不能确认可以提前退出，接下来还需要进行若干次的扫描交换。那么对于这样的一个例子，总体而言需要的扫描交换的趟数不会超过这个前缀的长度r。 因为此前所做的各趟扫描交换，与其说是在对绿色的范围做处理，不如说实际影响的是这个前缀中的倒数第一个倒数第二个 以及倒数第三个，即是在这个前缀中后面的那些元素。每一趟扫描交换所起的实质作用无非是在这样一个前缀中，令其中的一个一个的后缀元素依次就位，直到整个这个前缀中的元素完全就位。 因此这个算法总体消耗的时间应该是n乘以r，如果r取作根号n，相应地也就是n的1.5次方，即$O(n^{1.5})$。但如果能及时地检测出这样一种情况，也就是实质需要排序的元素集中在一个宽度仅为$\\sqrt{n}$的区间中，而不是整个向量。那么即使套用最原始的起泡排序算法，所需要的时间也无非是$O((\\sqrt{n})^2)=O(n)$。问题是如何才能够完成从1.5次方到一次方的优化转换呢？ 重新审视上面的例子，所多余出来的时间消耗无非是在后缀中，对这些已就位元素的反复扫描交换，不难理解这些元素都是不必扫描交换的，可惜此前的算法版本未能及时地将它们分解出来，但它们实际上是可以分解出来的。 比如说如果我们通过某一种方法记录在上一趟扫描交换过程中所进行的最后一次交换，就很容易确定在上一趟扫描的区间中有一个多长的后缀实际上没有做过任何交换，也就是说它们中的元素都是已经就位了的。如果能这样只需要将原先的右侧标志hi直接地指向这个新的位置，而不是像刚才那样亦步亦趋地、逐个地收缩。 基于以上的分析不难得到下面的新的改进的方法，从结构上看跟刚才大体类似，依然是逐个地检查所有的相邻对，如果是逆序的就做交换，不同之处在于这里我们所记录的不再只是一个逻辑性变量，而是一个名为last的整型或者说是秩，它的初值是取作lo，而每当需要交换就将这个last更新为新的位置。在整个算法的过程中lo这个变量是持续递增的，所以当它在返回的时候，last确实名副其实地记录了最右侧也就是最后一对逆序对的位置。 123456789101112template&lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while (!bubble(lo, hi--));&#125; //逐趟做扫描交换，直至全序template&lt;typename T&gt; void Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; Rank last = lo; //最右侧的逆序对初始化为[lo-1, lo] while(++lo &lt; hi)&#123; //自左向右，逐一检查各相邻元素 if (_elem[lo - 1] &gt; _elem[lo]) &#123; //若逆序，则 last = lo; //更新最右侧逆序对位置记录，并 swap(_elem[lo - 1], _elem[lo]); //交换 &#125; return last; //返回有序标志&#125; //前一版本中的逻辑型标志sorted，改为秩last 这样我们就可以有效地来处理刚才那种情况，回到刚才那个实例，我们构造了一个足够短的乱序前缀再加一个非常长但是已经就绪了的后缀。新的算法首先也会做一趟扫描交换，当然为此花费的时间是$O(n)$。但是与刚才那个版本的不同，在这个时候它会检测出发生的最后一次扫描交换绝对不会超过绿色末尾的位置，将扫描交换的右侧界桩hi一次性地挪到那里，这等效于判断出了此后的这些元素包括最后那个元素都是已经就位的。 从算法的流程来说我们的下一趟扫描交换的区间，就不再是原先整个那个绿色的区间，而是相对要短很多的一个区间。接下来等效于只是对这样一段区间做扫描交换，因此需要花费的时间除了刚才的$O(n)$以外，主要是对应于这样的一个更小的三角形，如果边长是$\\sqrt{n}$，累计也不过是再加上一个$O(n)$，与刚才的$O(n)$合并，总体不过是$O(n)$，更有意思的是这种情况在整个排序过程中有可能会多次出现。 我们也可以通过图形的方式，形象地将新的这个算法版本与之前的原始版本在时间效率上做一个对比。这个三角形 代表的是原始的起泡排序算法所需要的时间。新版本的算法所需要执行的扫描交换将会呈现为连续的一段。然后再间或地跳跃到下面一段以及再间或地有可能会跳跃到下面一段（深色部分）。换而言之这个算法的时间成本将取决于这样一个一个若干个梯形的面积总和，相对于此前那个梯形来说这种梯形的划分更加的精细，所以它节省下来的时间也会在通常的情况下相对更多。 当然在最坏的情况下这个算法依然是于事无补的，起泡排序依然注定需要$O(n^2)$的时间。 综合评价 三种起泡排序在最好和最坏情况下的效率相同：最好$O(n)$，最坏$O(n^2)$ 输入含重复元素时，算法的稳定性（stability）是更为细致的要求 重复元素在输入，输出序列中的相对次序，是否保持不变？（在某些问题中很敏感） ​ 输入：$6,7_a,3,2,7_b,1,5,8,7_c,4$ ​ 输出：$1,2,3,4,5,6,7_a,7_b,7_c,8$ //stable ​ $1,2,3,4,5,6,7_a,7_c,7_b,8$ //unstable 三种起泡排序算法都是稳定的，因为在起泡排序中，元素$7_a$和$7_b$的相对位置发生变化，只有一种可能： ​ 经分别与其他元素的交换，二者相互接近直至相邻 ​ 在接下来一轮扫描交换中，二者因逆序而交换位置 而起泡排序中交换，即if的判断条件是_elem[lo - 1] &gt; _elem[lo])，严格大于，因此不会出现上面的情况 虽然起泡排序可以做大量的改进，但从最坏情况而言它依然是注定也需要$O(n^2)$的时间，所以我们非常希望能够得到一个即便在最坏情况下也能够效率更高的排序算法，这也就是下一节所要介绍的内容。 归并排序采用包括Bubble sort在内的常规的基于比较式的算法（Comparison Based Algorithm），求解排序问题都存在一个下界$nlogn$。那么在$n^2$的上界到$nlogn$的下界之间是否存在一些其它的，相对于$n^2$而言更好的算法,甚至于是否有一个算法即使在最坏的情况下也只需要$n*logn$的时间就能完成排序呢？答案就蕴含在这一节的主题里也就是归并排序（Merge Sort）。 归并排序算法是分治策略在算法设计中应用的又一个典型，这个算法最初是由冯·诺依曼编码实现的，所谓的分治策略在这里就是说将待排序的那个序列（向量或者列表）一分为二，这种分法很快捷只需要$O(1)$的时间，接下来 对于划分出的两个子序列分别去做递归地求解，也就是递归地排序。而当两个子序列已经分别有序之后，我们接下来要解决的一个问题就是将它们合并准确地讲是归并merge，从而构成一个完整的有序序列。 对于上面这样一个由8个元素组成的向量，首先是分沿左右划分为左和右两个子序列，这两个子序列递归地求解的过程中依然还是相对比较大，所以它们会继续递归地、各自地进行划分继续分为左左、左右以及右左和右右四个子序列。同样 它们还是不够平凡所以我们最后还要对这四个子序列继续地一分为二，最终八个元素各自成为一个独立的序列，这个时候从递归地角度讲就抵达了递归基，所有这些元素都已经不需要再继续划分下去了，因为它们各自有序了。 所以如果说前面半层是做无序向量的递归分解，接下来就要通过逐层的合并使之逐渐地变成一个大一点的，更大一点的，直到最后那个有序的序列。我们可以看到每一次都是将两个已经是有序的子序列合并为一个有序的子序列，然后再继续相邻的子序列逐对地合并构成再更大的序列，最后左右这两个各自有序的子序列再逐对地合并最终得到整体的序列。 那么如果果真能像这里所说的那样，我们就应该能够得到一个总体是$n*logn$的算法，可由下面的递推式证明： T(n)=2\\cdot T(n/2)+O(n)可以得到：$T(n)=O(nlogn)$。 接下来的技术细节就是如何来兑现这一点呢？可以看到从这里的划分的过程是非常简单，递归也可以交给递归的机制去做，所以这里核心的任务是在怎么进行合并，或者准确地讲是怎么将两个已经有序的序列归并成一个更大的序列，这也是这个算法最关键的细节和技巧。 主算法把刚才的思路实现为这样一段具体的代码，和所有的递归程序一样首先要处理递归基，接下来开始实质的分也就是除二取到中点，这样的话我们可以将整体的一个序列分成左和右两部分，分别由lo和mi，以及mi和hi来界定。对于这两个序列，分别是递归调用自己，mergeSort前一个序列，mergeSort后一个序列。接下来最重要的实质的工作是在merge，下面不妨来通过一个实例来理解merge算法的原理 12345678template &lt;typename T&gt; //向量归并排序void Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; //0 &lt;= lo &lt; hi &lt;= size if ( hi - lo &lt; 2 ) return; //单元素区间自然有序，否则... int mi = ( lo + hi ) / 2; //以中点为界 mergeSort ( lo, mi ); mergeSort ( mi, hi ); //分别排序 merge ( lo, mi, hi ); //归并&#125; 二路归并：原理 2-way merge：将两个有序序列合并为一个有序序列 S[lo, hi) = S[lo, mi) + S[mi, hi) 首先（a）图给出了两个各自有序的子序列，二路归并算法的要诀就是我们只需要把注意力关注在这两个序列的首元素上，这样一个虚线的方框是我们的关注焦点，其余的元素可以暂时不用顾及。那么我们取出这两个序列各自的首元素的时候，都要从中挑选出更小的那个元素，如果是两者相等的话，可以任意取一个。比如 就这个例子而言 就这个例子而言首先取出的是这个2，我们将它择出来，相应地在摘除了首元素以后，后续的元素将逐次递补，也就是关注到新顶替上来的这个首元素上。同样在接下来的一轮比对中，我们考察这两个首元素的大小，并且同样地取出其中的更小的那个，4依然比5小所以4被取出，同样它的后继们会顶替上来对这个例子而言就是10。就这样逐步进行到图（h），直到最终一旦有一个向量已经变成空的，那么另一个向量所剩余的元素无论多少都直接串接在后边（因为剩余那部分必然是有序的）。 按照这样的原理，我们确实可以得到一个更大的单调序列，这种二路归并的算法实际上是非常通用的一个版本，但在这里针对于归并排序而言的，我们实际上用到的是其中的一种特例，在这个时候参与归并的两个序列实际上是来自于同一个更大的向量，只不过是由其中的三个界桩也就是lo、mi和hi来联合定义的。如果左侧的这个向量称作B，右侧的称作C的话，那么合并起来的整体的这个向量就是A。那下一小节介绍针对这样一种特殊情况，二路归并算法应该如何实现。","categories":[],"tags":[]},{"title":"ML:Week1","slug":"ML-Week1","date":"2020-02-11T02:15:57.000Z","updated":"2020-02-11T03:53:23.834Z","comments":true,"path":"2020/02/11/ML-Week1/","link":"","permalink":"http://nekomoon404.github.io/2020/02/11/ML-Week1/","excerpt":"","text":"IntroductionWhat is Machine LearningTwo definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition. Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.” Example: playing checkers. E = the experience of playing many games of checkers T = the task of playing checkers. P = the probability that the program will win the next game. In general, any machine learning problem can be assigned to one of two broad classifications: Supervised learning and Unsupervised learning. Supervised LearningIn supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output. Supervised learning problems are categorized into “regression“ and “classification“ problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories. Example 1: Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem. We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories. Example 2: (a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture (b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign. Unsupervised LearningUnsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables. We can derive this structure by clustering the data based on relationships among the variables in the data. With unsupervised learning there is no feedback based on the prediction results. Example: Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on. Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party). Model and Cost FunctionModel RepresentationTo establish notation for future use, we’ll use $x^{(i)}$to denote the “input” variables (living area in this example), also called input features, and $y^{(i)}$ to denote the “output” or target variable that we are trying to predict (price). A pair $(x^{(i)} , y^{(i)} )$ is called a training example, and the dataset that we’ll be using to learn—a list of m training examples $(x^{(i)},y^{(i)});i=1,…, m$—is called a training set. Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ. To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a hypothesis. Seen pictorially, the process is therefore like this: When the target variable that we’re trying to predict is continuous, such as in our housing example, we call the learning problem a regression problem. When y can take on only a small number of discrete values (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a classification problem. Cost FunctionWe can measure the accuracy of our hypothesis function by using a cost function. This takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s. J(\\theta_0, \\theta_1) = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left ( \\hat{y}_{i}- y_{i} \\right)^2 = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left (h_\\theta (x_{i}) - y_{i} \\right)^2To break it apart, it is $\\frac{1}{2} \\bar{x}$， where\\bar{x}$$ is the mean of the squares of $h\\theta (x{i}) - y_{i}$, or the difference between the predicted value and the actual value. This function is otherwise called the “Squared error function”, or “Mean squared error”. The mean is halved $\\left(\\frac{1}{2}\\right) $as a convenience for the computation of the gradient descent, as the derivative term of the square function will cancel out the$ \\frac{1}{2}$ term. The following image summarizes what the cost function does: Intuition 1If we try to think of it in visual terms, our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by $h_\\theta(x)$) which passes through these scattered data points. Our objective is to get the best possible line. The best possible line will be such so that the average squared vertical distances of the scattered points from the line will be the least. Ideally, the line should pass through all the points of our training data set. In such a case, the value of $J(\\theta_0, \\theta_1)$will be 0. The following example shows the ideal situation where we have a cost function of 0. When $\\theta_1 = 1$, we get a slope of 1 which goes through every single data point in our model. Conversely, when $\\theta_1 = 0.5$, we see the vertical distance from our fit to the data points increase. This increases our cost function to 0.58. Plotting several other points yields to the following graph: Thus as a goal, we should try to minimize the cost function. In this case, $\\theta_1 = 1$=1 is our global minimum. Intuition 2A contour plot（等高线，轮廓线） is a graph that contains many contour lines. A contour line of a two variable function has a constant value at all points of the same line. An example of such a graph is the one to the right below. Taking any color and going along the ‘circle’, one would expect to get the same value of the cost function. For example, the three green points found on the green line above have the same value for $J(\\theta_0,\\theta_1)$ and as a result, they are found along the same line. The circled x displays the value of the cost function for the graph on the left when $\\theta_0$ = 800 and $\\theta_1$= -0.15. Taking another h(x) and plotting its contour plot, one gets the following graphs: When $\\theta_0$ = 360 and $\\theta_1$ = 0, the value of $J(\\theta_0,\\theta_1)$ in the contour plot gets closer to the center thus reducing the cost function error. Now giving our hypothesis function a slightly positive slope results in a better fit of the data. The graph above minimizes the cost function as much as possible and consequently, the result of $\\theta_1$ and $\\theta_0$ tend to be around 0.12 and 250 respectively. Plotting those values on our graph to the right seems to put our point in the center of the inner most ‘circle’. Parameter LearningGradient DescentSo we have our hypothesis function and we have a way of measuring how well it fits into the data. Now we need to estimate the parameters in the hypothesis function. That’s where gradient descent comes in. Imagine that we graph our hypothesis function based on its fields $\\theta_0$ and $\\theta_1$ (actually we are graphing the cost function as a function of the parameter estimates). We are not graphing x and y itself, but the parameter range of our hypothesis function and the cost resulting from selecting a particular set of parameters. We put $\\theta_0$ on the x axis and $\\theta_1$ on the y axis, with the cost function on the vertical z axis. The points on our graph will be the result of the cost function using our hypothesis with those specific theta parameters. The graph below depicts such a setup. We will know that we have succeeded when our cost function is at the very bottom of the pits in our graph, i.e. when its value is the minimum. The red arrows show the minimum points in the graph. The way we do this is by taking the derivative (the tangential line to a function) of our cost function. The slope of the tangent is the derivative at that point and it will give us a direction to move towards. We make steps down the cost function in the direction with the steepest descent. The size of each step is determined by the parameter α, which is called the learning rate. For example, the distance between each ‘star’ in the graph above represents a step determined by our parameter α. A smaller α would result in a smaller step and a larger α results in a larger step. The direction in which the step is taken is determined by the partial derivative of J(\\theta_0,\\theta_1)J(θ0,θ1). Depending on where one starts on the graph, one could end up at different points. The image above shows us two different starting points that end up in two different places. The gradient descent algorithm is: repeat until convergence: \\theta_j := \\theta_j - \\alpha \\frac{\\partial}{\\partial \\theta_j} J(\\theta_0, \\theta_1)where $j=0,1$ represents the feature index number. At each iteration j, one should simultaneously update the parameters $\\theta_1, \\theta_2,…,\\theta_n$. Updating a specific parameter prior to calculating another one on the $j^{(th)}$ iteration would yield to a wrong implementation. IntuitionIn this part we explored the scenario where we used one parameter $\\theta_1$ and plotted its cost function to implement a gradient descent. Our formula for a single parameter was : Repeat until convergence: \\theta_1 := \\theta_1 - \\alpha \\frac{\\partial}{\\partial \\theta_1} J(\\theta_1)Regardless of the slope’s sign for $\\frac{d}{d\\theta_1} J(\\theta_1)$, $\\theta_1$ eventually converges to its minimum value. The following graph shows that when the slope is negative, the value of $\\theta_1$ increases and when it is positive, the value of $\\theta_1$ decreases. On a side note, we should adjust our parameter $\\alpha$ to ensure that the gradient descent algorithm converges in a reasonable time. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong. How does gradient descent converge with a fixed step size $\\alpha$? The intuition behind the convergence is that $\\frac{d}{d\\theta_1} J(\\theta_1)$ approaches 0 as we approach the bottom of our convex function. At the minimum, the derivative will always be 0 and thus we get: \\theta_1 := \\theta_1 - \\alpha*0 Gradient Descent For Linear RegressionWhen specifically applied to the case of linear regression, a new form of the gradient descent equation can be derived. We can substitute our actual cost function and our actual hypothesis function and modify the equation to : Repeat until convergence: \\begin{align*} & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}\\left((h_\\theta(x_{i}) - y_{i}) x_{i}\\right) \\newline & \\end{align*}where m is the size of the training set, $\\theta_0$ a constant that will be changing simultaneously with $\\theta_1$ and $x_i$, $y_i$ are values of the given training set (data). The point of all this is that if we start with a guess for our hypothesis and then repeatedly apply these gradient descent equations, our hypothesis will become more and more accurate. So, this is simply gradient descent on the original cost function J. This method looks at every example in the entire training set on every step, and is called batch gradient descent. Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have posed here for linear regression has only one global, and no other local, optima; thus gradient descent always converges (assuming the learning rate α is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function. The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (48,30). The x’s in the figure (joined by straight lines) mark the successive values of θ that gradient descent went through as it converged to its minimum.","categories":[],"tags":[]},{"title":"数据结构与算法（3）有序向量","slug":"数据结构与算法（3）有序向量","date":"2020-02-10T02:58:38.000Z","updated":"2020-02-12T12:44:19.826Z","comments":true,"path":"2020/02/10/数据结构与算法（3）有序向量/","link":"","permalink":"http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/","excerpt":"","text":"唯一化有序向量是相对于无序向量而言，无序向量要求元素之间至少应该能比较是否相等，我们称作比对操作；而有序向量更为复杂，它需要能够判定任何一对元素孰大孰小，这叫作比较操作。元素之间可以相互比较只是有序向量的一个必要条件，如果要成为一个真正的有序向量，还必须要求其中的元素确实是按照顺序排列的，因此就存在一个如何甄别一个向量是否有序的问题。 有序性及其甄别 与起泡排序算法的理解相同： ​ 有序序列中，任意一对相邻元素顺序；无序序列中，总有一对相邻元素逆序。 因此，逆序相邻元素的数目，可用以度量向量的逆序程度。 无序向量经预处理转换为有序向量之后，相关算法多可优化。 1234567template &lt;typename T&gt; //返回逆序相邻元素对的总数int Vector&lt;T&gt;::disordered() const &#123; int n = 0; //计数器 for (int i = 1; i &lt; _sizei++) //逐一检查各对相邻元素 n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数 return n; //向量有序当且仅当 n = 0&#125; //若只需判断是否有序，则首次遇到逆序对之后，即可立即终止 根据上面的分析可以知道，一个向量是有序的，当且仅当经过disordered()判断以后返回的值是零。实际上只要向量中的元素本身是支持大小比较的，就有一定的办法将它转化为有序向量。其中的原因在于经过这样的一个转换以后虽然我们花费了一定的成本，但此后涉及到的很多操作也就是相关算法，大多都可以优化，相应地所得要远远比转换时所花费的成本大的多。 低效算法上一篇文章介绍了无序向量的去重操作，现在我们希望把这种去重操作推广到有序向量，即将一个有序向量中的重复元素（如果存在）全部剔除掉，同样地每一组重复元素只保留一个副本。有序向量其实相对于无序向量而言，具有更好的规范性。这种规范性是指在有序向量中，彼此重复的元素必然会依次相互紧邻地构成一个一个的区间，比如就下图中的例子而言，这些元素相互重复，它们彼此紧邻，会紧密地排列成一个区间，其它元素也有这种规律。所以既然我们需要从每一组元素中保留一个副本，等价于从其中找出一个代表并且保留下来。 具体到一个算法，可以大致用一个线性扫描过程来描述：每次都观察并比对一对相邻的元素，如果二者相等就将后者删除掉，并且继续比较，如果后者还相等就把它继续删除掉，直到遇到一个不相重复的元素，这个时候我们才把注意力后移，再去考虑下一对紧邻的元素，如果依然出现这种情况再删除，直到又转到下一对。这样确实可以顺利地把所有重复的元素都剔除掉，但是不倾向与使用，因为其效率低。 12345678template &lt;typename T&gt;int Vector&lt;T&gt;::uniquify() &#123; int oldSize = _size; int i = 0; //从首元素开始 while (i &lt; _size - 1) //从前向后，逐一比对各相邻元素 //若雷同，则删除后者；否则，转至后一个元素 (_elem[i] == _elem[i + 1]) ? remove(i + 1) : i++; return oldSize - _size; //返回向量规模变化量，即删除元素总数&#125; //注意：其中_size的减小，由remove()内隐式地完成 低效算法的复杂度 算法的运行时间主要取决去while循环，次数共计: _size - 1 = n -1 最坏情况下：每次都需调用remove()，耗时$O(n-1)\\sim O(1)$，累计$O(n^2)$ ​ 尽管省去fine()，总体竟与无序向量的deduplicate()相同。 高效算法需要首先对原有的算法进行反思，我们发现造成低效率的根源在于：其中的同一个元素有可能会作为被删除元素的后继，而多次地参与前移操作，对于这样的一个元素来说虽然它每次都是向前移动，但是很可惜它的每一次移动只会移动一个单元，而不是一次性地一步到达它最终的位置。 反过来这就启示我们，如果能够将每一个重复的区间作为一个整体来考虑，成批地删除雷同的元素而不是像刚才那样逐个地去删除，并且逐个地移动，就有可能实现这种一步到位式的移动，从而使得整体的性能大大地改进。 这个新算法的思路可以由上面的图来表示，在任何时刻我们关注的都是i和j两个元素，而且这里有一个不变性，也就是在i之后 j之前的所有这些元素都与i重复，这个算法一直扫描直到发现第一个与i不同的元素。如果它确实是不同的话我们就只需将j向前移到与i紧邻于右侧的这个位置，这是一个很高明的删除算法，因为在这样的一个过程中虽然没有显式地去做这些重复元素的删除，但是实际上已经无形中将它们忽略掉了，等效于做删除。 1234567891011template &lt;typename T&gt;int Vector&lt;T&gt;::uniquify() &#123; Rank i = 0, j = 0; //各对互异“相邻”元素的秩 while (++j &lt; _size) //逐一扫描，直至末元素 //跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧 if (_elem[i] != _elem[j]) _elem[++i] = _elem[j]; _size = ++i; shrink(); //直接截除尾部多余元素 return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率 高效算法的复杂度下面通过一个例子来分析新算法的复杂度： 共计n-1次迭代，每次常数时间，累计$O(n)$时间。 算法首先考虑的i和j元素，其实就是0和1号元素，对这个例子而言它们是彼此重复的元素，所以在那个循环中将会通过那个隐藏着看不见的else直接将它忽略掉，并且使得j进而转向下一个单元，以及在接下来的一个循环中再下一个单元，以及再下一个单元。执行到3和5出现了第一次的不同，按照刚才算法的逻辑会把i++到1号位置，然后把第j号元素取出来复制到对应的1号位置上，这就是为什么变成了3和5相邻。注意，在这个过程中我们并没有做显式的删除操作。 接下来的操作与之类似，直到j第一次越过右侧的边界的时候循环退出，算法也就终止。这个时候我们已经无形中将后边的这些元素统一地给删除掉了，这种删除非常的高明，因为我们没有做任何的一次显式的删除操作，而只是通过合理的计算得知了最终的向量规模之后，对_size这个量重新进行了一次设置。 通过这个例子可以得出，算法过程中只是经过了i+1次的迭代，每次移动j必然总是会往后移动一位。而且在每一次过程中，所做的操作无非就是一次比对，只有在比对不同的情况下才会做一次复制，即便是最坏的情况下既比对而且也复制的话，累计起来也不过是常数的时间。所以换而言之，整个这个新的算法只需要$O(n)$线性的时间。 二分查找（版本A）在上一篇文章中介绍了无序向量的查找算法，它的格式为Vector::find(e, lo, hi)，第一个参数指明查找的对象，第二和第三个参数lo和hi指示查找的区间范围。这种算法从思路上来说大体是从一端出发不断地逐个比对，直到发现某一个特定的元素就是e，或者一直到lo-1这个位置在左侧越界，即是查找失败。所以最好情况它只需$O(1)$的时间，但是从最坏的情况以及从一般e的概率分布的平均情况而言，都不得不需要线性的时间。 那么在进入有序向量之后，我们应该可以得到更快的一种解决方案，不妨重新起一个名字叫search()，以示与无序向量的那个find()的区别。当然从操作的参数以及接口的语义来说都是类似的，即我们同样要在lo到hi这样一个左闭右开的区间里找到一个特定的元素。 统一接口123456template &lt;typename T&gt; //查找算法统一接口，0 &lt;= lo &lt; hi &lt;= _sizeRank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const&#123; return(rand() % 2) ? //按各50%的概率随机选用 binSearch(_elem, e, lo, hi) //二分查找算法，或者 : fibSearch(_elem, e, lo, hi); //Fibonacci查找算法&#125; 这里所提供的search()接口从形式上看是统一的，即ADT。从内部讲，它的具体实现算法却不见得完全一样，后面的的各节将会分别介绍二分查找算法以及Fibonacci查找算法，而且对每一种算法都有不同的版本。 为了做测试这里采用了一个随机的方法，也就是在0和1之间随机地取一个数，从而随机地调用这两个算法。在实际应用中可以针对不同的情况在这几种算法中选择其一。 seach()的简要的操作语义就是在lo和hi所确定的这个区间找出目标元素e（如果它确实存在的话）。这里需要处理很多特殊的情况，比如，目标元素并不存在与规定的区间中，这就叫失败。在此前学习的无序向量的find的接口中我们只是简单地返回了一个标志-1，但严格地说这样做是不够的。反过来有可能目标元素存在多个，既然作为有序向量，一旦有多个e的话，那么它肯定会连续地分布构成一个区间。在这种情况下，到底是返回最前边的一个，最后的一个？还是中间的某一个？这些都是我们需要进一步地从语义上予以约定的。 语义约定在语义上的细致约定是非常有必要的，否则search()接口将只能作为一个孤立的功能，而不能有效地、便捷地为其它的算法，作为一个基本的部件而利用。search()接口至少应该使得有序向量自身的动态维护变得非常便利，比如在有序向量不断插入元素过程中，我们希望往往能够采用这样一种形式：当插入某一个元素时，首先要通过search()来确定一个适当的位置，例如查找返回的那个值再加1，然后再将e插入于这个秩所对应位置，并且同时使得这个有序向量继续是一个有序向量。 1V.insert(1 + V.search(e), e); 幸运的是前人已经帮我们设计出了这样的语义约定，比如下面就是其中的一种约定： 在有序向量区间V[lo, hi)中，确定不大于e的最后一个元素 -∞ &lt; e &lt; V[lo] 时，返回 lo-1 （左侧哨兵） V[hi-1] &lt; e &lt; +∞ 时，返回hi-1（右侧哨兵的前一个） 按照这个约定，对于要查找的元素有重复元素的情况，即有多个元素是与目标的元素是重复的，应该返回的所谓的不大于e的最后一个元素，也就是这个区段的右端点。如果我们要做一个插入，把新的元素插入这个位置同加1后的位置，即重复元素区间右端点的后面，正是再合适不过的。 这里的合适是指：第一，它继续保持了整体的有序性；第二，它以及与它雷同的那些元素会保持它们插入到这个向量中的先后的次序。所以这种语义约定是非常好的，它涵盖了我们几乎所有的情况包括特殊情况。所以接下来我们在实现这些具体的算法的时候，必须最终落实到能够符合这种语义的要求。 原理这个版本只是为了说明原理，从严格的意义上讲，它还不能完全地符合刚才的语义要求，在后面的小节就会对它进行改进。 减而治之：以任一元素x = S[mi] 为界，都可将待查找的区间分为三部分 S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi) // S[mi] 称作轴点 只需将目标元素e与x做比较，即可分三种情况进一步处理： e &lt; x：则e若存在，必属于左侧子区间S[lo, mi)，故可递归深入 x &gt; e：则e若存在，必属于右侧子区间S(mi, hi)，亦可递归深入 x = e：已在此处命中，可随即返回 //若有多个，返回哪个？后面会介绍 二分（折半）策略：轴点mi总是取作中点（至少能保证不是最坏情况） 于是每经过至多两次比较，或者能够命中，或者将问题规模减一半 实现12345678910template &lt;typename T&gt; //在有序向量区间[lo, hi)内查找元素estatic Rank binSearch(T* A, T const&amp; e, Rank lo, Rank hi) &#123; while (lo &lt; hi) &#123; Rank mi = (lo + hi) &gt;&gt; 1; //每步迭代可能要做两次比较判断，有三个分支 if (e &lt; A[mi]) hi = mi; //深入前半段[lo, hi)继续查找 else if (A[mi] &lt; e) lo = mi + 1; //深入后半段(mi, hi) else return mi; //在mi处命中 &#125; return -1; //查找失败&#125; Tips：这里有编写程序的一个小的习惯，可以帮助我们更好地思考问题并且写出算法，更重要的是可以让代码更加好理解，同时也减少一些不必要的失误。我们这里统一地都用了小于号，因为小于号的左右的次序和我们通常所画的这样从小到大的次序是吻合的，所以这里e &lt; A[mi]的解读既可以认为是e小于mi，也可以认为是e存在于当前这个分界点mi的左侧。当这样顺着读下来时，当然我们就应该深入到前半段也就是左半段去，相应地呢，我们应该修改右侧的界桩hi = mi。同样接下来A[mi] &lt; e解读也是这样与其说是mi小于e，不如更直观地说是我们的目标e是处于mi这个分界点的右侧，所以我们应该深入到右半段也就是后半段去继续搜索，相应的操作也就是去修改左侧的界桩lo = mi +1。 实例与复杂度 S.search(8, 0, 7)：共经$2+1+2=5$次比较，在S[4]处命中 S.search(3, 0, 7)：共经$1+1+2=4$次比较，在S[1]处失败 线性递归：$T(n)=T(n/2)+O(1)=O(logn)$，大大优于顺序查找 递归跟踪：轴点总取重点，递归深度$O(logn)$；各递归实例均耗时$O(1)$。 查找长度有序向量的查找是一种非常基本的算法，而且它存在多个版本，因此除了上面利用渐近的复杂度能够从总体上把握它的大体性能以外，我们还需要对不同版本算法的性能做更加细微的评定。具体来说就是考察渐近复杂度$logn$前面的那个常系数，而具体地在统计和分析的时候，更多的是考量关键码的比较操作次数，也就是在其中所执行的if语句的次数，我们将此称作是不同的算法在不同的情况下所对应的查找长度。 如何更为精确地评估查找算法的性能？ 考查关键码的比价次数，即查找长度（search length） 通常，需分别针对成功与失败查找，从最好，最坏，平均等角度评估 例如，成功、失败时的平均查找长度均大致为$O(1.50\\cdot logn)$。 下面是一个一个具体的实例，这是一个由七个元素构成的有序向量，其实它的数值是具体是多少我们并不在意，只要它是非降排列的就可以。如果把算法改写成递归的形式，那么整个的不同情况的递归跟踪将构成下面的递归跟踪图，每条虚线旁边的数字代表由上一步执行到下一步所增加的比较操作的次数，具体位置的方框中的数字代表查找到它所需要总的比较操作次数，即查找长度。需要注意的是，每次递归到左子区间，比较操作次数增加1，而递归到右区间，比较操作次数增加2。 n = 7时，各元素对应的成功查找长度为${4,3,5,2,5,4,6}$ ​ 在等概率情况下，平均成功查找长度$=29/7=4.14$； 共有8中失败情况，查找长度分别为${3,4,4,5,4,5,5,6}$ 在等概率情况下，平均失败查找长度$=36/8=4.50$； 可见，成功和失败的平均查找长度大致是$1.50\\cdot log_28$ Fibonacci查找改进思路及原理在上一节引入了二分查找（Binary search）这样的一个概念，并且给出了一个基本的算法的版本，这个版本的复杂度从渐近意义而言应该是logn量级的，但如果进一步地细微地来考察前面的系数大致是1.5，我们也指出这个1.5是可以改进的。我们现在就来看看，如何通过一种新的算法：fibonacci查找（fibonaccian search）来对此进行改进。 上一节的末尾以一个长度为7的有序向量为例，具体地给出了在成功和失败情况下平均查找长度的估算的过程。实际上通过那个实例的推而广之，如果考虑更一般的情况，不难发现此前所介绍的版本A，确实还有很大地改进余地。这样一个判断是来自于这样一个观察事实，也就是说版本A这个算法实际上从用意上讲，它是试图通过使各种情况的搜索在迭代次数上的平衡来尽可能地回避掉最坏的情况。 具体讲比如所有的失败情况大部分都会失败在同样深度的，也就是最深的这个位置，所以它表面上看是平衡的，但这其中却蕴涵着很大的不平衡。因为在整个这个查找的过程中我们在任何一个位置上，如果要决定是向左或者是向右深入的话，所花费的成本，也就是比较的次数是不等的。准确地说按照版本A，向左侧只需要一次比较，而向右侧却需要两次比较，所以这样一个表面上看是非常公平的一个平衡，实际上在内部却蕴涵着极大的不平衡，所以我们确实有理由怀疑算法的效率是否已经达到最优。 反过来我们也可以得到改进的一个思路，具体讲就是既然我们已经看到目前的机制中，向左侧确实会成本更低，而向右侧更高。那么为什么不把这个搜索的各种情况画成类似下面的这样一个树状图，做成左侧是更深的，而右侧是相对更浅的。这样一个表面上看的不平衡，却因为它恰好和这种成本互相之间能做一个合适的补偿，反过来有可能从整体上会得到更优，也就是说使得整体的查找平均长度反而会缩短。 具体来讲，越是成本低的转向我们就越希望更多地做，越是成本更高的越是希望它能更少地来做，所以这样的话我们就得到了新的算法的改进的思路。那么具体这个思路怎么来兑现呢？非常有意思的是需要用到fibonacci数。不失一般性，假设有序向量的长度N，就是某个fibonacci数减1的形式。 如下图所示有序向量的长度n = fib(k) - 1，那我们就在其中选择这么样一个特定的切分点mi，mi = fib(k-1) - 1，如果以这个点为切分，那么左边子向量的长度就恰好是fib(k-1) - 1，而右边子向量的长度恰巧是fib(k-2) - 1。可见这样一种切分的好处就是，在任何时候只要按照这样来切分，无论是向左还是向右它都会从长度上保持某个fibonacci数再减1的形式，而这种形式实际上恰好是最优的。 实现首先定义一个Fib类，让其提供一些接口。 12345678910class Fib &#123; //Fibonacci数列类private: int f, g; //f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出public: Fib ( int n ) //初始化为不小于n的最小Fibonacci项 &#123; f = 1; g = 0; while ( g &lt; n ) next(); &#125; //fib(-1), fib(0)，O(log_phi(n))时间 int get() &#123; return g; &#125; //获取当前Fibonacci项，O(1)时间 int next() &#123; g += f; f = g - f; return g; &#125; //转至下一Fibonacci项，O(1)时间 int prev() &#123; f = g - f; g -= f; return g; &#125; //转至上一Fibonacci项，O(1)时间&#125;; Fibonacci查找可以实现为下面的一段代码，可以注意到它的接口还是完全一样的，而且在其中的这个循环，大致来说也是与版本A类似的，即每次都要来判断以保证当前的lo和hi构成一个合法的区间，如果这个区间能够收缩到非法(lo == hi)，那也就意味着查找是失败的，这跟此前的版本A是一样的。 123456789101112131415#include \"fibonacci/Fib.h\" //引入Fib数列类// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _sizetemplate &lt;typename T&gt; static Rank fibSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; Fib fib(hi - lo); //用O(log_phi(n = hi - lo)时间创建Fib数列 while(lo &lt; hi) &#123; while ( hi - lo &lt; fib.get() ) fib.prev(); //自后向前顺序查找（分摊O(1)） Rank mi = lo + fib.get() - 1; //确定形如Fib(k) - 1的轴点 if ( e &lt; S[mi] ) hi = mi; //深入前半段[lo, mi)继续查找 else if ( S[mi] &lt; e ) lo = mi + 1; //深入后半段(mi, hi)继续查找 else return mi; //在mi处命中 &#125; //成功查找可以提前终止 return -1; //查找失败&#125; //有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置 查找长度 fibonacci查找算法的平均查找长度为$O(1.44 \\cdot logn)$，略优于二分查找 仍以n = fib(6) -1 = 7 为例，在等概率情况下： 平均成功查找长度$=(2+3+4+4+5+5+5)/7=28/7=4.00&lt;4.14$ 平均失败查找长度$=(4+5+4+4+5+4+5+4)/7=35/7=4.38&lt;4.50$ 最优性 通用策略：对于任何的A[0, n)，总是选取A[λn]作为轴点，$0\\le \\lambda &lt;1$: 比如二分查找对应于$\\lambda=0.5$，Fibonacci查找对应于$\\lambda=\\phi=(\\sqrt{5}-1)/2=0.6180339\\dots$（黄金分割比） 在[0, 1)内，$\\lambda$如何取值才能达到最优？设平均查找长度为$\\alpha(\\lambda)\\cdot log_2n$，何时$\\alpha(\\lambda)$最小？ 递推式：$\\alpha(\\lambda)\\cdot log_2 n=\\lambda\\cdot [1+\\alpha(\\lambda)\\cdot log_2 (\\lambda n)]+(1-\\lambda)\\cdot [2+\\alpha(\\lambda)\\cdot log_2 \\left((1-\\lambda) n \\right)]$ 整理后：$\\frac{-ln2}{\\alpha(\\lambda)}=\\frac{\\lambda\\cdot ln\\lambda+(1-\\lambda)\\cdot ln(1-\\lambda)}{2-\\lambda}$，当$\\lambda=\\phi$时，$\\alpha(\\lambda)=1.440420\\dots$达到最小。 相对于我们上一节的二分查找$\\alpha(\\lambda)=1.50$，Fabonacci查找又有了一定的改进，而且从本节的分析可以看出这种改进已经达到了极限，如果我们不再改变这个算法的总体模式和框架的话。 二分查找（改进）这一节将介绍另一种思路的改进，这是一种直截了当的改进思路，既然我们已经注意到了此前的版本A中造成效率略低的原因是因为左右分支的转向代价不平衡，那么可以考虑是否能将二者做成是平衡的。 改进思路 二分查找中左、右分支转向代价不平衡的问题，也可直接解决 比如，每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个 同样地，轴点mi取作中点，则查找每深入一层，问题规模也缩减一半 1）e &lt; x： 则e若存在，必属于左侧子空间S[lo, mi)，故可递归深入 2）x &lt;= e：则e若存在，必属于右侧子空间S[mi, hi)，亦可递归深入 只有当元素数目hi - lo = 1时，才判断该元素是否命中，这是该算法做出的牺牲 版本B：实现主要注意代码中与版本A不同的地方。 123456789// 二分查找算法（改进）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _sizetemplate &lt;typename T&gt; static Rank binSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; while ( 1 &lt; hi - lo ) &#123; //每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止 Rank mi = ( lo + hi ) &gt;&gt; 1; //以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移） ( e &lt; S[mi] ) ? hi = mi : lo = mi; //经比较后确定深入[lo, mi)或[mi, hi) &#125; //出口时hi = lo + 1，查找区间仅含一个元素A[lo] return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; 这个算法是封闭的，可以运转，而且可以完全实现此前一样的功能。与此前的版本A对比，它在最好情况下反而有所倒退，原因是在与即使是成功的情况它也一直要推迟到最终，只有在经过最终的这次比对之后才会确定是否成功。此前的版本A它的最好情况是非常好的，最最好的情况莫过于在第一次试图做减而治之的时候，所采用的那个切分点就成功命中，只需要$O(1)$的时间。 本节改进的二分查找无论如何都一直要切分到最后，所以最好的情况的时间复杂度是$O(logn)$。但是反过来最坏的情况又会更好，因为我们这里最坏的情况不会出现每一次都是向右，即每次都要花费两次比较的情况，所以最坏的情况会得到抑制。所以从总体而言此前的那个版本A如果说它在性能上好坏情况相差非常大的话，那么本节中改进的版本在整体性能上，它就会趋于更加的稳定，即差异化不是那么大，当然这还不是它的最大的优势所在。 语义约定 以上的二分查找及Fibonacci查找算法，均未严格地兑现search()接口的语义约定： 返回不大于e的最后一个元素 只有兑现这一约定，才可以有效支持相关算法，比如：V.insert(1 + V.search(e), e) 1）当有多个命中元素时，必须返回最靠右（秩最大）者 2）失败时，应返回小于e的最大者（含哨兵lo-1） 版本C：实现在刚才代码的基础上，我们做进一步的调整，得到一个最终的版本，它可以严格地实现上面定义的语义。 12345678template &lt;typename T&gt; static Rank binSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; while ( lo &lt; hi ) &#123; //不变性：A[0,lo) &lt;= e &lt; A[hi,n) Rank mi = ( lo + hi ) &gt;&gt; 1; //以中点为轴点 ( e &lt; S[mi] ) ? hi = mi : lo = mi + 1; //经比较后确定深入[lo, mi)或(mi, hi) &#125; //出口时，A[lo = hi]为大于e的最小元素 return --lo; //故循环结束时lo - 1即不大于e的元素的最大秩&#125; //有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置 就算法的结构而言，这个新的算法版本C和此前的版本A，尤其是版本B，似乎没有什么太大的区别。解读一下：当这个区间还是合法之前我们就不断地迭代，每一次也照样是取出它的中点作为轴点，并且经过一次比较从而决定到底是向左侧还是向右侧深入，那么直到区间宽度缩小到足够小的时候，才返回最终的值。 需要注意的是版本C和版本B，虽然在功能上是等效的，但是在很多细节上却有着本质的区别： 待查找区间宽度缩短至0而非1时，算法才结束 转入右侧子向量时，左边界取作mi+1，而非mi //A[mi]会被遗漏？下一小节证明 无论成功与否，返回的秩严格符合接口的语义约定 正确性首先通过下面的图例来具体地了解一下版本C的工作过程，其实最主要的是它的每次迭代的过程都是类似的。如图(a)，在整个向量的区间内，我们关注的是某一个特定的从lo到hi的一个查找区间，每次在这个区间里都要考虑middle point，即图中的x。 我们以它为界，经过一次比较以后有可能会发现目标元素更小所以就深入到如图b所示的左侧的这个子区间；或者对称地，因为目标元素更大而深入到右侧的这个区间，如图(c)。版本C的算法中左侧子区间和右侧的子区间都没有覆盖这个middle point，而且对middle point也没有做显式地判断，所以这也是为什么有理由怀疑它有可能是这个算法的一个疏忽。 接下来我们来证明这样一个模式实际上是安全的，为此同样用我们的两种技巧：第一就是给出这个算法的不变性其次要给出它的一个单调性，而单调性是一目了然，就不再说明了，主要是证明它的不变性： 不变性：A[0, lo) &lt;= e &lt; A[hi, n) //A[hi] 总是大于e的最小者 初始时，lo = 0且 hi = n，A[0, lo) = A[hi, n) = $\\varnothing$，自然成立 数学归纳法：假设不变性一直保持至图(a)的状态，下一步无非两种情况： 第一种情况，也就是深入左侧这个分支的情况，即图(b)。那么此前的判断e &lt; A[mi]返回的是True，之后执行 hi = mi，从而使得右侧的这段区间向左拓展是安全的，因为确实可以断定这个整个区间内的这些元素都是严格地大于e的，因为它们其中最小的那个元素也就是A[mi]都大于e。而A[0, lo)保持不变,所以这种情况是没有问题的。 第二种情况，也就是深入右侧这个分支的情况，即图(c)。那么此前的判断e &lt; A[mi]返回的是False，之后执行 lo = mi，此时e是不小于A[mi]的，而A[mi]元素是左段区间中最大的，所以左段区间都是都是不大于e的。这样一个左侧区间向右拓展的动作在刚才不变性的意义上讲，依然是安全的，它使得不变性得到了延续。所以经过一次迭代以后无论是向左还是向右的深入，不变性都是成立的。 单调性：显而易见，直到最后会出现一个情况，就是整个区间的宽度变成零，可以表示为下图。 从整个的原始的搜索空间开始，经过不断地压缩、压缩、压缩之后，将搜索的范围缩小到一个宽度为零的一个区间，其实它就只是一个分界。它严格地将整个区间分为了左右两部分，由不变性左侧这部分依然是不大于e，而右侧这部分是严格地&gt;e。如果查找的结果是命中的，我们只需要返回左侧这个区间的最右端的那个元素就可以了，而这个元素正是A[lo-1]。这也就是为什么我们在算法的最终返回之前要做一次--lo的操作。 这样的话我们就得到了一个从功能上、从语义上、从性能上都近乎完美的算法！ 插值插值插值查找（Interpolation Search）有序向量查找算法的一个另类的变种，此前所介绍的Fibonacci search或binary search包括它们的各种版本对向量只做了一个假定，即其中的元素是单调有序的，对于其中元素的分布情况并没有做任何的假设，也就是可以是完全理想任意随机的。但是在某些情况下也许不是这样，比如我们可能不仅知道向量是有序的，而且其中的元素是按照某种先验规律随机分布的。 在这里我们考虑一种最常见的随机分布：均匀独立的随机分布，比如在从lo一直到hi的秩的范围之内，所有的元素都是互相不影响，各自独立的，然后从取值来看是均匀的取自于某一个区间范围。如果我们确实知道诸如此类的规律的话，就有可能实现优于此前那些算法$O(logn)$的更高的查找效率，以$o(logn)$的效率来完成一次查找。 原理与算法在均匀且独立的随机分布下，所有的元素在排序之后，即组织成一个有序向量之后，必然大体上是按线性增长的趋势分布的，从最小值lo开始大致是线性增长到最高值hi。这就意味着对于其中的任何一个潜在元素mi，都可以写出这样一个近似的线性等式，它们的秩的比与它们的数值比，二者是近似接近的。 \\frac{mi-lo}{hi-lo}\\approx \\frac{e-A[lo]}{A[hi]-A[lo]}实际上这给了我们一个启示，即在每次确定mi的时候，既不需要固定的用1/2，也不需要固定的用小写的φ（黄金分割比），甚至不需要用某一个一般的λ，而是可以动态的来猜测这样一个轴点，就是根据上面的等式。将这个等式稍微整理一下把mi提到左侧，我们就可以知道根据lo、hi以及它们对应的这两个元素的数值，以及每次动态要查找的那个元素的数值e，就可以大致的估算出mi，这样的话如果整个的减而治之的搜索过程可以认为是一个不断收缩包围圈逐步收敛的一个过程，那么它将会使得收敛的速度极大的加快，从而更快速的完成我们整个的查找。 mi\\approx lo+(hi-lo)\\cdot \\frac{e-A[lo]}{A[hi]-A[lo]} 正如这个图所画的是一本英文词典中abcd一直到z开头的单词各自起始的页码,它大致是1300多页，换而言之如果它确实是一个大致平均分布的话，每一个字母大概占50页，所以我们可以大致估算出来从1到50页大概是a，50页到100页大概是b，100页到150页大概是c，诸如此类。比如说去查binary (b)，那么因为它是第二个字母所以它大概会在整书从2/26这个位置开始，而search,s是第19个元素 所以大概它会位于19/26的位置。正因为这种算法在确定切分点也就是轴点的时候，采用的是近似的插值估算的方法，所以我们也称之为Interpolation Search插值查找，下面是一个实例。 性能从刚才的例子我们可以看出，对于这样一个长度为19的有序向量，只用了3次比较就给出了答案，而在通常的二分查找中这是做不到的，所以我们已经看到它在某些情况下确实很快，但是它总是能很快吗？包括这种很快到底定性是多大呢？ 我们需要做一个严格的界定，首先一个不好的消息是插值查找在某些情况下效率会很低，比如说 可能退化为与平凡的顺序查找没有什么区别，我们此前所做的那种假设也就是均匀独立的分布不满足，或者至少在某些部分不满足以致在全局或某些局部出现一些所谓的病态分布。 最坏情况：$O(hi- lo)=O(n)$ 当然 插值查找的最好情况也是不言而喻的，和其他的查找差不多，也就是说有可能我们在某次，甚至在第一次猜测的时候就直接命中，那么这种我们也不再考虑。我们转而再考虑一般的情况，也就是平均而言会怎么样。 这里我们需要用到一个非常基础类似引理的结论这个结论：在插值查找算法中每经过一次迭代，或者说每经过一次比较，都可以将查找的范围也就是减而治之之后剩余的部分由原先的规模n缩减为$\\sqrt{n}$。 平均情况：每经过一次比较，$n$缩减至$\\sqrt{n}$。 于是，待查找区间宽度将按一下趋势缩减： ​ $n,\\quad\\sqrt{n},\\quad \\sqrt{\\sqrt{n}},\\quad \\sqrt{\\sqrt{\\sqrt{n}}},\\dots,\\quad2$ ​ $n,\\quad n^{(1/2)},\\quad n^{(1/2)^2},\\dots,\\quad n^{(1/2)^k},\\dots,\\quad2$ 经多少次比较之后，有$n^{(1/2)^k}&lt;2$？ $k&gt;loglogn$ 插值查找的时间复杂度为：$O(loglogn)$ 我们同样可以来估算：如果向量的长度或者这个区间的宽度是n的话，考虑这个n按照二进制打印出来以后的位宽就是以的2为底 logn，那么每一次将它变为根号n从二进制的打印宽度来看其实就是变成了1/2的原来那么多宽度，换而言之每一次开方其实同步的是使宽度变成了原来的1/2，这样的过程 从n的数位宽度来说是一个不断折半的过程。 回顾此前的二分查找，如果是对的n的数值每次折半的话，那么这里的插值查找实际上就是对n的二进制位宽度来做二分查找。二分查找所需要的迭代次数是与它的初始值呈一个对数关系的，即$O(logn)$，而插值查找的位宽的初值相当于是logn，所以其需要的迭代次数就是$O(loglogn)$。 从今以后也许我们应该学会忘掉这些复杂的，虽然是精确的数学，而改用这种宏观的大趋势的把握本质的习惯。 综合对比现在将插值查找和其他的算法综合起来进行比对和考量，刚才插值查找所实现的这种改进也就是从logn到loglogn虽然从数学上是一个比较大的改进，但从实际效率来看却值得商榷。 从$O(logn)$到$O(loglogn)$，是否值得？ 通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高。 比如，n = 2^(2 ^ 5) = 2 ^ 32 = 4G时，$log_2(n)=32,\\quad log_2(log_2(n))=5$ 易受小扰动的干扰和“蒙骗”，可能在局部花费非常多的时间 须引入乘法、除法运算，相对而言成本更高（二分查找只需加法，Fibonacci查找只需加法和减法） 所以可行的查找算法也许应该将插值查找以及此前的那些查找算法各自的优势综合结合起来，比如说插值查找更善于在比较大的一个宏观的范围内，将问题的关注点尽可能快的缩小到一定的范围，即它比较擅长于处理那种极大的情况，然后一旦到了比较小的情况，这种容易受到干扰包括蒙骗尤其是乘法除法这样的一些overhead额外计算占得比重就会更大成为不可忽略的因素，而在这个时候二分查找的优势就体现出来了。 实际可行的方法： 首先通过插值查找，将插值范围缩小到一定的范围，然后再进行二分查找，或者顺序查找，即： 大规模：插值查找 中规模：折半查找 小规模：顺序查找","categories":[],"tags":[]},{"title":"数据结构与算法（2）向量","slug":"数据结构与算法（2）向量","date":"2020-02-08T02:04:27.000Z","updated":"2020-02-08T17:07:27.524Z","comments":true,"path":"2020/02/08/数据结构与算法（2）向量/","link":"","permalink":"http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/","excerpt":"","text":"接口与实现我们首先需要辨析一组非常相关但是又非常容易弄混的概念，也就是抽象数据类型以及数据结构。那么什么是Abstract Data Type呢？以及什么是Data Structure呢？可以从字面上给出定义，所谓的抽象数据类型，其实就是在一组数据的模型上定义的一组操作。那么什么叫作数据结构呢？是基于某种特定的语言真正实现的一套完整的算法。 我们此前比较熟悉的程序语言，先不要考虑什么抽象数据类型，先来看看什么叫作Data Type数据类型。比如在高级程序设计语言中int也就是整型，这就是一个数据类型，而float也是，还有char，诸如此类地。这种数据类型能够让我们能定义其中的一个成员，比如n是一个整数，从此以后我们就可以使用它了，我们也可以定义x是一个浮点数，c是一个字符。 123int n;float x;char c; 凡是这样指定了某一个元素是来自于某一个数据类型，或者说属于某一个数据类型，那么它就自然地具有了这种数据类型的特点，包括支持相应地处理方法，比如说运算。那么这里那些操作的运算具体是如何实现的，我们并不知道，我们也并不需要知道，这是最重要的。 把这样的一个概念抽象出来施加到我们所将要实现的数据结构上，比如这一章要介绍的vector。我们希望在使用的时候能够参照数据类型的这种形式，把它等同地当作是一个数据类型，比如可以用类似的方法来定义一个vector结构，包括下一章将要介绍的List。 这种使用方法使得我们可以将数据结构与数据类型等同起来，我们只需要知道它所提供的那些操作，比如说向量的查找、排序，而不需要去关心它其中的细节，比如说这些操作是如何实现的。那么从这个意义上讲，它就是一个经过了抽象以后的数据类型，所以称之为Abstract Data Type。 举个例子：我们可以将数据结构比喻成某种产品，比如说汽车，相关的有两类人，首先是用户，我们笼统地称之为应用Application，另一类人是汽车这种产品的设计和制造者，称之为实现Implementation。这两类人所关心的以及他们的职责是不同的，作为用户而言，他只关心这种产品的外在特性，能够提供的功能；而实现者则需要对这些功能以及特性具体如何落实负责。在这二者之间实际上是有某种形式的一个协议，也就是使用说明书，产品手册。而这种手册或者说明在数据结构的使用者与数据结构内部算法的设计者之间，达成了这么样一个协议，两类人可能互不见面，互不相识，但是他们通过这样一个规范，可以很好地彼此沟通，并且有效地合作。 向量ADT从数组到向量向量实际上是C++等高级编程语言中数组这种数据组织形式的一个推广和泛化。实际上在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都与0到n之间的某一个整数编号相互彼此对应，我们称之为第0号单元或者元素，或者第1号元素、第2号元素以及到最后的实质第n-1个元素。这里我们也同样延用此前已经约定的习惯，虽然最后这个第n个元素，实际上未必存在，我们还是把它虚拟地放在这儿作为哨兵，以帮助我们对很多问题的思考，并且使得我们很多算法的实现能够得以简化。 C/C++语言中，数组A[ ]中的元素与[0,n)内的编号一一对应。 既然每一个这样的元素都与这些编号是一一对应的，所以反过来我们通过合法区间内的编号都可以唯一地来指代并且访问对应的那个元素。一旦知道这个元素的下标i，就可以从A也就是这段存储区域的首地址出发，再向后以s作为间隔去数出i步，就可以得到某一个特定的单元。正因为所有这些元素的物理地址可以按照这样一个线性的方程来确定。所以我们也称之为线性数组（linear array）。 反之每个元素均由（非负）编号唯一指代，并可直接访问。A[i]的物理地址 = A + i×s，s为单个元素占用的空间量。 向量是数组的抽象与泛化，由一组元素按线性次序封装而成： 各元素与[0, n)内的秩（rank）一一对应 元素的类型不限于基本类型 操作、管理维护更加简化、统一于安全 可更为便捷地参与复杂数据结构的定制与实现 向量ADT接口按照抽象数据类型的规范，向量结构必须提供一系列的操作接口，可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作，这里的接口功能非常的丰富。 比如说 与其它的数据结构一样向量也可以看作是一组元素的集合，所以size( )实际上返回的是其中元素的总数，称之为这个数据结构的规模。也可以从中取特定的元素get(r)，也可以修改其中特定的元素put(r, e)，甚至插入insert(r, e)或者是删除某个元素remove(r)。我们也可以判定一下其中的元素是否已经有序排列disordered( )，如果没有有序排列，可以调用相应的接口使之有序排列sort( )。 我们也可以在它尚未有序排列的时候，按某种算法找到其中特定的元素find(e)，也可以在已经有序的前提下按照某种方式，来找到其中的元素search(e)。当然为了展示一些算法的实现我们也附加了一些其它的功能，比如说能够在无序和有序的情况下分别剔除这个数据集中的重复元素：deduplicate( )和uniquify( ) 。最后也是非常重要的一个接口就是如何对这个数据集中的元素逐一地进行枚举，并且访问一遍traverse( )，称之为遍历。 ADT接口操作实例下面举例说明ADT接口的实现。 最开始向量与任何一个数据结构一样，初始化的时候都是不包含任何实质的内容的，我们称它是一个空的向量。接下来调用插入操作insert，它在rank为0的这个位置上插入一个元素9，所以向量的组成将由空变成包含一个元素9。接下来继续调用insert接口，在0号这个位置上rank为0的这个位置上插入一个元素4，原来的元素9将会后移一位。同样地，我们也可以调用插入接口在rank为1的位置上插入5，在这个位置上出现了5，而它的后继统一地向后后移了一位。我们也可以调用put接口，这个接口的意思是修改，它会把当前rank为1的那个位置上的元素数值，由原来的5修改为2。我们也可以通过get这个接口获取秩为某一特定值的元素，比如说秩为2的那个元素，实际上就是2这个位置上的9，因此会返回9。 remove接口的参数是2，这说明它希望在原来这个向量中将rank为2的这个元素，把它剔除掉，剔除之后，会把这个被剔除的元素的值作为输出返回，即返回2，同时它的所有的后继与插入时候的操作的现象相反，会向前平移一个单元。当这个时候我们调用size的时候，因为这里所包含的元素总共是6个，所以它会返回6。 我们可以看到在整个这个操作的过程中向量都确实具有这么样一个特点，就是它在逻辑上，甚至在物理上必然是彼此紧邻的排列的，所有的元素之间没有任何的缝隙。需要注意的是无论是此前所介绍的这些接口，还是后面所要介绍的接口，就目前而言，我们并不关心它的具体实现方法，我们关心的只是它的操作语义。 接下来我们可以通过disordered()这个接口来检测向量的有序性，或者更准确地讲它的无序性。在此前介绍bubble sort算法的原理的时候，曾经指出包括向量在内的序列是否有序，当且仅当其中是否存在紧邻的逆序对。那么这里总共有6个元素，共定义了5组紧邻对，其中有3组，也就是4和3、7和4、和9和6是逆序的，disordered会返回逆序对的个数，即是3，只要这个数值不是0，就说明它尚未构成有序的序列。 对于这样的一个无序向量我们已经可以通过find接口，来查找其中特定的某个元素，比如说9。可以看到9号元素是位于rank为4的位置，因此find会返回4。同样地，也可以查找比如说5，我们发现5并不存在，这个时候我们统一地约定返回一个数值是-1，这个-1肯定不是一个合法的rank，表示查找失败。接着我们可以通过sort这个接口对整个向量排序，接下来再调用disordered()这个接口，它已经没有任何逆序的紧邻对了，所以返回0。 对于有序向量，我们可以通过另一套接口，也就是search来进行查找。比如说可以首先通过search，然后引用9来查找数值为9的元素，这个元素的rank为5，因此返回的是5。那么如果查找8会怎么样呢？向量中并没有8，这里我们采用了另一种约定：如果没有找到这个元素，我们要找的是不超过这个元素的最大的那个元素的值。对这个例子而言不超过8的最大的元素实际上就是7，而7的秩是4，所以search(8)会返回4。同样 我们如果要去查找10的话会返回不超过10的最大的那个元素也就是9的秩5，因此search(10)会返回5。 另一种特殊情况：查找一个全局都没有而且小于全局的最小的那个元素的数比如说1，我们会假设在-1的rank这个位置上有一个假想的哨兵，它的数值是负无穷，所以search(1)返回的是-1。这样一套约定可以使得我们在语义上更加的明确，使得我们在后续的操作过程中可以便利地来搭建不同的算法。还有一点要注意的是：在有些时候，我们要查找的元素尽管有，但是它却有多次出现，比如说这个4 出现了两次，那这个时候会返回什么呢？同样跟这里的语义所定义吻合的是，我们要返回其中不超过4这个目标元素的最后边那个元素，所以如果有两个甚至多个4的话，我们会取其中rank最大的那个元素把它的rank返回，对这个例子而言也就是2号元素，因此search(4)会返回2。 最后，uniquify()对于一个有序的向量把所有的重复的元素，比如说4都剔出掉，只保留一个拷贝。 vector模板类有上述接口规范之后，我们就可以遵照这种规范来学习如任何具体地在C++语言平台上实现这样一种向量模板类vector结构。首先约定用int来定义这里所说的秩这种概念，接下来会首先采用一种基本的扩容方式，它的初始容量需要设定，这里不妨取它的DEFAULT_CAPACITY取作3，在实际应用中完全可以取更大的一个数。 下面通过template这种方式给一个模板参数T，它的意思可以认为是定义了一个vector这样的模板类。其中的元素类型是什么可以是将来指定的任何名字现在叫作T的类型。所以与其说它写的是一个类，不如说这个模板类给的是一系列的类，我们可以根据实际需要直接地生成相应的vector类。在模板类里面有一些私有的，也就是封装和隐藏起来的变量，比如说其内部会记忆它到底有多少个元素有一个_size ，以及它目前的容量_capacity，还有包括真正存放元素的一个空间_elem。其它的内部函数以及公开的接口函数会在后边陆续学到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef int Rank; //秩#define DEFAULT_CAPACITY 3 //默认的初始容量（实际应用中可设置为更大） template &lt;typename T&gt; class Vector &#123; //向量模板类protected: Rank _size; int _capacity; T* _elem; //规模、容量、数据区 void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi) void expand(); //空间不足时扩容 void shrink(); //装填因子过小时压缩 bool bubble ( Rank lo, Rank hi ); //扫描交换 void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法 Rank max ( Rank lo, Rank hi ); //选取最大元素 void selectionSort ( Rank lo, Rank hi ); //选择排序算法 void merge ( Rank lo, Rank mi, Rank hi ); //归并算法 void mergeSort ( Rank lo, Rank hi ); //归并排序算法 void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解） Rank partition ( Rank lo, Rank hi ); //轴点构造算法 void quickSort ( Rank lo, Rank hi ); //快速排序算法 void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数 Vector ( int c = DEFAULT_CAPACITY, int s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v &#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=c Vector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制 Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间 Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制 Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间 // 析构函数 ~Vector() &#123; delete [] _elem; &#125; //释放内部空间 // 只读访问接口 Rank size() const &#123; return _size; &#125; //规模 bool empty() const &#123; return !_size; &#125; //判空 Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找 Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找 Rank search ( T const&amp; e ) const //有序向量整体查找 &#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125; Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口 T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素 const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本 Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量 T remove ( Rank r ); //删除秩为r的元素 int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素 Rank insert ( Rank r, T const&amp; e ); //插入元素 Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入 void sort ( Rank lo, Rank hi ); //对[lo, hi)排序 void sort() &#123; sort ( 0, _size ); &#125; //整体排序 void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱 void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱 int deduplicate(); //无序去重 int uniquify(); //有序去重// 遍历 void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改） template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector vector模板类的原理：整个vector结构是被封装起来，能供来自各种应用的用户使用的操作接口就是interface框中vector，~vector，insert，remove等等，它们就相当于vector结构的使用说明书，它告诉我们这里提供了哪些操作渠道、途径，通过这种接口规范直接使用。经过了这样地一个剥离之后，使得我们的应用和实现相互之间可以很好的分工，又同时很好的协作。那么具体内部怎么实现的呢？可以看出其实是开辟了一个名字叫作_elem的数据区，它的容量至少要足以容纳所存放的有效数据，对外而言的每一个元素都通过某种形式转译为内部这段数据区中的，实际上是这个有效的数据区（_size）中的某一个元素，由此实现了对内部数据项的封装。 构造与析构作为一种数据结构与所有的类一样，vector也首先需要解决构造和析构的问题。向量的默认的构造实际上只需指始初始的容量就可以了，如果没有指定会按照默认的容量，指定一个数值。在内部的操作其实就是通过new申请一个长度为c，基本类型就是模板参数T的一段连续的数据空间。在创建了这样一个空间之后，我们把这个空间的首地址交给内部的_elem记下来。这个时候虽然它有一定的空间，但是其中有效的数据是没有的，所以这就是为什么_size初始化是0。 12345Vector(int c = DEFAULT_CAPACITY)&#123; _elem = new T[_capacity = c]; _size = 0;&#125; //默认 当然还有其它的一些构造的方法，比如如果已经有一组以数组的形式存放的数据，我们也可以将其中从lo到hi的这段区间中的元素取出来作为初始向量，可以看到它是通过调用一个叫作copyFrom()的内部接口实现的。同样地 它还重载了其它的一些形式，比如被复制的元素可能是来自于一个数组，而是来自于一个本身已经被封装了的向量，我们可以从这个向量的_elem区域中去读取出来，并且同样调用copyFrom()来做这件事。所以这里有区间的复制，也可以有对整个向量的一个克隆。 123456Vector(T const *A, Rank lo, Rank hi) &#123; copyForm(A, lo, hi);&#125; //数组区间复制Vector(Vector&lt;T&gt; const &amp;V, Rank lo, Rank hi) &#123; copyForm(V._elem, lo, hi);&#125; //向量区间复制Vector(Vector&lt;T&gt; const &amp;V) &#123; copyForm(V._elem, 0, V._size);&#125; //向量整体复制 内部操作接口copyForm( )的工作原理以及过程可以通过下图示意，工作原理以及过程，可以通过这个图来示意。一般地我们需要从一个数组A中将介于lo到hi之间的元素整体复制到当前仍然为空的一个向量中，具体的操作大概分为两步，首先在向量内部开辟出足够的空间，接下来再将区间内的元素逐一地复制过来。 这个过程可以描述并且实现为下面的C++代码：首先申请足够多的空间，这里需要再强调一下这个区间的宽度可以直接通过lo和hi之间的一个减法得到，这是因为当我们在描述一个区间的时候往往是用左闭右开的形式，所以换而言之这个lo是在这个区间中最靠左的那个元素，而hi是在右侧第一个不属于这个区间的那个元素，尽管hi这个元素有可能压根就不存在。但是我们不妨把它统一地理解成是一个哨兵，这样的话我们就可以通过，hi减lo直接得到区间的宽度。 这里给计算出的宽度再乘个2，也就是说我们实际开辟的空间是我们需要复制的空间的两倍，而不是恰好那么多。这样做的主要的目的在于预留了一些空间之后，就可以使得我们在接下来足够长的时间之内，不会因为有必要扩容而打断我们的计算过程。 1234567template &lt;typename T&gt; //元素类型void Vector&lt;T&gt;::copyFrom (T const* A, Rank lo, Rank hi)//以数组区间A[lo, hi)为蓝本复制向量&#123; _elem = new T[_capacity = 2 * ( hi - lo ) ]; _size = 0; //分配空间，规模清零 while ( lo &lt; hi ) //A[lo, hi)内的元素逐一 _elem[_size++] = A[lo++]; //复制至_elem[0, hi - lo)&#125; 接下来还需要对这个向量的有效规模进行初始化 把它清为0。 再接下来 就是复制过程也就是说我们对于lo和hi中间的每一个Rank，都要从A这个数组中取出对应的元素，并将它们顺次的存入到_elem，对应的区间里面去。整体循环构成了这个操作的最重要的部分，所以我们也可以看出算法的复杂度主要是来自于这样一个循环。这样一个主体的复杂度是取决于被复制元素的个数，或者说这个复制区间的宽度，也可以认为是这个向量通过复制被创建之后的初始规模。 析构函数只需要把这个曾经动态分配获得的数据区域释放掉，归还给操作系统。 1~Vector() &#123; delete [] _elem; &#125; //释放内部空间 这样的话我们就完成了向量这种最基本的结构作为一种模板类它的最基本的一些接口，接下来会学习功能更为复杂的其它的接口。 可扩充向量与所有的数据结构一样，向量也可以认为是一组数据项的集合，换而言之，它首先必须能够自适应地在规模上适应其中所包含的元素个数的变化，这一节集中讨论它的可扩充性能。向量本身并不具有这种性能，我们需要采取一些策略。就目前的设计方案而言，我们的向量并不具备可扩充的性能，究其原因在于它采用的 实际上是所谓的静态空间管理的策略。 静态空间管理具体来说，它实际上在内部只不过是设置了一个私有的数组，这个数组所占有的那段连续的地址空间会被用来存放若干个对外界而言可见的，或者是有效的元素。这些元素的总数，或者说它们所占用的逻辑空间的数，用_size来表示，而整个物理空间的大小是由_capacity来确定的。 这里的问题是_capacity一旦确定,按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：第一 是有可能会出现所谓的上溢overflow，也就是说随着有效元素（个数）的增加，总会出现这样的可能，使得整个_elem所占用的物理空间已经不足以存放需要存放的元素组。尽管这个时候在系统的其它的部分仍然有足够多的空间可以用于存放这些元素，但是限于_capacity是固定的，我们不能直接做到这一点。 另一种情况虽然不是很严重，但是也是会造成一定的空间的效率低下，我们称之为下溢underflow。具体来说就是有可能我们开辟了一个比较大的空间，但是在整个这个数据结构的生命期内真正存放于其中的数据却寥寥无几，从而使得装填因子指标会非常非常的小，这个装填因子其实就是有效元素个数，也就是_size ，去除以可用于存放元素的空间总数_capacity，也可以理解成是空间的利用率有可能不到一半，甚至远远地低于一半，那么在这种时候空间效率非常低下。 很遗憾如果我们坚持采用这样一种固定容量的策略，我们在实际的一般应用环境中，很难在事先就预测到我们需要用多少空间，也就是说这种空间不足以及空间浪费的情况，都有可能发生甚至经常发生。 那么如何使得向量可以自适应地根据实际需要来动态地调整自己的容量呢？而且这种调整的过程既能保证足够同时又不致使得因为开辟的空间过多而导致空间效率的低下。 动态空间管理为了解决上述的问题，我们需要把刚才所采用的静态空间管理策略改变为所谓的动态空间管理策略，就是如果在某个时刻，某一个向量即将发生上溢，那么我们就适当地扩大内部数组的容量，使之足以容纳新的元素。按照这样一种策略向量的生命期可以大致由下面一组图来表示。 最开始的时候向量所存放的有效元素还不是很多，还不致于出现上溢的情况，这时候可以从容应对。但是剩余的空间有可能会逐步地被占用，直到某一个关键时刻，内部数组有可能已经饱和，这时就存在一个风险也就是说再插入一个元素的话，就会导致上溢。为此我们可以动态的申请另一段存放空间，当然它的大小应该比原来的有所增长。接下来我们要把原先已经存放好的那些有效元素，逐一地按次序地复制过来，从而使得它们对外界而言依然保持原貌。新多出来的这些空间就足够用以存放新需要插入的元素，而原来所占用的空间将在此之后被释放并且归还给系统。上述这样一个完整的调整过程可以描述并且实现为下面的c++的代码： 12345678910template&lt;typename T&gt;void Vector&lt;T&gt;::expand() &#123; //向量空间不足时扩容 if (_size &lt; _capacity) return; //尚未满员时，不必扩容 _capacity = max(_capacity, DEFAULT_CAPACITY); //不低于最小容量 T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍 for (int i = 0; i &lt; _size; i++) //复制原向量内容 _elem[i] = oldElem[i]; //T为基本类型，或已重载复制操作符'=' delete[] oldElem; //释放原空间&#125; 首先要判断现在是否处于即将发生上溢的临界状态，它的标志就是_size是否还继续严格地小于_capacity。如果是还不存在上溢的风险，可以直接返回，所以这里隐含着有一个else，即接下来_size虽然不一定大于_capacity，但是至少会出现等于_capacity的情况。 这时我们要做的是将原来的那个数据域做一个备份，接下来以原先的容量（注意这里是左移一位，相当于加倍）加倍的一个新的容量来申请一段动态空间，并且将这段空间交由原来的_elem来指示。接下来是复制，对从原先的那个数据域中逐一地取出各项，并且将其转移至新的这个数据域中对应的位置。在整体赋值完之后，原先的这个空间已经没有任何存在的意义了，所以通过delete操作将它释放。 其实对于尚未封装的数组同样可以采用上述的这样的一个策略，而对于向量而言，这里调整的优势体现在向量整体的封装性上。因为对于一般的数组，如果它经过了动态的重新分配地址，那么原先指向它内部的某些元素的一些指针就有可能会出现无效，即虽然它能指向一个地址但其中并没有存放所需要的数值。但是对于向量而言经过了这样的封装以后就安全了，因为无论是此前此后我们在访问某一个具体的元素的时候，在内部都是通过_elem这个统一的指示器来标识空间的起点。从这一点也可以看出进行封装以后的一个好处。 那么为什么要采用一个容量加倍的策略呢？采用其他策略，比如适当增加背部数组的容量，是否也可行呢？ 容量递增策略实际上情况并不那么简单，我们不妨以其中的一种典型的策略，即容量递增策略，来做一个对比。就是每当发现当前的内部数组即将发生上溢我们并不是对它进行容量的加倍，而只是在原来的容量的基础上追加一个固定的数额，这样看起来并没有什么问题。在代码上只需将原来的_capacity*2变成_capacity追加一个固定的数额，记为INCREMENT，简记作$I$。下面来考虑这个策略的效率。 在即将上溢之前，追加固定大小的容量 12T* oldElem = _elem;_elem = new T[_capacity += INCREMENT]; 最坏情况：在初始容量0的空向量中，连续插入$n = m * I$个元素（远大于2） 于是，在第$1, I+1, 2I+1, 3I+1,……$次插入时都需要扩容 即便不计申请空间操作，各次过程中复制原向量的时间成本依次为：$0,I,2I,\\dots,(m-1)I$（算术级数） 总体耗时 = $I\\times(m-1)\\times m/2=O(n^2)$，每次扩容的分摊成本为$O(n)$。 容量加倍策略 在即将上溢之前，使容量加倍 12T* oldElem = _elem;_elem = new T[_capacity &lt;&lt;= 1]; //容量加倍 最坏情况：在初始容量1的的满向量中，连续插入$n=2^m$个元素 于是，在第$1，2,4,8,16,32，\\dots$次插入时都需要扩容 各次扩容过程中复制原向量的时间成本依次为：$1,2,4,8,\\dots,2^m$ （几何级数） 总耗时 = $O(n)$，每次扩容的分摊成本为$O(1)$。 造成两种方法每次扩容分摊成本的时间复杂度出现很大差别的原因，可以用下图说明。实际上在向量规模不断递增达到某一固定的数值之前，如果采用的是递增式的增容策略，那么所需增容的操作必然是按当时的规模呈算数级数的形式分布。反过来如果是以倍增式的策略来进行的扩容，那么只需要进行其中的少数几次扩容就够了，具体来说就是这些以紫色标明的，可以看到要远远小于原先的数目，而且随着数组规模的增加，这种差异会更加的明显。 我们不妨将这两种策略所对应的性能列成如上面的一张表。在时间方面，在达到一个固定的规模n之前，累计所用的扩容时间：递增策略要多达$O(n^2)$，而倍增策略只需要$O(n)$，如果从分摊的意义上讲分摊到每一次扩容所需要的时间：前者是$O(n)$， 而后者是$O(1)$。可以看到就时间而言，容量加倍策略具有巨大的优势。而在空间方面，前一种策略似乎要非常好，因为它总是每次增加一个固定的数额，所以随着向量规模的增加，整个空间的利用率会越来越接近于百分之百。而加倍策略未必能做到百分之百，但是它至少有个底线，至少是50%，只有在它即将发生上溢，而因此刚刚通过加倍扩容的那个瞬间时才会是50%。所以相对而言，可以理解为倍增策略是通过在空间的效率上做了一个适当的牺牲，来换取在时间方面的巨大的收益，显然收益要远远大于损失。 平均分析 vs. 分摊分析平均复杂度或期望复杂度（average/expected complexity） 根据数据结构各种操作出现概率的分布，将对应的成本加权平均。 各种可能得操作，作为独立事件分别考查； 割裂了操作之间的相关性和连贯性； 往往不能准确地评判数据结构和算法的真实性能。 分摊复杂度（amortized complexity） 对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作。 从实际可行的角度，对一系列操作做整体的考量； 更加忠实地刻画了可能出现的操作序列； 可以更为精确地评判数据结构和算法的真实性能 无序向量回顾前两节，我们以向量为例给出了数据结构定义的一种通用方法，即模板，大致格式如下： 1template &lt;typename T&gt; Vector &#123; ...... &#125;; 这种方法实际上定义了 一系列的Vector，在使用的时候可以灵活指定它的类型。如果尖括号里是int的，那这个Vector实际上是a Vector of integers，即由一系列的整数组成的向量。更重要的是 在以后我们将利用这种方式来构造更为复杂的数据结构，比如可以把某些数据结构作为基本的组成元素来构成向量，举个例子在后面的学习中会定义二叉树Binary Tree这样一种数据结构，如果把BinTree作为基本的元素来构成Vector，那我们就可以构成一个由一系列的二叉树构成的一个线性序列，也就是A Vector of Binary Trees，取个形象的名字可以叫它forest 森林。在后面介绍霍夫曼编码的时候也会用到这种技巧，通过采用统一的模板式的方法，可以使得数据结构的定义非常的规范，而且更重要的是它们可以互相的融合组合，便捷地搭建更为复杂的数据结构。 12345Vector&lt;int&gt; myVector1;Vector&lt;float&gt; myVector2;Vector&lt;char&gt; myVector3;Vector&lt;BinTree&gt; forest; 这一节我们将围绕向量的最基本的形式，即无序向量来展开。无序向量不一定是说其中的元素没有顺序，甚至有时候其中的元素是根本就不可能排成顺序。在这样的一个前提下我们将研究如何来定义并且实现相应的操作接口。 循秩访问通过V.get(r)和V.put(r, e)接口，固然可以读，写向量元素，但便捷性远不如数组元素的下标式访问方式A[r]。通过重载下标操作符“ [ ] “，便可沿用数组的下标方式访问向量元素。对于任何一个指定的Rank r，只需在内部数据区中取出对应的第r号元素，此后凡是需要引用向量中的某个特定的比如说Rank为r的这个元素，就可以直接以这样一种类似于数组下标的形式进行引用。 123template&lt;typename T&gt;T&amp; Vector&lt;T&gt;::operator[](Rank r) const //0 &lt;= r &lt; _size &#123; return _elem[r]; &#125; 此后，对外的V[r]即对应于与内部的V._elem[r]。这种引用可以作为右值，以这种类似数组形式进行运算并且将运算的结果，向左侧赋值给某一变量；而反过来计算的结果也可以赋值给向量中某一个元素，也就是作为左值，因为这个接口返回值是一个引用。 右值：T x = V[r] + U[s] * W[t] 左值：V[r] = （T) (2*x + 3) 需要注意的是这里我们对入口参数r并没有做过多的检查，而是简易地在入口处增设了一个断言，用以提醒使用者保证入口参数r能够在合理的范围之内，但在真正的实际应用中，要做更为严格的处理。 插入 向量的插入算法具体来说就是如何将某一个特定的元素插入到向量的特定位置，在原来向量中因为所有的元素都必须是紧邻排列的，所以为了能够插入新的元素我们需要做一个调整，也就是将对应这个位置之后的所有的那些元素，称作它的后继，整体的构成一个后缀，进行一个整体的右移操作。这个right shift操作效果就是所有的后缀元素都向右移动一个单元，从而空出一个单，此时才可以将指定的那个元素纳入其中，从而完成插入。 整个算法可以描述并且实现如下的C++代码： 123456789template&lt;typename T&gt; //e作为秩为r的元素插入，0 &lt;= r &lt;= _sizeRank Vector&lt;T&gt;::insert(Rank r, T const&amp; e) &#123; expand(); //若有必要，扩容 for (int i = _size; i &gt; r; i--) //自后向前 _elem[i] = _elem[i - 1]; //后继元素顺次后移一个单元 _elem[r] = e; //置入新元素 _size++; //更新容量 return r; //返回秩&#125; 右移操作可以通过for循环完成，每个元素确实都是后移一位，当所有的后移完成之后，再将新的那个元素纳入到rank所指的位置上，当然同时还要更新整个向量的规模。 有两个需要注意的地方：第一，在for循环的方向是从最后一直向前不断地递减，也就是说整个的移动的方向虽然是向右，但是所有元素移动的先后次序却是后优先的，用图来表示也就是最后这个元素先移动，接下来是次后这个元素，再往前一直直到最前面的那个元素。这是必要的，如果把这个次序颠倒过来会有危险，会出现数据在无意中被覆盖的问题。 第二个主要注意的是expand()，即扩容操作，这是有必要的。因为确实在某些时候这个向量可能已经是满载的，所以为了插入新元素，在后移的过程中必然会出现上溢的情况，在这种时候就需要对向量进行扩容处理，比如上节的容量加倍策略，这样一件事情完全由expand()完成。 删除区间删除我们先考虑一个通用的一个版本，即区间删除，具体来说就是在某个向量中，我们要将介于lo和hi之间的一系列的元素成批地从中剔除掉。因为向量要求所有的元素始终都是彼此紧邻排列的，所以不应该在删除之后留下这个缝隙，换而言之，我们需要将它后继的那些元素（如果有的话）统一地向前或者说向左移动来填补这段空白。其实可以反过来看到如果能够完成这样的一个左移的话，那么实际上也就相当于把这些元素给剔除或者叫覆盖掉了，所以关键的任务在于如何实现这个左移。 这样的一个过程可以实现为下面代码： 12345678template&lt;typename T&gt; //删除区间[lo, hi)，0&lt;=lo&lt;=hi&lt;=_sizeint Vector&lt;T&gt;::remove(Rank lo, Rank hi) &#123; //O(n-hi) if (lo == hi) return 0; //处于效率考虑，单独处理退化情况 while (hi &lt; _size) _elem[lo++] = _elem[hi++]; //[hi, _size)顺次前移hi-lo个单元 _size = lo; shrink(); //更新闺蜜，若有必要则缩容 return hi - lo; //返回被删除元素的数目&#125; 代码中最关键的是while循环，它会遍历整个后缀，并且将其中的每一个元素逐一地取出，向前转移到合适的位置。比如第一个转移的是hi这个位置上的这个元素，它将被转移到lo这个位置，紧接着是hi+1转移到lo+1，hi+2转移到lo+2，直到最后。 同样有两个问题需要强调说明：第一个问题，在整个移动的过程中，所有这些元素参与移动的先后次序，同样也是很敏感的，或者说不能更改的，与插入算法完全颠倒，插入算法是自后向前，而区间删除算法是越往前的元素越优先参与移动，所以我们也可以认为它是一个自前向后的前移操作。如果把这个次序颠倒过来是有风险的，比如两者，即前缀的原来的那个位置和后来的那个位置中间有相互重叠的部分，如果优先移动后面的那个元素，那么就有可能会造成重叠区间的元素在无意中被覆盖掉。 第二点是shrink()这个历程的调用，它是某种意义上讲的缩容，这种操作在实际应用中并不是必须的，我们往往可以忽略它。 单元素删除上一小节中实现了区间的批量删除的接口，所以我们不妨把单元素的删除视作是整个区间操作的特例。具体来说，就是要将任何一个由单个元素构成的区间视作是由 r 到 r+1所定义的左闭右开的那段区间。这样就可以很简明地调用用此前重载的那个remove接口，只不过这里的参数改变为 r 和 r+1，与我们刚才的那种转换相对应。同理算法所进行的操作就是所有的后缀向前移动一个单位。 123456template&lt;typename T&gt; //删除向量中秩为r的元素，0 &lt;=r &lt; _sizeT Vector&lt;T&gt;::remove(Rank r) &#123; //O(n - r) T e = _elem[r]; //备份被删除的元素 remove(r, r + 1); //调用区间删除算法 return e; //返回被删除的元素&#125; 那么反过来，基于remove(r)接口，通过反复的调用，实现remove(lo, hi)是否可行呢。理论上是可行的，对于一个特定的一段从 lo 到 hi的区间，我们可以对其中的每一个元素分别去调用一次单元素删除接口，从而完成整体的删除操作。但是正如我们一直强调的，数据结构更多关注的是效率，而从效率上看这样做是非常差的。 首先考虑单元素删除本身的效率，最重要的实际上是这段区间也就是被删除元素的那些后继们，统一地要向前移动一次，这也是它的复杂度的来源。因此它的时间复杂度是取决于它的后继的个数，即为n-hi，最坏情况下是$O(n)$。如果按这种方式反复调用，有可能会导致$O(n^2)$的复杂度，在效率上是不能接受的。 查找查找即是按照某种特定的条件，从向量中找出特定的元素。首先我们要明确两个概念：判等与比较，对于任何的两个元素，我们来判断它们是否是相等，或者是比较它们之间谁大谁小，这两个操作并不是所有的类型都天然支持的。所以这里我们做一个假设：向量中元素的类型是基本类型，或者向量元素这个类已经重载了对应的判等的操作符或者是比较的操作符。无序向量可以一般性地认为它只支持判等操作，而对于有序向量，要求要更高一点，它还需要支持其中的元素能够相互比较大小。 无序向量：T为可判等的基本类型，或已重载操作符=或!= 有序向量：T为可比较的基本类型，或已重载操作符&lt;或&gt; 无序向量的查找过程可以描述为下图，如果查找的区间范围是 lo 到 hi 的话，就从 hi 出发逆向地、逐一地取出向量中的各个元素与目标元素进行比对，如果不相等就忽略它，进而考察它的前驱，所以整个的工作会亦步亦趋地逐个地遍历向量中的所有的元素。 经过这样一个逆向地扫描的过程，我们很有可能在中间的某一步找到所需要的那个目标，即查找成功；如果一直持续到最后，在试图越过lo也就是合法的最左侧的边界的时候，就可以断定整个查找是失败的。这个算法可以通过下面的代码实现： 1234567template&lt;typename T&gt; // 0 &lt;= lo &lt; hi &lt;= _sizeRank Vector&lt;T&gt;::find(T const &amp;e, Rank lo, Rank hi) cosnt&#123; //O(hi - lo) = O(n)，在命中多个元素时可返回秩最大者 while ((lo &lt; hi--) &amp;&amp; (e != _elem[hi])); //逆向查找 return hi; // hi &lt; lo 意味着失败，否则hi即命中元素的秩&#125; // Excel::match(e, range, type) 需要注意的是，find函数返回的都是最终停止的那个位置，有可能是合法的一个位置。也可能是刚刚越过左边界的那个非法的位置。而具体判别是否成功可以交给上层的调用者，因为他通过这个秩是否是合法就可以判断查找是否成功，如果是成功的话这样一个秩将可以被高层的算法进一步地利用。 我们也可以看出这个算法的复杂度有很大的变化空间，在最好的情况下，可能在第一个元素位置上就顺利地命中所以这时复杂度是常数$O(1)$；但是在最坏的情况下，比如一直持续到比较后才发现这个元素，甚至一直持续到最终也没有发现我们的目标元素，为此在这个过程中我们需要扫描的元素可能会与向量的规模相当，复杂度就会是$O(n)$。 这样一种在最好和最坏情况下相差极其悬殊的算法，叫作输入敏感算法（input-sensitive），即它的复杂度具体是多少与输入时候数据的配置紧密相关。 输入敏感（input-sensitive）：最好$O(1)$，最差$O(n)$。（对本例而言） 唯一化问题无序向量的唯一化问题，即是把其中重复的元素都剔除掉，使得每一组重复的元素只保留一个拷贝。在很多实际的应用中都能够找到唯一化的影子，比如在网络搜索的环境中有很多个不同的结点所分工完成的局部的搜索结果，可能会含有大量的重复的元素，我们需要将其中重复的元素剔除掉，从而得到一份记忆完整同时又不冗余的搜索报告。这样一个算法大致可以通过这样的一个图示来表示它的原理： 对于一个向量，我们总是把它分为三个部分，以当前的这个元素为界，当前这个元素自己是一部分，它的前驱所构成的前缀是一部分，以及对称地，所有的后继是一部分。每一次我们遇到一个新的元素，都在它的前缀中去进行查找，这可以通过find操作来完成的，如果能够找到雷同的元素，比如在某个位置上出现了一个x，就可以把这个元素剔除掉。反之，经过查找以后，如果这个元素没有出现，那么我们就可以把它保留下来，同时再去考察它的下一个元素。这个算法可以由下面的代码实现： 12345678910template&lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; int oldSize = _size; //记录原规模 Rank i = 1; //从_elem[1]开始 while (i &lt; _size) //自前向后逐一考查各元素_elem[i] (find(_elem[i], 0, i) &lt; 0) ? //在前缀中寻找雷同者 i++ //若无雷同者则继续考查其后继 : remove(i); //否则删除雷同者（可以是多个） return oldSize - _size; //返回向量规模变化量，即删除元素总数&#125; 正确性那么我们如何给出这个算法正确性的严格证明呢？同样根据第一章学到的知识，我们通过挖掘算法所具有的不变性和单调性，来证明一个算法最终的正确性。 首先来证明不变性，我们发现在这个算法运行的任何一个时刻，如果当前所对应的是第i个元素V[i]的话，那么在它所对应的那个前缀中所有的元素必然是彼此互异，即不包含重复元素。当算法开始时i=1，它的前缀只有V[0]。 其余的一般情况下可以用数学归纳法来予以证明：假设当时的状态是第i个元素e，它的前缀是从0到i的区间。按照数学归纳法我们假设在此前不变性是成立的话，那么接下来，无非两种情况，即当前的这次对应的查找成功或者失败。 如果是失败，即在它的前缀中不含元素e，算法给出的处理方法是直接令i++，也就是我们已经指向了它的下一个元素，而将刚才那个元素e归入了新的这个前缀中。既然e和此前的那些前缀是互不重复的，所以将e归入这样的一个区间以后，这个区间必然是不含重复元素的。 反之如果如果查找成功，e出现在它的前缀中，按照算法流程会将它剔除掉，也就是通过删除操作使得后继的元素整体地向前移动，从而使得原先它的直接后继变为当前的这个元素，并且算法继续地运转下去。经过了这样一次迭代之后当前的这个元素虽然换了，但是它的前缀并没有换，这个前缀所具有的元素互异的性质也依然会保持下来。 算法运行到最终是覆盖整个向量，到那时我们所说的当前的元素其实就是最末尾的那个哨兵元素，而它的前缀其实就是整个向量，那么它的前缀中不包含重复的元素其实也就相当于整体的向量中不包含重复的元素，这正是我们这个算法的功能唯一化所要求的，所以在最终这个不变性必然会转化为我们所需要的正确性 接着我们证明单调性，这个算法的主体是由一个while循环构成的，随着反复的while迭代: 当前元素前缀的长度单调非降，且迟早增至_size 当前元素后缀的长度严格单调下降，且迟早减至0 所以算法待处理元素的个数会严格单调减少，算法必然终止，且至多迭代$O(n)$轮。 复杂度这个算法的主体是while循环，而在while循环中真正能够造成有效复杂度的是find操作和remove操作，其中find操作是对于当前的元素的整个前缀而言的，而remove操作恰好对称是相对于当前这个元素的后继而言的。所以每一次while循环所需要的成本也就是find和remove两类操作的成本，累计起来也不会超过整个向量的长度，即$O(n)$线性步。而while循环最多会迭代$O(n)$轮，所以这个算法累计起来最多不超过$O(n^2)$的时间复杂度，这也是最坏情况。 这个算法也可以进一步的优化。 遍历遍历就是按照某种事先约定的操作（称之为visit），对向量中的每一个元素逐一地、统一地执行一次。所以这里涉及到两个问题：第一，如何来指定或者来描述这样一个visit操作；第二，如何将它传递到向量内部的每一个具体的元素。 通常有两种方法：第一种是使用函数指针，也就是说可以对于vector这样一个类定义一个traverse接口，作为它的参数visit本身就是一个函数的指针。所以为了兑现这样的一个遍历操作我们只需要逐一地取出向量中由这个i确定的每一个元素通过这个函数指针找到这个函数，并且对这个元素实施这个函数所指定的操作。 12345template&lt;typename T&gt;void Vector&lt;T&gt;::traverse(void(*visit)(T&amp;))&#123; //函数指针 for (int i = 0; i &lt; _size; i++) vist(_elem[i]);&#125; 第二种方式是使用函数对象，也就是说我们指定的这个参数visit，本身就是一个对象，它的作用就是用来模拟一个操作一个函数的一个行为方式。所以同样地，我们也可以对这个向量中的每一个元素都逐一地取出，并且转交给这样一个函数对象，通过它来实施具体地、统一地操作。 12345template&lt;typename T&gt; template&lt;typename VST&gt;void Vector&lt;T&gt;::traverse(VST&amp; visit) &#123; //函数对象 for (int i = 0; i &lt; _size; i++) vist(_elem[i]);&#125; 这两种方法其实是非常接近，但是也有一些重要的区别，相对而言，后一种方式的通用性更强。 下面通过一个实例来了解如何通过函数对象，实现刚才所说的具体地遍历。比如说，我们可以考虑将向量中的所有的元素统一地各自+1。为此我们只需要实现一个对应功能的函数对象，它本身也是以一个类的形式给出来的。这里为了简化起见使用了struct，而没有进行过多的封装。这个对象最重要的一个作用或者说唯一的作用就是重载了它的圆括号操作符()，从而使得它在行为上与一个函数非常的类似，而具体的功能就是把每一个参数e做一个+1操作。 1234template&lt;typename T&gt; //假设T可直接递增或已重载操作符“++”struct Inciease &#123; //函数对象：通过重载操作符\"()\"实现 virtual void operator()(T &amp; e) &#123; e++; &#125; //加一&#125;; 在实现了这样一个对应的类之后，就可以通过调用vector统一遍历接口traverse，将我们刚刚编写的这个函数对象以参数的形式传入就可以实现相应的功能，也就是把向量中的每一个元素统一地加一。 1234template&lt;typename T&gt;void increase(Vector&lt;T&gt; &amp; V) &#123; V.traverse(Increase&lt;T&gt;()); &#125;","categories":[],"tags":[]},{"title":"数据结构与算法（1）","slug":"数据结构与算法（1）","date":"2020-02-05T02:32:06.000Z","updated":"2020-02-06T16:31:08.004Z","comments":true,"path":"2020/02/05/数据结构与算法（1）/","link":"","permalink":"http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/","excerpt":"","text":"计算对象：规律，技巧 目标：高效，低耗 Computer science should be called called computing science, for the same reason why surgery is not called knife science. -E.Dijkstra 计算 = 信息处理 ​ 借助某种工具，遵照一定规则，以明确而机械的形式进行 计算模型 = 计算机 = 信息处理工具 算法所谓算法，即特定计算模型下，旨在解决特定问题的指令序列 ​ 输入：待处理的信息（问题） ​ 输出：待处理的信息（答案） ​ 正确性：的确可以解决指定的问题 ​ 确定性：任一算法都可以描述为一个由基本操作组成的序列 ​ 可行性：每一基本操作都可以实现，且在常数时间内完成 ​ 有穷性：任一算法在执行有限次基本操作之后终止并给出输出 列子：Hailstone序列 \\begin{align*}& 序列Hailstone(n)=\\begin{cases}\\{1\\} &n\\le1\\\\\\{n\\}\\cup Hailstone(n/2) &n为偶数\\\\\\{n\\}\\cup Hailstone(3n+1) &n为奇数\\end{cases}\\\\\\\\&Hailstone(42)=\\{ 42,21,64,32,\\dots,1\\}\\end{align*}12345int hailstone(int n)&#123;//计算序列Hailstone(n)的长度 int length = 1; //从1开始递推 while (n&lt;1) &#123; (n % 2) ? n = 3 * n + 1 : n / = 2; lenth++; &#125; return length; //返回hailstone(n)&#125; 问题：对于任意的n，总有|Hailstone(n)| &lt; ∞ ？ 目前还不能证明 程序不一定是算法 好算法正确：符合语法，能够编译，链接 ​ 能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入 健壮：能辨别不合法的输入并做适当处理，而不致非正常退出 可读性：结构化 + 准确命名 + 注释 + … 效率：速度尽可能快 ；存储空间尽可能少 （最重要的） ​ Algorithms + Data Structures = Programs -N. Wirth, 1976 ​ (Algorithms + Data Structures) × Efficiency = Computation 计算模型好的数据结构和算法才能有高效的计算，从而有好的应用。 算法分析两个主要方面： ​ 正确性：算法功能与问题要求一致？ ​ 数学证明？并不简单 ​ 成本： 运行时间+所需存储空间 ​ 如何度量？如何比较？ 考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。 ​ 意义不大，因为可能出现的问题实例太多。那么如何归纳概括？ 观察：问题实例的规模，往往是决定计算成本的主要因素。 特定算法 + 不同实例 令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。 ​ 讨论特定算法A（及其对应的问题）时，简记作$T(n)$。 然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。 稳妥起见，取$T(n) = max{ T(P)| |P| = n }$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。 特定问题 + 不同算法 同一问题通常有多种算法，如何评判其优劣？ 实验统计是最直接的方法，但足以准确反映算法的真正效率？ 但实验统计还是不足够的，还要考虑： 不同的算法，可能更适应于不同规模的输入 不同的算法，可能更适应 与不同类型的输入 同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现 同一算法，可能实现并运行与不同的体系结构、操作系统 为给出客观的评判，需要抽象出一个理想的平台或模型 不再依赖于上述种种具体的因素 从而直接而准确地描述，测量并评价算法 图灵机 Turing Machine Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’ Alphabet：字符的种类有限 Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格 State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态 Transition Function ：（q, c; d, L/R, P) ​ 若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格； ​ 转入p状态，一旦转入特定的状 态’h’，则停机。 RAM: Random Access Machine 与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。 在这些模型中： 算法的运行时间 转化为 算法需要执行的基本操作次数 $T(n)$ = 算法为求解规模为n的问题，所需执行的基本操作次数 大$O$记号渐进分析 回到原先的问题：随着问题规模的增长，计算成本如何增长？ ​ 注意：这里更关心足够大的问题，注重考察成本的增长趋势 渐进分析：在问题规模足够大后，计算成本如何增长？ ​ Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法 ​ 需执行的基本操作次数：T(n) = ? ​ 需占用的存储单元数：S(n) = ? //通常可不考虑 大$O$记号（big-$O$ notation） \\begin{align*} &T(n)=O(\\,f(n)\\,)\\quad if \\quad \\exists c>0, 当n>>2后，有T(n)","categories":[],"tags":[]},{"title":"Cpp基础（7）类和对象","slug":"Cpp基础（7）类和对象","date":"2020-02-04T08:09:38.000Z","updated":"2020-02-09T15:25:01.930Z","comments":true,"path":"2020/02/04/Cpp基础（7）类和对象/","link":"","permalink":"http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象程序设计的基本特点抽象：对同一类对象的共同属性和行为进行概括，形成类。 首先注意问题的本质及描述，其次是实现过程或细节。 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。 代码抽象：描述某类对象的共有的行为特征或具有的功能。 抽象的实现：类。 12345678class Clock&#123; public: void setTime(int newH, int newM. int newS); void showTiem(); private: int hour, minute, second;&#125; 封装：将抽象出的数据，代码封装在一起，形成类。 目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。 实现封装：类声明中的{ } 继承：在已有类的基础上，进行扩展形成新的类。 多态：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。 类和对象的定义对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。 设计类就是设计类型，需要关注哪些问题： 此类型的“合法值”是什么？ 此类型应该有什么样的函数和操作符？ 新类型的对象该如何被创建和销毁？ 如何进行对象的初始化和赋值？ 对象作为函数的参数如何以值传递？ 谁将使用此类型的对象成员？ 类定义的语法形式123456789class 类名称&#123; public: 公有成员（外部接口） private: 私有成员 protected: 保护型成员&#125; 在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。 12345678class Clock&#123; public: void setTime(int newH, int newM. int newS); void showTiem(); private: int hour = 0, minute = 0, second = 0;&#125; 类成员的访问控制公有类型成员：在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。 私有类型成员：在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。 保护类型成员：与private类似，其差别表现在继承与派生时对派生类的影响不同。 类中成员之间直接使用成员名互相访问。 从类外访问成员使用“ 对象名.成员”，来访问公有成员。 类的成员函数在类中声明函数原型： 可以直接在类中给出函数体，形成内联成员函数； 12345678910//定义一个矩形的类class Rectangle&#123; private: int w; int h; public: int getArea() &#123; return w*h; &#125; int getPerimeter() &#123; return 2*(w+h); &#125;&#125;; 也可以在类外给出函数体实现，并在函数名前用类名加以限定； 12345678910111213//定义一个矩形的类class Rectangle&#123; private: int w; int h; public: int getArea(); int getPerimeter();&#125;;int Rectangle::getArea() &#123; return w*h; &#125;int Rectangle::getPerimeter() &#123; return 2*(w+h); &#125; 允许声明重载函数和带默认参数值的函数。 例子：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Circle&#123;private: double x; double y; double r;public: void setM(double _x, double _y) &#123; x = _x; y = _y; &#125; void setR(double _r) &#123; r = _r; &#125; double getArea() &#123; return 3.14 * r * r; &#125; double getPerimeter() &#123; return 2 * 3.14 *r; &#125;&#125;;int main()&#123; Circle myCircle; myCircle.setM(1.7, 3.2); myCircle.setR(4.2); double myArea = myCircle.getArea(); double myPeri = myCircle.getPerimeter(); cout &lt;&lt; \"Area = \" &lt;&lt; myArea &lt;&lt; \", Perimeter = \" &lt;&lt; myPeri &lt;&lt; endl; myCircle.setR(8.4); myArea = myCircle.getArea(); myPeri = myCircle.getPerimeter(); cout &lt;&lt; \"Area = \" &lt;&lt; myArea &lt;&lt; \", Perimeter = \" &lt;&lt; myPeri &lt;&lt; endl;&#125; 构造函数当我们定义对象时，如何对对象进行初始化？在定义基本类型的变量时，是可以直接给定初始值的，但是在定义对象时却不是这么简单，因为一个类是我们自己定义的，对类的对象按照什么规则进行初始化，编译器是不会自动知道的，必须由程序员写程序来规定。为此C++中提供了一种特殊的机制：构造函数，在构造函数中我们可以描述如何对类的对象进行初始化。 基础知识构造函数的作用 在对象被创建时使用特点的值构造对象，将对象初始化为一个特定的初始状态 例如：希望在构造一个Clock类对象时，将初始时间设为0:0:0，就可以通过构造函数来设置 构造函数的形式 函数名与类名相同； 不能定义返回值类型，也不能在函数体有return语句； 可以有形式参数，也可以没有形式参数； 可以是内联函数； 可以是重载； 可以带默认参数值。 构造函数的调用时机 在对象创建时被自动调用，但如果没有定义构造函数就进行初始化，那么编译器就会报错。 1Clockk myClock(0,0,0); 默认构造函数调用时可以不需要实参的构造函数： 参数表为空的构造函数 全部参数都有默认值的构造函数 下面两个都是默认构造函数，如在类中同时出现，将产生编译错误，不是合法的函数重载形式 12Clock();Clock(int newH=0, int newM=0, int newS=0) 隐含生成的构造函数如果在程序中未定义构造函数，编译器将在需要时自动生成一个默认的构造函数： 参数列表为空，不为数据成员设置初始值； 如果类内定义了成员的初始值，则使用内类定义的初始值； 如果没有定义类内的初始值，则以默认方式初始化； 基本类型的数据默认初始化的值是不确定的。 如果定义的类的成员不是基本类型的成员，而是其他类的对象，这个就是类组合的情况，其默认的初始化方式由它所属的类决定。 =default如果程序中已定义构造函数，默认情况下编译器就不会再隐含生成默认构造函数。如果此时依然希望编译器隐含生成的默认构造函数，可以使用=default。 1234567class Clock&#123; public: Clock() = default; Clock(int newH, int newM, int newS); private: int hour, minute, second;&#125; 例子1 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;class Clock &#123;public: Clock(int newH, int newM, int newS); void setTime(int newH, int newM, int newS); void showTime();private: int hour, minute, second;&#125;;Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; //初始化列表int main() &#123; Clock c(0, 0, 0); c.showTime(); return 0;&#125; 例子2 1234567891011121314151617class Clock &#123;public: Clock(int newH, int newM, int newS); //构造函数 Clock(); //默认构造函数，如果类要重复使用，一般要提供一个默认构造函数 void setTime(int newH, int newM, int newS); void showTime();private: int hour, minute, second;&#125;;Clock::Clock():hour(0),mintue(0),second(0)&#123;&#125; //默认构造函数Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; int main()&#123; Clock c1(8,10,0); //调用有参数的构造函数 Clock c2; //调用无参数的默认构造函数&#125; 委托构造函数当我们在一个类中重载多个构造函数的时候，往往发现这些构造函数它们只是形参表不同，初始化列表不同，而其他都是一样的，初始化算法都是相同的，函数体都是相同的。那么在这种情况下，如果我们写多个函数体来重载，往往就显得重复了，为了避免这种重复，C++11新标准提供了一种新的机制：委托构造函数，也就是让一个构造函数可以去委托另一个构造函数去帮它完成初始化功能。 回顾Clock类的两个构造函数，第一个构造函数是有三个参数的，第二个构造函数是默认构造函数，没有参数。实际上，这两个构造函数进行初始化的方式是完全一样的，只不过第一个构造函数是用参数表里的参数进行初始化，第二个构造函数用默认状态全部用0进行初始化。那么我们其实没有必要写两个类似的重复的代码。 12Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; Clock::Clock():hour(0),mintue(0),second(0)&#123;&#125; //默认构造函数 委托构造函数使用类的其他构造函数执行初始化过程，我们用委托构造函数的方法重写上面的代码，这里第二个构造函数调用了另外一个有参数的构造函数，将默认的三个初始化参数传给有参数表的Clock构造函数，这样就不用把同样的初始化方法再写一遍了。 12Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125;Clock::Clock():Clock(0,0,0)&#123;&#125; 用委托构造函数不仅可以减少重复的工作，其最大的好处是可以保持代码实现的一致性，如果想要修改构造函数的初始化算法时，就只需在一处修改，其他的委托这个构造函数来进行初始化的构造函数的算法也就同步修改了。 复制构造函数当我们在定义一个基本类型的变量时，经常会用一个已经存在的已经有值的变量去初始化这个变量；我们在定义对象时可会有这样的需求，即用一个存在的对象去初始化一个新的对象，这时要如何实现这种初始化呢？C++中提供了一种特殊的构造函数，叫复制构造函数。 在复制构造函数中我们可以规定如何用一个已经存在的对象去初始化一个新对象，可以用这个已经存在的对象的引用作为构造函数的参数。如果在定义类的时候没有定义复制构造函数，编译器也生成一个默认的复制构造函数，它会实现类的两个对象的数据成员之间一一对应复制，这些功能在很多时候已经能满足需求，那么我们就不需要再写复制构造函数了。 复制构造函数定义 复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。 由于复制构造函数的目的不会是将原有的那个形参对象给修改了，所以最好是在形参引用前加上const关键字 123456789class 类名&#123; public: 类名(形参)； //构造函数 类名(const 类名 &amp;对象名); //复制构造函数 //......&#125;;类名::类(const 类名 &amp;对象名) //复制构造函数的实现&#123; 函数体 &#125; 复制构造函数的调用除了在定义新对象时，用已有的对象作为参数去初始化它这种情况以外，共有三种情况是典型的要调用复制构造函数的情况： 定义一个对象时，以本类另一个对象作为初始值，发生复制构造； 如果函数的**形参是类的对象**，调用函数时，将使用实参对象初始化形参对象，发生复制构造； 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。 隐含的复制构造函数 如果程序员没有为类拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数； 这个构造函数的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。 如果类的成员中有指针的时候，很多情况下，默认的复制构造函数其浅层的复制功能就不够用了，这是我们就需定义深层的复制构造。 =delete如果我们不希望对象被复制构造，那么可以采用下面的方法: C++98做法：将复制构造函数声明为private，并且不提供函数的实现。 C++11做法：用=delete指示编译器不生成默认复制构造函数。 1234567class Point&#123; public: Point(int xx=0, int yy=0) &#123;x=xx; y=yy&#125; //构造函数，内联 Point(const Point &amp;p) = delete; //指示编译器不生成默认复制构造函数 private: int x, y;&#125; 析构函数当一个对象在存续期间会占用系统资源，当这个对象的生存期结束时，需要进行善后工作将其删除清理掉，C++中提供了这样一种机制：析构函数。当对象被构造时，构造函数会自动调用；当对象要消亡时，其析构函数也会自动调用。 完成对象被删除前的一些清理工作； 在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间； 如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空； 析构函数的原型：~类名( ); 析构函数没有参数，没有返回类型 123456789101112class Point&#123; public: Point(int xx, int yy) //构造函数 ~Point(); //析构函数 private: int x, y;&#125;Point::Point(int xx, int yy)&#123; x=xx; y=yy;&#125;Point::~Point()&#123;&#125; 类的组合在制造业多年来都一直使用部件组装的生产方式，与一切手工从头做起相比，部件组装的生产效率肯定是要高，产品的标准化 它的可靠性也都更好。在程序中我们也可以借用这种部件组装的思想，用已经存在的这些类去组装新的类，C++语言支持类的组合。我们在定义一个新类的时候，可以让它的类成员是已有类的对象，也就是说一些类的对象可以作为另外一个类的部件，这就是类的组合。 类组合的基本概念： 类中的成员是另外其他类的对象； 可以在已有抽象的基础上实现更复杂的抽象。 类组合的构造函数设计那么组合类的构造函数如何设计呢？每个类的构造函数都是负责自己本类成员初始化的，如果用另外类的对象作为新定义类的成员，那么这个组合类是没有权利去访问部件对象内部的私有成员。因为一个类的私有成员只有这个类内部的函数可以访问，类外任何地方是不可以访问的，而且部件类的设计者、开发者，跟组合类的设计者 开发者可能不是一个人，甚至不是一个团队。因此在写组合类的构造函数时要考虑，由组合类的构造函数负责将部件对象初始化所需要的初始化参数传递给它，然后编译器会自动去调用部件类的构造函数，来初始化这些部件对象。其语法形式如下： 原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。 声明形式： 12345类名::类名(对象成员所需的形参，本类成员形参): 对象1(参数), 对象2(参数),...... &#123; //函数体其他语句 &#125; 构造组合类对象时的初始化次序 首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。 成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造 初始化列表中未出现的成员对象，调用默认构造函数（即无形餐的）初始化 处理完初始化化列表之后，再执行构造函数的函数体 需要注意的是，我们在写类的构造函数时，最好再写一个无参数的默认构造函数。当这个类的对象被用作其他类的部件成员时，可能组合类中没有写构造函数只使用默认构造函数，这个时候我们上面的操作就显得很必要了。 例子：构造一个Point类，再用Point类构造组合类Line类，通过构造函数和复制构造函数中的“调试信息”（cout&lt;&lt;……）可以更好地理解构造函数和复制构造函数的调用过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Point &#123; //Point类的定义public: Point(int xx = 0, int yy = 0) &#123; x = xx; y = yy; &#125; Point(Point &amp;p); int getX() &#123; return x; &#125; int getY() &#123; return y; &#125;private: int x, y;&#125;;Point::Point(Point &amp;p) &#123; //复制构造函数的实现 x = p.x; y = p.y; cout &lt;&lt; \"Calling the copy constructor of Point\" &lt;&lt; endl;&#125;//类的组合class Line &#123; //Line类的定义public: //外部接口 Line(Point xp1, Point xp2); Line(Line &amp;l); double getLen() &#123; return len; &#125;private: //私有数据成员 Point p1, p2; //Point类的对象p1,p2 double len;&#125;;//组合类的构造函数Line::Line(Point xp1, Point xp2) :p1(xp1), p2(xp2) &#123; cout &lt;&lt; \"Calling constructor of Line\" &lt;&lt; endl; double x = static_cast&lt;double&gt;(p1.getX() - p2.getX()); double y = static_cast&lt;double&gt;(p1.getY() - p2.getY()); len = sqrt(x*x + y * y);&#125;//组合类的复制构造函数Line::Line(Line &amp;l) :p1(l.p1), p2(l.p2) &#123; cout &lt;&lt; \"Calling the copy constructor of Line\" &lt;&lt; endl; len = l.len;&#125;//主函数int main() &#123; Point myp1(1, 1), myp2(4, 5); Line line(myp1, myp2); Line line2(line); cout &lt;&lt; \"The length of the line is: \"; cout &lt;&lt; line.getLen() &lt;&lt; endl; cout &lt;&lt; \"The length of the line2 is: \"; cout &lt;&lt; line2.getLen() &lt;&lt; endl; return 0;&#125; 前向引用声明类应该先声明，后使用，如果需要在某个类的声明之前引用该类，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其他地方。前向引用声明某个类之后，可在之后的其他类的成员函数中将该类作为参数类型使用。 123456789class B; //前向引用声明class A&#123; public: void f(B b);&#125;;class B&#123; public: void g(A a);&#125; 需要注意的是： 使用前向引用声明虽然可以解决一些问题，但它并不是万能的。 在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。 当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。 1234567class Fred; //前向引用声明class Barney&#123; Fred x; //错误：类Fred的声明尚不完整，不能声明该类的对象&#125;;class Fred&#123; Barney y;&#125; 示例 声明一个CPU类，包含等级（rank）、频率（frequency）、电压（voltage）等属性，有两个公有成员函数run、stop。其中，rank为枚举类型CPU_Rank，声明为enum CPU_Rank {P1=1,P2,P3,P4,P5,P6,P7}，frequency为单位是MHz的整型数，voltage为浮点型的电压值。类似地声明一个RAM类。 声明一个简单的Computer类，有数据成员芯片（cpu）、内存（ram），有两个公有成员函数run、stop。cpu为CPU类的一个对象，ram为RAM类的一个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;using namespace std;enum CPU_Rank &#123; P1 = 1, P2, P3, P4, P5, P6, P7 &#125;;class CPU&#123;private: CPU_Rank rank; int frequency; float voltage;public: CPU(CPU_Rank r, int f, float v) //构造函数 &#123; rank = r; frequency = f; voltage = v; cout &lt;&lt; \"构造了一个CPU!\" &lt;&lt; endl; &#125; CPU(CPU &amp;c) //复制构造函数 &#123; rank = c.rank; frequency = c.frequency; voltage = c.voltage; cout &lt;&lt; \"复制构造了一个CPU！\" &lt;&lt; endl; &#125; ~CPU() &#123; cout &lt;&lt; \"析构了一个CPU!\" &lt;&lt; endl; &#125; //析构函数 CPU_Rank GetRank() const &#123; return rank; &#125; //外部接口 int GetFrequency() const &#123; return frequency; &#125; float GetVoltage() const &#123; return voltage; &#125; void SetRank(CPU_Rank r) &#123; rank = r; &#125; void SetFrequency(int f) &#123; frequency = f; &#125; void SetVoltage(float v) &#123; voltage = v; &#125; void Run() &#123; cout &lt;&lt; \"CPU开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; cout &lt;&lt; \"CPU停止运行!\" &lt;&lt; endl; &#125;&#125;;enum RAM_TYPE &#123; DDR2 = 2, DDR3, DDR4 &#125;;class RAM&#123;private: enum RAM_TYPE type; unsigned int frequency; //MHz unsigned int size; //GBpublic: RAM(RAM_TYPE t, unsigned int f, unsigned int s) //构造函数 &#123; type = t; frequency = f; size = s; cout &lt;&lt; \"构造了一个RAM！\" &lt;&lt; endl; &#125; RAM(RAM &amp;c) //复制构造函数 &#123; type = c.type; frequency = c.frequency; size = c.size; cout &lt;&lt; \"复制构造了一个RAM！\" &lt;&lt; endl; &#125; ~RAM() &#123; cout &lt;&lt; \"析构了一个RAM！\" &lt;&lt; endl; &#125; //析构函数 RAM_TYPE GetType() const &#123; return type; &#125; unsigned int GetFrequency() const &#123; return frequency; &#125; unsigned int GetSize() const &#123; return size; &#125; void SetType(RAM_TYPE t) &#123; type = t; &#125; void SetFrequency(unsigned int f) &#123; frequency = f; &#125; void SetSize(unsigned int s) &#123; size = s; &#125; void Run() &#123; cout &lt;&lt; \"RAM开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; cout &lt;&lt; \"RAM停止运行!\" &lt;&lt; endl; &#125;&#125;;//COMPUTER类class COMPUTER&#123;private: CPU my_cpu; RAM my_ram; unsigned int storage_size; //GB unsigned int bandwidth; //MBpublic: COMPUTER(CPU c, RAM r,unsigned int s, unsigned b); //构造函数 ~COMPUTER() &#123; cout &lt;&lt; \"析构了一个COMPUTER！\" &lt;&lt; endl; &#125; //析构函数 void Run() &#123; my_cpu.Run(); my_ram.Run(); cout &lt;&lt; \"COMPUTER开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; my_cpu.Stop(); my_ram.Stop(); cout &lt;&lt; \"COMPUTER停止运行!\" &lt;&lt; endl; &#125;&#125;;//COMPUTER类的构造函数，内嵌对象采用初始化列表初始化//一共会调用两次复制构造函数，形实结合调用依次，初始化列表调用依次//当COMPUTER构造函数结束以后，形实结合那个形参的生命周期就结束，于是执行析构函数COMPUTER::COMPUTER(CPU c, RAM r, unsigned int s, unsigned int b) :my_cpu(c), my_ram(r)&#123; storage_size = s; bandwidth = b; cout &lt;&lt; \"构造了一个COMPUTER！\" &lt;&lt; endl;&#125;int main()&#123; CPU a(P6, 300, 2.8); a.Run(); a.Stop(); cout &lt;&lt; \"***********************\\n\"; RAM b(DDR3, 1600, 8); b.Run(); b.Stop(); cout &lt;&lt; \"***********************\\n\"; COMPUTER my_computer(a, b, 128, 10); cout &lt;&lt; \"***********************\\n\"; my_computer.Run(); my_computer.Stop(); cout &lt;&lt; \"***********************\\n\"; //return之前会执行析构函数，先析构my_computer，和它的两个内嵌成员，然后析构CPU a和RAM b return 0;&#125; PS：结构体，联合体，枚举类的内容在上一篇文章Cpp基础（6）中。","categories":[],"tags":[]},{"title":"Cpp基础（6）结构体与链表","slug":"Cpp基础（6）结构体与链表","date":"2020-02-02T09:03:07.000Z","updated":"2020-02-03T06:04:23.593Z","comments":true,"path":"2020/02/02/Cpp基础（6）结构体与链表/","link":"","permalink":"http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/","excerpt":"","text":"结构体结构体是一种特殊形态的类，与类的唯一区别是：类的缺省访问权限是private，结构体的缺省访问权限是public。 那么什么时候用结构体而不用类：定义主要用来保存数据，没没有什么操作的类型。人们习惯将结构体的数据成员设为公有，这时使用结构体更方便。 结构体相当于构造了一个新的数据类型，用一组变量描述同一个“事物”。 123456789struct stduent&#123; int id; char name[20]; char sex; int age; float score; char addr[30];&#125;; //注意大括号后的\" ; \" 定义结构体变量的方式： 直接用已声明的结构体类型定义变量名 1student student1, student2; 在声明类型的同时定义变量 123456789struct stduent&#123; int id; char name[20]; char sex; int age; float score; char addr[30];&#125;student1,student2; 结构体数据类型的特性与普通数据类型的特性是一致的，可以赋值，做函数参数，有指向结构体的指针，结构体数组等等。 定义结构体类型的变量12345678910111213141516#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; mike.id_num = 2123000 + mike.id_num; for (int i = 0; mike.name[i] != '\\0'; i++) mike.name[i] = toupper(mike.name[i]); cout &lt;&lt; mike.id_num &lt;&lt; \" \" &lt;&lt; mike.name &lt;&lt; endl; return 0;&#125; 结构体变量赋值12345678910111213141516171819#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike1 = &#123; 123,\"mike\" &#125;; student mike2; mike2 = mike1; mike2.id_num = 2123000 + mike2.id_num; for (int i = 0; mike2.name[i] != '\\0'; i++) mike2.name[i] = toupper(mike2.name[i]); cout &lt;&lt; mike1.id_num &lt;&lt; \" \" &lt;&lt; mike1.name &lt;&lt; endl; cout &lt;&lt; mike2.id_num &lt;&lt; \" \" &lt;&lt; mike2.name &lt;&lt; endl; return 0;&#125; 结构体做函数参数1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;void renew(student one)&#123; one.id_num = 2123000 + one.id_num; for (int i = 0; one.name[i] != '\\0'; i++) one.name[i] = toupper(one.name[i]); cout &lt;&lt; one.id_num &lt;&lt; \" \" &lt;&lt; one.name &lt;&lt; endl;&#125;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; renew(mike); return 0;&#125; 指向结构体的指针1234567891011121314#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; student *one = &amp;mike; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; return 0;&#125; 结构体数组123456789101112131415161718#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student myclass[3] = &#123; 123,\"mike\",133,\"tom\", 143,\"jack\"&#125;; student *one = myclass; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; one++; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; one++; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; return 0;&#125; 枚举类型枚举：如果一个变量只有几种可能的取值，则可以将该变量定义为枚举类型。 枚举类型的定义 1234567//声明一个枚举数据类型weekdayenum weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; //花括号内sun,mon,...,sat等称为枚举元素//定义枚举变量enum weekday workday,weekend;weekday workday,weekend//枚举变量赋值workday = sun; weekend = moon; 需要注意的是： 枚举类型按常量处理，不能对它们赋值。sun = mon; （错误） 枚举类型不能直接输出元素的名字。enum color{red,green,white,black}; color cloth = red; cout&lt;&lt;cloth; //结果为0。 枚举类型可以比较。if(cloth &gt; white) count++ 一个整型不能直接赋给一个枚举变量。workday = 2; （错误） 枚举元素有值： 定义时枚举元素如未指定值，编译系统按定义顺序取默认值依次为0,1,2,3,…. 也可以给枚举元素指定对应的值，enum day {sun=7,mon=1, tue, wed, thu, fri, sat}; 这时有sun=7, mon=1, tue=2, wed=3,...... 若要把整数赋给枚举变量应先进行强制类型转换，workday = (enum weekday) 2; 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;enum color&#123;red,yellow, green=3,blue&#125;;enum color cl;int main()&#123; cl = blue; cout &lt;&lt; \"red=\" &lt;&lt; red &lt;&lt; \" yellow=\" &lt;&lt; yellow &lt;&lt; \" green=\" &lt;&lt; green &lt;&lt; endl; cout &lt;&lt; \"blue=\" &lt;&lt; blue &lt;&lt; \" cl=\" &lt;&lt; cl &lt;&lt; endl; //输出枚举类型的内容 switch (cl) &#123; case red: cout &lt;&lt; \"red\\n\"; break; case yellow: cout &lt;&lt; \"yellow\\n\"; break; case green: cout &lt;&lt; \"green\\n\"; break; case blue: cout &lt;&lt; \"blue\\n\"; break; &#125; return 0;&#125; 例子：计算工资 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; enum day&#123;Mon,Tue,Wed,Thu,Fri,Sat,Sun&#125;; day workDay; double times, wages = 0, hourlyPay, hours; cout &lt;&lt; \"Enter the hourly wages rate.\" &lt;&lt; endl; cin &gt;&gt; hourlyPay; cout &lt;&lt; \"Enter hours worked daily\" &lt;&lt; endl; for (int i = 0; i &lt; 7; i++) &#123; cin &gt;&gt; hours; switch ((day)i) &#123; case Sat:times = 1.5*hours; break; case Sun:times = 2 * hours; break; default:times = hours; &#125; wages = wages + times * hourlyPay; &#125; cout &lt;&lt; \"The wages for the week are \" &lt;&lt; wages &lt;&lt; endl; return 0;&#125; 共用体共用体：为了节省内存空间，可以将几种不同类型的变量存放到同一段内存单元中，这段内存单元所对应的数据结构称为共用体。 共用体的定义：uniom 共用体名{ 成员列表; }变量列表; 12345678union data&#123; int i; char ch; float f;&#125;a,b,c; // 直接定义data a,b,c; //分开定义 共用体的引用：不能引用共用体变量，只能引用共用体变量中的成员。 共用体类型数据的特点： 同一内存段可以存放几种不同类型的成员，但在同一时刻时只能存放其中一种。 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。 共用体变量的地址和它的各成员的地址都是同一地址，如&amp;a, &amp;a.i, &amp;a.ch, &amp;a.f都是同一地址值。 共用体不能初始化，不能对整个共用体赋值。 在函数中，可以使用共用体的指针，但不能使用名字做函数参数。 共用体的空间是所有成员中最大的一个。 例子： 123456789101112struct&#123; int num; char name[10]; char sex; char job; union &#123; int Class; char position[10]; &#125;category;&#125;preson[2]; 链表链表是一种非常常用的动态数据结构，可以用来表示顺序访问的线性群体： 链表头：指向第一个链表结点的指针； 链表结点：链表中的每一个元素，包括：当前结点的数据，下一个结点的地址； 链表尾：不再指向其他结点的结点，其地址部分放一个NULL，表示链表到此结束。 关于new &amp; deletenew：C++运算符，动态地分配内存空间，并将所分配的内存的地址赋给指针变量。 delete：C++运算符，将动态分配的内存空间归还给系统。 用法一： &lt;指针变量&gt; = new&lt;类型&gt;; ​ 分配某种类型大小的一片连续内存空间，并将内存空间的首地址赋给指针变量。 delete&lt;指针变量&gt;; 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = new int; cout &lt;&lt; *p &lt;&lt; endl; *p = 10; cout &lt;&lt; *p &lt;&lt; endl; delete p; return 0;&#125; 用法二： &lt;指针变量&gt; = new&lt;类型&gt;(初值); ​ 分配空间，并将初始值存入所分配的空间中。 delete&lt;指针变量&gt;; 123456789int main()&#123; int *p = new int(10); cout &lt;&lt; *p &lt;&lt; endl; delete p; cout &lt;&lt; *p &lt;&lt; endl; return 0;&#125; 用法三： &lt;指针变量&gt; = new&lt;类型&gt;[&lt;常量表达式&gt;]; ​ 分配指定类型的数组空间，并将数组的首地址赋给指针变量。 delete[ ]&lt;指针变量&gt;; ​ 将指针变量所指向一维数组内存空间归还给系统。 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = new int[5]; memset(p, 0, 20); for(int i=0;i&lt;5;i++) cout &lt;&lt; *(p+i) &lt;&lt; endl; delete p; return 0;&#125; 当new &amp; delete 用于结构体 1234567891011121314#include&lt;iostream&gt;using namespace std;struct Node&#123; int n; Node *next;&#125;;int main()&#123; Node *p = new Node; cout &lt;&lt; p-&gt;n &lt;&lt; endl; cout &lt;&lt; p-&gt;next &lt;&lt; endl; return 0;&#125; 逐步建立链表 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;struct student&#123; int id; student *next;&#125;;student *create()&#123; student *head, *temp; int num, n = 0; head = new student; temp = head; cin &gt;&gt; num; while (num != -1) //-1作为结束符？ &#123; n++; temp-&gt;id = num; temp-&gt;next = new student; temp = temp-&gt;next; cin &gt;&gt; num; &#125; if (n == 0) head = NULL; else temp-&gt;next = NULL; return head;&#125;int main()&#123; student *pointer = create(); while (pointer-&gt;next != NULL) //遍历链表的元素 &#123; cout &lt;&lt; pointer-&gt;id &lt;&lt; endl; pointer = pointer-&gt;next; &#125; return 0;&#125; 删除结点 例子：在链表中将值为n的结点删掉 1234567891011121314151617181920212223242526student *dele(student *head, int n)&#123; student *temp, *follow; temp = head; if (head == NULL) //head为空时，说明链表为空表 return(head); if (head-&gt;id == n) //若第一个节点是要删除的目标 &#123; head = head-&gt;next; delete temp; return(head); &#125; while (temp != NULL &amp;&amp; temp-&gt;id != n) //寻到要删除的目标 &#123; follow = temp; temp = temp-&gt;next; &#125; if (temp == NULL) //若没到找到要删除的目标 cout &lt;&lt; \"not found\"; else &#123; follow-&gt;next = temp-&gt;next; //删除目标结点 delete temp; &#125; return(head);&#125; 插入结点1.将结点unit插入链表的最前面 2.将结点unit插入链表的中间 3.将结点unit插入链表的最后 例子：插入结点值为n的结点（按大小顺序） 12345678910111213141516171819202122232425262728293031323334student *insert(student *head, int n)&#123; student *temp, *unit, *follow; temp = head; unit = new student; unit-&gt;id = n; unit-&gt;next = NULL; if (head == NULL) //如果链表为空，直接插入 &#123; head = unit; return(head); &#125; while ((temp-&gt;next != NULL) &amp;&amp; (temp-&gt;id &lt; n)) //寻找第一个不小于n的结点temp &#123; follow = temp; temp = temp-&gt;next; &#125; if (temp == head) //如果temp为第一个结点 &#123; unit-&gt;next = head; head = unit; &#125; else &#123; if (temp-&gt;next == NULL) //如果temp为最后一个结点 temp-&gt;next = unit; else //如果temp为一个中间结点 &#123; follow-&gt;next = unit; unit-&gt;next = temp; &#125; &#125; return(head);&#125; 单向链表 双向链表 删除结点temp 将结点unit插入到temp之后 例子：约瑟夫环问题问题描述：n个孩子围坐成一圈，并按顺时针编号为1,2,3, ……,n，从编号为p的小孩顺时针依次报数，由1报到m，当报到m时，该小孩从圈中出去，然后下一个小孩再从1报数，当报到m时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号（假设小孩的个数不多于300个）。 关于输入：n,p,m的值在1行内输入，以空格间隔 关于输出：按出圈的顺序输出编号，编号之间以逗号间隔。 思路： 首先定义结点的结构体，列出需要的函数的，然后再考虑每个函数需要完成的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *next; Node *ahead;&#125;;Node *Create(int N);Node *Search(Node *head, int P);Node *Release(Node *head, int M);int main()&#123; int N, P, M = 0; cout &lt;&lt; \"请输入人数N，从几号开始P，报到哪个数M：\" &lt;&lt; endl; cin &gt;&gt; N &gt;&gt; P &gt;&gt; M; Node *head = Create(N); //创建N个结点的环 head = Search(head, P); //找到第P个结点 while (head-&gt;next != head) //不断释放第M个元素，直到只剩一个元素 &#123; head = Release(head, M); &#125; cout &lt;&lt; head-&gt;num; return 0;&#125;Node *Create(int N) //创建包含N个结点的双向循环链表&#123; int n = 1; Node *node = new Node; node-&gt;num = n; Node *head = node; //指向第一节点 Node *tail = head; //指向最后一个节点 while (n++ &lt; N) &#123; node = new Node; //创建新节点 node-&gt;num = n; //赋值 tail-&gt;next = node; //插入新节点 node-&gt;ahead = tail; tail = tail-&gt;next; //尾巴后移一个 &#125; tail-&gt;next = head; head-&gt;ahead = tail; return head;&#125;Node *Search(Node *head, int P) //从head开始寻找第P个节点&#123; while (head-&gt;num != P) &#123; head = head-&gt;next; &#125; return head;&#125;Node *Release(Node *head, int M) //释放Head开始的第M个节点&#123; int count = 1; Node *temp = head; while (count &lt; M) //寻找第M个节点 &#123; temp = temp-&gt;next; count++; &#125; temp-&gt;ahead-&gt;next = temp-&gt;next; //移除第M个节点 temp-&gt;next-&gt;ahead = temp-&gt;ahead; //移除第M个节点 cout &lt;&lt; temp-&gt;num &lt;&lt; \", \"; head = temp-&gt;next; //释放第M个节点所占的内存空间 delete temp; return head;&#125;","categories":[],"tags":[]},{"title":"Cpp基础（5）函数","slug":"Cpp基础（5）函数","date":"2020-01-30T11:41:22.000Z","updated":"2020-02-02T04:13:30.574Z","comments":true,"path":"2020/01/30/Cpp基础（5）函数/","link":"","permalink":"http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数基础函数的定义和声明函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）定义包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。 12345678//计算阶乘int fact(int val)&#123; int ret = 1; while (val &gt; 1) ret* = val--; return ret;&#125; 函数的类型是指函数返回值的数据类型，若函数类型与return语句中表达式的值不一致，则以函数类型为准，系统自动进行类型转换。 1234int bigger(float x, float y)&#123; return (x &gt; y ? x : y); //返回时会转换为整数&#125; 函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作函数原型（function prototype）。 建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 需要注意的是：函数不能嵌套定义，函数间可以互相调用，但不能调用main函数。 函数的调用函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。 123456int main()&#123; int j = fact(5); cout &lt;&lt; \"5! is\" &lt;&lt; j &lt;&lt; endl; return 0;&#125; 一个函数调用的执行过程可以分为3个阶段： 首先把实参值传入被调用函数形参的对应单元中，中断主调函数当前的执行，并且保存返回地点（称为断点）。 执行被调用函数语句，直到return语句返回。若被调用函数中没有return语句，则直到其全部语句执行完毕后自动返回到位于主调函数中的断点处。 从保存的断点处，主调函数继续执行其他剩余语句。 形参和实参实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。 函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名， 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是void，它表示函数不返回任何值。 变量的作用范围根据变量在程序中作用范围的不同，可以将变量分为： 局部变量：在函数内或块内定义，只在这个函数或块内起作用的变量； 全局变量：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量，即在局部变量的作用范围内，全局变量不起作用。 需要注意的是，不在必要时不要使用全局变量。因为全局变量在程序的全部指向过程中都占用存储单元；过多地使用全局变量，程序的可读性变差；会增加函数之间的“关联性”，降低了函数的独立性，使函数可移植性降低。 自动对象与局部静态对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为自动对象（automatic object）。 形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。 有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。 123456789101112//下面的函数统计它自己被调用了多少次size_t count_calls()&#123; static size_t ctr = 0; return ++ctr;&#125;int main()&#123; for (size_t i=0; i!=10; ++i) cout &lt;&lt; cout_calls() &lt;&lt; endl; return 0;&#125; 指针形参指针用做函数参数，在函数内部改变指针的值只能改变局部变量，不会影响实参原来的值；在函数内部通过解引用操作改变指针所指内容的值，即实参指针所指内容的值也发生了改变。 例子：编写一个函数，使用指针形参交换两个整数的值。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void mySWAP(int *p, int *q)&#123; int tmp = *p; *p = *q; *q = tmp;&#125;int main()&#123; int a = 5, b = 10; int *r = &amp;a, *s = &amp;b; cout &lt;&lt; \"交换前：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; mySWAP(r, s); cout &lt;&lt; \"交换后：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 需要注意的是，下面的函数并不能满足要求，因为在函数内部改变指针的值（改变指针所指的地址）只能改变局部变量。 123456void mySWAP(int *p, int *q)&#123; int *tmp = p; p = q; q = tmp;&#125; 引用形参我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。 与值传递（实参的值被拷贝给形参，形参和实参是两个相互独立的变量）不同的是，引用形参是传引用的方式，形参是对应的实参的别名，形参绑定到初始化它的对象，如果改变了形参的值，也就是改变了对应实参的值。 用引用形参重写上面例子中的程序，引用形参绑定初始化它的对象，p绑定我们传给函数的int对象a，改变p的值也就是改变p所引对象的值。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void mySWAP(int &amp;p, int &amp;q)&#123; int tmp = p; p = q; q = tmp;&#125;int main()&#123; int a = 5, b = 10; cout &lt;&lt; \"交换前：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; mySWAP(a, b); cout &lt;&lt; \"交换后：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 使用引用形参避免拷贝拷贝大类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 如果函数无须改变引用形参的值，最好将其声明为常量引用。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量s的内容；二是限制了该函数所能接受的实参类型，我们无法把const对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。 123456789101112131415161718192021//比较两个string 对象的长度bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125;//判断一个string对象是否含有大写字母bool HasUpper(const string &amp;str) //无须修改参数的内容，设为常量引用类型&#123; for (auto c : str) if(isupper(c)) return true; return false;&#125;//把字符串的所有大写字母转成小写void ChangeToLower(string &amp;str)&#123; for (auto &amp;c : str) c = tolower(c);&#125; 使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为一次返回多个结果提供了有效的途径。（对于引用的操作实际上是作用在引用所引的对象上） 例子：定义一个名为find_char的函数，返回string对象中某个指定字符第一次出现的位置，同时能“返回”该字符出现的次数。 一种思路是定义一个新的数据类型，包含位置和数量两个成员，显然比较复杂；另一种更简单的方法是，给函数传入一个额外的引用实参。 123456789101112131415string::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123; auto ret = s.size(); occurs = 0; for (decltyoe(ret) i = 0; i!=s.size(); i++) &#123; if(s[i] == c) &#123; if(ret == s.size()) ret = i; //记录c第一次出现的位置 ++occurs; &#125; &#125; return ret; //出现次数通过occurs隐式地返回&#125; 数组形参数组有两个特殊性质：不允许拷贝数组，以及使用数组时通常会将其转换成指针。所以我们不能以值传递的方式使用数组参数，当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： 1234//这三个print函数是等价的void print(const int*);void print(const int[]);void print(const int[10]); 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型；如果我们传给print函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。以数组为形参的函数也必须确保使用数组时不会越界。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void sum(int *p, int n)&#123; int total = 0; for (int i=0; i&lt;n; i++) &#123; total+=*p++; &#125; cout &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; sum(a,10); return 0;&#125; 多维数组名做函数参数当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，而多维数组的首元素是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。 123//这两个print等价void print(int (*matrix)[10], int rowSize); //（*matrix)的括号不能少void print(int matrix[][10], int rowSize); 例子：求一个$3\\times 4$的矩阵的所以元素中的最大值。 123456789101112131415int maxvalue(int (*p)[4])&#123; int max = p[0][0]; for(int i=0; i&lt;3; i++) for(int j=0; j&lt;4; j++) if(p[i][j] &gt; max) max = p[i][j]; return max;&#125;int main()&#123; int a[3][4] = &#123;&#123;1,3,5,7&#125;,&#123;9,11,13,15&#125;,&#123;2,4,6,8&#125;&#125;; cout &lt;&lt; \"The Max value is\" &lt;&lt; maxvalue(a); return 0;&#125; 数组引用形参形参也可以是数组的引用，此时引用形参绑定到对应的实参上，也就是绑定到数组上。但此时函数只能作用于固定大小的数组。 12345void print(int (&amp;arr)[10]) //只能将函数作用于大小为10的数组，(&amp;arr)的括号不能少&#123; for(auto elem : arr) cout &lt;&lt; elem &lt;&lt;endl;&#125; 函数的递归什么是递归我们已经知道：函数不能嵌套定义，函数可以嵌套调用。那么一个函数能调用“自己”嘛？答案是可以的 例子：已知 n，求n的阶乘$n!$ \\begin{align*} n!&=(n-1)!*n \\\\ (n-1)!&=(n-2)!*(n-1) \\\\ &\\dots \\\\ 2!&=1!*2 \\\\ 1!&=1 \\end{align*}1234567891011121314#include&lt;iostream&gt;using namespace std;int fact(int n)&#123; if(n==1) return 1; else return n*fact(n-1); //每次调用，数据规模缩小&#125;int main()&#123; cout &lt;&lt; fact(4) &lt;&lt;endl; return 0;&#125; 深入理解递归的过程递归调用与普通调用在实质上是一样的。 通过下面的两个例子来理解递归的过程。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int recur()&#123; char c; c = cin.get(); if (c != '\\n') recur(); cout &lt;&lt; c; return 0;&#125;int main()&#123; recur(); return 0;&#125; 12345678910111213141516#include&lt;iostream&gt;using namespace std;int recur()&#123; char c; c = cin.get(); cout &lt;&lt; c; if (c != '\\n') recur(); return 0;&#125;int main()&#123; recur(); return 0;&#125; 递归的作用用递归来完成递推递归的关注点放在求解目标上，重在表现第i次与第i+1次的关系，让程序变得简明。必须要确定第1次的返回结果。 例子：斐波那契数列 \\begin{align*} fab(n)&=fab(n-1)+fab(n-2) \\\\ fab(1)&=1,\\, fab(2)=1 \\end{align*}123456789int f(int n)&#123; if(n == 1) return 1; if(n == 2) return 1; else return(f(n-1)+f(n-2)); &#125; 模拟连续发生的动作主要是搞清楚连续发生的动作是什么；搞清楚不同动作之间的关系；搞清楚边界条件是什么。 例子1：将一个十进制整数转换成二进制数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;void convert(int x)&#123; if ((x / 2) != 0) &#123; convert(x / 2); cout &lt;&lt; x % 2; &#125; else cout &lt;&lt; x;&#125;int main()&#123; int x; cin &gt;&gt; x; convert(x); return 0;&#125; 例子2：汉诺塔问题 相传在古代印度有位僧人整天把三根柱子上的金盘倒来倒去，他想把64个一个比一个小的金盘从一根柱子上移到另一个柱子上去。移动过程中恪守下述规则：每次只允许移动一只盘，且大盘不得落在小盘上面。 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;void move(int m, char A, char B, char C) //表示将m个盘子从A经过B移动到C&#123; if (m == 1) &#123; cout &lt;&lt; \"move 1# from\" &lt;&lt; A &lt;&lt; \"to\" &lt;&lt; C &lt;&lt; endl; //直接可解结点 &#125; else //如果m不为1，则要调用move(m-1) &#123; move(m - 1, A, C, B); cout &lt;&lt; \"move 1# from\" &lt;&lt; A &lt;&lt; \"to\" &lt;&lt; C &lt;&lt; endl; move(m - 1, B, A, C); &#125;&#125;int main()&#123; int n; cout &lt;&lt; \"请输入盘数n=\" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; \"在3根柱子上移\" &lt;&lt; n &lt;&lt; \"个盘子的步骤为：\" &lt;&lt; endl; move(n, 'A', 'B', 'C'); return 0;&#125; 进行“自动的分析”先假设有一个函数能给出答案，再利用这个函数分析如何解决问题；搞清楚最简单的情况下答案是什么。 例子：放苹果 把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？注意：5,1,1和1,5,1是同一种分法。 思路： 假设有一个函数f(m,n)能解决这个问题，那么最简单的情况是m&lt;=1||n&lt;=1，此时只有1种分法。 当n&gt;m时，必有盘子会空着，空着的盘子不影响结果，那么有f(m,n)=f(m,m)。 当n&lt;=m时，分两种情况： (1)如果有盘子空着，那么减少一个盘子也不会影响结果，有f(m,n)=f(m,n-1)。 (2)如果盘子全满，那么每个盘子至少有1个苹果，那么只需考虑剩下m-n个苹果在n个盘子中的分法，则有 f(m,n)=f(m-n,n)。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int count(int m, int n)&#123; if (m &lt;= 1 || n &lt;= 1) return 1; if (m &lt; n) return count(m, m); else return count(m, n - 1) + count(m - n, n);&#125;int main()&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; count(m, n) &lt;&lt; endl;&#125; 递归问题解法小结面对一个问题时： 假设有一个函数f()可以解决问题；接下来考虑这个函数是什么样的？ 找到f^n()与f^n-1()之间的关系； 确定f()的参数； 分析并写出边界条件。 例子1：组合问题 用递归法计算从n个人中选择k个人组成一个委员会，求不同的组合的个数一共是多少？ 思路： 由n个人里选k个人的组合数=由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数； 当n = k或k = 0时，组合数为1。 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int comm(int n, int k)&#123; if (k &gt; n) return 0; else if (n == k || k == 0) return 1; else return comm(n - 1, k) + comm(n - 1, k - 1);&#125;int main() &#123; int n, k; cout &lt;&lt; \"Please enter two integers n and k: \"; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; \"C(n,k) = \" &lt;&lt; comm(n, k) &lt;&lt; endl; return 0;&#125; 探索式递归例子1：下楼问题 从楼上走到楼下共有h个台阶，每一步有3种走法：走1个台阶；走2个台阶；走3个台阶。问可以走出多少种方案？将所有的方案输出。 思路： 既然要列出所有方案，所以需要用一个数组存放每步走的步数，可设为take[99]，步数存放在take[ ]中，满足条件就打印出来； 假设有一个函数Try( )能解决问题，接着寻找Try^n^( )与Try^n+1^( )的关系； Try^n^( )代表走完第n步的状态，即已经填完第n个take[ ]； Try^n( )与Try^n+1( )的关系：在走完第n步后，再走第n+1步时，有三种选择（走1、2、3步），每个选择下有三种可能性： 如果剩下的台阶数小于想要走的步数：返回 如果剩下的台阶数恰好等于要走的步数：打印输出 如果剩下的台阶数大于想要走的步数：走下去 Try( )的参数如何确定：Try^n^( )与Try^n+1^( )之间哪些数据是不一样的？而且是需要由Try^n( )传递给Try^n+1^( )的？ ​ Try^n^( )代表走完第n步的情况，Try^n+1^( )代表走完第n+1步的情况； ​ Try^n^( )需要将走完第 n步后剩余的台阶数传递 给Try^n+1^( )。 ​ 因此可以将Try^n^( )定义为：Try(i, s)，i表示剩余的台阶数，s表示步数。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int take[99]; //记录每一个走的台阶数int num = 0; //num记录解决方案的个数void Try(int i,int s)&#123; for (int j = 1; j &lt;= 3; j++) &#123; if (i &lt; j) continue; take[s] = j; if (i == j) &#123; num++; cout &lt;&lt; \"solution\" &lt;&lt; num &lt;&lt; \": \"; for (int k = 1; k &lt;= s; k++) cout &lt;&lt; take[k]; cout &lt;&lt; endl; &#125; else Try(i - j, s + 1); //take[s]=0; &#125;&#125;int main()&#123; int h = 0; cout &lt;&lt; \"how many stairs:\"; cin &gt;&gt; h; Try(h, 1); cout &lt;&lt; \"There are \" &lt;&lt; num &lt;&lt; \" solutions.\" &lt;&lt; endl; return 0;&#125; 例子2：字母全排列 从键盘读入一个英文单词（全部字母小写，且该单词中各个字母均不相同），输出该单词英文字母的所有全排列。 如输入abc，则打印出abc, acb, bac, bca, cab, cba。 思路： 需要反复做的事情是：选择第n个位置的字母，依次检查每个字母，如果某个字母没被选择过，则进行： 将该字母放第n个位置； 标记该字母已经被选择； 如果全部位置都已选完，打印输出；否则，为下一个位置选择字母； 把刚刚标记过的字母重新标记为“未选择”； 假设一个函数ranker( )能够完成上述事情，每次调用之间的区别在于位置n，ranker(1)—&gt;ranker(2)—&gt;ranker(3)……—&gt;ranker(n)。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;char in[30] = &#123; 0 &#125;; //存放输入的单词char out[30] = &#123; 0 &#125;; //存放准备输出的字符串int used[30] = &#123; 0 &#125;; //记录第i个字母是否已经使用过int length = 0; //记录输入的单词的长度void ranker(int n)&#123; if(n==length) //如果全部字母已经被选择完，则打印输出 &#123; cout &lt;&lt; out &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; length; i++) //依次查看每个字母 &#123; if (!used[i]) //如果某个字母没有被选用 &#123; out[n] = in[i]; //选入该字母 used[i] = 1; //标记该字母已经被选择 ranker(n + 1); //为下一个位置寻找字母 used[i] = 0; //回溯，标记字母未被使用，让其可重新被选择 &#125; &#125;&#125;int main()&#123; cout &lt;&lt; \"Input the word: \"; cin &gt;&gt; in; length = strlen(in); ranker(0); //从第一个字母开始 return 0;&#125; 例子3：分书问题 有编号分别为1, 2, 3, 4, 5的五本书，准备分给A，B，C，D，E五个人，每个人阅读兴趣用一个二维数组加以描述。请写一个程序，输出所有分书方案，让人人都能拿到喜欢的书。 思路： 假设函数trybook( )可以解决问题，从第0个人开始分书，函数trybook(i)应该要完成： 试着给第i个人分书，从0号书开始试，当第i个人喜欢第j个书，且j书还没被选走时（因此要建一个数组记录书被选走的状态），那么第i个人就得到第j本书； 如果不满足上述条件，则什么也不做，返回循环条件； 若满足条件，则做三件事情： 做事：将第j个书分给第i个人，同时记录j书已被选用； 判断：查看是否将所有5个人所要的书分完，若分完，则输出每个人所得之书；若未分完，去寻找其他解决方案； 回溯：让第i个人退回j书，恢复j书尚未被选用的状态。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int like[5][5] = &#123; &#123;0,0,1,1,0&#125;,&#123;1,1,0,0,1&#125;,&#123;0,1,1,0,1&#125;,&#123;0,0,0,1,0&#125;,&#123;0,1,0,0,1&#125; &#125;;int book[5] = &#123; 0 &#125;; //book[5]记录书是否被选用，选用记为1int take[5] = &#123; 0 &#125;; //take[5]记录第i个人领到那本书int num; //num记录分书方案的个数void trybook(int i) //第i个人&#123; for (int j = 0; j &lt;=4; j++) //第j本书 &#123; if ((like[i][j] &gt; 0) &amp;&amp; (book[j] == 0)) //若第i个人喜欢第j本书，且第j本书还没被选用 &#123; take[i] = j; //把第j本书分给第i个人 book[j] = 1; //记录第j本书已经被选用 if (i == 4) //如果第5个人已经拿到书，即书已分完，则输出方案 &#123; num++; cout &lt;&lt; \"第\" &lt;&lt; num &lt;&lt; \"个方案\" &lt;&lt; endl; for (int k = 0; k &lt;= 4; k++) cout &lt;&lt; take[k] &lt;&lt; \"号书给\" &lt;&lt; char(k + 65)&lt;&lt;\" \"; cout &lt;&lt; endl; &#125; else //如果书没分完，则继续给下一个人分书 trybook(i + 1); //take[i] = -1; 把第i个人的书退回，实际上可以不加这一条 book[j] = 0; //回溯，把第j本书标记为未选用 &#125; &#125;&#125;int main()&#123; int n = 0; trybook(0); return 0;&#125; 探索式递归问题的解法第n步需要做什么？对于面前的每种选择： 把该做的事情做了； 判定是否得到解； 递归（调用第n+1步）； 看是否需要回溯。","categories":[],"tags":[]},{"title":"Cpp基础（4）字符数组与字符串","slug":"Cpp基础（4）字符数组与字符串","date":"2020-01-27T03:08:57.000Z","updated":"2020-01-27T14:29:00.012Z","comments":true,"path":"2020/01/27/Cpp基础（4）字符数组与字符串/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符数组与字符串定义字符型用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 初始化与赋值只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 字符/字符数组/字符串的输入与输出一个字符的输入直接用cin输入字符。cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; char c; cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while(cin&gt;&gt;c) //abc def g cout&lt;&lt;c; //abcdefg return 0;&#125; 用cin.get()函数输入可以用于读入一个字符；有2中形式： 无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( (c=cin.get())!= EOF ) //abc def gcout &lt;&lt; c; //abc def g 一个参数cin.get(char) 12345char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; //读取一个字符赋给字符变量cwhile( cin.get(c) ) //abc def gcout &lt;&lt; c; //abc def g 要注意的是，cin.get()遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。 123456char ch1,ch2; cout&lt;&lt;\"请输入两个字符：\"&lt;&lt;endl; cin.get(ch1);//或ch1 = cin.get(); cin.get(ch2); cout&lt;&lt;ch1&lt;&lt;\" \"&lt;&lt;ch2&lt;&lt;endl; cout&lt;&lt;(int)ch1&lt;&lt;\" \"&lt;&lt;(int)ch2&lt;&lt;endl; 输入a[Enter]，读取到结束符&#39;/n&#39;，其仍在缓冲区中被存入ch2，在输出a之后，第二次输出&#39;/n&#39;即换行，而输出的第二个ASCII码值为10，即&#39;/n&#39;的ASCII值，说明cin.get()遇到结束符并不会将之删除。 用getchar()输入字符1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( c = getchar() ) //abc def g 不跳过任何字符cout &lt;&lt; c; //abc def g 字符串的输入直接用cin输入字符123456789#include&lt;iostream&gt;using namespace std;int main() &#123; char str[10]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; while (cin &gt;&gt; str) cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; 用cin.get()函数输入有三个参数的cin.get()函数：cin.get(ch, 10, &#39;/n&#39;) 读取10-1（10减1=9，最后一个为&#39;/0&#39;）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符&#39;/n&#39;，则提前结束读取（如果第3个参数没有指定，则默认为&#39;/n&#39;），而结束符仍在缓冲区中；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。 还要一点要注意，cin.get(ch, 10, &#39;/n&#39;)，当第一个输入字符为结束符时，缓冲区将无该结束符。 1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; char ch1[20]，ch2[20]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; cin.get(ch1,10,'o'); //指定终止符为'o' cin.get(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; return 0;&#125; 输入：we are good friends[Enter]，由于遇到结束符 &#39;o&#39; ，首先读入we are g到ch1，此时ood friends仍在缓冲区，当执行cin.get(ch2,10)会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。 用cin.getline()函数输入用法与上面的cin.get()类似，但也有区别： cin.get()当输入的字符串在结束符之前的长度超过接收长度时，不会引起cin函数的错误，剩余的字符会留在缓冲区，后面若有cin操作，会继续从缓冲区读取；当cin.getline()输入超长时，会引起cin函数的错误，后面的cin操作将不再执行。 cin.get()每次读取一整行并把由Enter键生成的换行符&#39;/n&#39;留在输入队列中，然而cin.getline()每次读取一整行并把由Enter键生成的换行符抛弃。 cin.get()遇到结束符是停止读取，缓冲区指针不移动；cin.getline()遇到结束符时，缓冲区指针移到终止标志字符之后。 123456char ch1[20]，ch2[20];cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl;cin.getline(ch1,10,'o'); //指定终止符为'o' cin.getline(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; //注意与上节的区别 一个需要注意的地方：cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。而无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区， for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); //当执行cin.getline(a[1],10)时，[Enter]被读取到a[1] for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 12345678910111213#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区 cin.get(); //用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了 for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 字符串的输出用cout输出字符数组12345678#include&lt;iostream&gt;using namespace std;int main()&#123; char a[10] = \"Computer\"; cout &lt;&lt; a; return 0;&#125; 需要注意的是，cout输出有终止条件（一般是碰到&#39;\\0&#39;），当用字面值初始化字符数组时，会自动在串尾加上&#39;\\0&#39;；当用列表初始化字符数组时，若不在串尾加上’\\0’，用cout输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。 12char a[8] = &#123; 'C','o','m','p','u','t','e','r' &#125;;cout &lt;&lt; a; 例子1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main() &#123; char str[200]; while (cin.getline(str, 200)) &#123; for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == 'Z')&#123; str[i] = 'A'; continue; &#125; if (str[i] == 'z')&#123; str[i] == 'a'; continue; &#125; if (str[i] == ' ') continue; str[i]++; &#125; cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数strcat，每个输入的串的长度不超过20。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main() &#123; int len1, len2; char str1[40], str2[40]; cin.getline(str1,20); cin.getline(str2, 20); for (len1 = 0; str1[len1] != '\\0'; len1++); for (len2 = 0; str2[len2] != '\\0'; len2++); if (len1 &gt;= len2) &#123; for (len2 = 0; str2[len2] != '\\0'; len2++) str1[len1++] = str2[len2]; //后置++，先执行表达式，再len+1 str1[len1] = '\\0'; //必须要加，要不然cout&lt;&lt;str1会出错 &#125; else &#123; for (len1 = 0; str1[len1] != '\\0'; len1++) str2[len2++] = str1[len1]; str2[len2] = '\\0'; &#125; cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; str2 &lt;&lt; endl; return 0;&#125; 3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == ' ') flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125; 当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if ((str[i] &gt;= 'A'&amp;&amp; str[i] &lt;= 'Z') || (str[i] &gt;= 'a'&amp;&amp;str[i] &lt;= 'z')) flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Cpp基础（3）数组","slug":"Cpp基础（3）数组","date":"2020-01-27T03:06:06.000Z","updated":"2020-01-27T14:32:08.225Z","comments":true,"path":"2020/01/27/Cpp基础（3）数组/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 定义和初始化内置数组数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个常量表达式。 123456constexpr unsigned sz = 42; //常量表达式int arr[10];int *parr[sz];unsigned cnt = 42; // 不是常量表达式string bad[cnt]; // 错误：cnt不是常量表达式 默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。 123456const unsigned sz = 3;int ial[sz] = &#123;0, 1, 2&#125;;int a2[] = &#123;0, 1, 2&#125;;int a3[5] = &#123;0, 1, 2&#125;;string a4[3] = &#123;\"hi\", \"bye\"&#125;;int a5[2] = &#123;0, 1, 2&#125;; //错误 字符数组的特殊性当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。 复杂的数组声明数组能存放大多数类型的对象，可以定义一个存放指针的数组；又因为数组本身是对象，所以允许定义数组的指针及数组的引用。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。 12345int *ptrs[10]; //ptrs是含有10个整型指针的数组int &amp;refs[10] = /* ？ */ //错误：不存在引用的数组int (*Parray)[10] = &amp;arr; //Parray是一个指针，指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef是一个引用，引用一个含有10个整数的数组int *(&amp;arry)[10] = ptrs; //arry是一个引用，引用一个含有10个指针的数组 练习3.27 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？ 12345unsigned buf_size = 1024;int ia[buf_size]; //非法的，因为buf_size不是一个常量表达式int ia[4*7-14]; //正确，因为4*7-14是一个常量表达式int ia[txt_size()]; //非法的，因为txt_size没有被定义为常量表达式 constexprchar st[11] = \"fundamental\" //非法的，因为用字符串字面值初始化，没有空间存放空字符 访问数组元素与标准库类型vector 和string 一样，数组的元素也能使用范围for 语句或下标运算符来访问。数组的索引从0开始。 数组下标通常定义为size_t类型，size_t是一种机器相关的无符号类型，在cstddef头文件中定义。 1234567//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100unsigned scores[11] = &#123;&#125;; //列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。unsigned grade;while (cin &gt;&gt; grade) &#123; if (grade &lt;= 100) ++scores[grade/10];&#125; 与vector 和string 一样，当需要遍历数组的所有元素时，最好的办法是使用范围for语句。 1234//对于scores中的每个计数值输出当前的计数值for (auto i : scores) cout &lt;&lt; i &lt;&lt; \" \";cout&lt;&lt;endl; 必须要检查数组下标的值在合理范围内，下标越界会产生缓冲区溢出。 练习3.31编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。 123456789101112131415include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(auto val: a) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 3.32 将上一题创建的数组拷贝给另外一个数组，利用vector重写程序，实现类似的功能。 //如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。 1234567891011121314include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz], b[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(int j = 0; j &lt; sz: j++) b[j] = a[j]; return 0;&#125; //用vector重写 123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; const int sz = 10; vector&lt;int&gt; vInt, vInt2; for (int i = 0; i &lt; sz; i++) vInt.push_back(i); for (int j = 0; j &lt; sz; j++) vInt2.push_back(vInt[j]); for (auto val: vInt2) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 例子：输出100以内的所有素数。 一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足： 1","categories":[],"tags":[]},{"title":"Cpp基础（2）引用与指针","slug":"Cpp基础（2）引用与指针","date":"2020-01-27T03:02:17.000Z","updated":"2020-01-27T14:31:11.996Z","comments":true,"path":"2020/01/27/Cpp基础（2）引用与指针/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/","excerpt":"","text":"引用与指针复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。 一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。 引用当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成$d的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。 为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。 引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 12345678910int ival = 1024;int &amp;refVal = ival; //refVal指向ivalint &amp;refVal2; //错误。引用必须被初始化refVal = 2; //把值赋给了ivalint &amp;refVal3 = refVal; //正确：refVal3绑定到了那个与refVal绑定的对象上，即ivalint i = refVal; //相当于i = ivalint i = 1024, i2 = 2048;int &amp;r1 = i, &amp;r2 = i2; 指针指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同： （1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。 （2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。 指针运算符*，取地址符&amp; 指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 指针变量：专门用于存放指针（某个变量的地址）的变量 1234int c = 76;int *pointer; //定义名字为pointer的指针变量pointer = &amp;c; //将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c//pointer = c; //错误：因为pointer是存放地址的变量，所以只能存放地址 通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。 12345int c = 76;int *pointer = &amp;c; //*pointer为“pointer所指向的存储单元的内容\"，即是变量ccout &lt;&lt; &amp;c &lt;&lt;endl; //取变量c的地址cout &lt;&lt; &amp;pointer &lt;&lt; endl; //取指针变量c的地址 赋值和指针：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。 1234int i = 42;int *pi = 0; //pi被初始化pi = &amp;ival; //pi所存的地址改变，指向ival*pi = 0; //ival的值被改变，指针pi所存的地址没有改变 &amp;与*`的运算优先级：同级 空指针（null pointer）不指向任何对象。 123int *p1 = nullptr //C++11int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //需要首先#include&lt;cstdlib&gt; 使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。 void*指针：可用于存放任意对象的地址。利用void*指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个void*指针。不能访问其内存空间中所存的对象。 123double obj = 3.14, *pd = &amp;obj;void *pv = &amp;obj;pv = pd;","categories":[],"tags":[]},{"title":"Cpp基础（1）基础语法","slug":"Cpp基础（1）基础语法","date":"2020-01-27T02:59:54.000Z","updated":"2020-01-27T14:11:39.005Z","comments":true,"path":"2020/01/27/Cpp基础（1）基础语法/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"基础语法Hello world1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello world\" &lt;&lt; endl; //变量创建的语法： 数据类型 变量名 = 变量初始值 int a = 10; cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl; system(\"pause\"); return 0;&#125; 变量创建的语法： 数据类型 变量名 = 变量初始值 定义常量的两种方法： #define 宏常量名 常量值 const 修饰的变量 const 数据类型 常量名 = 常量值 定义变量或常量时不要用C++中已经使用的关键字 C++中给标识符（变量，常量）命名时，要注意：1.标识符不可以是关键字2.标识符只能由字母，数字，下划线组成3.标识符的第一个字母只能是字母或者下划线4.标识符中区分大小写5.给变量命名时最好能做到见名知意，方便阅读 数据类型数据类型存在的意义：给不同类型的变量分配合适的内存空间 整型的几种类型：1.短整型 short 2字节 -2^15 - 2^15-12.整型 int 4字节 -2^31 - 2^31-1 //int最常用3.长整型 long 4字节 -2^31 - 2^31-14.长长整型 long long 8字节 -2^63 - 2^63-1 sizeof 关键字可以得到数据类型所占的内存的大小语法： sizeof（数据类型/变量名） 实型/浮点型：用于表示小数1.单精度 float 4字节 7位有效数字2.双精度 double 8字节 15-16位有效数字 字符型：用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型：用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符： 用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 布尔类型bool：代表真或假的值 占用1个字节bool类型只有两个值：true（本质是1） false（本质是0） 数据的输入：用于从键盘获取数据语法：cin &gt;&gt; 变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;using namespace std;int main1() &#123; short num1 = 10; cout &lt;&lt; \"short所占的内存空间为\" &lt;&lt; sizeof(num1) &lt;&lt; endl; float f1 = 3.14f; //编译器会把小数默认为双精度数，所以要在3.14后加上f cout &lt;&lt; \"f1=\" &lt;&lt; f1 &lt;&lt; endl; double d1 = 3.1415926; cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; endl; //显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的 setprecision( ) const double value = 12.3456789; cout &lt;&lt; value &lt;&lt; endl; // 默认以6精度，所以输出为 12.3457 cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35 cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679 cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457 cout.unsetf(ios::fixed); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35 cout &lt;&lt; value &lt;&lt; endl; cout.precision(6); // 恢复成原来的样子，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; //科学计数法 float f2 = 3e2; cout &lt;&lt; \"f2=\" &lt;&lt; f2 &lt;&lt; endl; //查看字符型变量对应的ASCII码 a-97 A-65 char ch = 'a'; cout &lt;&lt; (int)ch &lt;&lt; endl; ch = 97; cout &lt;&lt; ch &lt;&lt; endl; //字符串 char str1[] = \"hello world\"; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = \"hello world\"; cout &lt;&lt; str2 &lt;&lt; endl; //布尔类型 bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; flag = false; cout &lt;&lt; flag &lt;&lt; endl; //数据的输入 string str; cout &lt;&lt; \"请输入字符串变量：\" &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; system(\"pause\"); return 0;&#125; 运算符算术运算符：加+ 减- 乘* 除/ 取模（取余）% 只有整型变量可以进行取模运算需要注意：1.进行运算的变量类型，如两个整型相除结果仍是整数2.除数不能为0，取模运算除数也不能为03.只有整型变量可以进行取模运算，小数不可以 赋值运算符：用于将表达式的值赋给变量赋值= 加等于+= 减等于-= 乘等于*= 除等于/= 模等于%= 比较运算符：用于表达式的比较，并返回一个真值或假值相等于== 不等于!= 小于&lt; 大于&gt; 小于等于&lt;= 大于等于&gt;= 逻辑运算符：用于根据表达式的值返回真值或假值非! 与&amp;&amp; 或|| 要注意运算符的优先级 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main2() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; // a2=11, b2=110 //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; // a3=11, b3=100 //比较运算符 a = 10; b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(\"pause\"); return 0;&#125; 程序流程结构C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构1.顺序结构：程序按顺序执行，不发生跳转2.选择结构：依据条件是否满足，有选择的执行相应功能3.循环结构：依据条件是否满足，循环多次执行某段代码 选择结构if语句：1.单行格式if语句：if (条件) { 条件满足执行的语句}2.多行格式if语句：if (条件) { 条件满足执行的语句} else{条件不满足执行的语句}3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}4.嵌套if语句注意：if条件后面不要加分号 三目运算符：实现简单的判断语法：表达式1 ? 表达式2 : 表达式3解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果 如果表达式1的值为假，执行表达式3，并返回表达式3的结果注意：C++中三目运算符返回的是变量，可以继续赋值 switch语句：执行多条件分支语句语法：switch(表达式){ case 结果1：执行语句;break; case 结果2：执行语句;break; … default:执行语句;break;}注意：1. switch语句中的表达式的数据类型只能是整型或字符型 2. case里如果没有break，那么程序会一直向下执行 3.对于多条件判断，switch的结构清晰，执行效率高 循环结构while循环结构：满足循环条件，执行循环结构 语法：while (循环条件) {循环结构} 注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环 do … while循环语句：满足循环条件，执行循环语句 语法：do {循环语句} while (循环条件) 注意：do…while先执行一次循环语句，再判断循环条件 for 循环语句：满足循环条件 语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句} 注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体 嵌套循环 跳转语句break 语句：用于跳出选择结构或者循环结构 使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环结构 continue语句：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 注意：continue不会使循环终止，而break会跳出循环 goto语句：可以无条件跳转语句 语法：goto 标记 如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;int main()&#123; //嵌套if语句 int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; \"我考上了北大\" &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; \"我考上了清华\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我考上了人大\" &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; \"我考上了二本大学\" &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; \"我考上了三本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上本科\" &lt;&lt; endl; &#125; //三目运算符 int a = 10, b = 20, c = 0; c = a &gt; b ? a : b; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; //b=100 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //a=10 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //b=100 cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //嵌套循环体 //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; \"*\" &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; //continue语句 for (int i = 0; i &lt; 100; i++)&#123; if (i % 2 == 0) continue; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125;","categories":[],"tags":[]},{"title":"搭建自己的博客","slug":"搭建自己的博客","date":"2020-01-18T03:08:31.000Z","updated":"2020-01-18T05:42:11.186Z","comments":true,"path":"2020/01/18/搭建自己的博客/","link":"","permalink":"http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.安装GitGIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：https://gitforwindows.org/，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。 2.安装node.js在官网选择LTS版本下载安装即可：https://nodejs.org/en/download/。 3.安装Hexo在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。 1npm install -g hexo-cli 初始化博客 1hexo init 启动服务：依次执行以下命令 12345npm stallhexo shexo chexo ghexo d 浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决： 1npm install hexo-deployer-git --save 之后每次更新博客内容后都要执行 hexo c —&gt;hexo g —&gt;hexo d，来重新部署。 4.将Hexo部署到GitHub在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式 回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 打开提示已经创建好的.ssh文件夹，其中id_rsa是私人密钥，id_rsa.pub是公共密钥。在GitHub中打开setting —&gt; New SSH key，将id_rsa.pub里面的信息复制进去。 在blog文件夹中打开博客配置文件_config.yml，将最后几行修改为： 1234deploy: type: git repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git branch: master 安装deploy-git 1npm install hexo-deployer-git --save 最后重新部署博客 123hexo chexo ghexo d 这样就可以在 http://yourname.github.io 访问自己的博客了。 5.设置主题我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在blog文件夹下右键GIt Bash Here，下载主题： 1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 打开blog目录下的博客站点配置文件_config.yml，在开头的Site中添加自己博客的信息，注意将language改为zh-CN： 123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-CNtimezone: 往下拉，将theme改为next： 1theme: next 重新部署博客即可看到主题已经替换。 接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。 设置scheme在\\blog\\themes\\next文件夹中打开主题配置文件_config.yml，找到外观scheme，想使用哪一种就把前面的注释符#去掉，我选用的是Mist。 1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单在主题配置文件_config.yml中找到菜单menu，将需要的项前的#去掉，我保留了about关于，categories分类，tags标签，archives归档。 123456789menu: home: &#x2F; || home about: &#x2F;about&#x2F; || user tags: &#x2F;tags&#x2F; || tags categories: &#x2F;categories&#x2F; || th archives: &#x2F;archives&#x2F; || archive #schedule: &#x2F;schedule&#x2F; || calendar #sitemap: &#x2F;sitemap.xml || sitemap #commonweal: &#x2F;404&#x2F; || heartbeat 创建菜单需要的页面： 123hexo new page abouthexo new page tagshexo new page categories 在\\blog\\source下就会生成对应的文件夹，打开其中的index.md文件，将type设置为相应的内容，以about为例： 1234title: aboutdate: 2020-01-17 20:16:07type: &quot;about&quot; comments: false 设置背景动画在主题配置文件_config.yml中找到Animation Settings，我使用的是Canvas-nest，将Canvas-nest下的enable状态改为true即可： 123canvas_nest: enable: true onmobile: true # Display on mobile or not —————————————————————————— 到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。 2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-12T07:14:03.207Z","updated":"2020-01-12T07:14:03.207Z","comments":true,"path":"2020/01/12/hello-world/","link":"","permalink":"http://nekomoon404.github.io/2020/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}