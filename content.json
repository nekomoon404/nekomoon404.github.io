{"meta":{"title":"nekomoon的个人小站","subtitle":"","description":"","author":"nekomoon","url":"http://nekomoon404.github.io","root":"/"},"pages":[{"title":"about","date":"2020-01-17T12:16:07.000Z","updated":"2020-01-17T12:45:38.714Z","comments":false,"path":"about/index.html","permalink":"http://nekomoon404.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-17T12:15:51.000Z","updated":"2020-01-17T12:45:26.408Z","comments":false,"path":"categories/index.html","permalink":"http://nekomoon404.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-17T12:15:21.000Z","updated":"2020-01-17T12:45:12.630Z","comments":false,"path":"tags/index.html","permalink":"http://nekomoon404.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Cpp基础（14）容器","slug":"Cpp基础（14）容器","date":"2020-03-03T00:21:37.000Z","updated":"2020-03-03T02:41:42.312Z","comments":true,"path":"2020/03/03/Cpp基础（14）容器/","link":"","permalink":"http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/","excerpt":"","text":"容器是可容纳各种数据类型的数据结构 包括顺序容器和关联容器 还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器 容器适配器不支持迭代器，由使用者选择合适的底层数据结构 1.顺序容器在顺序容器中，元素的插入位置与元素的值无关： vector （声明于 &lt; vector&gt;） 顺序表：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以自动调整大小，在尾端增删元素时具有较佳的性能 array （C++11 中新增，声明于 &lt; array&gt;）顺序表：封装了一个静态数组，只能在初始化时指定大小 deque （声明于 &lt; deque&gt;）双端队列：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以快速地在数组的头尾两端增删元素 list （声明于 &lt; list&gt;）双向链表：不支持随机存取，但在任何位置增删元素都能在常数时间完成 forward_list （ C++11 中新增，声明于 ）单向链表：list 类的单链表版，去掉了一些操作 1.1. vectorvector 实现了一个动态数组，在实例化 vector 模板类时，需要在 &lt;&gt; 内指定容器中元素的具体类型，元素可以是基本数据类型，也可以是自定义的类。vector 可以在常数时间内完成随机存取元素，支持随机访问迭代器。 vector 可以自动调整大小，在尾端增删元素时具有较佳的性能，可以视为在常数时间内完成；在其他位置增删元素时较慢，与具体的位置有关。所有 STL 算法都能对 vector 操作。 构造 vector 对象时，需要声明具体的数据类型：可以指定一个初始长度，但之后还可以通过其他成员函数改变长度；还可以传入两个参数，分别指定初始长度和元素的初始值。也可以根据一个已有的数组来构造 vector 对象，传入的两个参数分别表示数组的起始和终止位置，是个左闭右开的区间。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; v1; // 长度为 0 的 int 数组 vector&lt;int&gt; v2(5); // 长度为 5 的 int 数组 vector&lt;int&gt; v3(4, 7); // 长度为 4 的 int 数组，且初值都为 7 vector&lt;string&gt; v4(3, “Hi”); // 长度为 3 且值都为 Hi 的 string 数组 double x[] = &#123;1.1, 2.3, 5.8, 13.21&#125;; vector&lt;double&gt; v5(x, x + 4); // 从 x[0..3] 构造一个 double 数组 vector&lt;double&gt; v6(x + 1, x + 2); // 从 x[1] 构造一个 double 数组 return 0;&#125; 访问vector中的元素时，可以通过迭代器来访问或修改元素，也可以通过 [] 或 at() 成员函数访问或修改元素。 123456789101112131415int main() &#123; int p[] = &#123;2, 3, 5, 7, 11&#125;; vector&lt;int&gt; v(p, p + 5); vector&lt;int&gt;::iterator it; //迭代器 for (it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; *it = *it * 2 + 1; &#125; // 输出 2 3 5 7 11 v[3] -= 2; // 修改 v[3] v.at(4) = 17; // 修改 v[4] for (int i = 0; i &lt; v.size(); ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; \" \"; &#125; // 输出 5 7 11 13 17 return 0;&#125; vector 在数组尾部增删元素较快，使用 push_back() 在尾部增加元素，使用 pop_back() 在尾部删除元素。 可以使用 insert() 在任意位置插入一个或一段元素，但效率较低，插入的位置由迭代器来表示；erase() 则可以删除一个或一段元素，用法与 insert() 类似，效率也低。 1234567891011121314int main() &#123; vector&lt;char&gt; v1, v2(3, 'D'); for (int i = 0; i &lt; 4; ++i) &#123; v1.push_back(i + 'A'); &#125; // 依次加入 A B C D v1.pop_back(); // 删除 D v1.insert(v1.begin() + 2, 'Z'); v1.insert(v1.begin(), v2.begin(), v2.end()); vector&lt;char&gt;::iterator it; for (it = v1.begin(); it != v1.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 D D D A B Z C return 0;&#125; 可以使用 resize() 来修改数组的长度，若修改后的长度比现有的要小，则舍弃后面的元素，否则添加缺省元素。 123456789101112131415int main() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; // 依次添加 1 至 10 v.resize(5); // 留下 v[0..4] // 将长度扩展到 8，用 100 填充新元素 v.resize(8, 100); // 将长度扩展到 12，用缺省值 0 填充新元素 v.resize(12); for (int i = 0; i &lt; v.size(); ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; \" \"; &#125; // 输出 0 1 2 3 4 100 100 100 0 0 0 0 return 0;&#125; 1.2. dequedeque 实现了一个双端队列，通过动态数组来实现，可以快速地在数组的头尾两端增删元素，支持随机存储迭代器，可以在常数时间内完成随机存取元素。 所有适用于 vector 的操作都适用于 deque，除此之外，deque 还提供了这些成员函数： front() 取第一个元素（队首）的值 back() 取最后一个元素（队尾）的值 push_front() 将元素插入到最前面 pop_front() 删除第一个元素 1.3. listlist 实现了一个双向链表，不支持随机存取，支持双向迭代器，与 vector 相比，不支持用 [] 来访问任意位置的元素，也不支持将迭代器移动多个单位（即不支持 begin() + i 这样的操作），但支持向前或向后移动（即支持 ++ 和 — ），可以在末尾或开头快速增加或删除元素，在任何位置增删元素都能在常数时间完成。 1234567891011121314int main() &#123; int p[] = &#123;2, 3, 5, 7&#125;; list&lt;int&gt; li(p + 1, p + 4); list&lt;int&gt;::iterator it; for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 3 5 7 li.pop_back(); li.push_back(11); li.pop_front(); li.push_front(2); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 2 5 11 return 0;&#125; list 的构造函数与 vector 类似，可以指定一个初始长度，还可以分别指定初始长度和元素的初始值，也可以根据一个已有的数组来构造 list 对象。与 vector 类似，可以使用 insert() /erase() 在任意位置插入/删除一个或一段元素，且效率较高；与 vector 类似，可以使用 resize() 修改长度。 可以使用成员函数 reverse() 将整个链表反序。 12345678910111213141516#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; list&lt;int&gt; li; list&lt;int&gt;::iterator it; for (int i = 0; i &lt; 7; ++i) li.push_back(i); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 0 1 2 3 4 5 6 li.reverse(); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 6 5 4 3 2 1 0 return 0;&#125; 可以使用成员函数 remove() 删除指定值的元素。 12345678910111213141516#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int p[] = &#123;2, 3, 3, 6, 6, 6&#125;; list&lt;int&gt; li(p, p + 6); list&lt;int&gt;::iterator it; for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 2 3 3 6 6 6 li.remove(3); // 删除链表中所有的 3 for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 2 6 6 6 return 0;&#125; 可以使用成员函数unique() 删除所有和前一个元素相同的元素，注意删除时只与前一个元素比较是否相同，所以最后得到的链表里仍然可能有重复的元素。还可以通过函数自定义元素相同的含义，将函数值返回 true 时，就删除当前元素 12345678910111213#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; double p[] = &#123;0.1, 0.1, 0.2, 0.3, 0.1, 0.8, 1.3&#125;; list&lt;double&gt; li(p, p + 7); list&lt;double&gt;::iterator it; li.unique(); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 0.1 0.2 0.3 0.1 0.8 1.3 return 0;&#125; 1234567891011121314bool is_near(double d1, double d2) &#123; return fabs(d1 - d2) &lt; 0.5; // 相差不超过 0.5 就认为是相同的元素&#125;int main() &#123; double p[] = &#123;0.1, 0.1, 0.2, 0.3, 0.1, 0.8, 1.3&#125;; list&lt;double&gt; li(p, p + 7); list&lt;double&gt;::iterator it; li.unique(is_near); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 0.1 0.8 1.3 return 0;&#125; 由于 list 不支持随机存取，因此无法使用STL中的 sort 算法模板进行排序，只能使用 list 自己的成员函数sort() 来排序，缺省按照 operator &lt; 的含义来排序，可以重载 &lt; 操作符。也可以传入函数指针，通过自定义的函数来重新定义元素的大小。 1234567891011121314bool cmp(int a, int b) &#123; return a % 10 &lt; b % 10; &#125;int main() &#123; int p[] = &#123;2, 11, 27, 9&#125;; list&lt;int&gt; li(p, p + 4); list&lt;int&gt;::iterator it; li.sort(); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 按大小排序，输出 2 9 11 27 li.sort(cmp); for (it = li.begin(); it != li.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 按 % 10 之后的大小排序，输出 11 2 27 9 return 0;&#125; 可以使用成员函数 merge() 合并两个链表，并清空被合并的那个链表。合并的两个链表中的元素必须按照某种规则排好序，否则会出错，因此 merge() 经常配合 sort() 一起使用，合并后的链表也是排好序的，可以自定义排序规则。 123456789101112int main() &#123; int p[] = &#123;2, 3, 5, 7, 11&#125;; list&lt;int&gt; li1(p, p + 4); // 2 3 5 7 list&lt;int&gt; li2(p + 2, p + 5); // 5 7 11 list&lt;int&gt;::iterator it; li1.merge(li2); // li1 和 li2 都是按升序排列好的 for (it = li1.begin(); it != li1.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 2 3 5 5 7 7 11 cout &lt;&lt; li2.size(); // 输出 0 return 0;&#125; 可以使用成员函数 splice() 在指定位置前面插入另一链表中的一个或多个元素，并在另一链表中删除这些被插入的元素。 123456789101112int main() &#123; int p[] = &#123;2, 3, 5, 7, 11&#125;; list&lt;int&gt; li1(p, p + 5), li2(3, 1); list&lt;int&gt;::iterator it = li1.begin(); for (int i = 0; i &lt; 3; ++i) ++it; // 找到 li1 中的 7 li2.splice(li2.begin(), li1, it); // 在 li2 开头插入 7 for (it = li2.begin(); it != li2.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 7 1 1 1 cout &lt;&lt; li1.size(); // li1 中的 7 被删除，输出 4 return 0;&#125; 总结：常用的这三种顺序容器的主要差别在于访问/修改元素与增加/删除元素的速度上，因此需要根据实际情况选用合适的容器。 2.关联容器在关联容器中，元素的插入位置与元素的值有关，必须按相应的排序准则来确定，在查找元素时具有非常好的性能: set / multiset （声明于 #include&lt;set&gt;） 集合：实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）；set 容器中不允许存在相同元素，multiset 容器中允许存在相同的元素 map / multimap （声明于 #include&lt;map&gt;）映射表：实现了一棵平衡二叉搜索树，存放的是成对的键值和数据（key / value），并根据键值对元素进行排序，可快速地根据键值来检索元素；map 容器中不允许存在键值相同的元素，而 multimap 容器中则允许 C++11 中新增的 unordered_set / unordered_multiset （声明于 &lt; unordered_set&gt;）和 unordered_map / unordered_multimap （声明于 &lt; unordered_map&gt;）映射表：通过哈希表实现，功能与 set/multiset 和 map/multimap 相似，但不对键值排序 键值与数据（key-value pair）：在关联容器中，通过键值来查询对应的数据，对于集合容器来说，键值与数据相等。 pair：可以使用 pair 模板来生成 key-value 对，pair 声明于 &lt; utility&gt; 头文件中，pair 中有两个成员变量 first 和 second：first 表示 key，second 表示 value。实例化的 pair 模板类可以用来绑定两个对象为一个新的对象。 比较两个 pair 对象的大小： p1 &lt; p2：如果 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second，则返回 true p1 == p2：如果 p1.first == p2.first &amp;&amp; p1.second == p2.second，则返回 true 声明一个 pair 对象： pair&lt;T1, T2&gt; p：创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化 pair&lt;T1, T2&gt; p(v1, v2)：创建一个 pair 对象，它的两个元素分别是 T1 和 T2 类型，其中 first 成员初始化为 v1，second 成员初始化为 v2 make_pair(v1, v2)：以 v1 和 v2 值创建一个新的 pair 对象，其元素类型分别是 v1 和 v2 的类型 2.1. set/multisetset / multiset 是集合容器，实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）。set 容器中不允许存在相同元素，而 multiset 容器中允许内部元素有序排列，新元素插入的位置取决于其值。 支持双向迭代器，不支持 [] 下标访问元素，但可以通过 find() 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为$O( \\log n)$。可根据 operator &lt; 来比较两个元素的大小，对于自定义的类，需要重载其 &lt; 操作符。 2.1.1. set可使用成员函数 insert() 向集合中增加元素，根据元素对应的 operator &lt; 来确定元素应处的位置，插入容器中已有的元素时，插入操作失败（即不会插入重复的元素）。 1234567891011121314int main() &#123; set&lt;int&gt; s; set&lt;int&gt;::iterator it; for (int i = 0; i &lt; 5; ++i) s.insert(i); for (it = s.begin(); it != s.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 0 1 2 3 4 for (int i = 0; i &lt; 5; ++i) &#123; s.insert(i * 2 + 1); // 想要插入 1 3 5 7 9 &#125; // 但是已经存在 1 和 3，不会重复插入 for (it = s.begin(); it != s.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; // 输出 0 1 2 3 4 5 7 9 return 0;&#125; 对于自定义的类，需要重载 operator &lt; 1234567891011121314151617181920class Customer &#123; int age; string name;public: Customer(int _a, string _n) : age(_a), name(_n) &#123; &#125; bool operator &lt; (const Customer &amp;c) const &#123; if (age == c.age) return name &lt; c.name; return age &lt; c.age; &#125; // 若 age 相同则比较 name，否则比较 age 的大小 void print() const &#123; cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age &lt;&lt; endl; &#125;&#125;;int main() &#123; set&lt;Customer&gt; s; Customer c1(18, \"Alice\"); s.insert(c1); Customer c2(37, \"Bob\"); s.insert(c2); Customer c3(26, \"Daisy\"); s.insert(c3); set&lt;Customer&gt;::iterator it; for (it = s.begin(); it != s.end(); ++it) it-&gt;print(); // 依次输出 Alice 18 、Daisy 26 和 Bob 37 return 0;&#125; 几种查找元素的接口： 使用成员函数 find() 来查找容器中的某个元素 x，若能找到，则返回指向 x 的迭代器，否则返回 end()，在这里，两个元素的相等是根据 operator &lt; 判断的（即同时满足 x &lt; y 为假且 x &gt; y 为假），与 operator == 运算符无关。 使用成员函数 lower_bound() 来查找容器中的某个元素 x，返回第一个大于等于 x 的元素的迭代器，若找不到则返回 end()。 使用成员函数 upper_bound() 来查找容器中的某个元素 x，返回第一个大于 x 的元素的迭代器，若找不到则返回 end()。 使用成员函数 equal_range() 来查找容器中的某个元素 x，返回一个迭代器对（pair），其 first 值就是 lower_bound() ，其 second 值就是 upper_bound()。 使用成员函数 count() 来计算等于某个值的元素个数。 注意通过迭代器访问元素时，先判断迭代器是否等于 end()。 1234567891011121314151617#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;void disp(const set&lt;int&gt; &amp;s, set&lt;int&gt;::iterator it) &#123; if (it == s.end()) cout &lt;&lt; \"Not found.\" &lt;&lt; endl; else cout &lt;&lt; \"Find Element \" &lt;&lt; *it &lt;&lt; endl;&#125;int main() &#123; int f[] = &#123;2, 3, 5, 8, 13, 21&#125;; set&lt;int&gt; s; s.insert(f, f + 6); disp(s, s.find(3)); // 输出 Find Element 3 disp(s, s.find(4)); // 输出 Not found. disp(s, s.lower_bound(8)); // 输出 Find Element 8 disp(s, s.upper_bound(8)); // 输出 Find Element 13 disp(s, s.lower_bound(20)); // 输出 Find Element 21 return 0;&#125; 使用成员函数 erase() 来删除某个元素，传入的参数可以是元素值，若该元素不存在容器中，则删除失败；也可以是指向容器中某个元素的迭代器，迭代器必须是有效的；还可以传入两个迭代器，表示一段左闭右开的区间。 erase()与 find() 、lower_bound()、upper_bound() 以及 begin()、end()、rbegin()、rend() 等配合使用，可以达到一些常见的效果，使用时注意 STL 中的区间一般都是左闭右开的，例如 [ begin(), end() )以及 lower_bound() 与 upper_bound() 在相等元素上的处理区别。 如下程序，假设普通函数 disp(set&lt; int&gt;) 用于输出容器中的所有元素 1234567891011121314151617int main() &#123; int f[] = &#123;2, 3, 5, 8, 13, 21&#125;; set&lt;int&gt; s; s.insert(f, f + 6); disp(s); // 输出 2 3 5 8 13 21 s.erase(8); // 删除值为 8 的元素 disp(s); // 输出 2 3 5 13 21 s.erase(s.begin()); // 删除第一个元素（2） disp(s); // 输出 3 5 13 21 set&lt;int&gt;::iterator p; p = s.lower_bound(5); // 找到 5 s.erase(s.begin(), p); // 删除 3 disp(s); // 输出 5 13 21 p = s.upper_bound(13); // 找到 13 s.erase(s.begin(), p); // 删除 5 和 13 disp(s); // 输出 21 return 0;&#125; 2.1.2. multisetmultiset 在使用上与 set 基本一致，主要区别在于 multiset 允许插入值相同的元素。在使用 find() 查找时，会返回第一个等于该查找值的元素，在使用 erase() 删除等于某个值的元素时，会删除所有等于该值的元素假设 multiset&lt; int&gt; s 中的元素如下： 如下程序，假设普通函数 disp() 用于输出容器set&lt; int&gt;和multiset&lt; int&gt;中的所有元素。 1234567891011121314151617int main() &#123; int f[] = &#123;1, 2, 3, 1, 1, 2, 3, 6&#125;; set&lt;int&gt; s1; s1.insert(f, f + 8); disp(s1); // 输出 1 2 3 6 multiset&lt;int&gt; s2; s2.insert(f, f + 8); disp(s2); // 输出 1 1 1 2 2 3 3 6 s2.erase(2); // 删除所有的 2 disp(s2); // 输出 1 1 1 3 3 6 multiset&lt;int&gt;::iterator it = s2.find(3); s2.erase(it); // 删除第一个 3 disp(s2); // 输出 1 1 1 3 6 // equal_range(1) 找到所有的 1 s2.erase((s2.equal_range(1)).first, (s2.equal_range(1)).second); disp(s2); // 输出 3 6 return 0;&#125; 示例：s1 是一个不允许重复元素的集合，且元素按降序排列，因此输出 9 7 5 3 1；s2 是一个允许有重复元素的容器，缺省将元素按升序排列，因此输出 1 3 3 5 7 9。 12345678910111213141516int main() &#123; int p[] = &#123;9, 1, 3, 5, 7, 3&#125;; set&lt;int, greater&lt;int&gt; &gt; s1; set&lt;int, greater&lt;int&gt; &gt;::iterator i1; multiset&lt;int&gt; s2; multiset&lt;int&gt;::iterator i2; s1.insert(p, p + 5); for (i1 = s1.begin(); i1 != s1.end(); i1++) &#123; cout &lt;&lt; *i1 &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; s2.insert(p, p + 6); for (i2 = s2.begin(); i2 != s2.end(); ++i2) &#123; cout &lt;&lt; *i2 &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; 2.2. map/multimapmap / multimap 是一张映射表，通过平衡二叉搜索树来实现，存放的是成对的 key-value，实例化时需要在 &lt;&gt; 中依次指定 key 和 value 的类型，根据 key 对元素进行排序，可快速地根据 key 来检索元素。map 容器中不允许存在 key 相同的元素，而 multimap 容器中则允许，用法与 set / multiset 类似。 支持双向迭代器，可以通过 find() 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为 $O(\\log n)$。根据 operator &lt; 来比较两个元素的大小，对于自定义的类，需要重载其 &lt; 操作符。 2.2.1. map可以使用成员函数 insert() 向 map 容器中插入元素，注意插入的元素是成对的 key-value，因此是一个个的 pair。可以通过迭代器访问元素，也可以使用 [] 运算符访问容器中已有的 key 对应的元素。 123456789101112int main() &#123; map&lt;string, int&gt; m; m.insert(make_pair(\"Alice\", 18)); m.insert(make_pair(\"Daisy\", 26)); m.insert(make_pair(\"Bob\", 37)); map&lt;string, int&gt;::iterator it; for (it = m.begin(); it != m.end(); ++it) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \"-&gt;\" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; // 依次输出 Alice-&gt;18 Bob-&gt;37 Daisy-&gt;26 int p = m[\"Alice\"]; // p = 18 return 0;&#125; 旧一些的编译器只支持通过 make_pair() 的方式插入元素，新一些的编译器则可以直接通过 [] 来插入元素，如 m[“Alice”] = 18; 。因此当使用 [] 访问元素时，如果 [] 中的 key 不存在于容器中，则可能运行出错，也可能访问到一个未正确初始化的元素（其值不一定有意义）。当向容器中插入一个 key 已经存在的元素时，插入失败，但是可以通过 [] 来修改 key 对应的 value。 使用成员函数 erase() 删除元素，可以传入 key 作为参数，也可以传入指定元素的迭代器；还可以传入两个迭代器，表示删除一个左闭右开的区间内的所有元素。 使用成员函数 find()、lower_bound()、upper_bound() 或者 begin() 、rbegin() 等时，返回的都是 pair 迭代器，因为返回值对应于容器中的元素，而 map 容器中的元素是一个个 pair。 成员函数 equal_range() 的返回值则是一个由两个 pair 组成的 pair 迭代器，例如对于 map&lt;string, int&gt; 容器来说，equal_range() 的返回值类型为 pair&lt;map&lt;string, int&gt;::iterator, map&lt;string, int&gt;::iterator&gt;。因为 equal_range() 返回的是 lower_bound() 和 upper_bound() 构成的 pair，而 map 的 lower_bound() 和 upper_bound() 都是 pair 迭代器。 2.2.2. multimapmultimap 在使用上与 map 基本一致，主要区别在于 multimap 允许插入 key 相同的元素。multimap 不支持使用 [] 运算符访问元素，因为元素的 key 可能重复，用 [] 访问时可能不知道应该访问哪一个。 12345678910111213int main() &#123; map&lt;char, int&gt; m1; multimap&lt;char, int&gt; m2; for (int i = 0; i &lt; 4; ++i) &#123; m1.insert(make_pair(i + 'A', i)); m1.insert(make_pair(i + 'A', i * 2 + 1)); m2.insert(make_pair(i + 'A', i)); m2.insert(make_pair(i + 'A', i * 2 + 1)); &#125; disp(m1); // 输出 A-&gt;0 B-&gt;1 C-&gt;2 D-&gt;3 disp(m2); // 输出 A-&gt;0 A-&gt;1 B-&gt;1 B-&gt;3 C-&gt;2 C-&gt;5 D-&gt;3 D-&gt;7 return 0;&#125; 3.容器适配器在容器适配器中，不提供真正的用于存储元素的数据结构实现，不支持迭代器，由使用者选择合适的底层数据结构： stack （声明于 #include&lt;stack&gt;）栈：是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则 queue （声明于 #include&lt;queue&gt;）队列：插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即按照先进先出的原则 priority_queue （声明于 #include&lt;queue&gt;）优先队列：最高优先级元素总是第一个出队，可视作堆 容器适配器可以用某种顺序容器来实现，即让已有的顺序容器以栈/队列的方式工作。 3.1. stackstack 栈是一种后进先出的数据结构，只能插入、删除、访问栈顶元素。对应的操作为： push() 入栈 / 插入元素 pop() 出栈 / 删除元素 top() 返回栈顶元素的引用 / 访问元素 此外还可以通过成员函数 empty() 来判断栈是否为空，如果想要清空一个栈，只能通过 while (!empty()) pop(); 这样的方式。如下图依次演示了：1 入栈、2 入栈、3 入栈、3 出栈、1 入栈、4 入栈。 stack 在缺省情况下用 deque 实现：template&lt;class T, class Cont = deque&lt;T&gt; &gt;，例如 stack&lt;int&gt; s; 声明了一个元素为 int 型的栈，用 deque 实现。但也可以用 vector 或 list 来实现，例如 stack&lt;string, vector&lt;string&gt; &gt; s; 声明了一个元素为 string 型的栈，用 vector 实现。在声明时可以同时对栈初始化，初始化方式与 vector / deque / list 类似。 3.2. queuequeue 队列是一种先进先出的数据结构，只能在队尾插入元素，只能访问或删除队首元素，对应的操作为： push() 入队 / 插入元素 pop() 出队 / 删除元素 front() 返回队首元素的引用 / 访问元素 queue 在缺省情况下用 deque 实现：template&lt;class T, class Cont = deque&lt;T&gt; &gt;。例如 queue&lt;int&gt; q; 声明了一个元素为 int 型的队列，用 deque 实现。但也可以用 vector 或 list 来实现，例如 queue&lt;string, vector&lt;string&gt; &gt; q; 声明了一个元素为 string 型的队列，用 vector 实现。在声明时可以同时对队列初始化，初始化方式与 vector / deque / list 类似。 3.3. priority_queuepriority_queue 是一个优先队列，也可以看做是一个堆（heap），能保证最大的元素总是在最前面，一些操作为： pop() 删除的是队列中最大的元素（因为最大的元素总是在队首） 没有名叫 front() 成员函数，通过 top() 返回最大元素的引用 通过 push() 添加元素，每次 push() 之后队首元素可能发生变化 priority_queue用法基本和 queue 类似，可以用 vector 和 deque 实现，缺省情况下用vector 实现。缺省情况是根据 less&lt;T&gt; 模板比较大小的，实例化时是个函数对象。可以使用其他的函数对象类模板来定义大小，或者重载元素的 &lt; 运算符，例如 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; 就声明了一个将最小的元素排在队首的优先队列。 例如下面声明了三种队列，设 disp() 可以按序输出队列中的元素。 12345678910111213141516int main() &#123; int v[] = &#123;1, 3, 7, 2, 6, 4, 5&#125;; queue&lt;int&gt; q1; // 普通的队列 priority_queue&lt;int&gt; q2; // 优先队列，降序 // 优先队列，升序 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; for (int i = 0; i &lt; 7; ++i) &#123; q1.push(v[i]); q2.push(v[i]); q3.push(v[i]); &#125; // 依次入队 1 3 7 2 6 4 5 disp(q1); // 输出 1 3 7 2 6 4 5 disp(q2); // 输出 7 6 5 4 3 2 1 disp(q3); // 输出 1 2 3 4 5 6 7 return 0;&#125; 这一章中各容器在数据结构与算法中有详细的介绍，包括原理，实现，效率与优化等等，可以参考我的博客中数据结构与算法categories中的相关文章(┌・ω・)┌✧","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构与算法（13）二叉搜索树","slug":"数据结构与算法（13）二叉搜索树","date":"2020-03-01T09:53:30.000Z","updated":"2020-03-03T14:50:58.915Z","comments":true,"path":"2020/03/01/数据结构与算法（13）二叉搜索树/","link":"","permalink":"http://nekomoon404.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"1.概述回顾在第二，三章作为基础所介绍的两类基本数据结构：向量和列表，虽然它们都已经可以解决相当多的问题，然而对于进一步的算法设计要求来说它们都显得力不从心。基本的数据结构，可以在一定程度上支持静态查找 但很遗憾，并不能高效地兼顾静态查找与动态修改。 在第五章我们做了改进的尝试，通过对一维列表的拓展引入了树结构或者说二叉树结构，二叉树结构可以认为是二维的列表，即列表在维度上的一种扩充。 而这一章要介绍的二叉搜索树（binary search tree，BST），它首先在形式上继承了二叉树也就是列表结构的特点，同时也巧妙地借鉴了向量，或者更准确地讲是有序向量的特点和优势。相对而言后一方面的借鉴更为重要，如果此前对列表结构的借鉴只是外表的形式，那么这种对有序向量特点的借鉴才是一种质的提高，这也是BST相对于其它的数据结构最为 “传神”的部分。实际上BST中所有这些传神的部分都集中体现在其中的一个子集：平衡二叉搜索树（balanced binary search tree，BBST），在接下来的两章中会介绍其中最具代表性的几个变种。 1.1.循关键码访问二叉搜索树的数据项之间，按照各自的关键码彼此区分（call-by-key）。 前提条件是：关键码之间支持大小比较与相等比对。 因此为了简化和抽象不妨将整个数据集中的数据项都已统一地表示和实现为词条entry的形式： 123456789template &lt;typename K, typename V&gt; struct Entry &#123; //词条模板类 K key; V value; //关键码、数值 Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) &#123;&#125;; //默认构造函数 Entry ( Entry&lt;K, V&gt; const&amp; e ) : key ( e.key ), value ( e.value ) &#123;&#125;; //基于克隆的构造函数 bool operator&lt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &lt; e.key; &#125; //比较器：小于 bool operator&gt; ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key &gt; e.key; &#125; //比较器：大于 bool operator== ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key == e.key; &#125; //判等器：等于 bool operator!= ( Entry&lt;K, V&gt; const&amp; e ) &#123; return key != e.key; &#125; //判等器：不等于&#125;; //得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码 若二叉树中各节点所对应的词条之间支持大小比较，则在不致歧义的情况下，我们可以不必严格区分树中的节点、节点对应的词条以及词条内部所存的关键码。 1.2.顺序性在二叉搜索树BST中处处中都满足顺序性： 任一节点r的左子树中的所有节点都不大于r； 任一节点r的右子树中的所有节点都不小于r。 为回避边界情况，这里暂且假设所有节点互不相等，于是上述顺序性便可简化表达为： 任一节点r的左子树中的所有节点都小于r； 任一节点r的右子树中的所有节点都大于r。 当然在实际应用中，对相等元素的禁止既不自然也不必要。顺序性虽然只是对局部特征的刻画，但可由此导出某种全局特征：BST的中序遍历序列，必然单调非降。这一性质也是BST的充要条件，即任何一颗二叉树是二叉搜索树当且仅当中序遍历序列单调非降。（二叉树图中往下垂直投影就可以得到中序遍历序列） 二叉搜索树属于二叉树的特例，故可以基于BinTree模板类派生出BST模板类： 12345678910111213141516171819#include \"BinTree/BinTree.h\" //引入BinTreetemplate &lt;typename T&gt; class BST : public BinTree&lt;T&gt; &#123; //由BinTree派生BST模板类protected: BinNodePosi(T) _hot; //“命中”节点的父亲 BinNodePosi(T) connect34 ( //按照“3 + 4”结构，联接3个节点及四棵子树 BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T) ); BinNodePosi(T) rotateAt ( BinNodePosi(T) x ); //对x及其父亲、祖父做统一旋转调整public: //基本接口：以virtual修饰，强制要求所有派生类（BST变种）根据各自的规则对其重写 virtual BinNodePosi(T) &amp; search ( const T&amp; e ); //查找 virtual BinNodePosi(T) insert ( const T&amp; e ); //插入 virtual bool remove ( const T&amp; e ); //删除 /*DSA*/ /*DSA*/void stretchToLPath() &#123; stretchByZag ( _root ); &#125; //借助zag旋转，转化为左向单链 /*DSA*/void stretchToRPath() &#123; stretchByZig ( _root ); &#125; //借助zig旋转，转化为右向单链 /*DSA*/void stretch(); /*DSA*/void imitate ( const BST&lt;T&gt; &amp; ); //临摹&#125;; 在继承原模板类BinTree的同时，BST内部也继续沿用了二叉树节点模板类BinNode。BST中新增了三个接口search()，insert()，和remove()，这三个标准接口的调用参数都是属于元素类型T的对象引用，这正是此类结构“循关键码访问”方式的具体体现。以BST为基类可以进一步派生出二叉搜索树的多个变种，因此这里的三个接口在前面加上virtual定义为虚函数。由于这些操作接口涉及词条的大小和相等的关系，因此这里假定基本元素类型T直接支持比较和判等操作，或者已重载过对应的操作符。 2.算法及实现2.1. BST：查找二叉搜索树的查找算法，亦采用了减而治之的思路与策略，其执行过程可描述为：从树根出发，逐步地缩小查找范围，知道发现目标（成功）或缩小至空树（失败）。 一般地，在上述查找过程中，一旦发现当前节点为NULL，即说明查找范围已经缩小至空，查找失败；否则，视关键码比较结果，向左（更小）或向右（更大）深入，或者报告成功。对照中序遍历序列可见，整个过程与有序向量的二分查找过程可视为等效。 BST的search()可以实现为下面一段代码： 123456789template &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( const T&amp; e ) //在BST中查找关键码e&#123; return searchIn ( _root, e, _hot = NULL ); &#125; //返回目标节点位置的引用，以便后续插入、删除操作template &lt;typename T&gt; //在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码estatic BinNodePosi(T) &amp; searchIn ( BinNodePosi(T) &amp; v, const T&amp; e, BinNodePosi(T) &amp; hot ) &#123; if ( !v || ( e == v-&gt;data ) ) return v; //递归基：在节点v（或假想的通配节点）处命中 hot = v; //一般情况：先记下当前节点，然后再 return searchIn ( ( ( e &lt; v-&gt;data ) ? v-&gt;lc : v-&gt;rc ), e, hot ); //深入一层，递归查找&#125; //返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL） 节点插入和删除操作，都需要首先调用查找算法，并根据查找结果确定后续的处理方式。因此这里以引用方式传递（子）树根节点，以为后续操作提供必要的信息。searchIn()采用典型的尾递归来实现。这种实现方式是为了统一并简化后续不同搜索树的各种操作接口的实现，其中的技巧体现于返回值和hot变量的语义约定。 若查找成功，则searchIn()和search()的返回值都指向一个关键码为e且真实存在的节点；若查找失败，则返回值的数值为NULL，但它作为引用将指向最后一次试图转向的空节点。对于后一种情况不妨将此空节点转换为一个数值为e的哨兵节点，这样无论成功与否，查找的返回值总是等效地指向“命中节点”。在整个查找的过程中，hot变量始终指向当前节点的父亲，因此在算法返回时，按照如上定义，_hot将统一指向“命中节点”的父亲。而_hot节点是否拥有另一个孩子与查找成功与否无关。 接着分析查找算法的效率，在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故中体所需时间应线性正比与查找路径的长度，或最终返回节点的深度。在最好情况下，目标关键码出现在树根处，只需$O(1)$时间；而规模为n的二叉搜索树，深度在最坏情况下可达$O(n)$，如退化为一条单链，可见最坏情况下查找所需时间为$O(n)$。因此若要控制单词查找在最坏情况下的运行时间，须从控制二叉树的高度入手，后面介绍的平衡二叉树正是基于这一思路而做的改进。 2.2. BST：插入为了在二叉搜索树中插入一个节点，首先要利用search(e)确定插入位置及方向（左孩子还是右孩子），再将新节点作为叶子插入。若e尚不存在，则_hot为新节点的父亲，v=search(e)为 _hot对新孩子的引用。于是只需令 _hot通过v指向新节点。 如图(a)中的二叉搜索树为例，若欲插入关键码40，则在执行search(40)之后，如图(b)，_hot将指向比较过的最后一个节点46，同时返回其左孩子（此时为空）的位置，于是接下来如图(c)，只需将其作为46的左孩子接入。为了保持二叉搜索树作为数据结构的完整性和一致性，还需从节点 _hot(46)出发，自底而上地逐个更新新插入的节点40的历代祖先的高度。 BST的插入算法的代码实现： 1234567template &lt;typename T&gt; BinNodePosi(T) BST&lt;T&gt;::insert ( const T&amp; e ) &#123; //将关键码e插入BST树中 BinNodePosi(T) &amp; x = search ( e ); if ( x ) return x; //确认目标不存在（留意对_hot的设置） x = new BinNode&lt;T&gt; ( e, _hot ); //创建新节点x：以e为关键码，以_hot为父 _size++; //更新全树规模 updateHeightAbove ( x ); //更新x及其历代祖先的高度 return x; //新插入的节点，必为叶子&#125; //无论e是否存在于原树中，返回时总有x-&gt;data == e 按照以上的实现方式，无论插入操作成功与否，都会返回一个非空位置，且该处的节点与拟插入的节点相等，如此可以确保一致性，以简化后续的操作。节点插入操作所需的时间主要消耗于对算法search()和updateHeightAbove()的调用。后者与前者一样都是在每一层至多涉及一个节点，仅消耗$O(1)$时间，故时间复杂度取决于新节点的深度，在最坏情况下不会超过全树的高度$O(h)$。 2.3. BST：删除为从二叉搜索树中删除节点，首先也要调用search()，判断目标节点是否存在与树中，若存在，则需返回其位置。具体的删除操作要分两种情况来讨论： 单分支情况： 如图(a)欲删除节点69，首先通过search(69)定外待删除节点69，该节点的右子树为空，故只需将69与替换为其左孩子64。为保持二叉搜索树作为数据结构的完整性和一致性，还需要更新全树的规模纪录，释放被摘除的节点69，并自下而上地逐个更新节点64历代祖先的高度。注意，首个需要更新高度的祖先58恰好由_hot指示。以上同时已涵盖左、右孩子均不存在（即目标节点为叶节点）的情况。如此操作之后，二叉搜索树的拓扑结构依然完整，顺序性依然满足。 双分支情况： 以上图的二叉树为例，若欲删除节点36，则如图(c)首先调用BinNode::succ()算法找到该节点的直接后继(40)，即中序遍历下的下一个节点，然后交换二者的数据项，则可将后继节点等效地视作待删除的目标节点。而该后继节点必然无左孩子，从而问题转化为上面的单分支情况，于是如图(d)将新的目标节点(36)替换为其右孩子(46)，再释放被摘除的节点(36)，并更新一系列祖先节点的高度，此时首个需要更新高度的祖先，依然恰好由_hot指示，如图(e)。尽管全树的顺序性在中途会不满足，但完成整个删除操作后，全树的顺序性必然恢复。 BST的删除算法的代码实现： 123456789101112131415161718192021222324252627282930template &lt;typename T&gt; bool BST&lt;T&gt;::remove ( const T&amp; e ) &#123; //从BST树中删除关键码e BinNodePosi(T) &amp; x = search ( e ); if ( !x ) return false; //确认目标存在（留意_hot的设置） removeAt ( x, _hot ); _size--; //实施删除 updateHeightAbove ( _hot ); //更新_hot及其历代祖先的高度 return true;&#125; //删除成功与否，由返回值指示/********************************************************************************** * BST节点删除算法：删除位置x所指的节点（全局静态模板函数，适用于AVL、Splay、RedBlack等各种BST） * 目标x在此前经查找定位，并确认非NULL，故必删除成功；与searchIn不同，调用之前不必将hot置空 * 返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲——二者均有可能是NULL *********************************************************************************/template &lt;typename T&gt;static BinNodePosi(T) removeAt ( BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot ) &#123; BinNodePosi(T) w = x; //实际被摘除的节点，初值同x BinNodePosi(T) succ = NULL; //实际被删除节点的接替者 if ( !HasLChild ( *x ) ) //若*x的左子树为空，则可 succ = x = x-&gt;rc; //直接将*x替换为其右子树 else if ( !HasRChild ( *x ) ) //若右子树为空，则可 succ = x = x-&gt;lc; //对称地处理——注意：此时succ != NULL else &#123; //若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要 w = w-&gt;succ(); //（在右子树中）找到*x的直接后继*w swap ( x-&gt;data, w-&gt;data ); //交换*x和*w的数据元素 BinNodePosi(T) u = w-&gt;parent; ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; //隔离节点*w &#125; hot = w-&gt;parent; //记录实际被删除节点的父亲 if ( succ ) succ-&gt;parent = hot; //并将被删除节点的接替者与hot相联 release ( w-&gt;data ); release ( w ); return succ; //释放被摘除节点，返回接替者&#125; //release()负责释放复杂结构，与算法无直接关系 效率：BST的删除操作所需的时间，主要消耗于对search()、succ()和updateHeightAbove()的调用。在树中的任一层，它们各自都至多消耗$O(1)$时间，故总体的渐进时间复杂度，亦不超过全树的高度$O(h)$。 3.平衡二叉搜索树3.1.树高和性能由以上的实现与分析，BST主要接口search()，insert()和remove()的运行时间在最坏情况下，均线性正比于其高度$O(h)$，因此若不能有效地控制树高，则就实际的性能而言，较之此前的向量和列表等数据结构，BST将无法体现出明显优势。比如在最坏情况下，二叉搜索树可能彻底地退化为列表，此时的查找效率甚至会降至$O(n)$，线性正比于树（列表）的规模。那么出现此类最坏或较坏情况的概率有多大，或者从平均复杂度的角度看，二叉搜索树的性能究竟如何呢？下面按两种常用的随机统计口径，就BST的平均性能做一分析和对比。 随机生成： 考查n个互异词条$\\{e_1,e_2,\\dots,e_n\\}$，对任一排列$\\sigma=(e_{i_1},e_{i_2},\\dots,e_{i_n})$，从空树开始，通过依次执行insert($e_{i_k}$)，即可得到这n个关键码的一棵二叉搜索树$T(\\sigma)$。与随机排列$\\sigma$相对应的$T(\\sigma)$称为由$\\sigma$随机生成（randomly generated）。下图以关键码为例$\\{1,2,3\\}$为例，列出了由其所有排列生成的二叉搜索树。 显然任意的n个互异关键码都可以构成$n!$种全排列，若设各排列作为输入序列的概率均等，则在随机生成下二叉搜索树的平均高度为$\\Theta(\\log n)$。 随机组成： 另一种随机策略是，假定n个互异节点同时给定，然后在遵守顺序性的前提下，随机确定它们之间的拓扑联接关系，如此所得的二叉搜索树，称为由这组节点随机组成（randomly composed）。 由n个互异节点组成的二叉搜索树，总共有： T(n)=\\sum_{k=1}^n SP(k-1)\\cdot SP(n-k)=Catalan(n)=\\frac{(2n)!}{(n+1)!\\cdot n!}若设所有BST等概率出现，则其平均高度为$\\Theta(\\sqrt{n})$。 随机生成口径的$\\Theta(\\log n)$和随机组成口径的$\\Theta(\\sqrt{n})$之间就渐进意义为言有实质的差别。原因在于随机生成下，同一组关键码的不同排列所生成的二叉搜索树，未必不同，会发现中位数越早插入，树的高度越低即越平衡，而实际上越是平衡的树，被统计的次数亦越多。从这个角度看，随机生成口径有些“乐观”，高估了二叉搜索树的平均性能，因而按照随机组成口径得到的$\\Theta(\\sqrt{n})$更可信。 实际上按照随机组成口径统计出的平均树高，仍不足以反映树高的随机分布情况，在实际应用中，理想的随机并不常见，一组关键码往往会按照（接近）单调次序出现，树高较大的情况依然可能频繁出现。另外若removeAt()操作总是固定地将待删除的二度节点与其直接后继交换，则随着操作次数的增加，二叉搜索树向左侧倾斜的趋势将愈发明显。 3.2.理想平衡与适度平衡理想平衡： 在节点数目固定的前提下，应尽可能地降低高度，相应地应尽可能使兄弟子树的高度彼此接近，即全树尽可能平衡。由n个节点组成的二叉树，高度不低于$\\log_2 n$，当高度恰为$\\log_2 n$时称作理想平衡，即大致相当于完全二叉树或者满树，但是“叶节点只能出现于最底部的两层”—这一条件过于苛刻。此类二叉树所占的比例极低，而随着二叉树规模的增大，这一比例还将减小，且对二叉树的动态操作很容易就破坏了这种理想操作。 适度平衡： 若将树高限制为“渐进地不超过$O(\\log n)$，称作适度平衡。适度平衡的BST称为平衡二叉搜索树（balanced binary search tree，BBST），如之后要介绍的伸展树，红黑树，kd-树等都属于BBST。 3.3.等价变换3.3.1.等价二叉搜索树若两棵二叉搜索树的中序遍历序列相同，则称它们彼此等价。如下图两个由11个节点组成的相互等价的二叉搜索树，它们在拓扑关系上有差异。 等价二叉搜索树的特点可概括为： 上下可变：联接关系不尽相同，承袭关系可能颠倒 左右不乱：中序遍历序列完全一致，全局单调非降 3.3.2.局部性平衡二叉搜索树的适度平衡性，都是通过对树中每一局部增加某种限制条件来保证的。除了适度平衡性外，还具有如下局部性： 单次动态修改操作后，至多$O(1)$处局部不再满足限制条件 可在$O( \\log n)$时间内，使这些局部（以至全树）重新满足 这就意味着刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的BBST，等价二叉搜索树之间的上述转换过程，也称作等价变换。 3.3.3.旋转调整最基本的等价变换方法，即修复局部性失衡的方法，就是通过围绕特定节点的旋转，实现等价前提下的局部拓扑调整。 zig和zag： zig和zag旋转均属于局部操作，仅涉及常数个节点及其之间的联接关系，故均可在常数时间内完成。每经过一次zig或zag旋转之后，节点v的深度加一，节点c的深度减一；这一局部子树（乃至全树）的高度可能发生变化，但上下幅度均不超过一层。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Cpp基础（13）STL","slug":"Cpp基础（13）STL","date":"2020-02-28T01:37:54.000Z","updated":"2020-02-28T04:05:25.307Z","comments":true,"path":"2020/02/28/Cpp基础（13）STL/","link":"","permalink":"http://nekomoon404.github.io/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/","excerpt":"","text":"1.C++标准库 C++ 标准库（C++ Standard Library）是一个类库和函数的集合 提供了若干泛型容器、函数对象、泛型字符串和流、常用函数等 声明在 std 名字空间中 using namespace std; 吸收了 ISO C90 C 标准程序库原有的 C 标准库中的所有头文件，都移去末尾的 .h 并在开头加上 c，如 &lt;stdio.h&gt; 变为 &lt;cstdio&gt; C++ 标准模板库（C++ Standard Template Library，STL） 是 C++ 标准库的一个子集 包括容器、算法、迭代器和函数对象 包含标准库声明的一些头文件关系： 2.C++标准库模板 C++ 中主要有两个方面体现了重用 面向对象的设计思想，包括继承和多态，以及标准类库 泛型程序设计（generic programming）的思想，包括模板机制，以及标准模板库（STL） 泛型程序设计，简单来说就是使用模板的程序设计法 将一些常用的数据结构（如链表、队列、二叉树）和算法（如排序、查找）写成模板，无论数据结构里放的是什么类型的对象 标准模板库（Standard Template Library，STL）就是一些常用数据结构和算法模板的集合 STL大致可以视为由四部分组成：容器、迭代器、算法、函数对象 2.1.容器 容器是可容纳各种数据类型的数据结构 包括顺序容器和关联容器 还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器 容器适配器不支持迭代器，由使用者选择合适的底层数据结构 在顺序容器中，元素的插入位置与元素的值无关： vector （声明于 &lt; vector&gt;） 顺序表：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以自动调整大小，在尾端增删元素时具有较佳的性能 array （C++11 中新增，声明于 &lt; array&gt;）顺序表：封装了一个静态数组，只能在初始化时指定大小 deque （声明于 &lt; deque&gt;）双端队列：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以快速地在数组的头尾两端增删元素 list （声明于 &lt; list&gt;）双向链表：不支持随机存取，但在任何位置增删元素都能在常数时间完成 forward_list （ C++11 中新增，声明于 ）单向链表：list 类的单链表版，去掉了一些操作 在关联容器中，元素的插入位置与元素的值有关，必须按相应的排序准则来确定，在查找元素时具有非常好的性能: set / multiset （声明于 #include&lt;set&gt;） 集合：实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）；set 容器中不允许存在相同元素，multiset 容器中允许存在相同的元素 map / multimap （声明于 #include&lt;map&gt;）映射表：实现了一棵平衡二叉搜索树，存放的是成对的键值和数据（key / value），并根据键值对元素进行排序，可快速地根据键值来检索元素；map 容器中不允许存在键值相同的元素，而 multimap 容器中则允许 C++11 中新增的 unordered_set / unordered_multiset （声明于 &lt; unordered_set&gt;）和 unordered_map / unordered_multimap （声明于 &lt; unordered_map&gt;）映射表：通过哈希表实现，功能与 set/multiset 和 map/multimap 相似，但不对键值排序 在容器适配器中，不提供真正的用于存储元素的数据结构实现，不支持迭代器，由使用者选择合适的底层数据结构： stack （声明于 #include&lt;stack&gt;）栈：是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则 queue （声明于 #include&lt;queue&gt;）队列：插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即按照先进先出的原则 priority_queue （声明于 #include&lt;queue&gt;）优先队列：最高优先级元素总是第一个出队，可视作堆 所有 STL 容器的共有的成员函数： operator = / &lt; / &lt;= / &gt; / &gt;= / == / != ： 比较元素大小 empty() ：判断容器中是否有元素 max_size() ：容器中最多能装多少元素 size() ：容器中的元素个数 swap()：交换两个容器对象中的内容 只在顺序容器和关联容器中的成员函数： begin()：返回指向容器中第一个元素的迭代器 end()：返回指向容器中最后一个元素后面的位置的迭代器 rbegin()：返回指向容器中最后一个元素的迭代器 rend()：返回指向容器中第一个元素前面的位置的迭代器 erase()：从容器中删除一个或几个元素 clear()：从容器中删除所有元素 除前述共同操作外，顺序容器还有以下共同操作： front()：返回容器中第一个元素的引用 back()：返回容器中最后一个元素的引用 push_back()：在容器末尾增加新元素 pop_back()：删除容器末尾的元素 2.2.迭代器迭代器用于指向顺序容器和关联容器中的元素，实际上就是泛化的指针，有 const 和非 const 两种： const_iterator 对于遍历 const 容器是必需的，允许以只读方式访问容器的底层元素； 通过迭代器可以读取它指向的元素，通过非 const 迭代器还能修改其指向的元素，用法和指针类似。 使用“容器类名::iterator ”或“容器类名::const_iterator ”声明： 例如 vector&lt;int&gt;::iterator it; 或 set&lt;string&gt;::const_iterator it; 读取元素时就可以用 *it 来实现 迭代器上可以执行自增（++）操作，以指向容器中的下一个元素： 如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成 past-the-end 值，其与 NULL 的含义类似。 不同容器上支持的迭代器功能强弱有所不同，按功能由弱到强，可以将迭代器分为 5 种： 输入迭代器 Input iterators 和 输出迭代器 Output iterators提供对数据的只读或只写访问 正向迭代器 Forward iterators提供读写操作，并能一次一个地向前推进迭代器 双向迭代器 Bidirectional iterators提供读写操作，并能一次一个地向前和向后移动 随机访问迭代器 Random access iterators提供读写操作，并能在数据中随机移动 注意：强迭代器拥有弱迭代器的所有功能，能当作弱迭代器使用。 不同迭代器所能进行的操作如下所示： 所有迭代器： ++p、p++ 输入迭代器： *p、p = q、p == q、p != q 输出迭代器： *p、p = q 正向迭代器： 以上所有 双向迭代器： 以上所有，以及 --p、p-- 随机访问迭代器： 以上所有，以及移动 i 个单元（p += i、p -= i、p + i、p – i）、大小比较（p &lt; q、p &lt;= q、p &gt; q、p &gt;= q）、数组下标访问p[i]（p 后面的第 i 个元素的引用） 容器所支持的迭代器类别如下： 示例： 1234567891011121314151617181920212223#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; vector&lt;int&gt; v; // 一个存放 int 型元素的向量，一开始是空的 // 依次放入 1 2 3 4 v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); // 使用常量迭代器打印这个容器中的元素 vector&lt;int&gt;::const_iterator i; for (i = v.begin(); i != v.end(); ++i) cout &lt;&lt; *i &lt;&lt; \" \"; cout &lt;&lt; endl; // 输出 1 2 3 4 // 非常量迭代器修改容器中的元素 vector&lt;int&gt;::iterator j; for (j = v.begin(); j != v.end(); ++j) *j = 100; // 再次使用常量迭代器打印这个容器中的元素 for (i = v.begin(); i != v.end(); i++) cout &lt;&lt; *i &lt;&lt; \" \"; cout &lt;&lt; endl; // 输出 100 100 100 100 return 0;&#125; 2.3.算法算法就是一个个函数模板，STL 中提供了能在各种容器中通用的算法，如插入、删除、查找、排序等，约有70种标准算法。算法可以处理容器，也可以处理内置类型的数组。 算法通过迭代器来操纵容器中的元素，许多算法需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。有的算法返回一个迭代器，比如 find() 算法，其功能是在容器中查找一个元素，并返回一个指向该元素的迭代器。 头文件 #inlcude&lt;algorithm&gt; 中实现了一些常见的针对序列区间的算法：包括不修改值的序列操作、修改值的序列操作、分割与合并、查找与排序、堆操作、排列相关操作等。 头文件 #include&lt;numeric&gt; 中则实现了一些特别针对数值序列的算法 accumulate()：累加一个区间中的值 adjacent_difference()：依次计算一个区间内每一对相邻元素的差 inner_product()：计算两个向量的内积 下面介绍一些&lt; algorithm&gt;中实现的常见算法： 不修改值的序列操作for_each()：遍历一个区间内的元素find()：在一个区间中进行查找指定的元素count()：在一个区间中计数指定元素search()：在一个区间中查找指定的子序列 修改值的序列操作copy()：复制一个区间的内容swap()：交换两个对象的值replace()：替换一个区间中的某个值unique()：去重，删除相邻的相同元素random_shuffle()：随机洗牌，重排区间中的元素 分割与合并partition()：将一个区间根据指定规则分割为两个merge()：将有序区间合并set_intersection()：找出两个区间中相同的元素set_difference()：找出两个区间中不同的元素 查找binary_search()：二分查找min_element()：查找最小的元素max_element()：查找最大的元素 排序sort()：用快速排序算法给一个区间中的元素排序 堆（Heap）make_heap()：根据指定序列构建堆push_heap()：向堆中插入元素pop_heap()：弹出堆顶元素 排列next_permutation()：产生指定序列的下一个排列prev_permutation()：产生指定序列的上一个排列 2.4.函数对象函数对象即重载了操作符 () 的对象，类的实例都可以称作为函数对象，本身是对象，但是用起来看上去象函数调用，实际上也执行了函数调用。 STL 中的头文件 &lt; functional&gt; 里实现了一些函数对象类模板，例如 equal_to&lt; T&gt;、greater&lt; T&gt;、less&lt; T&gt; 等这些模板都可以用来生成函数对象。 函数对象可以包含其他成员变量或成员函数，函数对象的优点是可以在对象内部修改而不用改动外部接口，可以存储先前调用结果的数据成员，编译器可通过内联函数对象来增强性能。 例如下面声明了一个函数对象 average 计算均值： 1234567891011121314151617class Average &#123;public: double operator()(int a1, int a2) &#123; return (double)(a1 + a2) / 2; &#125; double operator()(int a1, int a2, int a3) &#123; return (double)(a1 + a2 + a3) / 3; &#125;&#125;; // 重载 () 运算符时，参数可以是任意多个int main() &#123; Average average; // 函数对象 // 调用 average.operator(2, 3, 5) // 但是使用时看上去象普通函数调用 cout &lt;&lt; average(2, 3, 5) &lt;&lt; endl; // 输出 3.33333 cout &lt;&lt; average(7, 11) &lt;&lt; endl; // 输出 9 return 0;&#125; 例2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class IntMod &#123; int p;public: IntMod(int _p) : p(_p) &#123; &#125; bool operator() (int v1, int v2) &#123; return v1 % p &gt;= v2 % p; &#125; bool operator() (float v1, float v2) &#123; return (int)(v1) * p % 10 &gt;= (int)(v2) * p % 10; &#125;&#125;; //IntMod 类重载了 ()对于 int 型，比较 %p 之后的大小//对于 float 型，先转换成 int 型，然 后比较 *p 后 %10 的大小template &lt;class T&gt;T myMax(T *pV, int n, IntMod fun) &#123; T result = *pV; for (int i = 1; i &lt; n; ++i) &#123; if (!fun(result, *(pV + i))) &#123; result = *(pV + i); &#125; &#125; return result;&#125;//函数模板 myMax() 寻找最大值，可以处理不同类型的数组//根据 IntMod 类中定义的大小关系，找到不同类型数组中的最大值int main()&#123; int a[5] = &#123;3, 9, 12, 5, 20&#125;; float b[5] = &#123;3, 9, 12, 5, 20&#125;; IntMod obj1(8), obj2(3); cout &lt;&lt; myMax(a, 5, obj1) &lt;&lt; endl; //第一行输出对应 int 型数组 a，数组长度为 5，对 8 模后取余 //即找到 %8 之后最大的整数，因此最大值是 5，输出 5 cout &lt;&lt; myMax(b, 5, obj1) &lt;&lt; endl; //第二行输出对应 float 型数组 b，数组长度为5,*8后对10模后取余 //即找到 *8 %10 之后最大的数，因此最大值是 12，输出 12 cout &lt;&lt; myMax(a, 5, obj2) &lt;&lt; endl; //第三行输出对应 int 型数组 a，数组长度为 5，对 3模后取余 //即找到 %3 之后最大的整数，若有相等的情况找靠前的那个，因此最大值是 5，输出 5 cout &lt;&lt; myMax(b, 5, obj2) &lt;&lt; endl; //输出3 return 0;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构与算法（12）广度/深度优先搜索","slug":"数据结构与算法（12）广度-深度优先搜索","date":"2020-02-26T01:31:21.000Z","updated":"2020-02-27T13:21:14.014Z","comments":true,"path":"2020/02/26/数据结构与算法（12）广度-深度优先搜索/","link":"","permalink":"http://nekomoon404.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"1.广度优先搜索1.1.算法 始自顶点s的广度优先搜索（Breadth-First-Search） 访问顶点s 依次访问s所有尚未访问的邻接顶点 依次访问它们尚未访问的邻接顶点 …….如此反复，直至没有尚未访问的邻接顶点 这种搜索将首先访问s，在这个图中通过将s染黑表示它已经接受了访问。接下来需要访问S所有尚未访问的邻接顶点，由s通往它的那些刚被访问的邻居的边都被加粗，这暗示着这些边都已经被算法所采纳和保留，这些边都是非常重要的，它们携带了整个遍历过程中所发现的一些信息。反过来在原图中还会有一些边并不采纳（浅色线部分）在经过广度优先遍历之后，它们将不再保留而是被舍弃掉。 这个算法将不断地如此迭代反复，直到所有的顶点都接受了访问。所谓广度优先搜索的确是一种遍历，它会按照刚才所介绍的策略确定不同顶点接受访问的次序，并且按照这种次序对各顶点逐个地访问，而整个搜索过程的最终产物或成果不过是选自原图的一系列的加粗的边。 这里按照与起点s的距离将所有的顶点划分为若干个等价类，在同一等价类内部各顶点的边都不会被采纳，而只有连接于相邻等价类之间的某些边才会被采纳。所有被保留下来并且采纳的这些边将足以把所有的顶点连接起来构成一个连通图，且它是一个极大无环图。这就相当于一棵树，这棵树中涵盖了原图的所有的顶点，所以称之为支撑树（Spanning Tree）。对于树而言，以上策略及过程完全等同于层次遍历。 1.2.实现上述的策略可以实现而这样一段代码： 123456789101112131415161718template &lt;typename Tv, typename Te&gt; //广度优先搜索BFS算法（单个连通域）void Graph&lt;Tv, Te&gt;::BFS ( int v, int&amp; clock ) &#123; //assert: 0 &lt;= v &lt; n Queue&lt;int&gt; Q; //引入辅助队列 status ( v ) = DISCOVERED; Q.enqueue ( v ); //初始化起点 while ( !Q.empty() ) &#123; //在Q变空之前，不断 int v = Q.dequeue(); dTime ( v ) = ++clock; //取出队首顶点v for ( int u = firstNbr ( v ); -1 &lt; u; u = nextNbr ( v, u ) ) //枚举v的所有邻居u if ( UNDISCOVERED == status ( u ) ) &#123; //若u尚未被发现，则 status ( u ) = DISCOVERED; Q.enqueue ( u ); //发现该顶点 status ( v, u ) = TREE; parent ( u ) = v; //引入树边拓展支撑树 &#125; else &#123; //若u已被发现，或者甚至已访问完毕，则 status ( v, u ) = CROSS; //将(v, u)归类于跨边 &#125; status ( v ) = VISITED; //至此，当前顶点访问完毕 &#125;&#125; 可以看到遍历的起点总是某个预先指定的顶点v，既然图的广度优先遍历可以视作为树的层次遍历的一种推广，所以与后者相仿这里依然借助一个队列结构来实现。在v入队之前将它的状态由最初的undiscovered转化为discovered，接下来的while循环每次都通过dequeue()取出队首的顶点并且重新命名为v。 请注意 在每一个顶点刚刚出队并随即接受访问的同时，我们还需要给它打上一个时间标签dTime，在算法的入口处还有一个名为clock的引用型参数，它就像是一块钟表在整个算法的运行过程中都会给出时间的进度，任何时候如果你希望加注当前的时间标签，只需要将这块表取出来并读取上面的时刻。 按照算法的策略我们需要枚举出当前节点v的所有邻居，通过for循环语句来实现，firstNbr以及nextNbr接口在上文有介绍过。 经过整个的遍历搜索过程，每一个顶点的状态都会由最初的undiscovered转化为discovered，并最终转化为visited，这样的三个状态也就构成了每一个顶点在它的生命期内的三部曲。 下面以一个无向图为例来理解算法的过程： 1.3.全图BFS与起始顶点s相连通的每一个顶点都会被bfs搜索、发现并访问，即s顶点所属的那个连通域确实可以被悉数的遍历。然而问题是并非每幅图都只包含一个连通域，那么在含有多个连通域的时候从任何一个起点s出发未必能够抵达其它的连通域。那么这种情况如何处理，如何使得bfs搜索足以覆盖整幅图呢，可以采用下面的方法： 12345678template &lt;typename Tv, typename Te&gt; //广度优先搜索BFS算法（全图）void Graph&lt;Tv, Te&gt;::bfs ( int s ) &#123; //assert: 0 &lt;= s &lt; n reset(); int clock = 0; int v = s; //初始化 do //逐一检查所有顶点 if ( UNDISCOVERED == status ( v ) ) //一旦遇到尚未发现的顶点 BFS ( v, clock ); //即从该顶点出发启动一次BFS while ( s != ( v = ( ++v % n ) ) ); //按序号检查，故不漏不重&#125; 这里毕竟引入了一层新的循环而且至少从表面看来，这个循环的迭代次数将多达线性次。但这里并非对每一个顶点都启动一轮bfs搜索，而是只有在当前的顶点能够经过这个if判断（顶点尚未被发现）之后才启动这样一次搜索。这种处理方式可以保证对于每一个连通域只有一个顶点可能作为起点引起它所属的那个连通域被完全的遍历掉，每一个连通域启动而且只启动一次广度优先搜索，因此所有花费在搜索上的时间累计也不过是对全图的一次遍历，而不是多次。 1.4.复杂度广度优先搜索算法的复杂度取决于不同实现方法，尤其是图结构自身的实现算法，这里不妨就以我们的实现版本为例，算法主体的复杂度部分是由while以及for所构成的两重循环。 1.5.最短路径最好来讨论BFS算法的一个特性：最短距离性。 回顾此前所介绍的树结构，相对于树根节点任何一个节点v都对应于一条唯一的通路，这条路径的长度称作顶点v的深度depth(v)，于是我们可以对所有的顶点自上而下按照它们的深度进行等价类划分，在每一个等价类中的所有顶点所具有的深度指标都是彼此相等的。而树的层次遍历也可以认为是按照这一指标非降的次序，将所有的顶点逐一枚举出来。 那么这样一个遍历的过程是否也可以转化为图结构的遍历过程呢？表面看来似乎不太容易，因为此时与树结构极不相同的就是从起始顶点s出发可能有多条路径都最后通往同一个顶点，而且可能出现分叉。然而这样一个问题不难解决，实际上我们只需考察顶点之间的最短通路，并且将这两个顶点之间的距离取作这条最短通路的长度dist(v, s)。 巧合的是图的BFS搜索与树的层次遍历一样都具有这样一种单调性，即BFS所给出的顶点序列按照这样到起点的距离也是按照非降次单调排列的。在我们最终所生成的BFS树中，每个顶点与s之间的那条通路恰好就是在原图中这两个顶点之间的最短通路。 2.深度优先搜索2.1.算法这一节将介绍与上一节中的广度优先搜索完全对称的另一种搜索算法：深度优先搜索。相对于此前的广度优先搜索，深度优先搜索的算法策略更为简明，然而深度优先搜索的过程更为复杂，其功能也相对而言更为强大，因此也成为有效解决很多实际问题的。 深度优先搜索的基本算法框架如下： 首先确定一个搜索的起点s，找到它的任意的一个邻居，并且将控制权交给这个新的顶点。接下来新的顶点一旦接过控制权，它也会仿效这种策略在它的所有邻居中任选其一，并且将控制权交给这个尚未访问的邻居。当然如果有已经被访问过的，对应的这条边将不会被采用，而是以某种适当的形式加以标注（图中以浅色线表示）。假设这个顶点已经没有任何邻居尚未访问，那么按照算法的策略，我们将在这个位置返回（回溯），顺着此前的通路回到它的前驱顶点。 可以看到遍历的效果与此前的BFS类似，我们依然会得到一棵DFS树，也就是图中这些粗边所构成的一棵支撑树，同样地未被这棵树所采纳的那些边会被分类，而且这种分类要更为细致。 这样一个遍历和递归的过程可以实现为下面的代码： 1234567891011121314151617181920212223template &lt;typename Tv, typename Te&gt; //深度优先搜索DFS算法（单个连通域）void Graph&lt;Tv, Te&gt;::DFS ( int v, int&amp; clock ) &#123; //assert: 0 &lt;= v &lt; n dTime ( v ) = ++clock; status ( v ) = DISCOVERED; //发现当前顶点v for ( int u = firstNbr ( v ); -1 &lt; u; u = nextNbr ( v, u ) ) //枚举v的所有邻居u switch ( status ( u ) ) &#123; //并视其状态分别处理 case UNDISCOVERED: //u尚未发现，意味着支撑树可在此拓展 status ( v, u ) = TREE; parent ( u ) = v; DFS ( u, clock ); break; case DISCOVERED: //u已被发现但尚未访问完毕，应属被后代指向的祖先 status ( v, u ) = BACKWARD; break; default: //u已访问完毕（VISITED，有向图），则视承袭关系分为前向边或跨边 status ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS; break; &#125; status ( v ) = VISITED; fTime ( v ) = ++clock; //至此，当前顶点v方告访问完毕&#125;template &lt;typename Tv, typename Te&gt; //深度优先搜索DFS算法（全图）void Graph&lt;Tv, Te&gt;::dfs ( int s ) &#123; //assert: 0 &lt;= s &lt; n reset(); int clock = 0; int v = s; //初始化 do //逐一检查所有顶点 if ( UNDISCOVERED == status ( v ) ) //一旦遇到尚未发现的顶点 DFS ( v, clock ); //即从该顶点出发启动一次DFS while ( s != ( v = ( ++v % n ) ) ); //按序号检查，故不漏不重&#125; 2.2.实例（无向图）下面是一个无向图的实例，每一行的3格分别代表顶点及其dTime和fTime，为了方便理解将当前顶点在图中变为大写字母。 2.3.实例（有向图）有向图的深度优先搜索要更为复杂，所涉及的情况也会更多。不妨来看下面的一个实例，首先确认这是一幅有向图，在这个图中我们将每一个顶点都绘制成长方形，顶点的标识居中，在它的左右空白处将分别记录下它在遍历过程中所获得的dTime和fTime两个时间标签。当前顶点用深色加粗边框表示且字母大写，被访问过的顶点用双线边框表示，处于VISITED状态的顶点用黑色方框表示。 综观整个过程，我们总共用了10秒遍历完了由这五个顶点所构成的一个子图，更确切地讲它们构成了在这个图中从顶点a出发可以达到的区域，也称作可达区域。那么图中的其余部分呢？比如说这里的顶点d以及e呢？ 回顾对广度优先遍历算法bfs的处理手法，就不难发现我们完全可以效仿那种做法，在这样的dfs算法之外再包装一层循环来枚举图中的所有顶点。这样的话就可以无一遗漏地遍历图中的所有顶点，而且只要处理得当对所有可达域的遍历都不会彼此有所重叠，从而在时间效率上也依然可以得到保证。 最后不妨来盘点一下遍历所获得的成果，首先是这些粗边它们构成了两棵遍历树，整体地构成了一个遍历森林；此外我们还对所有未被采纳的边进行了分类：跨越边、前向边以及后向边，无一遗漏。在通过遍历所获得的所有这些信息中遍历树或者说遍历森林无疑是最为重要的，然而相对于原图，它们毕竟只是一个子集，这样一个子集所携带的难道是原图的所有信息吗？从某种意义上讲的确是这样的，而其中至关重要的一点就在于我们通过遍历不仅获得了这样一棵树，而且为每一个顶点都标记了dTime和fTime两类时间标签，而这两类时间标签的作用是非常巨大的。 2.4.括号引理/嵌套引理通过深度优先搜索DFS为图中所有顶点所标注的两个时间标签dTime和fTime，实际上蕴含了大量有用的信息这一点可以由括号引理或嵌套引理来加以印证。 为此首先要引入顶点的活动期的概念，也就是由它的dTime和fTime两个时间标签所界定的那样一段时间范围，即这个顶点在整个DFS搜索过程中处于活跃状态的时间范围。嵌套引理指出任何有向图经过了DFS搜索之后，在对应的DFS森林或者DFS树中任何一对顶点之间存在直系的血缘关系，当且仅当它们的活跃期存在包含与被包含的关系。 为了获得对这个引理更为直观的认识，我们不妨以横向作为时间轴，依然以上节的有向图为例，将每个顶点都沿水平方向适当展开使得它们恰好覆盖各自所对应的活跃期。不难看出祖先的活跃期的确会覆盖它的后代，而反过来没有直接血缘关系的节点比如说F和B，或者B和G，它们的活跃期都的确彼此没有任何公共的部分。 这样一种特性是非常强大的一个工具，比如在算法中我们经常需要做的一个判断就是：任意的一对顶点 v 和 u 之间在遍历树中是否存在一个直系血缘的关系。如果没有这样一种简便的机制，我们将不得不从 u 出发顺着parent引用不断地溯流而上直到遇到顶点v，才能够确定它们的确存在祖先和后代的直系关系；或者不得不一直追溯到整个遍历的起点，从而断定u和v之间并没有直系血缘关系。而现在借助时间标签，我们可以快速准确地在$O(1)$的时间内就得出相应的结论。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（11）图","slug":"数据结构与算法（11）图","date":"2020-02-25T01:23:52.000Z","updated":"2020-02-25T07:59:39.508Z","comments":true,"path":"2020/02/25/数据结构与算法（11）图/","link":"","permalink":"http://nekomoon404.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/","excerpt":"","text":"1.概述1.1.基本术语 G = ( V; E) = ( 顶点集; 边集) 顶点（vertex）：n = |V| 边（edge）|弧（arc）：e = |E| 邻接关系（adjacency）：定义同一条边的两个顶点之间的关系 自环（self-loop）：同一顶点自我相邻 简单图（simple graph）：不含自环，这一章讨论的都是简单图 关联关系（incidence）：顶点与其所属的边之间的关系 度（degree）：于同一顶点关联的边数 此前所学的几种数据结构都可以视作是图的特例，比如在向量和列表等线性结构中只有互为前驱与后继的元素之间才能够定义邻接关系，而树结构中只能在父节点与子节点之间才能够定义邻接关系。 图更为一般化，其中的任何两个节点之间都允许存在这样的一个邻接关系，我们这里讨论的图排除自环的存在。 1.2.无向图/有向图 若关联顶点u和v次序无所谓，则(u, v)为无向边（undirected edge） 所有边均为无方向的图，即为无向图（undigraph） 反之，有向图（digraph）中均为有向边（directed edge） u，v分别称作边(u, v)的尾（tail）、头（head） 无向边、有向边并存的图，称作混合图（mixed graph） 在图这一章我们关注有向图，因为通过有向图完全可以表示并且实现无向图以及混合图，简单的做法是将任何一条无向边转化为彼此对称的一对有向边。 1.3.路径/环路 路径：$\\pi$ = &lt;$V_0,V_1,\\dots,V_k&gt;$ 长度： | $\\pi$ | = k 简单路劲：$V_i=V_j$ 除非$i=j$，即路劲中不含重复顶点 环/环路：$V_0=V_k$ 有向无环图（DAG） 欧拉环路：| $\\pi$ | = | E |，即各边恰好出现一次 哈密尔顿环路：| $\\pi$ | = | V |，即各顶点恰好出现一次 2.基于邻接矩阵实现图结构2.1. Graph模板类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef enum &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; //顶点状态typedef enum &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EType; //边在遍历树中所属的类型template &lt;typename Tv, typename Te&gt; //顶点类型、边类型class Graph &#123; //图Graph模板类private: void reset() &#123; //所有顶点、边的辅助信息复位 for ( int i = 0; i &lt; n; i++ ) &#123; //所有顶点的 status ( i ) = UNDISCOVERED; dTime ( i ) = fTime ( i ) = -1; //状态，时间标签 parent ( i ) = -1; priority ( i ) = INT_MAX; //（在遍历树中的）父节点，优先级数 for ( int j = 0; j &lt; n; j++ ) //所有边的 if ( exists ( i, j ) ) type ( i, j ) = UNDETERMINED; //类型 &#125; &#125; void BFS ( int, int&amp; ); //（连通域）广度优先搜索算法 void DFS ( int, int&amp; ); //（连通域）深度优先搜索算法 void BCC ( int, int&amp;, Stack&lt;int&gt;&amp; ); //（连通域）基于DFS的双连通分量分解算法 bool TSort ( int, int&amp;, Stack&lt;Tv&gt;* ); //（连通域）基于DFS的拓扑排序算法 template &lt;typename PU&gt; void PFS ( int, PU ); //（连通域）优先级搜索框架public:// 顶点 int n; //顶点总数 virtual int insert ( Tv const&amp; ) = 0; //插入顶点，返回编号 virtual Tv remove ( int ) = 0; //删除顶点及其关联边，返回该顶点信息 virtual Tv&amp; vertex ( int ) = 0; //顶点v的数据（该顶点的确存在） virtual int inDegree ( int ) = 0; //顶点v的入度（该顶点的确存在） virtual int outDegree ( int ) = 0; //顶点v的出度（该顶点的确存在） virtual int firstNbr ( int ) = 0; //顶点v的首个邻接顶点 virtual int nextNbr ( int, int ) = 0; //顶点v的（相对于顶点j的）下一邻接顶点 virtual VStatus&amp; status ( int ) = 0; //顶点v的状态 virtual int&amp; dTime ( int ) = 0; //顶点v的时间标签dTime virtual int&amp; fTime ( int ) = 0; //顶点v的时间标签fTime virtual int&amp; parent ( int ) = 0; //顶点v在遍历树中的父亲 virtual int&amp; priority ( int ) = 0; //顶点v在遍历树中的优先级数// 边：这里约定，无向边均统一转化为方向互逆的一对有向边，从而将无向图视作有向图的特例 int e; //边总数 virtual bool exists ( int, int ) = 0; //边(v, u)是否存在 virtual void insert ( Te const&amp;, int, int, int ) = 0; //在顶点v和u之间插入权重为w的边e virtual Te remove ( int, int ) = 0; //删除顶点v和u之间的边e，返回该边信息 virtual EType &amp; type ( int, int ) = 0; //边(v, u)的类型 virtual Te&amp; edge ( int, int ) = 0; //边(v, u)的数据（该边的确存在） virtual int&amp; weight ( int, int ) = 0; //边(v, u)的权重// 算法 void bfs ( int ); //广度优先搜索算法 void dfs ( int ); //深度优先搜索算法 void bcc ( int ); //基于DFS的双连通分量分解算法 Stack&lt;Tv&gt;* tSort ( int ); //基于DFS的拓扑排序算法 void prim ( int ); //最小支撑树Prim算法 void dijkstra ( int ); //最短路径Dijkstra算法 template &lt;typename PU&gt; void pfs ( int, PU ); //优先级搜索框架&#125;; 2.2.邻接矩阵与关联矩阵 邻接矩阵（adjacency matrix）：用二维矩阵记录顶点之间的邻接关系，矩阵元素与图中存在的边一一对应 $A(i, j)=1$，若顶点$i$与$j$之间存在一条边；否则为0 （可以推广到带权图，即网络） 既然只考察简单图，则对角线元素统一设置为0 空间复杂度为$\\Theta(n^2)$，与图中实际的边数无关 关联矩阵（incidence matrix）：用二维矩阵记录顶点与边之间的关联关系 空间复制度为$\\Theta(n*e)=O(n^3)$ 空间利用率 &lt; 2/n 下面是几个实例： 2.3. Vertex下面是顶点（vertex）的一种实现方式： 123456789101112typedef enum &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; //顶点状态template &lt;typename Tv&gt; struct Vertex &#123; //顶点对象（为简化起见，并未严格封装） Tv data; int inDegree, outDegree;//数据、出入度数 VStatus status; //（如上三种）状态 int dTime, fTime; //时间标签 int parent; //在遍历树中的父节点 int priority; //在遍历树中的优先级数（最短通路、极短跨边等） Vertex ( Tv const&amp; d = ( Tv ) 0 ) : //构造新顶点 data ( d ), inDegree ( 0 ), outDegree ( 0 ), status ( UNDISCOVERED ), dTime ( -1 ), fTime ( -1 ), parent ( -1 ), priority ( INT_MAX ) &#123;&#125; //暂不考虑权重溢出&#125;; 边（Edge）的一种实现方式： 12345678typedef enum &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EStatus; //边在遍历树中所属的类型template &lt;typename Te&gt; struct Edge &#123; //边对象（为简化起见，并未严格封装） Te data; //数据 int weight; //权重 EStatus status; //（如上五种）状态 Edge ( Te const&amp; d, int w ) : data ( d ), weight ( w ), status ( UNDETERMINED ) &#123;&#125; //构造&#125;; 2.4. GraphMatrix现在就可以给出基于邻接矩阵实现图结构的一种可行方式，GraphMatrix类派生于此前所定义的Graph模板类，将顶点集实现为向量结构，其长度恰好等于顶点的规模即n；将边集实现为向量的向量，相当于一个n×n的矩阵，它恰好就是此前所构思的邻接矩阵。 1234567891011121314template &lt;typename Tv, typename Te&gt; //顶点类型、边类型class GraphMatrix : public Graph&lt;Tv, Te&gt; &#123; //基于向量，以邻接矩阵形式实现的图private: Vector&lt; Vertex&lt; Tv &gt; &gt; V; //顶点集（向量） Vector&lt; Vector&lt; Edge&lt; Te &gt; * &gt; &gt; E; //边集（邻接矩阵）public: GraphMatrix() &#123; n = e = 0; &#125; //构造 ~GraphMatrix() &#123; //析构 for ( int j = 0; j &lt; n; j++ ) //所有动态创建的 for ( int k = 0; k &lt; n; k++ ) //边记录 delete E[j][k]; //逐条清除 &#125; /* 操作接口：顶点查询、顶点修改、边查询、边修改 */&#125;; 由于我们此前对向量所重载的方括号操作符[]，这里只需用E[i][j]这样一种形式即可指代在顶点i与 j 之间的一条边，既可以读出这条边的信息，也可以反过来修改其中的某些信息。 2.5.顶点操作按照这种实现方式，我们可以简明实现顶点操作中的大部分基本操作： 123456789// 顶点的基本操作：查询第i个顶点（0 &lt;= i &lt; n） virtual Tv&amp; vertex ( int i ) &#123; return V[i].data; &#125; //数据 virtual int inDegree ( int i ) &#123; return V[i].inDegree; &#125; //入度 virtual int outDegree ( int i ) &#123; return V[i].outDegree; &#125; //出度 virtual VStatus&amp; status ( int i ) &#123; return V[i].status; &#125; //状态 virtual int&amp; dTime ( int i ) &#123; return V[i].dTime; &#125; //时间标签dTime virtual int&amp; fTime ( int i ) &#123; return V[i].fTime; &#125; //时间标签fTime virtual int&amp; parent ( int i ) &#123; return V[i].parent; &#125; //在遍历树中的父亲 virtual int&amp; priority ( int i ) &#123; return V[i].priority; &#125; //在遍历树中的优先级数 对于任意顶点i，如何枚举其所有的邻接顶点neighbor？为此首先需要实现一个名为nextNbr的接口，它的功能语义是如果我们现在已经枚举到顶点i的编号为 j 的邻居，那么它将返回接下来的下一个邻居。与顶点 i 潜在的可以相邻的点，无非就是它在邻接矩阵中所对应的那一行中数值为1的单元，对应于与i邻接的一个顶点。而第一个有效的邻居是通过firstNbr接口实现，它调用了nextNbr，将顶点n（并不实际存在）作为上一个有效的邻居。 1234567virtual int nextNbr ( int i, int j ) &#123;//相对于顶点j的下一邻接顶点 while ( ( -1 &lt; j ) &amp;&amp; ( !exists ( i, --j ) ) ); //逆向线性试探，O(n) return j; &#125; //改用邻接表可提高至O(1 + outDegree(i))virtual int firstNbr ( int i ) &#123; return nextNbr ( i, n ); &#125; //首个邻接顶点 2.6.边操作同样地，利用邻接矩阵我们也可以便捷地实现很多边的基本操作 1234567// 边的确认操作 virtual bool exists ( int i, int j ) //边(i, j)是否存在 &#123; return ( 0 &lt;= i ) &amp;&amp; ( i &lt; n ) &amp;&amp; ( 0 &lt;= j ) &amp;&amp; ( j &lt; n ) &amp;&amp; E[i][j] != NULL; &#125;// 边的基本操作：查询顶点i与j之间的联边（0 &lt;= i, j &lt; n且exists(i, j)） virtual EStatus &amp; status ( int i, int j ) &#123; return E[i][j]-&gt;status; &#125; //边(i, j)的状态 virtual Te&amp; edge ( int i, int j ) &#123; return E[i][j]-&gt;data; &#125; //边(i, j)的数据 virtual int&amp; weight ( int i, int j ) &#123; return E[i][j]-&gt;weight; &#125; //边(i, j)的权重 边插入： 假设我们需要在顶点i与顶点j之间连接一条有向边，假设这条边尚不存在，那么只需要将待插入的那条边的信息比如它的权重等等，封装为一个具体的边记录，然后将这个新的边记录地址存入于邻接矩阵中对应的那个单元，也可以说这个单元将指向这个新的边记录。 1234567virtual void insert ( Te const&amp; edge, int w, int i, int j ) &#123; //插入权重为w的边e = (i, j) if ( exists ( i, j ) ) return; //确保该边尚不存在 E[i][j] = new Edge&lt;Te&gt; ( edge, w ); //创建新边 e++; //更新边计数 V[i].outDegree++; //更新关联顶点i的出度 V[j].inDegree++; //更新关联顶点i的入数&#125; 边删除： 不妨假设从顶点 i 通往顶点 j 之间存在一条边，因此在邻接矩阵中对应的那一项就非空，而且这一项将指向一个对应的边记录。为了删除这条边，只需将这条边对应的记录释放并且归还给系统，然后令在邻接矩阵中对应于这一项的引用指向空。 12345678virtual Te remove ( int i, int j ) &#123; //删除顶点i和j之间的联边（exists(i, j)） Te eBak = edge ( i, j ); delete E[i][j]; E[i][j] = NULL; //备份后删除边记录 e--; V[i].outDegree--; V[j].inDegree--; //更新边计数与关联顶点的度数 return eBak; //返回被删除边的信息&#125; 2.7.顶点插入与删除顶点的插入与删除相对于边的操作要更为复杂，原因在于在此前的边操作中整个矩阵的规模并不会发生变化，而顶点的插入以及稍后的删除则会改变。为了在其中引入一个新的顶点，首先要将邻接矩阵中已有的各行分别向后扩展一个单元，即增加一列；接下来针对新引入的顶点还需在邻接矩阵中增加对应的一行；当然还需在第一级的边表中增加一个相应地单元用来指示或者说记录新引入的行向量；最后对应于这个新引入的顶点还需要在顶点向量中加入一个新的对应元素。 这样的四个步骤可以实现为这段代码： 12345virtual int insert ( Tv const&amp; vertex ) &#123; //插入顶点，返回编号 for ( int j = 0; j &lt; n; j++ ) E[j].insert ( NULL ); n++; //各顶点预留一条潜在的关联边 E.insert ( Vector&lt;Edge&lt;Te&gt;*&gt; ( n, n, ( Edge&lt;Te&gt;* ) NULL ) ); //创建新顶点对应的边向量 return V.insert ( Vertex&lt;Tv&gt; ( vertex ) ); //顶点向量增加一个顶点&#125; 顶点删除就是上述步骤的逆过程。 1234567891011virtual Tv remove ( int i ) &#123; //删除第i个顶点及其关联边（0 &lt;= i &lt; n） for ( int j = 0; j &lt; n; j++ ) //所有出边 if ( exists ( i, j ) ) &#123; delete E[i][j]; V[j].inDegree--; e--; &#125; //逐条删除 E.remove ( i ); n--; //删除第i行 Tv vBak = vertex ( i ); V.remove ( i ); //删除顶点i for ( int j = 0; j &lt; n; j++ ) //所有入边 if ( Edge&lt;Te&gt; * x = E[j].remove ( i ) ) &#123; delete x; V[j].outDegree--; e--; &#125; //逐条删除 return vBak; //返回被删除顶点的信息&#125; 2.8.优缺点邻接矩阵的优点有： 直观，易于理解和实现 适用范围广泛：digrah / network / cyclic / … 尤其适用于稠密图（dense graph） 判断两点之间是否存在联边：$O(1)$ 获取顶点的（出/入）度数：$O(1)$ 添加、删除边后更新度数：$O(1)$ 扩展性（scalability）： 得益于Vector良好的空间控制策略，空间溢出等情况可“透明地”予以处理 邻接矩阵的缺点则是： 空间利用率，它始终是需要$\\Theta(n^2)$空间，与边数无关 在实际问题中的图通常不会有$n^2$级的边数，不妨考虑下平面图（planar graph），即可嵌入平面的图，其中不相邻的边不相交。根据欧拉推导的公式：对于所有的平面图有，$v-e+f-c=1$，各字母分别表示顶点数、边数、区域面片数、连通域数。因此平面图的边数有：$e\\le 3\\times n-6=O(n) \\ll n^2$，此时空间利用率$\\approx 1/n$。而对于一般的稀疏图（sparse graph），空间利用率同样很低，因此可以采用压缩存储技术予以改进。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Cpp基础（12）文件操作和模板","slug":"Cpp基础（12）文件操作和模板","date":"2020-02-22T08:51:42.000Z","updated":"2020-02-25T08:51:42.000Z","comments":true,"path":"2020/02/22/Cpp基础（12）文件操作和模板/","link":"","permalink":"http://nekomoon404.github.io/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"1.文件操作本节介绍如何利用C++语言来处理文件的一些操作，我们知道所有的数据在计算机上保存的时候都是具有一定的层次化的结构的，一个数据在计算机实质上被保存的就是一个个0,1的比特位，它是每位这样存放的。但是去处理每个比特位的话那么可能在很多时候这个数据在构建时就会变得非常的繁琐，并且具有很强的不规律性，所以我们进一步把这8个比特位构成的称之为字节。那么每一个byte它对应描述了一定的内容，而这些各个字节组成的一些具体的内容又称之为域或者记录。 数据的层次： 位 bit 字节 byte 域/记录 把所有记录顺序地写入一个文件 $\\to$ 顺序文件 1.1.文件和流 顺序文件：一个有限字符构成的顺序字符流 C++标准库中：ifstream，ofstream和fstream共3个类 $\\to$ 用于文件操作，统称为文件流类。 ifstream用于将文件读取，从文件中读取数据 ofstream用于向文件中写入数据 fstream即可以从文件中读取数据，又可以向文件中写入数据 （图中箭头表示派生） 1.2.文件操作 使用/创建文件的基本流程： 1）打开文件：通过指定文件名，建立文件和文件流对象的关联；指明文件的使用方式； 2）读/写文件：利用读/写指针进行相应的操作 3）关闭文件 1.3.建立顺序文件12#include&lt;fstream&gt; //包含头文件ofstream outFile(\"clients.dat\", ios::out | ios:: binary); //打开文件 也可以先创建ofstream对象，再用open函数打开； 一般要判断打开是否成功； 文件名可以给出绝对路径，也可以给相对路径； 没有交代路径信息，就是在当前文件夹下找文件 1234#include&lt;fstream&gt;ofstream fout;fout.open(\"test.out\", ios::out | ios::binary);if(!fout) &#123; cerr &lt;&lt; \"File open error!\" &lt;&lt; endl;&#125; 1.4.文件的读写指针 对于输入文件，有一个读指针； 对于输出文件，有一个写指针； 对于输入输出文件，有一个读写指针； 标识文件操作的当前位置，该指针在哪里 $\\to$ 读写操作就在哪里进行 写指针：（location可以为负值） 1234567ofstream fout(\"a1.out\", ios::app);long location = fout.tellp(); //取得写指针的位置location = 10L;fout.seekp(location); //将写指针移动到第10个字节处fout.seekp(location, ios::beg); //从头数locationfout.seekp(location, ios::cur); //从当前位置数locationfout.seekp(location, ios::end); //从尾部数location 读指针： 1234567ifstream fin(\"a1.out\", ios::in);long location = fin.tellg(); //取得写指针的位置location = 10L;fin.seekg(location); //将写指针移动到第10个字节处fin.seekg(location, ios::beg); //从头数locationfin.seekg(location, ios::cur); //从当前位置数locationfin.seekg(location, ios::end); //从尾部数location 1.5.二进制文件读写123456int x=10;fout.seekp(20,ios::beg);fout.write( (const char*)(&amp;x), sizeof(int) );fin.seekg(0,ios::beg);fin.read( (char*)(&amp;x), sizeof(int) ); 二进制文件读写，直接读/写二进制数据，记事本看未必正确 例子：从键盘输入几个学生的姓名和成绩，并以二进制文件形式存起来 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstring&gt;using namespace std;class Student &#123;public: char szName[20]; int nScore;&#125;;int main() &#123; Student s; ofstream OutFile(\"D:\\\\tmp\\\\student.dat\", ios::out | ios::binary); while (cin &gt;&gt; s.szName &gt;&gt; s.nScore) &#123; if (stricmp(s.szName, \"exit\") == 0) //名字为exit则结束 break; OutFile.write((char*)&amp;s, sizeof(s)); &#125; OutFile.close(); return 0;&#125; 对二进制文件来进行读写的时候最好是能够保持一致，即以二进制的形式去写入就以二进制的形式来读出。例子2： 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstring&gt;using namespace std;class Student &#123;public: char szName[20]; int nScore;&#125;;int main() &#123; Student s; ifstream inFile(\"student.dat\", ios::in | ios::binary); if (!inFile) &#123; cout &lt;&lt; \"error\" &lt;&lt; endl; return 0; &#125; while (inFile.read((char*)&amp;s, sizeof(s))) &#123; int nReadedBytes = inFile.gcount(); cout &lt;&lt; s.szName &lt;&lt; \" \" &lt;&lt; s.nScore &lt;&lt; endl; &#125; inFile.close(); return 0;&#125; 在刚才的两个例子当中介绍了如何对一个文件进行二进制形式的一个写入，或者是对一个文件具体以二进制的形式来进行读出，而在很多时候我们通常会对一个文件同时要进行读和写的操作。 例子3：将student.dat文件的Jane的名字改成Mike 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstring&gt;using namespace std;class Student &#123;public: char szName[20]; int nScore;&#125;;int main() &#123; Student s; fstream iofile(\"D:\\\\tmp\\\\student.dat\", ios::in | ios::out | ios::binary); if (!iofile) &#123; cout &lt;&lt; \"error\"; return 0; &#125; iofile.seekp(2 * sizeof(s), ios::beg); //定位写指针到第三个记录 iofile.write(\"Mike\", strlen(\"Mike\") + 1); iofile.seekg(0, ios::beg); //定位读指针到开头 while (iofile.read((char*)&amp;s, sizeof(s))) cout &lt;&lt; s.szName &lt;&lt; \" \" &lt;&lt; s.nScore &lt;&lt; endl; iofile.close(); return 0;&#125; 显示关闭文件（写或读之后都要显示关闭文件） 12345ifstream fin(\"test.dat\", ios::in);fin.close();ofstream fout(\"test.dat\",ios::out);fout.close(); 例子4：文件拷贝，用法示例：mycopy src.dat dest.dat，即将src.dat拷贝到dest.at，如果dest.dat原来就有，则原来的文件会被覆盖。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//main函数的两个参数分别记录命令行操作相应的参数的个数以及参数对应的字符串int main(int argc, char* argv[]) &#123; if (argc != 3) &#123; cout &lt;&lt; \"File name missing!\" &lt;&lt; endl; return 0; &#125; ifstream inFile(argv[1], ios::binary | ios::in); //打开文件用于读 if (!inFile) &#123; cout &lt;&lt; \"Source file open error.\" &lt;&lt; endl; return 0; &#125; ofstream outFile(argv[2], ios::binary | ios::out); //打开文件用于写 if (!outFile) &#123; cout &lt;&lt; \"New file open error.\" &lt;&lt; endl; inFile.close(); //打开的文件一定要关闭 return 0; &#125; char c; //仅做示例，实际文件拷贝时不会是逐字节拷贝 while (inFile.get(c)) //每次读取一个字符 outFile.put(c); //每次写入一个字符 outFile.close(); inFile.close(); return 0;&#125; 2.函数模板通过模板的使用就正式开始了泛型程序程序设计这样一个模块的学习。 泛型程序设计（Generic Programming） 算法实现时不指定具体要操作的数据的类型； 泛型—算法实现一遍 $\\to$ 适用于多种数据结构 优势：减少重复代码的编写 大量编写模板，使用模板的程序设计： 函数模板 类模板 函数模板的形式： 1234template&lt;class 类型参数1, class 类型参数2,...&gt; 返回值类型 模板名(形参表)&#123; 函数体&#125; 例子： 123456789101112template&lt;class T&gt; void Swap(T &amp;x, T &amp;y)&#123; T tmp = x; x = y; y = tmp;&#125;int main()&#123; int n = 1, m = 2; Swap(n, m); //编译器自动生成 void Swap(int &amp;, int &amp;)函数 double f = 1.2, g = 2.3; Swap(f, g); //编译器自动生成 void Swap(double &amp;, double &amp;)函数 return 0;&#125; 函数模板中可以有不止一个类型参数 12345template&lt;class T1, class T2&gt; T2 print(T1 arg1. T2 arg2)&#123; cout&lt;&lt;arg1&lt;&lt;\" \"&lt;&lt;arg2&lt;&lt;endl; return arg2;&#125; 函数模板可以重载，只要它们的形参表不同即可，例如下面两个模板可以同时存在： 12345678template&lt;class T1, class T2&gt; void print(T1 arg1. T2 arg2)&#123; cout&lt;&lt;arg1&lt;&lt;\" \"&lt;&lt;arg2&lt;&lt;endl;&#125;template&lt;class T&gt; void print(T arg1. T arg2)&#123; cout&lt;&lt;arg1&lt;&lt;\" \"&lt;&lt;arg2&lt;&lt;endl;&#125; C++编译器遵循以下优先顺序： Step1：先找参数完全匹配的普通函数（非由模板实例化而得的函数）； Step2：再找参数完全匹配的模板函数； Step3：再找实参经过自动类型转换后能够匹配的普通函数； Step4：上面的都找不到，则报错。 要注意赋值兼容原则引起函数模板中类型参数的二义性 12345678template&lt;class T1, class T2&gt; void print(T1 arg1. T2 arg2)&#123; cout&lt;&lt;arg1&lt;&lt;\" \"&lt;&lt;arg2&lt;&lt;endl;&#125;......print(5, 7); //ok, replace T with intprint(5.8, 7.8); //ok, replace T with doubleprint(5, 7.8); //error, replace T with int or double? 二义性 函数模板的类型参数可以用于函数模板的局部变量声明，也可以用于声明函数模板的返回值。 3.类模板 类模板：在定义类的时候给它一个/多个参数，这个/些参数表示不同的数据类型；在调用类模板时，指定参数，由编译系统根据参数提供的数据类型自动产生相应的模板类。 1234template&lt;类型参数表&gt; class 类模板名&#123; 成员函数和成员变量&#125;; 类模板里的成员函数，如在类模板外面定义时： 12345template&lt;型参数表&gt;返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)&#123; ......&#125; 3.1类模板的定义 用类模板定义对象的写法如下： 1类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表); 如果类模板有无参构造函数，那么也可以只写： 1类模板名&lt;真实类型参数表&gt; 对象名; 下面是一个实例： 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T1,class T2&gt;class Pair &#123;public: T1 key; T2 value; Pair(T1 k, T2 v) :key(k), value(v) &#123; &#125;; bool operator&lt;(const Pair&lt;T1, T2&gt; &amp; p) const;&#125;;template&lt;class T1, class T2&gt;bool Pair&lt;T1,T2&gt;::operator&lt;(const Pair&lt;T1, T2&gt; &amp; p) const&#123; return key &lt; p.key;&#125;int main() &#123; Pair&lt;string, int&gt;student(\"Tom\", 19); //实例化出一个类Pair&lt;string,int&gt; cout &lt;&lt; student.key &lt;&lt; \" \" &lt;&lt; student.value; return 0;&#125; 输出结果：Tom 19 3.2.使用类模板声明对象 编译器由类模板生成类的过程叫类模板的实例化 编译器自动用具体的数据类型 $\\to$ 替换类模板中的类型参数，生成模板类的代码 由类模板实例化得到的类叫模板类 为类型参数指定的数据类型不同，得到的模板类不同 同一个类模板的两个模板类是不兼容的 123Pair&lt;string,int&gt; *p;Pair&lt;string,double&gt; a;p = &amp; a; //Wrong 3.3.函数模板作为类模板成员1234567891011template&lt;class T&gt;class A&#123;public: template&lt;class T2&gt; void Func(T2 t)&#123; cout &lt;&lt; t; &#125; //若改为template&lt;class T&gt;将报错&#125;;int main()&#123; A&lt;int&gt; a; a.Func('K'); //成员函数模板Func被实例化 return 0;&#125; 程序输出：K 3.4.类模板与非类型参数 类模板的参数声明中可以包括非类型参数，如template&lt;class T, int elementsNumber&gt; 非类型参数：用来说明类模板中的属性，且非类型参数必须实例化，实参必须是编译时常量表达式 类型参数：用来说明类模板中的属性类型，成员操作的参数类型和返回值类型 123456789template&lt;class T,int size&gt;class Array&#123; T array[size];public: void Print()&#123; for(int i=0; i &lt; size; ++i) cout &lt;&lt; array[i] &lt;&lt; endl; &#125;&#125;; 注意：由不同的参数生成的模板类是不同的，Array&lt;int,40&gt;和Array&lt;int,50&gt;完全是两个类，这两个类的对象之间不能互相赋值，Array&lt;int,40&gt;实例化后得到的模板类是一个拥有一个固定长度为5的int型数组的成员变量的类。 3.5.类模板与继承 类模板派生出类模板 模板类（即类模板中类型/非类型参数实例化后的类）派生出类模板 普通类派生出类模板 模板类派生出普通类 3.6.类模板与静态成员类模板中可以定义静态成员： 从该类模板实例化得到的模板类的所有对象都包含同样的静态成员 例如，声明一个类模板A，有一个静态成员变量count用于计数，有一个静态成员函数printCount()用于输出计数结果。由类模板 A 实例化的两个模板类 A&lt;int&gt; 和 A&lt;double&gt; 各自拥有一个名为 count 的静态成员变量，和一个名为 printCount() 的静态成员函数。A&lt;int&gt; 和 A&lt;double&gt; 是不同的模板类，不能共享静态成员变量 count，因而需要分别初始化。在声明了 1 个 A&lt;int&gt; 对象和 2 个 A&lt;double&gt; 对象之后，A&lt;int&gt;::count 的值变为 1，A&lt;double&gt;::count 的值变为 2 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A &#123; static int count;public: A() &#123; ++count; &#125; ~A() &#123; --count; &#125; A(const A &amp;a) &#123; ++count; &#125; static void printCount() &#123; cout &lt;&lt; count &lt;&lt; endl; &#125;&#125;;template&lt;&gt; int A&lt;int&gt;::count = 0;template&lt;&gt; int A&lt;double&gt;::count = 0;int main() &#123; A&lt;int&gt; ia; A&lt;double&gt; da1, da2; ia.printCount(); // 输出 1 A&lt;double&gt;::printCount(); // 输出 2 return 0;&#125; 3.7.类模板与友元类模板与友元大致分为四种情况： 函数、类、类的成员函数作为类模板的友元 例如，下面的代码中声明了一个类模板 C，可以将普通函数 func1() 声明为 C 的友元，使得 func1() 可以访问 val；还可以将普通类 A 声明为类模板 C 的友元；也可以将普通类 B 的成员函数 func2() 声明为类模板 C 的友元。 123456789101112131415class A &#123; &#125;;class B &#123; public: void func2(); &#125;;template &lt;class T&gt;class C &#123; T val; friend void func1(); friend class A; friend void B::func2();public: C(T _val) : val(_val) &#123; &#125;&#125;;C&lt;int&gt; c1(4);C&lt;double&gt; c2(2.8);void func1() &#123; cout &lt;&lt; c1.val &lt;&lt; endl; &#125;void B::func2() &#123; cout &lt;&lt; c2.val &lt;&lt; endl; &#125; 函数模板作为类模板的友元 例如，下面声明了重载流运算符的两个函数模板为类模板 Array 的友元，两个函数模板的具体实现如下，作为友元可以访问 size 和 ptrElement ，分别用于依次读入和输出数组中的每个元素。声明 Array&lt;int&gt; 对象 a 时，自动生成了类模板 Array&lt;int&gt;，并根据两个函数模板自动重载了对应的流运算符：istream &amp;operator &gt;&gt; (istream &amp;, Array&lt;int&gt; &amp;)ostream &amp;operator &lt;&lt; (ostream &amp;, const Array&lt;int&gt; &amp;) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;template &lt;class T1&gt;class Array &#123; T1 *ptrElement; int size;public: Array(int _size = 0) : size(_size) &#123; ptrElement = new T1[_size]; &#125; ~Array() &#123; delete[] ptrElement; &#125; template&lt;class T2&gt; friend istream &amp;operator &gt;&gt; (istream &amp;, Array&lt;T2&gt; &amp;); template&lt;class T3&gt; friend ostream &amp;operator &lt;&lt; (ostream &amp;, const Array&lt;T3&gt; &amp;);&#125;;template&lt;class T2&gt;istream &amp;operator &gt;&gt; (istream &amp;s, Array&lt;T2&gt; &amp;a) &#123; for (int i = 0; i &lt; a.size; ++i) &#123; s &gt;&gt; *(a.ptrElement + i); &#125; return s;&#125;template&lt;class T3&gt;ostream &amp;operator &lt;&lt; (ostream &amp;s, const Array&lt;T3&gt; &amp;a) &#123; for (int i = 0; i &lt; a.size; ++i) &#123; s &lt;&lt; *(a.ptrElement + i) &lt;&lt; \" \"; &#125; return s;&#125;int main()&#123; Array&lt;int&gt; a(5); cin &gt;&gt; a; // 若输入 1 2 3 4 5 cout &lt;&lt; a; // 则输出 1 2 3 4 5 return 0;&#125; 函数模板作为类的友元 例如下面的普通类 A 和 B 都将 print() 函数模板声明为自己的友元，根据函数模板自动生成 print(const A &amp;) 和 print(const B&amp;) 来分别输出类 A 的 int 型私有成员变量 v 和类 B 的 double 型私有成员变量 v。 123456789101112131415161718192021222324252627class A &#123; int v;public: A(int _v = 3) : v(_v) &#123; &#125; template &lt;class T&gt; friend void print(const T &amp;);&#125;;class B &#123; double v; char *buf; void func() &#123; &#125;public: B(double _v = 2.1) : v(_v) &#123; &#125; template &lt;class T&gt; friend void print(const T &amp;);&#125;;class A &#123; int v; ... &#125;;class B &#123; double v; ... &#125;;template &lt;class T&gt;void print(const T &amp;p) &#123; cout &lt;&lt; p.v &lt;&lt; endl; &#125;int main() &#123; A a; print(a); // 输出 3 B b; print(b); // 输出 2.1 return 0;&#125; 类模板作为类模板的友元 例如下面的类模板 B 将类模板 A 声明为了自己的友元，在声明 b 对象时，自动生成模板类 B&lt;int&gt;；在声明 a 对象时，则自动生成模板类 A&lt; B&lt;int&gt; &gt;。由于 B&lt;int&gt; 声明了模板类 A 类为自己的友元，因此 A&lt; B&lt;int&gt; &gt; 对象 a 可以通过 func() 访问并输出 B&lt;int&gt; 对象 b 的私有成员变量 v。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class A &#123;public: void func(const T &amp;p) &#123; cout &lt;&lt; p.v; &#125;&#125;;template &lt;class T&gt;class B &#123; T v;public: B(T _v) : v(_v) &#123; &#125; template &lt;class T2&gt; friend class A; // 把类模板 A 声明为友元&#125;;int main() &#123; B&lt;int&gt; b(5); A&lt; B&lt;int&gt; &gt; a; // 用 B&lt;int&gt; 替换 A 中的 T a.func(b); // 输出 5 return 0;&#125; 类模板的一个综合示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template&lt;class T, int size&gt;class A&#123; T array[size];public: A(T* array_) &#123; for (int i = 0; i &lt; size; i++) &#123; array[i] = array_[i]; &#125; &#125; T&amp; operator[](int index) &#123; return array[index]; &#125; T sum() &#123; T s = array[0]; for (int i = 1; i &lt; size; i++) &#123; s += array[i]; &#125; return s; &#125;&#125;;int main() &#123; int b1[10] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; A&lt;int, 10&gt; a1 = b1; cout &lt;&lt; a1[2] &lt;&lt; endl; //输出：2 double b2[5] = &#123;4.2, 0.0, 3.1, 2.7, 5.2&#125;; A&lt;double, 5&gt; a2 = b2; cout &lt;&lt; a2.sum() &lt;&lt; endl; //输出：15.2 string b3[4] = &#123;\"Hello\", \", \", \"world\", \"!\"&#125;; A&lt;string, 4&gt; a3 = b3; cout &lt;&lt; a3.sum() &lt;&lt; endl; //输出：Hello, world! return 0; &#125; 4. string类string类本身是一个模板类，而它本身其实是由一个类模板实例化得到的，string类是一个非常好用的类库，在很多字符串处理的场合都会用到string类。 与string类有关的一些函数： 4.1.基础操作 string类是一个模板类，它的定义为：typedef basic_string&lt;char&gt;string; 使用string类要包含头文件：#include&lt;string&gt; string对象的初始化，string 类提供了多种构造函数： 可以根据字符串常量（const char *）来构造 string 对象 也可以指定字符串长度和填充的字符来构造 string 对象 123string s1(\"Hello\"); //一个参数的构造函数string S2(8,'x'); //两个参数的构造函数string month = \"March\"; 不提供以字符和整数为参数的构造函数，以下都是错误的初始化方法： 1234string error = 'c'; //错string error2('u'); //错string error3 = 22; //错string error4(8); //错 可以将字符赋值给string对象 12string s;s = 'n'; 构造的string对象太长而无法表达 $\\to$ 会抛出length_error异常 string对象的长度用成员函数length()读取： 12string s(\"hello\");cout &lt;&lt; s.length() &lt;&lt; endl; string支持流读取运算符： 12string stringObject;cin &gt;&gt; stringObject; string支持getline函数 12string s;getline(cin,s); 4.2. string的赋值和连接 用’=‘赋值 12string s1(\"cat\"), s2;s2 = s1; 用assign成员函数复制，也可以部分复制 123string s1(\"catpig\"), s2, s3;s2.assign(s1);s3.assign(s1,1,3); //从s1中下标为1的字符开始复制3个字符给s3 单个字符复制：s2[5] = s1[3] = &#39;a&#39;; 逐个访问string对象中的字符 123string s1(\"Hello\");for(int i = 0; i &lt; s.length(); i++) cout &lt;&lt; s1.at(i) &lt;&lt; endl; 成员函数at会做范围检查，如果超出范围，会抛出out_of_range异常，而下标运算符不做范围检查 用 + 运算符连接字符串 123string s1(\"good\"), s2(\"morning\");s1 += s2;cout &lt;&lt; s1; 用成员函数append连接字符串 123456string s1(\"good\"), s2(\"morning\");s1.append(s2);cout &lt;&lt; s1; //输出goodmornings2.append(s1,3,s1.size()); //s1.size()返回s1的字符数，//取下标从3开始，s1.size()个字符，如果字符串内没有足够字符，则复制到字符串的最后一个字符cout &lt;&lt; s2; //输出morningd 子串：成员函数substr() 123string s1(\"hello world\")s2 = s1.substr(4,5); //从下标4开始5个字符cout &lt;&lt; s2 &lt;&lt; endl; //输出：o wor 4.3.比较string 可以用关系运算符比较string对象的大小，==，&gt;，&gt;=，&lt;，&lt;=，!=，利用字符在字典中的顺序进行比较，且对字母的大小写敏感，返回值都是bool类型，成立返回true，否则返回false。 也可以使用成员函数 compare(string) 比较字符串大小，返回值为 int 型 若当前对象比被比较的对象（即括号中的对象）大，则返回 1；若相等则返回 0 ；若比被比较的对象小，则返回 -1。 比较原则为逐字符比较；若前面的字符全部相等，则较长的字符串大。 也可以使用成员函数 compare(int, int, string) 或 compare(int, int, string, int, int) 比较两个子串的大小，返回值为 int 型。 比较规则与 compare(string) 相同 使用时依次指定子串的起始位置和长度即可 1234567891011int main() &#123; string s1(\"Alice\"), s2(\"Bob\"); string s3(\"Alice and Bob\"); cout &lt;&lt; s2.compare(s1) &lt;&lt; endl; // 'B' &gt; 'A'，\"Bob\" 比 \"Alice\" 大，输出 1 cout &lt;&lt; s1.compare(s3) &lt;&lt; endl; // s1 是 s3 的一个前缀，s3 比 s1 大，输出 -1 cout &lt;&lt; s2.compare(0, 3, s3, 10, 3); // 输出 0 // (s2[0..2] = \"Bob\") == (s3[10..12] = \"Bob\") return 0;&#125; 4.4.寻找string中的字符 成员函数find()，如下例在s1中从前向后查找lo第一次出现的地方，如果找到，返回lo开始的位置，即l所在的位置下标；如果找不到，返回string::nps(string中定义的静态常量) 12string s1&#123;\"hello world\"&#125;;s1.find(\"lo\"); 成员函数rfind()，如下例在s1中从后向前查找lo第一次出现的地方，如果找到，返回lo开始的位置，即l所在的位置下标；如果找不到，返回string::nps 12string s1&#123;\"hello world\"&#125;;s1.rfind(\"lo\"); 成员函数find_first_of()，如下例在s1中从前向后查找abcd中任何一个字符第一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回string::nps 12string s1&#123;\"hello world\"&#125;;s1.find_first_of(\"abcd\"); 成员函数find_last_of()，如下例在s1中从前向后查找abcd中任何一个字符最后一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回string::nps 12string s1&#123;\"hello world\"&#125;;s1.find_last_of(\"abcd\"); 成员函数find_first_not_of()，如下例在s1中从前向后查找不在abcd中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回string::nps 12string s1&#123;\"hello world\"&#125;;s1.find_first_not_of(\"abcd\"); 成员函数find_last_not_of()，如下例在s1中从后向前查找不在abcd中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回string::nps 12string s1&#123;\"hello world\"&#125;;s1.find_last_not_of(\"abcd\"); 4.5.替换string的字符 成员函数erase()，删除字符串中指定位置及以后的内容；缺省值为 0 ，即清除字符串的所有内容（变成一个空串 “” ） 12345string s1(\"hello world\");s1.erase(5); //去掉下标5及之后的字符cout &lt;&lt; s1;cout &lt;&lt; s1.length(); cout &lt;&lt; s1.size(); //输出：hello55 成员函数find() 1234string s1(\"hello worlld\");cout &lt;&lt; s1.find(\"ll\", 1) &lt;&lt; endl;cout &lt;&lt; s1.find(\"ll\", 2) &lt;&lt; endl;cout &lt;&lt; s1.find(\"ll\", 3) &lt;&lt; endl; //分别从下标1,2,3开始查找ll，输出：2;2;9 成员函数replace(int, int, string)将字符串中的某一段替换为指定子串，前两个参数指定需要替换的起始位置和长度，第三个参数是进行替换的子串 123456string s1(\"hello world\");s1.replace(2,3,\"haha\"); //将s1中从下标2开始的3个字符换成\"haha\"cout &lt;&lt; s1; //输出hehaha worlds1.replace(2,3,\"haha\",1,2); //将s1中从下标2开始的3个字符换成\"haha\"中下标1开始的2个字符cout &lt;&lt; s1; //输出heha world 4.6.在string中插入字符 成员函数insert() 123456string s1(\"hello world\");string s2(\"show insert\");s1.insert(5,s2); //将s2插入s1下标5的位置cout &lt;&lt; s1 &lt;&lt; endl; //输出：helloshow insert worlds1.insert(2,s2,5,3); //将s2中下标5开始的3个字符插入s1下标2的位置cout &lt;&lt; s1 &lt;&lt; endl; //输出：heinslloshow insert world 可以使用成员函数 push_back(char) 在字符串末尾增加一个字符；C++11 标准中还增加了成员函数 pop_back() ，可以用来删除字符串中的最后一个字符。 12345string s = \"\";for (int i = 0; i &lt; 7; ++i) &#123; s.push_back('A' + i);&#125;cout &lt;&lt; s &lt;&lt; endl; // 输出 ABCDEFG 4.7.将string转换成C语言式 成员函数c_str()，返回传统的const char*类型字符串，且该字符串以’\\0‘结尾；data()也可以，但不会在字符串末尾增加结束符。 1234string s1(\"hello world\");printf(\"%s\\n\",s1.c_str()); //输出：hello worldconst char *p = s1.data();printf(\"%s\\n\", p); // 输出 Hello world C++11 中提供了 std::to_string() 函数，可以将 int / unsigned int / float / double 等数值转换为 string 对象，效果与 C 语言中的 %i / %u / %f / %lf 等相同 123456789101112#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int x = 42; double p = 3.14; string s = to_string(x); s += \" \" + to_string(p); cout &lt;&lt; s &lt;&lt; endl; // 输出 42 3.140000 return 0;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构与算法（10）二叉树的遍历","slug":"数据结构与算法（10）二叉树的遍历","date":"2020-02-21T03:42:13.000Z","updated":"2020-02-22T04:27:41.943Z","comments":true,"path":"2020/02/21/数据结构与算法（10）二叉树的遍历/","link":"","permalink":"http://nekomoon404.github.io/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次。 $T=V\\cup L \\cup R=\\{root\\} \\cup L_ subtree(T) \\cup R _ subtree(T)$ 遍历结果 ~ 遍历过程 ~ 遍历次序 ~ 遍历策略 先序遍历：V | L | R 中序遍历：L | V | R 后序遍历：L | R | V 层次遍历：自上为下，先左后右 1.先序遍历1.1递归以上三种典型的遍历策略都不难实现，因为它们的定义本身就是递归式的，以先序遍历为例，只需四句就可以实现。 1234567template &lt;typename T, typename VST&gt; //元素类型、操作器void travPre_R(BinNodePosi(T) x, VST&amp; visit) &#123; //二叉树先序遍历算法（递归版） if (!x) return; visit(x-&gt;data); travPre_R(x-&gt;lc, visit); travPre_R(x-&gt;rc, visit);&#125; //T(n) = O(1) + T(a) + T(n-a-1) = O(n) 这个算法的时间复杂度是线性的，即$O(n)$，然而这只具有渐近的意义。在实际的运行过程中，因为递归程序的实现机制，并不可能做到针对具体的问题来量体裁衣，而只能采用通用的方法。在运行栈中尽管每一个递归实例都的确只对应于一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。而针对于具体的问题，只要我们能够进行精巧的设计，完全是可以使得每一帧做到足够小的，尽管从big O的意义上讲，这两种策略所对应的每一帧都可以认为是常数，但是这种常数的差异实际上是非常巨大的。 因此作为树算法的一个重要基石，遍历算法非常有必要从递归形式改写为迭代形式，同时经过这样的改写之后，我们也可以对整个遍历算法的过程以及原理获得更加深刻的认识。稍加观察不难发现此处的两句递归调用都非常类似于尾递归，其特征是递归调用出现在整个递归实例体的尾部，这种递归是非常容易化解为迭代形式的，为此我们只需引入一个栈。 1.2.迭代（版本1）改写之后的第一个跌打版本，如这段代码所示，作为初始化取一个栈s用以存放树节点的位置，即它们的引用。首先将当前的树根x推入栈中，以下进入一个主体的循环，每一次弹出当前的节点并且随即对它进行访问，此后如果当前这个节点拥有右孩子就将右孩子推入栈中，如果有左孩子 那么左孩子也会随后入栈，此后整个循环又进入下一步迭代直到整个栈变空。 123456789template &lt;typename T, typename VST&gt; //元素类型、操作器void travPre_I1(BinNodePosi(T) x, VST&amp; visit) &#123; //二叉树先序遍历算法（迭代版#1） Stack&lt;BinNodePosi(T)&gt; S; //辅助栈 if (x) S.push(x); //根节点入栈 while (!S.empty()) &#123; //在栈变空之前反复循环 x = S.pop(); visit(x-&gt;data); //弹出并访问当前节点，其非空孩子的入栈次序为先右后左 if (HasRChild(*x)) S.push(x-&gt;rc); if (HasLChild(*x)) S.push(x-&gt;lc); &#125;&#125; 需要注意的是：左右孩子的入栈次序是先右后左，这是因为包括先序遍历在内的所有遍历，都先遍历左子树再去遍历右子树，在这个算法模式中既然每个节点都是在被弹出栈的时刻才接受访问，所以根据栈后进先出的特性，自然应该将希望后出栈的右子树先入栈了。 下面是一个实例： 正确性： 无遗落：每个节点都会被访问到 归纳假设：若深度为d的节点都能被正确访问到，则深度为d+1的也是 根先：对于任一子树，根被访问后才会访问其他节点 只需注意到：若u是v的真祖先，则u必先于v被访问到 左先右后：同一节点的左子树，限于右子树被访问 效率：$O(n)$ 每步迭代，都有一个节点出栈并被访问； 每个节点入/出栈一次仅且一次； 每步迭代只需$O(1)$时间。 可以看到算法所输出的节点序列恰好就是我们所希望得到的先序遍历序列，第一个迭代版算法非常简明，然而遗憾的是这种算法策略并不容易直接推广到此后要研究的中序遍历和后序遍历算法，因此我们或许应该另辟蹊径寻找其它等效的策略。 1.3.迭代（版本2）不妨从一个规模略大同时更具一般性的例子入手： 可以发现这样一个规律：一旦树根节点接过控制权并接受访问，接下来被访问的就是它的左孩子以及左孩子的左孩子，以及同样地，当不能下去的时候才会进行一次新的转移，而每转移到一个具体的局部，做的事情都是尝试着沿着这样的一个左孩子的分支不断地下行。 对于任何一棵子树，都将起始于树根的接下来总是沿着左侧孩子分支不断下行的这样一条链称作是当前这棵子树的左侧链，而这个算法就是沿着这个左侧链逐渐展开。 沿着左侧分支：各节点与其右孩子（可能为空）一一对应； 从宏观上，整个遍历过程可划分为：自上而下对左侧分支的访问，及随后自下而上对一系列右子树的遍历； 不同右子树的遍历相互独立，自成一个子任务。 新版本的迭代算符首先需要实现一个标准的例程visitAlongLeftBranch，它的任务就是来实现从根节点开始沿着left branch 不断下行，依次访问沿途所有节点的这样一个过程。 这个主算法则是反复地在每一个局部调用visitAlongLeftBranch这个例程来实现。 12345678910111213141516171819//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问template &lt;typename T, typename VST&gt; //元素类型、操作器static void visitAlongVine(BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S) &#123; while (x) &#123; visit(x-&gt;data); //访问当前节点 S.push(x-&gt;rc); //右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈） x = x-&gt;lc; //沿左分支深入一层 &#125;&#125;template &lt;typename T, typename VST&gt; //元素类型、操作器void travPre_I2(BinNodePosi(T) x, VST&amp; visit) &#123; //二叉树先序遍历算法（迭代版#2） Stack&lt;BinNodePosi(T)&gt; S; //辅助栈 while (true) &#123; visitAlongVine(x, visit, S); //从当前节点出发，逐批访问 if (S.empty()) break; //直到栈空 x = S.pop(); //弹出下一子树的树根 &#125; #pop = #push = #visit = O(n) = 分摊O(1)&#125; 这里之所以使用一个栈而不是队列的用意，依然是因为栈的后进先出的特性，对于左侧链的访问的是自上而下的，存入栈中的右子树也就是自上而下的，而接着对右子树的遍历是自下而上的，对栈来说就是自顶向底的，对栈的一系列依次的pop操作则恰好可以实现栈中右子树的自顶向底的访问。 下面看一个实例：（^代表空） 2.中序遍历2.1.递归1234567template &lt;typename T, typename VST&gt; //元素类型、操作器void travIn_R(BinNodePosi(T) x, VST&amp; visit) &#123; //二叉树中序遍历算法（递归版） if (!x) return; travIn_R(x-&gt;lc, visit); visit(x-&gt;data); travIn_R(x-&gt;rc, visit);&#125; 将递归转换为迭代的难点在于尽管右子树的递归遍历是尾递归，但左子树却严格地不是。解决方法可是是：找到第一个被访问的节点，将其祖先用栈保存，这样原问题就分解为依次对若干棵子树的遍历问题。 2.2迭代同样从一个规模略大同时更具一般性的例子入手： 与先序遍历非常类似，整个中序遍历过程是从根节点开始，一直沿着左侧分支逐层向下，直到末端不能再向下的那个节点，因此可以将整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理。我们可以将任何一棵二叉树抽象地规范为如下图所示的形式，整棵树可以分解为一条起自根节点的左侧链以及左侧链上各节点所对应的右孩子。 在一个局部，当前节点$L_{d-1}$将控制权交给并访问它的左孩子$L_d$后，再遍历$L_d$的右子树$T_d$，然后回到并访问节点$L_{d-1}$，再遍历其右子树$T_{d-1}$，如此反复直到遍历全树。在这样的一个过程中存在着某种逆序性，我们最初的起点是在根节点处可是首先接受访问的却是它所对应的左侧链的末端节点，如果说这个的过程是自顶而下的话，那么各节点实际被访问的次序大体而言是呈一种自下而上的过程，因此仍然要使用栈结构来实现这一过程。 12345678910111213141516template &lt;typename T&gt; //从当前节点出发，沿左分支不断深入，直至没有左分支的节点static void goAlongLeftBranch(BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S) &#123; while (x) &#123; S.push(x); x = x-&gt;lChild; &#125; //当前节点入栈后随即向左侧分支深入，迭代直到无左孩子&#125;template &lt;typename T, typename VST&gt; //元素类型、操作器void travIn_I1(BinNodePosi(T) x, VST&amp; visit) &#123; //二叉树中序遍历算法（迭代版#1） Stack&lt;BinNodePosi(T)&gt; S; //辅助栈 while (true) &#123; goAlongLeftBranch(x, S); //从当前节点出发，逐批入栈 if (S.empty()) break; //直至所有节点处理完毕 x = S.pop(); //x的左子树或为空，或已遍历（等效于空），故可以 visit(x-&gt;data); //弹出栈顶节点并访问之 x = x-&gt;rChild; //转向右子树 &#125;&#125; 下面是一个实例： 我们知道递归的版本可以简明地实现$O(n)$的复杂度，尽管它的常系数非常之大，那么迭代版本的时间复杂度仍是$O(n)$，但常系数要小的多（分摊分析）。尽管单次调用goAlongLeftBranch就可能需要做$\\Omega(n)$次入栈操作需要$\\Omega(n)$时间，但这些左侧链的长度加起来也不过是n，因此迭代算法的复杂度仍是线性的，即$O(n)$。 此外还要其他版本的中序遍历的迭代实现，如版本2： 1234567891011121314template &lt;typename T, typename VST&gt; //元素类型、操作器void travIn_I2 ( BinNodePosi(T) x, VST&amp; visit ) &#123; //二叉树中序遍历算法（迭代版#2） Stack&lt;BinNodePosi(T)&gt; S; //辅助栈 while ( true ) if ( x ) &#123; S.push ( x ); //根节点进栈 x = x-&gt;lc; //深入遍历左子树 &#125; else if ( !S.empty() ) &#123; x = S.pop(); //尚未访问的最低祖先节点退栈 visit ( x-&gt;data ); //访问该祖先节点 x = x-&gt;rc; //遍历祖先的右子树 &#125; else break; //遍历完成&#125; 版本3： 1234567891011121314151617template &lt;typename T, typename VST&gt; //元素类型、操作器void travIn_I3 ( BinNodePosi(T) x, VST&amp; visit ) &#123; //二叉树中序遍历算法（迭代版#3，无需辅助栈） bool backtrack = false; //前一步是否刚从左子树回溯——省去栈，仅O(1)辅助空间 while ( true ) if ( !backtrack &amp;&amp; HasLChild ( *x ) ) //若有左子树且不是刚刚回溯，则 x = x-&gt;lc; //深入遍历左子树 else &#123; //否则——无左子树或刚刚回溯（相当于无左子树） visit ( x-&gt;data ); //访问该节点 if ( HasRChild ( *x ) ) &#123; //若其右子树非空，则 x = x-&gt;rc; //深入右子树继续遍历 backtrack = false; //并关闭回溯标志 &#125; else &#123; //若右子树空，则 if ( ! ( x = x-&gt;succ() ) ) break; //回溯（含抵达末节点时的退出返回） backtrack = true; //并设置回溯标志 &#125; &#125;&#125; 版本4： 12345678910111213template &lt;typename T, typename VST&gt; //元素类型、操作器void travIn_I4 ( BinNodePosi(T) x, VST&amp; visit ) &#123; //二叉树中序遍历（迭代版#4，无需栈或标志位） while ( true ) if ( HasLChild ( *x ) ) //若有左子树，则 x = x-&gt;lc; //深入遍历左子树 else &#123; //否则 visit ( x-&gt;data ); //访问当前节点，并 while ( !HasRChild ( *x ) ) //不断地在无右分支处 if ( ! ( x = x-&gt;succ() ) ) return; //回溯至直接后继（在没有后继的末节点处，直接退出） else visit ( x-&gt;data ); //访问新的当前节点 x = x-&gt;rc; //（直至有右分支处）转向非空的右子树 &#125;&#125; 3.层次遍历我们此前讨论的有根有序树，任何一棵二叉树都被指定了一个特殊的节点：根节点，由此就可以在垂直方向按照深度将所有节点划分为若干个等价类，因此可以认为所谓的有根性对应的就是垂直方向的次序。 进一步地位于同一深度也属于同一等价类内部的所有节点，即所有的同辈节点也可以分出次序，比如对于二叉树可以通过左右的明确定义给出同辈节点之间的相对次序，因此可以认为有序给出沿水平方向的一个次序。 因此按照垂直方向和水平方向的次序可以在所有的节点之间定义一个整体的次序，并进而对它进行遍历。自高向低而在每一层自左向右逐一地访问树中的每一个节点的遍历策略及过程就是层次遍历。 此前的三种遍历策略：先序、中序和后序都无法保证所有节点严格地按照深度次序访问，都有后代限于祖先被访问的情况，即逆序，为此需要借助栈结构。反过来，在层次遍历中，所有节点的访问都满足顺序性，因此这里就需要借助与栈结构对称的队列结构。 具体实现为： 12345678910template &lt;typename T&gt; template &lt;typename VST&gt; //元素类型、操作器void BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; //二叉树层次遍历算法 Queue&lt;BinNodePosi(T)&gt; Q; //辅助队列 Q.enqueue ( this ); //根节点入队 while ( !Q.empty() ) &#123; //在队列再次变空之前，反复迭代 BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); //取出队首节点并访问之 if ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lChild ); //左孩子入队 if ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rChild ); //右孩子入队 &#125;&#125; 下面是一个实例： 4.重构由任何一棵二叉树我们都可以导出三个序列：先序(preorder)、中序(inorder)和后序(postorder)遍历序列，这三个序列的长度相同，它们都是由树中的所有节点依照对应的遍历策略所确定的次序依次排列而成。那么如果我们已知某棵树的遍历序列，是否可以还原出这棵树的拓扑结构？什么情况下可以？什么情况下不可以？如果可以具体又应该使用什么样的方法？ 关于二叉树重构的第一个结论是：只需中序遍历序列再加上先序与后序遍历序列之一，即可还原二叉树的完整拓扑结构。 用数学归纳来证明：假设对于规模小于大N的所有二叉树这个规律都是成立的，接下来考察规模恰好为N的二叉树。在先序遍历序列中可以地将左子树和右子树所对应的遍历子序列切分开。这样就将原来全树的重构问题化解为两棵子树的重构问题，这两棵子树在规模上都符合归纳假设，即它们都严格地小于大N，因此根据归纳假设无论是左子树还是右子树都可以重构出来。 当然你应该不难写出一个递归式的重构算法，需要特别注意的是无论是左子树还是右子树，都有可能是空树，在这种情况下树的规模应该是零。而不借助中序遍历序列而只凭借先序和后序遍历序列，是不能保证完成对左右子树的正确切分的。因为无论是L还是R都有可能是空树，在先序遍历或者后序遍历的表达中会出现歧义，我们无法根据先序遍历序列以及后序遍历序列来区分在这种情况下除去根节点之后的部分究竟是左子树还是右子树。 在某些特定情况下由先序和后序遍历序列也可以还原树的整体结构。比如对于真二叉树，每个节点的度数都必须是偶数，即0度或2度，此时的左子树和右子树要么同时为空要么同时非空。 在任何给定的先序遍历序列中都可以找到其左子树L，进而在后序遍历序列中对它进行定位，而这个节点在它所属的这棵子树的后序遍历子序列中必然垫后，这就意味着我们可以明确地界定左右子树的范围，即左子树由哪些节点构成以及右子树由哪些节点构成都是可以确定的。 当然对称地在后序遍历序列中，右子树的树根位置也是确定的，因此通过右子树的树根节点依然可以反过来在先序遍历序列中进行定位，而且同样地可以确定左右子树的切分位置。也就是说我们在这里确实可以进行分而治之从而通过递归的形式，完整地重构出一棵真二叉树原本的结构。","categories":[],"tags":[]},{"title":"Cpp基础（11）虚函数和多态","slug":"Cpp基础（11）虚函数和多态","date":"2020-02-20T10:03:49.000Z","updated":"2020-02-22T10:03:49.000Z","comments":true,"path":"2020/02/20/Cpp基础（11）虚函数和多态/","link":"","permalink":"http://nekomoon404.github.io/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/","excerpt":"","text":"1.基本概念1.1.虚函数 在类的定义中，前面有virtual 关键字的成员函数就是虚函数。 1234class base&#123; virtual int get();&#125;;int base::get() &#123;...&#125; virtual 关键字只用在类定义里的函数声明中，写函数体时不用。 构造函数和静态成员函数不能是虚函数。 虚函数和普通函数的本质区别在于虚函数可以参与多态，而普通成员函数不能。 派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数。 1.2.多态的表现形式一 派生类的指针可以赋给基类指针。 通过基类指针调用基类和派生类中的同名虚函数时： 若该指针指向一个基类的对象，那么被调用的是基类的虚函数； 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 这种机制就叫作多态。 123456789101112131415class Animal &#123;public: virtual void sayHi() &#123; cout &lt;&lt; \"Hi\" &lt;&lt; endl; &#125;&#125;;class Dog : public Animal &#123;public: void sayHi() &#123; cout &lt;&lt; \"Woof!\" &lt;&lt; endl; &#125;&#125;;void func(Animal *pa) &#123; pa-&gt;sayHi(); &#125; // 使用基类指针调用函数int main() &#123; Animal a; Dog d; func(&amp;a); // 指向基类对象，则输出 Hi func(&amp;d); // 指向派生类对象，则输出 Woof! return 0;&#125; 1.3.多态的表现形式二 派生类的指针可以赋给基类引用。 通过基类引用调用基类和派生类中的同名虚函数时： 若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数； 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。 不加virtual，就根据指针，引用的类型来决定调用基类还是派生类的函数；加virtual，就是虚函数，就根据指针所指，引用所引的类型来决定调用基类还是派生类的函数。派生类的函数与基类的虚函数同名且参数列表完全相同时才能体现多态性，因此一般应该禁止重新定义继承而来的非虚函数。 在多层继承的情况下，从定义virtual开始的派生类中同名函数均为虚函数，无论在这些派生类的同名函数中是否显示加virtual。如果派生类将基类中的某个非虚函数声明为虚函数，使用基类指针调用该函数时，不能体现多态。 当基类指针指向派生类对象时，会优先选择符合多态的派生类成员函数。 2.多态程序实例2.1.例1几何形体处理程序几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出。输出时要指明形状。 输入Input：第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母c开头 若 c 是 ‘R’，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高； 若 c 是 ‘C’，则代表一个圆，本行后面跟着一个整数代表其半径； 若 c 是 ‘T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。 输出Output：按面积从小到大依次输出每个几何形体的种类及面积，每行一个几何形体，输出格式为：形体名称：面积 类的定义： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;using namespace std;class Shape &#123;public: virtual double Area() = 0; //纯虚函数 virtual void PrintInfo() = 0;&#125;;class Rectangle :public Shape &#123;public: int w, h; virtual double Area(); virtual void PrintInfo();&#125;;class Circle :public Shape &#123;public: int r; virtual double Area(); virtual void PrintInfo();&#125;;class Triangle :public Shape &#123;public: int a,b,c; virtual double Area(); virtual void PrintInfo();&#125;; 各成员函数的实现： 123456789101112131415161718192021222324double Rectangle::Area() &#123; return w * h;&#125;void Rectangle::PrintInfo() &#123; cout &lt;&lt; \"Rectangle: \" &lt;&lt; Area() &lt;&lt; endl;&#125;double Circle::Area() &#123; return 3.14 * r * r;&#125;void Circle::PrintInfo() &#123; cout &lt;&lt; \"Circle: \" &lt;&lt; Area() &lt;&lt; endl;&#125;double Triangle::Area() &#123; double p = (a + b + c) / 2.0; return sqrt(p*(p - a)*(p - b)*(p - c));&#125;void Triangle::PrintInfo() &#123; cout &lt;&lt; \"Triangle: \" &lt;&lt; Area() &lt;&lt; endl;&#125; 用一个指向Shape基类的指针数组pShapes来存放各个几何形体，数组中的每一个元素都是基类指针，因此它可以指向不同派生类的对象。MyCompare函数比较两个几何形体面积的大小。 12345678910111213141516Shape * pShapes[100];int MyCompare(const void * s1, const void * s2) &#123; double a1, a2; Shape **p1; //s1,s2是void*，不可写 *s1 来取得s1指向的内容 Shape **p2; p1 = (Shape**)s1; //s1,s2指向Shapes数组中的元素，数组元素的类型是Shape* p2 = (Shape**)s2; //故p1,p2都是指向指针的指针，类型为Shae** a1 = (*p1)-&gt;Area(); //*p1的类型是Shape*，是基类指针，故此句为多态 a2 = (*p2)-&gt;Area(); if (a1 &lt; a2) return -1; else if (a2 &lt; a1) return 1; else return 0;&#125; 主函数： 123456789101112131415161718192021222324252627282930int main() &#123; int i; int n; Rectangle *pr; Circle *pc; Triangle *pt; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; char c; cin &gt;&gt; c; switch (c) &#123; case'R': pr = new Rectangle(); cin &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h; pShapes[i] = pr; break; case'C': pc = new Circle(); cin &gt;&gt; pc-&gt;r ; pShapes[i] = pc; break; case'T': pt = new Triangle(); cin &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c; pShapes[i] = pt; break; &#125; &#125; qsort(pShapes, n, sizeof(Shape*), MyCompare); //按指针指向的几何形体的面积从小到大排序 for (i = 0; i &lt; n; i++) pShapes[i]-&gt;PrintInfo(); //多态，根据pShapes[i]指向的对象调用其对应的成员函数 return 0;&#125; 运用多态来实现这个问题所带来的好处就是提高了程序的可扩充性，如果要添加新的几何形体如五边形，则只需要从Shape里派生出Pentagon，以及在main函数中的swtich语句中增加一个case，其余部分不变。 用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常见的做法。 2.2.例2再看下面的例子： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;class Base &#123;public: void fun1() &#123; fun2(); &#125; //等价于 this-&gt;fun2，fun2是虚函数，所以这句是多态 virtual void fun2() &#123; cout &lt;&lt; \"Base::fun2()\" &lt;&lt; endl; &#125;&#125;;class Derived:public Base &#123;public: virtual void fun2() &#123; cout &lt;&lt; \"Derived::fun2()\" &lt;&lt; endl; &#125;&#125;;int main() &#123; Derived d; Base * pBase = &amp;d; pBase-&gt;fun1(); return 0;&#125; 上面程序运行的结果是Derived::fun2()，而不是Base::fun2()。这是因为pBase-&gt;fun1指至pbase是指向一个派生类的对象d的，那进到fun1里面，this指针指向的东西自然也就是这个d，所以此时this指针指向的是一个派生类的对象，那么根据多态的原则这条语句就会调用派生类的fun2，也就是Derieved类的fun2，所以会输出Derieved的fun2，即Derived::fun2()。 成员函数中调用虚函数有这样的规则： 在非构造函数，非析构函数的成员函数中调用虚函数，是多态。 在构造函数和析构函数中调用虚函数，不是多态。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class myclass &#123;public: virtual void hello() &#123; cout &lt;&lt; \"hello from myclass\" &lt;&lt; endl; &#125; virtual void bye() &#123; cout &lt;&lt; \"bye from myclass\" &lt;&lt; endl; &#125;&#125;;class son :public myclass &#123;public: //派生类中和基类中虚函数同名同参数表的函数，不加`virtual`也自动成为虚函数 void hello() &#123; cout &lt;&lt; \"hello from son\" &lt;&lt; endl; &#125; son() &#123; hello(); &#125;; ~son() &#123; bye(); &#125;;&#125;;class grandson :public son &#123;public: virtual void hello() &#123; cout &lt;&lt; \"hello from grandson\" &lt;&lt; endl; &#125; virtual void bye() &#123; cout &lt;&lt; \"bye from grandson\" &lt;&lt; endl; &#125; grandson() &#123; cout &lt;&lt; \"constructing grandson\" &lt;&lt; endl; &#125; ~grandson() &#123; cout &lt;&lt; \"destructing grandson\" &lt;&lt; endl; &#125;&#125;;int main() &#123; grandson gson; son *pson; pson = &amp;gson; pson-&gt;hello(); //多态 return 0;&#125; 程序运行结果： 3.多态实现原理“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫“动态联编”。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;class Base &#123;public: int i; virtual void Print() &#123; cout &lt;&lt; \"Base:Print\"; &#125;&#125;;class Derived:public Base &#123;public: int n; virtual void Print() &#123; cout &lt;&lt; \"Derived:Print\"; &#125;&#125;;int main() &#123; Derived d; cout &lt;&lt; sizeof(Base) &lt;&lt; \".\" &lt;&lt; sizeof(Derived); return 0;&#125; 程序运行输出结果为：8,12。那么为什么这个对象的大小都多出了4个字节呢？ 多态实现的关键——虚函数表： 每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的4个字节就是用来放虚函数表的地址的。 多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。 多态在提高程序可扩充性时也会有一定的代价：多态程序在运行期间会有额外的时间和空间上的开销，即时间上编译时会查询虚函数表，空间上每个有虚函数的类的对象里都会多出4个字节来存放虚函数表的地址。 需要注意的是，在构造函数和析构函数中调用虚函数时，调用的是自己的类或基类中定义的函数，不会等到运行时才决定，因此不是动态联编。在普通成员函数中调用虚函数，才是动态联编，是多态。 4.虚析构函数12345678910111213141516class son &#123;public: ~son() &#123; cout &lt;&lt; \"bye from son\" &lt;&lt; endl; &#125;&#125;;class grandson :public son &#123;public: ~grandson() &#123; cout &lt;&lt; \"bye from grandson\" &lt;&lt; endl; &#125;&#125;;int main() &#123; son *pson; pson = new grandson; delete pson; return 0;&#125; 上面的程序运行会输出bye from son，pson这个基类的指针指向了派生类的对象，当delete pson后会引起一些问题，直观上看因为delete掉的是一个基类的指针，所以会去调用基类的析构函数。但是逻辑上讲这个指针本身又指向的是一个派生类的对象，那么分配的也是一个派生类对应的这样的一个内存空间，那么这时它应该调用的还有派生类的析构函数，但是目前的程序设计角度上来看编译器是不会知道它需要调用派生类的机构函数的，这样可能导致一些问题。 我们希望做的是： 通过基类的指针删除一个派生类的对象时，先调用派生类的析构函数，再调用基类的析构函数。 解决方法是： 把基类的析构函数声明为virtual，派生类的析构函数virtual可以不进行声明。 类如果定义了虚函数，则最好将析构函数也定义成虚函数。 注意：不允许以虚函数作为构造函数 一般来说，如果一个类中定义了虚函数，则应该将析构函数也定义成虚函数；同理，若一个类没有定义虚函数，但需要通过基类的指针销毁派生类对象，也应该将析构函数声明为虚函数。 12345678910111213141516class son &#123;public: virtual ~son() &#123; cout &lt;&lt; \"bye from son\" &lt;&lt; endl; &#125;&#125;;class grandson :public son &#123;public: ~grandson() &#123; cout &lt;&lt; \"bye from grandson\" &lt;&lt; endl; &#125;&#125;;int main() &#123; son *pson; pson = new grandson; delete pson; return 0;&#125; 5.纯虚函数和抽象类 纯虚函数：没有函数体的虚函数 123456789101112class A&#123;private: int a;public: virtual void Print() = 0; //纯虚函数 void fun()&#123; cout &lt;&lt; \"fun\"; &#125;&#125;;int main()&#123; A a; //错误，A是抽象类，不能创建对象 A *pa; //正确，可以定义抽象类的指针和引用 pa = new A; //错误，A是抽象类，不能创建对象&#125; 抽象类：包含纯虚函数的类 抽象类只能作为基类来派生新类使用； 不能创建抽象类的对象； 抽象类的指针和引用 $\\to$ 由抽象类派生出来的类的对象。 在抽象类中： 在成员函数内可以调用纯需函数； 在构造函数/析构函数内部不能调用纯虚函数 如果一个类从抽象类派生而来 $\\to$ 它实现了基类中的所有纯需函数，才能成为非抽象类。 123456789101112131415class A&#123;public: virtual void f() = 0; //纯虚函数 void g()&#123; this-&gt;f(); &#125; //ok A() &#123; f();&#125; //错误&#125;;class B:public A&#123;public: void f()&#123; cout &lt;&lt; \"B:f()\" &lt;&lt; endl;&#125; //将虚函数“实例化”&#125;;int main()&#123; B b; b.g(); return 0;&#125; 输出结果：B:f()","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构与算法（9）二叉树","slug":"数据结构与算法（9）二叉树","date":"2020-02-20T01:11:42.000Z","updated":"2020-02-21T03:31:16.237Z","comments":true,"path":"2020/02/20/数据结构与算法（9）二叉树/","link":"","permalink":"http://nekomoon404.github.io/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"1.树回顾之前所学的向量结构（Vector）和列表结构（List），对于以查找为代表的静态操作和以插入为代表的动态操作，两者都无法兼顾静态和动态的高效性。而本章要介绍的树结构恰好能将二者的优势结合起来，即可快速查找，又可以快速插入和删除。树可以理解为列表的列表，或二维的列表。树并不是严格意义上的线性结构，但又带有一定的线性特征，因此树可以被称为半线性结构。 树是用来按照层次关系组织一系列数据项的一种方式，如：表达式、文件系统、函数调用和递归过程、Internet URL等等。 1.1.有根树 树是特殊的图T = ( V, E)，可以认为树是定义在一组元素之间的二元关系，节点（Vertex）数 |V| = n，边（edge）数 |E| = e。 为树指定任一节点 r $\\in$ V作为根后，树T 即称作有根树（rooted tree）。 对于任何一组有根树都可以通过引入一个新的顶点，并且在新的这个顶点与此前各棵有根树的树根之间引入对应的一条连边，从而构成一棵规模更大的有根树，这棵新的有根树的树根就是所引入的这个新的节点，通常记作r，暗示着它就是root树根。而对于这棵更大的树，参与组成它的每一棵有根树都相对地称作是它的子树subtree。 若：$T_1,T_2,\\dots ,T_d$是有根树，则：$T=\\left( (\\cup V_i)\\cup\\{r\\},\\,(\\cup E_i)\\cup\\{|1\\le i\\le d\\} \\right)$也是有根树。 相对于$T$，$T_i$称作以$r_i$为根的子树（subtree rooted at $r_i$），记作$T_i$ = subtree( $r_i$ )。 1.2.有序树 $r_i$称作$r$的孩子（child），$r_i$之间互称兄弟（sibling）； $r$为其父亲（parent），d = degree( r )为$r$的（出）度（degree）。 可归纳证明： e（节点数总和）= $\\sum_{r\\in V}degree(r)$ = n - 1 = $\\Theta(n)$，即任何一棵树中的边数与其中顶点的数目是同阶的，一棵树的总体规模也可度量为( n + e )，故在衡量相关复杂度时，可以n作为参照。 若指定$T_i$为$T$的第$i$棵子树，$r_i$作为$r$的第$i$个孩子（即在兄弟间定义了次序），则$T$称作有序树（ordered tree）。 1.3.连通与无环上面从递归嵌套的角度定义了树，但我们并没有看到树结构相对于一般的图结构而言在拓扑上到底有什么不同。那么接下来将从连通性和无环性两个角度来揭示树结构的特性。 V中的k+1个节点，通过E中的k条边依次相连，构成一条路径（path）： $\\pi=\\{ \\, (V_0,V_1),\\, (V_1,V_2),\\,\\dots,\\,(V_{k-1},V_k)\\, \\}$ 路径长度：$|\\pi|=$边数$=k$ 任意节点之间均有路径的图，称作连通图（connected graph） 若$V_k=V_0$，则该路径是环路（cycle/loop），不含环路的图，称作无环图（acyclic graph）。 树结构是无环连通图，即是极小连通图，也是极大无环图。 故在树中，任一节点V与根之间存在唯一路径，故可记 path(v, r) = path(v) 因此可以|path(v)|为指标，对所有节点做等价类划分。 1.4.深度与层次 在不致歧义的情况下，路径、节点和子树可相互指代： path(v) ~ v ~ subtree(v) v的深度：depth(v) = |path(v)| path(v)上的节点均为v的祖先（ancestor），v是它们的后代（descendent）；除v自身以外的祖先，是真（proper）祖先。 在任一深度：v的祖先若存在则必然唯一；v的后代未必唯一。从这个意义上讲也应该将数称为半线性结构。 根节点是所有节点的（公共）祖先，深度为0；没有后代的节点称作叶子（leaf）。 所有叶子深度中的最大者称为子树的高度：height(v) = height( subtree( v ) )；注意与树根的高度（height(T))区分开。 特别低，只有一个节点的树的高度为1，空树的高度为-1。 depth( v ) + height( v ) $\\le$ height( T ) 2.树的表示上一节介绍了树的基本概念，这一节将来讨论在计算机中如何从逻辑上来表示一棵树，从抽象数据类型的角度来看树结构应该提供大致如下这些接口： 2.1.父节点 除根外，任一节点有且仅有一个父节点。 不妨将所有的节点组织为一个序列：其中的每一个元素都分别包括三项，data是节点本身的信息，rank或者position指明的是这个节点的记录在这个序列中所对应的秩或者是位置，而parent恰好就是节点唯一的父节点所对应的秩或者是位置。树根也有一个“虚构的”父节点-1或NULL。 空间性能：$O(n)$ 时间性能： ​ parent()：$O(1)$ ​ root()：$O(n)$或$O(1)$ firstChild()：$O(n)$ nextSibling()：$O(n)$ 这样做有一定的好处，不幸的是如果要向下索取某个节点的后代比如长子，依然需要去遍历所有的元素并且逐一地确认它的父节点是否就是当前查询的元素，这个基本操作在最坏情况下需要线性时间$O(n)$；而查找兄弟节点也是类似的在最坏情况下需要遍历整棵树。因此我们下一步改进自然就集中在这两种向下方向的查询上。 2.2.孩子节点不妨对于任何一个节点都将它的孩子汇聚起来构成一个更小的数据集，为每一个节点准备一个名为children的引用，所指向的是由它的所有的孩子构成的一个序列，如使用列表来实现这个序列，列表的长度分别等于对应节点当前的度数。 这个方法解决了向下的查找问题，而向上的查找优势却丧失殆尽，不难发现为了查找某一个节点的父亲不得不去遍历整个线性序列，并且逐一地翻看它所对应的孩子记录，在最坏的情况下仍需要线性时间$O(n)$。 2.3.父节点+孩子节点如果将刚才的两个线性的序列组合起来，即对于同一个节点不仅保留它的parent域，同时还要保留它的children这样的一个引用，那么刚才两个方向的优势是可以兼而有之的。如果要去查找父亲就在parent这一列中进行查找，需要$O(1)$的时间；如果要是去查找孩子，就在children所指向的序列中再去查找，若是长子就可在$O(1)$的时间内直接返回，若是其它的孩子最多是去遍历序列。 但这种方法仍有一些不足：每一个节点的children引用所指向的序列在规模上有可能相差极其悬殊，每一个序列的长度恰好是节点对应的出度，而出度的总和为$\\sum_{r\\in V}degree(r)$ = n - 1 = $\\Theta(n)$，与n同阶。而这种组织方式有时需要长达$O(n)$的一个数据集，为此需要找到一些新的办法，更加规范并相应也更简洁和高效。 2.4.长子+兄弟反观上小节方法存在根源在于每一个节点的出度是不尽相同的，为进行改进我们必须发现每个节点所具有的某种不变性。就向下的引用而言每一个节点只需记两个信息就够了，第一个就是它的长子，第二个是每一个节点的下一个兄弟。 每个节点均设两个引用： 纵向：firstChild() 横向：nextSibling() 如此，对于度数为d的节点，可在$O(n+1)$时间内遍历其所有孩子 若再设置parent引用，则parent()接口也仅需$O(1)$时间 相对于此前的表示方法，这种表示方法的规整性非常的突出，由于每个节点只需记录两个引用，因此其点所需要占用的空间依然是常数，，而且都彼此接近，这是此前的常规方法所无法比拟的。 这种长子兄弟法不仅是树的一种很好的表示方法，而且也是对树的本质的一种更深刻的理解，在此后介绍二叉树并且用二叉树来代表所有的树的时候，我们将再次用到这样一种表示方法。对于树这样的一个全集来说尽管二叉树只是它的一个特殊的子集，但是很有趣的是在施加了某些条件之后，二叉树却足以来表示和实现所有的树，而这样一种方法背后的原理在很大程度上就是基于长子兄弟法。 3.二叉树这一节介绍树的一种特殊但又不失代表性的特例：二叉树（binary tree） 节点数不超过2的树，称作二叉树 同一节点的孩子和子树，均以左、右区分（隐含着有序性） lChild() ~ lSubtree() rChild() ~ rSubtree() 3.1.基数 二叉树中深度为k的节点至多$2^k$个 含n个节点、高度为h的二叉树中有：$h&lt;n&lt;2^{h+1}$ 当 $n=h+1$时，退化为一条单链 当$n=2^{h+1}-1$时，称作满二叉树（full binary tree） 由此也可见一棵二叉树在横向上的宽度与它在纵向上的高度是呈一个指数的关系的，宽度是高度的指数，而指数意味着爆炸（剧烈的增长），所以如果节点的总数固定，宽度大致与它相当，但是高度却会增长的非常的缓慢呈一个对数的形式。也就是说对于一棵二叉树而言，它非常倾向于“涨宽”，它“涨宽”的速度更快，而它的高度呢如果控制得当的话会增长的异常的缓慢，这个特点也是之后介绍的二叉搜索树的重要理论基础。 3.2.真二叉树上面介绍的二叉树只对每个节点的出度做了个上限的约定，即不得超过2。这样一般性的一棵二叉树在很多操作，包括算法的实现以及对算法的理解上都会引来一些不必要的麻烦。而反过来一个比较有效的改进方法就是将任何的这样一棵一般性的二叉树转化为一棵真二叉树（proper binary tree）。 通过引入$n_0+n_2$个外部节点，可是原有节点度数同一为2，如此即可将任一二叉树转化为真二叉树。 经过转换之后，从渐进意义上，全树自身的复杂度并未实质增加。 在之后实现相应的算法的时候就会看到这种添加实际上完全是假想的，即并不需要真正去引入节点，只需要假想着它们存在，你的算法就可以更加简洁的实现而且更加简洁的被理解。 3.3.描述多叉树接下来来介绍这一节最重要的一点：如何通过二叉树来描述多叉树。其实上需要的条件只有两条：有根和有序。 二叉树是多叉树的特例，但在有根且有序时其描述能力却足以覆盖后者； 即任意有根有序的多叉树均可转换为二叉树——回顾“长子-兄弟”表示法； 为此只需将节点处旋转45度，将长子，兄弟与左、右孩子等效地相互对应： firstChild() ~ lChild() nextSibling() ~ rChild() 如果说这一章的任务是描述并且实现以及利用树结构的话，不如说我们只需研究并且实现二叉树。接下来几节将介绍二叉树结构的实现和相关的算法。 4.二叉树实现在此前的几节先后介绍了树的概念，了解了树的特点，并且懂得了如何来表示一棵树。最重要的方法就是借助二叉树来表示任何一棵有根有序树，所以接着就来介绍如何在C++语言中实现一棵二叉树。 4.1.BinNode模板类二叉树的基本组成单位是二叉树节点（Binary Node， 或简称BinNode），每一个BinNode的逻辑组成可以用下图来表示。每一个BinNode节点首先应该有一个data域，记录它携带的信息，这是BinNode节点的核心的要素；它也应该配备相应的引用域，分别指向左右孩子以及父亲；此外作为在树中的一个特定元素它也需要记录一些重要的指标，比如height 高度，对于红黑树而言就会有颜色的区别，对于左式堆而言有npl指标，所以也需要为它们留有余地。 下面定义名为BinNode的类 12345678910111213141516171819202122232425#define BinNodePosi(T) BinNode&lt;T&gt;* //节点位置template &lt;typename T&gt; struct BinNode &#123; //二叉树节点模板类 BinNodePosi(T) parent, lChild, rChild; //父节点及左、右孩子 T data; int height; //数据，/高度（通用）// 构造函数 BinNode() : parent ( NULL ), lc ( NULL ), rc ( NULL ), height ( 0 ), npl ( 1 ), color ( RB_RED ) &#123; &#125; BinNode ( T e, BinNodePosi(T) p = NULL, BinNodePosi(T) lc = NULL, BinNodePosi(T) rc = NULL, int h = 0, int l = 1, RBColor c = RB_RED ) : data ( e ), parent ( p ), lc ( lc ), rc ( rc ), height ( h ), npl ( l ), color ( c ) &#123; &#125; // 操作接口 int size(); //统计当前节点后代总数，亦即以其为根的子树的规模 BinNodePosi(T) insertAsLC(T const&amp;); //作为当前节点的左孩子插入新节点 BinNodePosi(T) insertAsRC(T const&amp;); //作为当前节点的右孩子插入新节点 BinNodePosi(T) succ(); //取当前节点的直接后继 template &lt;typename VST&gt; void travLevel(VST&amp;); //子树层次遍历 template &lt;typename VST&gt; void travPre(VST&amp;); //子树先序遍历 template &lt;typename VST&gt; void travIn(VST&amp;); //子树中序遍历 template &lt;typename VST&gt; void travPost(VST&amp;); //子树后序遍历 &#125;; 4.2.BinNode接口实现这一小节介绍BinNode类的几个常用接口，首先是insertAsLC接口，我们要对传入的参数e进行封装使之成为一个新的节点，并且将它作为当前节点的左孩子接入所属的这棵树中。当然作为入口条件可以假设当前节点的左孩子现在是空的。 这个功能的实现方法是：通过BinNode构造函数创建一个新的BinNode节点，而它的父节点就是this即当前这个节点。从下面的图来看，这一步就相当于将新的BinNode节点的parent引用指向当前的这个节点。这只是自下而上一个方向的连接，为了保证整体的一致性我们还需要相应地完成自上而下的连接，也就是令当前这个节点this的左孩子引用lChild能够指向新创建的节点，这一步可以通过直接用这个新生成的节点赋予当前节点的lChild引用来实现。 insertAsRC接口实现的方式完全对称，只需相应地将左孩子引用替换为右孩子引用。两个插入操作的复杂度均为$O(1)$。 1234567template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T const&amp; e)&#123; return lc = new BinNode(e, this);&#125; //将e作为当前节点的左孩子插入二叉树, O(1)template &lt;typename T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T const&amp; e)&#123; return rc = new BinNode(e, this);&#125; //将e作为当前节点的右孩子插入二叉树, O(1) BinNode的size()接口，返回包括当前节点在内所有后代的总数，可以通过递归来实现，复杂度为$O(n=|size|)$。 123456template &lt;typename T&gt; int BinNode&lt;T&gt;::size() &#123; //统计当前节点后代总数，即以其为根的子树规模 int s = 1; //计入本身 if (lChild) s += lChild-&gt;size(); //递归计入左子树规模 if (rChild) s += rChild-&gt;size(); //递归计入右子树规模 return s;&#125; //O(n = |size|) 4.3.BinTree模板类在完成了对二叉树节点类BinNode的定义之后，我们就可以基于它来实现整体的binary tree简称BinTree这样一种模板类，代码的主体结构如下： 123456789101112131415161718192021222324252627282930313233343536373839#include\"BinNode.h\"template &lt;typename T&gt; class BinTree &#123; //二叉树模板类protected: int _size; BinNodePosi(T) _root; //规模、根节点 virtual int updateHeight(BinNodePosi(T) x); //更新节点x的高度 void updateHeightAbove(BinNodePosi(T) x); //更新节点x及其祖先的高度public: BinTree() : _size(0), _root(NULL) &#123; &#125; //构造函数 ~BinTree() &#123; if (0 &lt; _size) remove(_root); &#125; //析构函数 int size() const &#123; return _size; &#125; //规模 bool empty() const &#123; return !_root; &#125; //判空 BinNodePosi(T) root() const &#123; return _root; &#125; //树根 //操作接口 BinNodePosi(T) insertAsRoot(T const&amp; e); //插入根节点 BinNodePosi(T) insertAsLC(BinNodePosi(T) x, T const&amp; e); //e作为x的左孩子（原无）插入 BinNodePosi(T) insertAsRC(BinNodePosi(T) x, T const&amp; e); //e作为x的右孩子（原无）插入 BinNodePosi(T) attachAsLC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); //T作为x左子树接入 BinNodePosi(T) attachAsRC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); //T作为x右子树接入 int remove(BinNodePosi(T) x); //删除以位置x处节点为根的子树，返回该子树原先的规模 BinTree&lt;T&gt;* secede(BinNodePosi(T) x); //将子树x从当前树中摘除，并将其转换为一棵独立子树 template &lt;typename VST&gt; //操作器 void travLevel(VST&amp; visit) &#123; if (_root) _root-&gt;travLevel(visit); &#125; //层次遍历 template &lt;typename VST&gt; //操作器 void travPre(VST&amp; visit) &#123; if (_root) _root-&gt;travPre(visit); &#125; //先序遍历 template &lt;typename VST&gt; //操作器 void travIn(VST&amp; visit) &#123; if (_root) _root-&gt;travIn(visit); &#125; //中序遍历 template &lt;typename VST&gt; //操作器 void travPost(VST&amp; visit) &#123; if (_root) _root-&gt;travPost(visit); &#125; //后序遍历 bool operator&lt; (BinTree&lt;T&gt; const&amp; t) //比较器（其余自行补充） &#123; return _root &amp;&amp; t._root &amp;&amp; lt(_root, t._root); &#125; bool operator== (BinTree&lt;T&gt; const&amp; t) //判等器 &#123; return _root &amp;&amp; t._root &amp;&amp; (_root == t._root); &#125;&#125;; //BinTree 需要注意的是：其中updateHeight这个接口是以virtual来修饰的，即虚函数。后面我们会看到二叉树，尤其是二叉搜索树是一个庞大的家族，其中的每一个成员对于高度的定义包括更新的方法都不尽相同，因此通过将它定义为虚方法可以便于各种派生类对这个方法进行适当的重写。 4.4.高度更新对于任何一个节点x，它的高度是在以它为根的子树中，从它通往那个最深的叶节点的路径长度。有两种特殊情况：单节点的树高度取0，空树高度取-1，这里采用宏定义的封装的方式，通过重新命名一个新的等价意义上的高度，将常规情况下的高度与退化情况下的高度统一起来，使得此后对算法的描述和理解可以更为简便，同时也不致于影响到算法的正确性。 一个节点的高度恰好等于它的左孩子与右孩子高度中的更大者再加1，因此可以相应地得到对任意节点x进行高度更新的算法。 而如果x的祖先节点存在，那么祖先节点的高度可能因为x的高度变化而变化，整个这样的过程需要从x开始遍历它的所有历代祖先，算法的复杂度正比于x节点的深度，即$O(n=depth(x))$。 1234567891011#define stature(p) ( (p) ? (p)-&gt;height : -1 ) //节点高度—约定空树高度为-1template &lt;typename T&gt; int BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x) //更新节点x高度&#123; return x-&gt;height = 1 + __max(stature(x-&gt;lc), stature(x-&gt;rc));&#125; //具体规则，因树而异template &lt;typename T&gt; void BinTree&lt;T&gt;::updateHeightAbove(BinNodePosi(T) x) //更新节点x及其历代祖先的高度&#123; while (x) &#123; updateHeight(x); x = x-&gt;parent; &#125;&#125; //可优化：一旦高度未变，即可终止。 O(n = depth(x)) 4.5.节点插入insertAsRC接口为原树中一个没有右孩子的节点插入一个右孩子节点，插入后原树的规模会增加1，x节点的高度有可能因为它新加入了一个孩子而发生变化，因此还要调用updateHeightAbove来对x这个节点以及它的历代祖先更新高度。 123456template &lt;typename T&gt; BinNodePosi(T) BinTree&lt;T&gt;::insertAsRC(BinNodePosi(T) x, T const&amp; e)&#123; _size++; x-&gt;insertAsRC(e); updateHeightAbove(x); //x及其祖先的高度可能增加，其余节点必然不变 return x-&gt;rc;&#125; //e插入为x的右孩子，insertAsLC()完全对称","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（8）栈应用","slug":"数据结构与算法（8）栈应用","date":"2020-02-17T11:52:34.000Z","updated":"2020-02-18T15:07:01.394Z","comments":true,"path":"2020/02/17/数据结构与算法（8）栈应用/","link":"","permalink":"http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/","excerpt":"","text":"栈结构的经典应用场合大致可以分为以下四类： 逆序输出 conversion： 输出次序与处理过程颠倒；递归深度和输出长度不易预知 递归嵌套 stack permutation + parenthesis 具有自相似的问题可递归描述，但分支位置和嵌套深度不固定 延迟缓冲 evaluation 线性扫描算法模式中，在欲读足够长之后，方能确定可处理的前缀 栈式计算 RPN 基于栈结构的特定计算模式 1.进制转换问题描述：给定任一10进制非负整数，将其转换为$\\lambda$进制表示形式。 解法我们都很熟悉，即短除法：对给定的数做除法，留商取余，所得的余数再逆序输出。 这样一个过程在用代码实现时一个问题需要考虑：计算的过程是由上而下的，而输出的过程是由下而上的，如果不借助对数我们很难预测最终会有多少个数位，也就是整个计算的深度到底有多少，那这个问题该如何解决呢？ 回顾上篇文章中介绍的栈结构，我们只需引入一个栈，在计算的过程中，我们每得到一个数位（余数），就通过push()使它入栈，那么这些数位入栈的次序恰好就是它们被计算出来的次序（在图中是自上而下）。而栈的特性是后进先出（LIFO），一旦计算终止，我们就可以通过一系列pop()操作将这些数位按刚才的数位的逆序（在图中是自下而上）输出出来，从而得到所需要的结果。 123456789void convert(Stack&lt;char&gt; &amp; S, _int64 n, int base) &#123; //薪进制下的数位符号，可视bae取值范围适当扩充 static char digit[] = &#123; '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' &#125;; while (n &gt; 0) &#123; //由低到高，逐一计算出薪进制下的各数位 S.push( digit[ n % base ] ); //余数（对应的数位）入栈 n /= base; //n更新为其对base的除商 &#125;&#125; 2.括号匹配括号匹配这个问题可以归为递归嵌套式问题，以括号匹配为代表的这类问题它们的共同特点是，具有某种意义上的自相似性，即它们的某一个局部往往和整体具有某种共性，同时这种局部作为分支它的位置以及嵌套的深度却难以在事先固定或者确定。 括号匹配是合法表达式的必要条件之一，下面是一个实例： 我们的任务是给定任意一个含有括号的表达式如何来判定它是否是匹配的，为了简化问题不妨将括号之外的其余符号都暂时地忽略掉，只需要做一次线性扫描的预处理即可，这样就可以集中注意处理括号匹配的情况。 2.1.构思为了得到这个问题的有效解法，我们或许应该继续沿用不断将问题简化的总体策略。为此需要首先来考察最基本的平凡情况：如果一个表达式不含任何的括号，从而实质上等价于一个空串，那么它自然是匹配的。 接下来我们注意到这样一个事实：如果某一个表达式E已经是括号匹配的，那么在它的左侧和右侧添加一对匹配的括号，整体依然将是匹配的；如果两个表达式E和F已经是各自匹配的，那么只要将它们串接起来就可以得到一个更大的匹配表达式。 然而很遗憾这两个性质都不能使得我们很好地运用此前所学的减而治之或者分而治之的策略。因此这两条性质只能作为括号匹配判断的必要条件而非充要条件，从逻辑推理的方向来看它是由左侧的前命题推向右侧的后命题，与简化问题的方向背道而驰。 而且它们也存在反例，这就让减而治之和分而治之都是行不通的。因此为了真正使这个问题能够得到有效的简化，必须发现并且借助这个问题所蕴含的某种充分性。 一种可行的方法是将以上的减而治之的策略颠倒过来，不是去试图减除一个表达式最外围的一对括号，而是试图去减除其中相互紧邻的一对左右括号。如果在一个表达式中能够发现一对彼此紧邻的左右括号，那么在将这对括号减除之后，剩余的部分是否匹配与此前的表达式是否匹配必然是互为充要条件的。 那么如何找到这样一对括号呢？另外，更重要的是如何使得这种简化能够持续地进行下去呢？ 实际针对上面的情况，正是栈可以大显身手的时候，借助栈结构的算法过程原理可以表示为下图。如果这是我们所使用的栈，那么其中所包含的就是我们已经扫描过但是仍待处理的部分，其中只需保存左括号。在接下来的扫描中一遇到左括号就令它入栈；而一旦遇到右括号不仅不需要令它入栈，反而应该令栈顶的那个左括号出栈。 这样就刚好实现了上述的可行方法，算法的确可以持续地如此往复进行下去。如果最后一个括号被处理之后，整个栈恰好变空，那么就意味着原来的表达式是匹配的；反之，无论到最后栈非空或者在中途某个阶段提前变空，我们都可以判定原来的表达式是不匹配的。 2.2.实现上节的构思可以具体兑现为这样一段代码： 12345678bool paren(const char exp[], int lo, int hi) &#123; //exp[lo, hi) Stack&lt;char&gt; S; //使用栈记录已发现但尚未匹配的左括号 for (int i = lo; i &lt; hi; i++) //逐一检查当前符号 if ('(' == exp[i]) S.push(exp[i]); //若遇左括号，则进栈 else if (!S.empty()) S.pop(); //否则如果遇右括号，且栈非空，则令栈顶的左括号出栈 else return false; //否则（遇右括号是栈已空），必不匹配 return S.empty(); //最终，栈空当且仅当匹配&#125; 为了判别low与high之间的这样一段表达式是否括号匹配，需要引入一个名为S的栈。以下的这个循环逐一地检查每一个字符，如果是左括号就令它入栈，否则就试图弹出栈顶，如果它的确存在的话应该就是与当前这个右括号匹配的那个左括号，而如果此时栈已经提前变空那么就意味着整个表达式失配，可以断定此时的失配是由于某一个右括号缺少与之匹配的左括号。 当处理完所有的字符并退出循环的时候，需要检查栈在当前是否是空的，只有当栈恰好为空时才说明表达式是匹配的，否则可以断定原来那个表达式是不匹配的，且是属于某一左括号缺失与之配对的右括号的情况。 2.3.反思与拓展为更好地理解这个算法，我们不妨来看一个具体的实例： 在理清这个实例的执行过程后，你可能会质疑我们为什么要使用栈呢[・_・?]。就这样一个特定的问题而言，只需借助一个简明的整数计数器就足以完成刚才的算法任务。如果令计算器初始为0，将算法的过程对应过来，若遇左括号计数器就加1；若遇右括号计算器就减1。最终如果计数器为0，则表达式匹配；如果计数器不为0，或在中途出现负数，则表达式不匹配。 实际上这个计数器所反映的就是刚才我们所使用的那个栈在任何时刻的规模，这样就不难理解其中的必然性了。那么既然如此我们为什么不使用更加简明的计数器，而要使用更为复杂的栈结构呢[・_・?] 这背后的原因在于采用栈结构可以便捷地推广至多种括号并存的情况，这时如果想要使用多个计数器也是行不通的，比如一个简单的反例[ ( ] )，因为如果孤立地通过计数器来考察方括号或者是圆括号，两个计数器都是可以正常工作并且在最终复位为0的，而这个表达式显然是不匹配的。 通过下面这个实例来解释这个算法如何扩展到多个括号并存的情况。当遇到一个左括号，无论是什么形式都放入栈中；遇到一个右括号，则判断此时栈顶的左括号是否与它匹配，若匹配则令栈顶的左括号出栈。 同样地在经过了这样一趟线性的扫描之后，只有当栈最终为空，我们才可以断定原来这个包含多种括号的表达式是匹配的。反过来这时括号不匹配的情况相对于此前单括号的情景要多出一种，即当遇到右括号时，发现此时栈顶的左括号与之不匹配，如刚才举的反例[ ( ] )，则表达式必是不匹配的，因为实际上这样每次“消去”的一对括号必是紧邻的一对括号。 扩展后括号匹配算法可以实现为下面一段代码： 123456789101112bool paren(const char exp[], int lo, int hi) &#123; //表达式括号匹配检查，可兼顾三种括号 Stack&lt;char&gt; S; //使用栈记录已发现但尚未匹配的左括号 for (int i = lo; i &lt;= hi; i++) /* 逐一检查当前字符 */ switch (exp[i]) &#123; //左括号直接进栈；右括号若与栈顶失配，则表达式必不匹配 case '(': case '[': case '&#123;': S.push(exp[i]); break; case ')': if ((S.empty()) || ('(' != S.pop())) return false; break; case ']': if ((S.empty()) || ('[' != S.pop())) return false; break; case '&#125;': if ((S.empty()) || ('&#123;' != S.pop())) return false; break; default: break; //非括号字符一律忽略 &#125; return S.empty(); //整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配&#125; 最后需要指出的是，实际上这样一种拓展还可以进一步地进行，也就是并不限于某几种特定的括号，甚至不需要对这些括号到底有多少种做出限定，就像在HTML语言中那样只要表达式中能够按照合理的语法，就能够定义任何一种匹配标志，我们都可以来进行这种意义上的匹配检查。 3.栈混洗本节介绍一个与上一节括号匹配问题非常相关的问题：栈混洗问题。栈混洗就是按照某种约定的规则对栈中的元素进行重新的排列。初始情况下所有的元素都存在栈A中，这里约定分别用尖括号和方括号来表示栈顶以及栈底，栈混洗的目标是将所有这些元素都通过某种方式转入到另一个初始为空的栈B中，为此需要借助一个中转栈S。 栈 A = $&lt;a_1,a_2,\\dots,a_n]$、B = S = $\\varnothing$ 只允许的操作： 将A的顶元素弹出并压入S； //S.push(A.pop()) 或将S的顶元素弹出压入B。 //B.push(S.pop()) 若经过一系列以上的操作后，A中元素全部转入B中； 则B = $[a_{k1},a_{k2},\\dots,a_{kn}&gt;$则称之为A的一个栈混洗（stack permutation） 在遵守以上规则的前提下同一输入序列可能导出不同的栈混洗序列，比如 A = &lt;1, 2, 3, 4]就可能得到： B = [1, 2, 3, 4&gt;，[4, 3, 2, 1&gt;，[3, 2, 4, 1&gt;，…… 3.1.计数那么长度为n的序列，可能的栈混洗总数$SP(n)$为多少呢？ 假定输入栈 A = &lt; 1, 2, 3, ……, n ]，关注1号元素，它第一个被推入栈S中，假设它是第K个从S出栈的元素，当它出栈后S已为空，相应地A剩余最靠底的n-k个元素。此时B中最靠底的k-1个元素和A中最靠底的n-k个元素，它们的栈混洗实际上是相互独立的。 因此对应于1号元素作为第k个元素被推入B中的情况，对应的栈混洗总数就应该是这两个相互独立的子序列所各自对应的栈混洗总数的乘积$SP(k-1)\\times SP(n-k)$，又k可以取1到n，因此长度为n的序列，可能的栈混洗总数为： SP(n)=\\sum_{k=1}^n SP(k-1)\\times SP(n-k)=catalan(n)=\\frac{(2n)!}{(n+1)!n!}3.2.甄别对于输入序列&lt; 1, 2, 3, ……, n ] 的任一个排列 [$p_{1},p_{2},\\dots,p_{n}$ &gt; 如何来判断它究竟是不是一个合法的栈混洗？ 先从简单的例子入手，考虑由三个元素所构成的一个输入序列，则$SP(3)=5$，而三个数的全排列为$3!=6$，对于这种情况有一种排列不是栈混洗，显然不是栈混洗的排列是[ 3, 1, 2&gt;。 实际上任意的三个元素能否按照某种相对的次序出现在最终的栈混洗中，与其它的元素实是无关的，因此推而广之对于任何三个互异的整数 $1\\le i &lt; j&lt;k \\le n$，如果在某个排列中出现了 k i j，那么它就必然不是栈混洗。这是栈混洗所必须禁止的一种特征，称之为禁形。 Kunth在他的《The Art of Computer Programming》中证明了 一个排列permutation是一个栈混洗的充要条件就是其中不含禁形。 由此可以导出一个算法：不断地枚举所有的i j k的组合，但其复杂度高达$O(n^3)$。进一步地可以将这样一个判别的依据简化：判断栈混洗的充要条件是，对于每一对互异的i&lt;j，在排列中不会出现 j+1 i j 这样的一个模式，由此导出的枚举算法的复杂度是$O(n^2)$。 而借助栈结构可以实现一个线性时间$O(n)$的甄别算法，其思想是：完全按照栈混洗的定义引入三个栈，并且通过对栈混洗过程的模拟以一种验证的方式来判别某一个排列是否的确为栈混洗。具体地对于输出序列中的任何一个元素，都采用一种贪心算法的原则以S为中介 将其从A转移至B中，只要这个贪心的过程能够持续进行并最终将所有的元素顺利地从A转入B中，那么就可以判断它是一个栈混洗。反之每次通过pop操作试图从S中弹出当前的元素时，如果S已经变空，或者要弹出的元素不是S栈顶的元素，就可以立即判断这个栈混洗是非法的。 12345678910111213//参照LeetCode面试题31：栈的压入，弹出序列bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; S; auto i=pushed.begin(); for(auto j=popped.begin();j!=popped.end();j++)&#123; while(S.empty()||S.top()!=*j) if(i==pushed.end()) return false; else S.push(*i++); S.pop(); &#125; return true;&#125; 3.3.栈混洗与括号匹配的关系n个元素的任何一个栈混洗都对应于中转栈S的n次push操作以及n次pop操作所构成的一个序列。如果将每push都换成一个左括号，而将每次pop对应一个右括号，就会发现同一元素所对应的那对push、pop操作都恰好对应于一对彼此匹配的括号。反过来由n对括号所构成的任何一个合法的表达式，实际上也可以解释为对n个元素进行栈混洗的一个合法的过程，也相应地对应于某一个输出的栈混洗。 因此合法的栈混洗序列与合法的括号匹配表达式之间存在一个一一对应的关系，n个元素的栈混洗有多少种n对括号所能构成的合法表达式也就有多少种。 4.中缀表达式求值中缀表达式求值问题属于栈结构的另一种典型应用场合：延迟缓冲，在中缀表达式求值这样一类线性扫描算法中我们并不能保证处理的速度和读取的速度同步，而往往是需要预读足够多的信息之后才能够确定足以处理的一个前缀。这节中只考虑语法正确的算术表达式，即给定任一语法正确的表达式S，计算出与之对应的数值。 4.1.表达式求值回顾括号匹配算法：对于任何的一个表达式，在其中找到一对彼此紧邻也因此相互配对的括号，将这样一对括号删去，从而在剩余表达式与原先表达式在是否匹配上互为充要条件的前提下，使得问题的规模也就是括号的对数有所减少。 对于表达式求值，我们依然要在表达式中寻找一个能够优先计算的子串，并且对它进行计算，然后将计算所得的数值重新放置在这个位置上，经过如此的转换之后，新的表达式的数值与原表达式的数值保持一致。如果将一个表达式的复杂度定义为其中包含的运算符的数目，那么这个过程依然是一个减而治之（decrease and conquer）的过程。因此这个算法具有单调性，最终将消除掉所有的运算符，从而得到最终的数值。下面是个具体的例子（计算次序由下到上）： 这样一个计算过程虽然在纸面上简便易行，但是如果面对比较长甚至非常长的表达式就将碰到很大的困难，这个困难就在于我们很难定位当前可以计算的那个运算符。如果以一种线性扫描的次序来处理表达式，每当扫到一个运算符的时候都未必能够确认它已经是可以计算的，也就是说计算次序未必与扫描的次序完全一致。 对于这样的一类问题，一种行之有效的办法就是借助栈结构，只需将所有已经扫描过的部分保存为一个栈，在所有已经扫描过的部分中有一些是能够及时处理的即在局部具有足够高的优先级，并且已经计算过的部分；而已经扫描过但是还不足以判断能够计算的部分将通过这个栈被缓冲起来，而我们的策略就是逐步地将尚未扫描的部分扫描并且处理掉。 求值算法 = 栈 + 线性扫描： 12345自左向由扫描表达式，用栈记录已扫描的部分（含已执行运算的结果） 在每一字符处 while(栈的顶部存在可优先计算的子表达式) 该子表式退栈；计算其数值；计算结果进栈 当前字符进栈，转入下一字符 相对于此前那种纸面操作这样一个过程更加接近于机器能够自动实现的层次，然而离最终的目标还有差距，原因在于我们每次在栈顶检出这个可以计算的子表达式，无论是2乘3还是10除以5都不是那么自然，而诀窍在于将运算符和运算数分别对待，即将运算符和运算数分别存入两个栈中。 4.2.实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//定义优先级表const char pri[9][9] = &#123; // 当前运算符 // + - * / ^ ! ( ) \\0 /* + */&#123; '&gt;','&gt;','&lt;','&lt;','&lt;','&lt;','&lt;','&gt;','&gt;' &#125;, /* - */&#123; '&gt;','&gt;','&lt;','&lt;','&lt;','&lt;','&lt;','&gt;','&gt;' &#125;, /* * */&#123; '&gt;','&gt;','&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;' &#125;, /* / */&#123; '&gt;','&gt;','&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;' &#125;, /* ^ */&#123; '&gt;','&gt;','&gt;','&gt;','&gt;','&lt;','&lt;','&gt;','&gt;' &#125;, /* ! */&#123; '&gt;','&gt;','&gt;','&gt;','&gt;','&gt;',' ','&gt;','&gt;' &#125;, /* ( */&#123; '&lt;','&lt;','&lt;','&lt;','&lt;','&lt;','&lt;','=',' ' &#125;, /* ) */&#123; ' ',' ',' ',' ',' ',' ',' ',' ',' ' &#125;, /* \\0*/&#123; '&lt;','&lt;','&lt;','&lt;','&lt;','&lt;','&lt;',' ','=' &#125; //(栈顶运算符)&#125;;//解析数字void readNumber(char*&amp; p, Stack&lt;float&gt;&amp; stk) &#123; //将起始于p的子串解析为数值，并存入操作数栈 stk.push((float)(*p - '0')); //当前数位对应的数值进栈 while (isdigit(*(++p))) //只要后续还有紧邻的数字（即多位整数的情况），则 stk.push(stk.pop() * 10 + (*p - '0')); //弹出原操作数并追加新数位后，新数值重新入栈 if ('.' != *p) return; //此后非小数点，则意味着当前操作数解析完成 float fraction = 1; //否则，意味着还有小数部分 while (isdigit(*(++p))) //逐位加入 stk.push(stk.pop() + (*p - '0') * (fraction /= 10)); //小数部分&#125;// 由运算符得出编号int optr2rank(char op) &#123; switch (op) &#123; case '+':return 0; case '-':return 1; case '*':return 2; case '/':return 3; case '^':return 4; case '!':return 5; case '(':return 6; case ')':return 7; case '\\0': return 8; default:exit(-1); &#125;&#125;//比较运算符的优先级char orderBetween(char op1, char op2) &#123; return pri[optr2rank(op1)][optr2rank(op2)];&#125;//执行二元运算float calcu(float a, char op, float b) &#123; switch (op) &#123; case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': if (0 == b) exit(-1); return a / b; //注意：如此判浮点数为零可能不安全 case '^': return pow(a, b); default: exit(-1); &#125;&#125;//执行一元运算float calcu(float b) &#123; if (b &lt; 1.01) return 1; return b*(calcu(b-1)); //目前仅有阶乘，可照此方式添加 &#125;//算法主体部分，中缀表达式求值float evaluate(char* S ) &#123; Stack&lt;float&gt; opnd; //运算数栈 Stack&lt;float&gt; optr; //运算符栈 optr.push('\\0'); //尾哨兵'\\0'也作为头哨兵入栈 while (!optr.empty()) &#123; //逐个处理各字符，直至运算符栈空 if (isdigit(*S)) //若当前字符为操作数，则 readNumber(S, opnd); //读入（可能多位的）操作数 else //若当前字符为运算符，则视其余栈顶运算符之间优先级的高低 switch(orderBetween(optr.top(), *S))&#123; case '&lt;': //栈顶运算符优先级更低时 optr.push(*S); S++; //计算推迟，当前运算符进栈 break; case '=': //优先级相等（当前运算符为右括号或者尾部哨兵'\\0'）时 optr.pop(); S++; //脱括号并接收下一个字符 break; case '&gt;': &#123; //栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈 char op = optr.pop(); //栈顶运算符出栈并续接至RPN末尾 if ('!' == op) &#123; //若属于一元运算符 opnd.push( calcu( opnd.pop() )); //实施一元计算，结果入栈 &#125; else &#123; //对于其它（二元）运算符 float pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop(); //取出后、前操作数 opnd.push( calcu( pOpnd1, op, pOpnd2 ) ); //实施二元计算，结果入栈 &#125; break; &#125; &#125; &#125; return opnd.pop();&#125; 5.逆波兰表达式5.1.RPN逆波兰表达式（Reverse Polish notation，RPN），是一种由波兰数学家Jan Łukasiewicz在1920年引入的数学表达式，在逆波兰表达式中，所有操作符置于操作数的后面，不需要括号来标识操作符的优先级。在RPN中我们原先使用的运算符优先级和括号强制指定优先级都不存在了，因此RPN更适合机器来完成表达式的计算。 在由运算符（operator）和操作数（operand）组成的表达式中不使用括号（parenthesis-free）即可表示带优先级的运算关系。 相对于日常使用的中缀式（infix），RPN被称为后缀式（postfix） 作为补偿，须额外引入一个起分隔作用的元字符（比如空格） 相比于上节的中缀表示式计算，RPN的计算显得十分简便，只需引入一个辅助栈： 12345678910111213rpnEvaluate(expr) &#123; //假定RPN表达式epxr的语法正确 引入栈S，用于存放操作数； while(expr尚未扫描完毕)&#123; 读入expr的下一个元素x; if(x是操作数) 将X压入S; else&#123; //x是运算符 从栈中弹出运算符x所需数目的操作数; 对弹出的操作数实施x运算，并将运算结果重新压入S; &#125; &#125; 返回栈顶; //也是栈底&#125; 5.2.中缀表达式向RPN的转换中缀表达式向逆波兰表达式的转换可以按以下过程实现： 主要注意的是：在转换完成后，操作数的次序不会发生变换，而运算符的次序可能发生变换。 转换的具体算法实际上可以直接借助上节计算中缀表达式的算法，它在计算中缀表达式结果的同时，实际上也完成了向RPN的转换，重点关注下面代码的第6行和第12行。 1234567891011121314151617float evaluate(char* S string *RPN) &#123; /*.................................*/ while (!optr.empty()) &#123; //逐个处理各字符，直至运算符栈空 if (isdigit(*S)) &#123; //若当前字符为操作数，则 readNumber(S, opnd); *(RPN++) = to_string(opnd.top()); //将其压入RPN else //若当前字符为运算符 switch(orderBetween(optr.top(), *S))&#123; /*..............................*/ case '&gt;': &#123; //栈顶运算符优先级更高时，可实施相应的计算，则 char op = optr.pop(); *(RPN++) = op;//在执行相应的同时将其压入RPN /*.............................*/ &#125; &#125; return opnd.pop();&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（7）栈与队列","slug":"数据结构与算法（7）栈与队列","date":"2020-02-17T09:49:20.000Z","updated":"2020-02-17T11:48:18.235Z","comments":true,"path":"2020/02/17/数据结构与算法（7）栈与队列/","link":"","permalink":"http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"栈和队列这对孪生兄弟都是线性序列的特例，它们在算法以及应用中都扮演着非常基本而重要的角色，本文主要介绍如何以ADT的形式来定义和规范它们的接口，以及如何借助此前学习过的序列结构（向量与列表）简洁高效地加以实现。 1.栈1.1操作与接口栈结构（Stack）依然是由一组元素组成的线性序列，与一般的序列不同的是，在任何时候我们只能够访问栈中的一个特定元素——最末端那个元素，而其余的元素在当前都是禁止访问的。 通常习惯于将可以访问的开放的这一端，称作顶端top，而不开放的那个盲端称作底部bottom。 一般意义下的栈以及它的操作可以由下面的一组图来表示，如果需要将某一个新的元素插入其中，那么只能将它作为最顶部的元素插入，这个动作我们也形象地称之为push。反过来如果需要从栈中取出某一个元素，那么也只能取出当前这个顶部的元素，这个元素被取出之后其余元素将依次向前递补，将会出现一个新的顶部元素，这样的一个过程称为pop。当然通常的栈还会提供另一个辅助的接口，查询顶部元素的数值而并不需要将它真正的弹出，那么这样一个动作称之为top。 1.2.操作实例接下来通过一个实例来了解栈结构各种接口的准确功能，以及它们组合之后所能达到的效果。 首先通过构造函数Stack()来创建一个空的栈，调用empty()来检查其是否为空，push(5)在栈中插入第一个元素，图中栈顶是在左侧，栈底是在右侧。push(3)即在栈顶也就是左侧插入元素3，pop(3)则将栈顶的元素删除，size()返回栈序列中元素的个数，top()返回栈顶元素的值。 需要留意的是，栈中元素入栈的出栈的次序，即相对而言后入栈的元素会更早出栈，这也是栈结构的一个非常独特的性质，即后进先出（LIFO），正是因为栈的这种特性使得它在很多算法中都有重要作用。 1.3.实现实际上既然栈可以视作是序列的一种受限后的特例，那么自然可以通过此前学过的向量或列表结构直接派生而得，即我们完全可以利用向量或者列表来模拟栈以及它的接口行为。 以向量为例，栈中有多少元素，向量中也对应地有多少个元素，如果约定首元素是栈的底部盲端，那么末元素也就是可操作的栈顶，按照这样一个思路就可以简洁地写出栈模板类。 123456template &lt;typename T&gt; class Stack : public Vector&lt;T&gt; &#123; //由向量派生public: //size()、empty()以及其它开放接口均可直接沿用 void push(T const &amp; e) &#123; insert(size(), e); &#125; //入栈 T pop() &#123; return remove(size() - 1); &#125; //出栈 T &amp; top() &#123; return (*this)[size() - 1]; &#125; //取顶&#125;; 对于向量结构而言无论是插入操作还是删除操作，所需要的时间都线性正比于插入和删除位置的后继的数目。对于栈结构，无论是插入操作还是删除操作都是在向量的末端进行，因此所有这些操作接口的时间复杂度都是常数的，即为$O(1)$。如果将向量的首元素作为栈顶，那么每次插入和删除操作的时间复杂度就会变成$O(n)$。 2.队列队列（queue）也是一种特殊的线性序列，想想生活中机场安检窗口的队列或者超市等待付款的队列，用数据额结构的语言来说它们都构成一个线性的序列，与栈一样它也是一个受限的序列，不同的是队列的一端只能够出，另一端只能怪进。通常，允许插入的那一端被称作尾部，允许删除的一端被称为头部。 队列也是受限的序列： 只能在队尾插入（查询）：enqueue() + rear() 只能在队头删除（查询）：dequeue() + front() 队列中元素入队和出队的次序与栈相反： 先进先出（FIFO） 后进后出（LILO） 下面是一个队列的操作具体事例： 2.2.实现与栈同理既然队列也是属于序列，自然可以利用此前已经实现的最基本的向量以及列表结构直接派生而得，这里选用列表来实现队列。 123456template &lt;typename T&gt; class Queue : public List&lt;T&gt; &#123; //由列表派生public: //size()与empty()以及其它开放接口均可直接沿用 void enqueue(T const &amp; e) &#123; insertAsLast(e); &#125; //入队 T dequeue() &#123; return remove( first() ); &#125; //出队 T &amp; front() &#123; return first()-&gt;date; &#125; //查询队首元素&#125;; 由于列表结构的特性，无论是enqueue() ，dequeue()还是front()这些接口都能够在常数的时间内完成，即$O(1)$的时间。 这种基于以前的工作来进一步完成新的任务的思路，不仅使得我们的工作可以快速推进，而且使得整个工作的系统性和安全性都能得到保障(ง •_•)ง 队列结构在此后的图算法以及其它的场合都有广泛的应用，所以这里只是首先简要地介绍它的接口定义，以及它在C++中的实现方式。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Cpp基础（10）继承和派生","slug":"Cpp基础（10）继承和派生","date":"2020-02-17T03:57:42.000Z","updated":"2020-02-18T05:45:39.995Z","comments":true,"path":"2020/02/17/Cpp基础（10）继承和派生/","link":"","permalink":"http://nekomoon404.github.io/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/","excerpt":"","text":"1.继承和派生 继承的概念：在定义一个新的类B时，如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类（也称为子类）。 派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖与基类。 派生类拥有基类的全部成员变量和成员函数，包括private，public，protected 派生类的写法：class 派生类名: public 基类名 { }; 派生类的内存空间：派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。 123456class CBase&#123; int v1, v2;&#125;;class CDerived:public CBase&#123; int v3;&#125; 示例：写了一个学生的类Student，再写一个Student类的派生类UndergraduateStudent，补充和修改一些功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Student &#123; //学生类private: string name; string id; char gender; int age;public: void PrintInfo() &#123; cout &lt;&lt; \"Name: \"&lt;&lt;name&lt;&lt; endl; cout &lt;&lt; \"ID: \" &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; \"Gender: \" &lt;&lt; gender &lt;&lt; endl; &#125; void SetInfo(const string &amp;_name, const string &amp;_id, int _age, char _gender) &#123; name = _name; id = _id; age = _age; gender = _gender; &#125; string GetName() &#123; return name; &#125; &#125;;class UndergraduateStudent :public Student &#123; //本科生类，继承了Student类的派生类private: string department;public: void QualifiedForBaoyan() &#123; cout &lt;&lt; \"qualified for baoyan\" &lt;&lt; endl; &#125; void PrintInfo() &#123; //派生类中修改基类中的PrintInfo Student::PrintInfo(); //调用基类的PrintInfo cout &lt;&lt; \"Department:\" &lt;&lt; department &lt;&lt; endl; &#125; void SetInfo(const string &amp;_name, const string &amp;_id, int _age, char _gender, const string &amp;_department) &#123; Student::SetInfo(_name, _id, _age, _gender); department = _department; &#125; &#125;; int main() &#123; UndergraduateStudent S; S.SetInfo(\"Harry Potter\", \"20200217\", 19, 'M', \"Machine Learning\"); cout &lt;&lt; S.GetName() &lt;&lt; \" \"; S.QualifiedForBaoyan(); S.PrintInfo(); return 0;&#125; 程序运行结果： 2.继承关系和复合关系类与类之间有两种关系： 继承：“是”关系 基类A，B是基类A的派生类 逻辑上要求：“一个B对象也是一个A对象”，比如上节中Student类和UndergraduateStudent类。 复合：“有”关系 类C中“有”成员变量k，k是类D的对象，则C和D是复合关系 一般逻辑上要求：“D对象是C对象的固有属性或组成部分”。 举一个简单的例子：如果要写一个小区养狗管理程序，需要写一个“业主”类和“狗”类，狗的主人即是业主，规定狗只能有一个主人，而一个业主最多可以有5条狗。 正确的写法：为”狗“类设一个”业主“类的对象指针；为”业主“类设一个”狗“类的对象指针数组。 1234567class Master;class Dog&#123; Master *m;&#125;;class Master&#123; Dog dogs[10];&#125;; 而以下的做法都是错误的或者不好的： 1234567class Dog;class Master&#123; Dog dogs[10];&#125;;class Dog&#123; Master m;&#125;; //会造成循环定义，不定确定Master和Dog所需的内存空间 1234567class Dog;class Master&#123; Dog *dogs[10];&#125;;class Dog&#123; Master m;&#125;; //如何维护不同的狗所属的相同的主人的信息的一致性？改了一条狗，其他狗也要更着改，十分麻烦 1234567class Master;class Dog&#123; Master *m;&#125;;class Master&#123; Dog dogs[10];&#125;; //这样狗对象都包含在业主对象里面，只能通过修改业主信息来修改狗的信息 3.基类和派生类有同名成员的情况 基类和派生类有时会拥有相同名称的成员变量或者成员函数。 12345678910111213141516171819202122232425class base&#123; int j;public: int i; void func();&#125;;class derived:public base&#123;public: int i; //与基类相同的成员对象 void access(); void func(); //与基类相同的成员函数&#125;;void derived::access()&#123; j = 5; //错误的，j是基类的私有成员 i = 5; //引用的是派生类的i base::i = 5; //引用的是基类的i func(); //派生类的成员函数 base::func(); //基类的成员函数 &#125;int main()&#123; derived obj; obj.i = 3; //对派生类的成员变量赋值 obj.base::i = 3; //对派生类对应的基类部分的成员变量赋值&#125; obj对象占用的存储空间： 注意：一般来说，基类和派生类不定义同名成员变量。 4.访问范围说明符 基类的private成员，可以被下列函数访问： 基类的成员函数 基类的友元函数 基类的public成员，可以被下列函数访问： 基类的成员函数 基类的友元函数 派生类的成员函数 派生类的友元函数 其他的函数 基类的protected成员，可以被下列函数访问： 基类的成员函数 基类的友元函数 派生类的成员函数可以访问当前对象的基本的protected成员 1234567891011121314151617181920212223242526class Father &#123;private: int nPrivate;public: int nPublic;protected:int nProtected;&#125;;class Son:public Father&#123; void AccseeFather() &#123; nPublic = 1; //Ok nPrivate = 1; //Wrong nProtected = 1; //Ok，访问从基类基础的protected成员 Son f; f.nProtected = 1; //Wrong,f不是AccseeFather作用的当前对象 &#125;&#125;;int main() &#123; Father f; Son s; f.nPublic = 1; //Ok s.nPublic = 1; //Ok f.nProtected = 1; //Wrong f.nPublic = 1; //Wrong s.nProtected = 1; //Wrong s.nPublic = 1; //Wrong return 0;&#125; 5.派生类的构造函数 派生类对象包含基类对象 执行派生类构造函数之前，先执行基类的构造函数 派生类交代基类初始化，具体形式： 1234构造函数名(形参表):基类名(基类构造函数实参表)&#123; &#125; 看一个具体的例子 ： 1234567891011121314151617181920212223242526272829303132class Bug &#123;private: int nLegs; int nColor;public: int nType; Bug(int _legs, int _color); void PrintBug() &#123; &#125;;&#125;;class FlyBug :public Bug &#123; int nWings;public: FlyBug(int _legs, int _color, int _wings);&#125;;Bug::Bug(int _legs, int _color) &#123; nLegs = _legs; nColor = _color;&#125;//错误的FlyBug构造函数FlyBug::FlyBug(int _legs, int _color, int _wings) &#123; nLegs = _legs; //Wrong，不能访问基类的私有成员 nColor = _color; //Wrong，不能访问基类的私有成员 nType = 1; //OK nWings = _wings;&#125;//正确的FlyBug构造函数FlyBug::FlyBug(int _legs, int _color, int _wings) :Bug(_legs, _color) &#123; nWings = _wings;&#125; 在创建派生类的对象时： 需要调用基类的构造函数：初始化派生类对象中从基类继承的成员 在执行一个派生类的构造函数之前，总是先执行基类的构造函数 调用基类构造函数的两种方式： 显式方式：派生类的构造函数中 $\\to$ 基类的构造函数提供参数 FlyBug::FlyBug(int _legs, int _color, int _wings) :Bug(_legs, _color) 隐式方式：派生类的构造函数中，省略基类构造函数时，会自动调用基类的默认构造函数 派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数 1234567891011121314151617181920212223class Base &#123;public: int n; Base(int i):n(i)&#123; cout &lt;&lt; \"Base\" &lt;&lt; n &lt;&lt; \" constructed\" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; \"Base\" &lt;&lt; n &lt;&lt; \" destructed\" &lt;&lt; endl; &#125;&#125;;class Derived:public Base &#123;public: Derived(int i) :Base(i) &#123; cout &lt;&lt; \"Derived constructed\" &lt;&lt; endl; &#125; ~Derived()&#123; cout &lt;&lt; \"Derived destructed\" &lt;&lt; endl; &#125;&#125;;int main() &#123; Derived Obj(3); return 0;&#125; 程序运行结果为： 对于包含成员对象的派生类的构造函数，创建派生类的对象时： 调用基类的构造函数 $\\to$ 初始化派生类对象中从基类继承的成员 调用成员对象类的构造函数 $\\to$ 初始化派生类对象中成员对象 执行派生类的构造函数 析构时： 执行派生类的析构函数 调用成员对象类的析构函数 调用基类的析构函函数（仍然遵循先构造的后析构的规则） 6.public继承的赋值兼容规则1234class base&#123; &#125;;class derived:public base&#123; &#125;;base b;derived d; 派生类的对象可以赋值给基类对象：b = d; 派生类的对象可以初始化基类引用：base &amp; br = d; 派生类的对象的地址可以赋给基类指针：base * bp = &amp; d; 注意上述规则不能颠倒，且如果派生方式是private或者protected，上述三条都不可行 7.直接基类与间接基类C++中类的派生可以是很多层的。 如类A派生类B，类B派生类C，类C派生类D： 类A是类B的直接基类； 类B是类C的直接基类，类A是类C的间接基类； 类C是类D的直接基类，类A、B是类D的间接基类； 在声明派生类时，只需要列出它的直接基类；派生类沿用着类的层次自动向上继承它的间接基类。 派生类的成员包括：派生类自己定义的成员，直接基类中的所有成员，所有间接基类的全部成员 当执行构造函数时，从顶层基类开始，依次往下执行基类的构造函数，最后执行自己的构造函数。 下面看一个例子：Base $\\to$ Derived $\\to$ MoreDerived 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class Base &#123;public: int n; Base(int i) :n(i) &#123; cout &lt;&lt; \"Base\" &lt;&lt; n &lt;&lt; \" constructed\" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; \"Base\" &lt;&lt; n &lt;&lt; \" destructed\" &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: Derived(int i) :Base(i) &#123; cout &lt;&lt; \"Derived constructed\" &lt;&lt; endl; &#125; ~Derived() &#123; cout &lt;&lt; \"Derived destructed\" &lt;&lt; endl; &#125;&#125;;class MoreDerived :public Derived &#123;public: MoreDerived(int i) :Derived(i) &#123; cout &lt;&lt; \"MoreDerived constructed\" &lt;&lt; endl; &#125; ~MoreDerived() &#123; cout &lt;&lt; \"MoreDerived destructed\" &lt;&lt; endl; &#125;&#125;;int main() &#123; MoreDerived Obj(3); return 0;&#125; 程序运行结果为：","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（9）运算符重载","slug":"Cpp基础（9）运算符重载","date":"2020-02-16T01:55:33.000Z","updated":"2020-02-16T07:55:33.000Z","comments":true,"path":"2020/02/16/Cpp基础（9）运算符重载/","link":"","permalink":"http://nekomoon404.github.io/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"1.基本概念 运算符：C++预定义表示对数据的运算 +, - , *, /, %, ^, &amp;, ~, !, |, =, &lt;&lt;, &gt;&gt;, != ……. 只能用于基本的数据类型：整型，实型，字符型，逻辑型，…… C++提供了数据抽象的手段：用户自己定义数据类型——类 调用类的成员函数 $\\to$ 操作它的对象，有时会不方便 比如在数学上，两个复数可以直接进行+, -等运算；而在C++中，直接将+，-作用于复数（我们定义的类）是不允许的 运算符重载：对抽象数据类型也能够直接使用C++提供的运算符 程序更简洁 代码更容易理解 运算符重对已有的运算符赋予多重的含义 在使用同一运算符作用于不同类型的数据时 $\\to$ 不同类型的行为 目的是扩展C++中提供的运算符的适用范围，以用于类所表示的抽象数据类型 运算符重载的实质是函数重载 ​ 返回值类型 operator 运算符(形参表) { …… } 在程序编译时： 把含运算符的表达式 $\\to$ 对运算符函数的调用 把运算符的操作数 $\\to$ 运算符函数的参数 运算符被多次重载时，根据实参的类型决定调用哪个运算符函数 运算符可以被重载为普通函数，也可以被重载为成员函数 运算符重载为普通函数时，参数个数为运算符目数（如+为2） 1234567891011121314151617class Complex &#123;public: Complex(double r = 0.0, double i = 0.0) &#123; real = r; imaginary = i; &#125; double real; double imaginary;&#125;;Complex operator+(const Complex &amp;a, const Complex &amp;b) &#123; return Complex(a.real+b.real,a.imaginary+b.imaginary)&#125;int main() &#123; Complex a(1, 2), b(2, 3), c; c = a + b; //相当于operator+(a,b)，会传递两个参数a,b return 0;&#125; 运算符重载为成员函数时，参数个数为运算符目数减一 123456789101112131415161718192021222324class Complex &#123;public: Complex(double r = 0.0, double i = 0.0):real(r),imaginary(i) &#123; &#125; //constructor Complex operator+(const Complex &amp;); //addition Complex operator-(const Complex &amp;); //subtractionprivate: double real; double imaginary;&#125;;//Overload addition operatorComplex Complex::operator+(const Complex &amp;operand2) &#123; return Complex(real + operand2.real, imaginary + operand2.imaginary)&#125;//Overload subtraction operatorComplex Complex::operator-(const Complex &amp;operand2) &#123; return Complex(real - operand2.real, imaginary - operand2.imaginary)&#125;int main() &#123; Complex x(4.3,8.2),y(3.3,1.1),z; z = x + y; //相当于z = x.operator(y)，即只传入一个参数 z = x - y; //相当于z = x.operator(y) return 0;&#125; 2.赋值运算符’=’重载2.1.基本实现当类和对象这个新概念对引入的时候，原先一些传统的运算符并不能直接作用在我们自己定义的类型的对象上，但是唯有赋值运算符’=’是可以直接使用的，它会会按对象的数据成员一一完成赋值。当我们对’=’有更多的要求时，比如两边类型可以不匹配，或者除了完成普通的赋值外还要实现其他功能，就需要重载运算符’=’。 赋值运算符’=’只能重载为成员函数 例子：编写一个长度可变的字符串类String，包含一个char *类型的成员变量 $\\to$ 指向动态分配的存储空间，该存储空间用于存放&#39;\\0&#39;结尾的字符串。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class String &#123;private: char *str;public: String():str(NULL)&#123;&#125; //构造函数，初始化str为NULL const char * c_str() &#123; return str; &#125; char * operator=(const char * s); ~String();&#125;;char * String::operator=(const char *s) &#123; if (str) delete[] str; if (s) &#123; str = new char[strlen(s) + 1]; strcpy(str, s); &#125; else str = NULL; return str;&#125;String::~String() &#123; if (str) delete[] str;&#125;int main() &#123; String s; s = \"Good Luck\"; //相当于s.operator = \"Good Luck\"; cout &lt;&lt; s.c_str() &lt;&lt; endl; //String s2 = \"hello!\"; 这条语句是错误的，我们并没有定义这样的构造函数 s = \"C++\"; cout &lt;&lt; s.c_str &lt;&lt; endl; return 0;&#125; 2.2.重载赋值运算符的意义—浅复制和深复制 浅复制/浅拷贝：执行逐个字节的复制工作 比如利用我们上节定义的String类，它有两个对象S1和S2，利用我们已经重载的复制运算符可以实现直接将一个字符串赋值给一个String对象，如果想进一步将S2直接赋值给S1，在语法上也是没问题的，它会实现浅复制，即将S2对象中的内容逐字节地复制给S1，实际上就是S1.str = S2.str，两个指针就指向了同一块地址，但这会引发一些问题。 1234String S1, S2;S1 = \"this\";S2 = \"that\";S1 = S2; 当执行了S1 = S2 后，S1.str和S2.str两个指针指向了同一块地址，这引发了两个问题：第一个是存放”this“字符串的内存没有任何指针来对它进行控制，成为了一个内存垃圾；当S1和S2同时消亡的时候，存放”that“的内存会被释放两次，这会导致严重的内存错误。 深复制/深拷贝：将一个对象中指针变量指向的内容 $\\to$ 复制到另一个对象中指针成员对象指向的地方 123456String &amp; operator=(const String &amp;s) &#123; if (str) delete[] str; str = new char[strlen(s.str) + 1]; strcpy(str, s.str); return *this; //注意这里返回的是this指针&#125; 通过上面的赋值运算符深拷贝的实现，我们是否已经完全实现了String对象的赋值呢？仔细考虑一下，还会一点小疏漏，就是当执行s = s，即把当前对象赋值给其自身，那么在刚才的重载函数中就会出现一些小问题，当执行strcpy(str, s.str)时会发现我们已经把原来s.str所指的内存空间中的内容删掉了，所以我们要在原来代码基础上加一条if语句。 1234567String &amp; operator=(const String &amp;s) &#123; if (str == s.str) return *this; if (str) delete[] str; str = new char[strlen(s.str) + 1]; strcpy(str, s.str); return *this;&#125; 那么上面定义的String类还有其他问题嘛？ 需要注意的是：为String类编写复制构造函数时，会面临和’=’同样的问题，如果采用浅拷贝或者调用默认的复制构造函数，就会出现问题，为此我们也要采用深拷贝的方式 12345678String(String &amp;s) &#123; if (s.str) &#123; str = new char[strlen(s.str) + 1]; strcpy(str, s.str); &#125; else str = NULL;&#125; 3.运算符重载为友元函数 通常，将运算符重载为类的成员函数 重载为友元函数的情况： 成员函数不能满足要求 普通函数又不能访问类的私有成员 123456789101112131415class Complex &#123;public: Complex(double r,double i):real(r),imag(i) &#123;&#125; Complex operator+(double r);private: double real, imag;&#125;;Complex Complex::operator+(double r) &#123; return Complex(real + r, imag);&#125;int main()&#123; Complex c; c = c + 5; return 0;&#125; 上面的例子中，能实现c = c + 5，相当于c = c.operator +(5)，但不能实现c = 5 + c，如果要实现后者，就需要将’+’重载为普通函数，且要能访问Complex类的私有成员real，因此要将’+’重载为友元函数。 1234567891011121314class Complex &#123;public: Complex(double r,double i):real(r),imag(i) &#123;&#125; Complex operator+(double r); friend Complex operator+(double r, const Complex &amp;c);private: double real, imag;&#125;;Complex Complex::operator+(double r) &#123; return Complex(real + r, imag);&#125;Complex operator+(double r, const Complex &amp;c) &#123; return Complex(c.real + r, c.imag);&#125; 4.实例-长度可变的整型数组类C++中的数组的大小（size）是固定的，不能按存放元素的多少自动调整容量，为此我们想自己定义一个长度可变的整型数组类，可以实现下面的功能： 12345678910111213141516171819int main() &#123; //要编写可变长度的整型数组类，使用如下功能 CArray a; //开始里的数值是空的 for (int i = 0; i &lt; 5; ++i) a.push_back(i); CArray a2, a3; for (int i = 0; i &lt; a.length(); ++i) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; a2 = a3; //a2这时为空 for (int i = 0; i &lt; a2.length(); ++i) //a2.length()为0，所以没有输出 cout &lt;&lt; a2[i] &lt;&lt; \" \"; cout &lt;&lt; endl; a[3] = 100; CArray a4(a); //复制构造 for (int i = 0; i &lt; a4.length(); i++) cout &lt;&lt; a4[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return 0;&#125; 程序的输出结果是： 分析一下需要实现的功能： 要用动态分配的内存来存放数组元素，需要一个指针成员变量 要重载’=’ 要重载’[]’，即实现a2[i]，取下标 有复制构造函数 这个长度可变的整型数组类可以有下面的代码实现，还是有一些需要注意的点的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class CArray &#123; int size; //数组元素的个数 int *ptr; //指向动态分配的数组public: CArray(int s = 0); //s代表数组元素的个数 CArray(CArray &amp;a); ~CArray(); void push_back(int v); //用于在数组尾部添加一个元素v int length() &#123; return size; &#125; //返回数组元素个数 CArray &amp; operator=(const CArray &amp; a); //用于数组对象间的赋值 int &amp; operator[](int i) &#123; //用于支持根据下标访问数组元素，如n = a[i] 和 a[i] = 4 //若返回类型为int，则不能实现a[i] = 4，因为非引用的函数返回值不能作为左值 return ptr[i]; &#125;&#125;;CArray::CArray(int s) :size(s) &#123; if (s == 0) ptr = NULL; else ptr = new int[s];&#125;CArray::CArray(CArray &amp;a) &#123; if (!a.ptr) &#123; ptr = NULL; size = 0; return; &#125; ptr = new int[a.size]; memcpy(ptr, a.ptr, sizeof(int)*a.size); size = a.size;&#125;CArray::~CArray() &#123; if (ptr) delete[] ptr;&#125;CArray &amp; CArray::operator=(const CArray &amp;a) &#123; //重载后的赋值号的作用是使'='左边对象里存放的数组，大小和内容都和右边的对象一样 if (ptr == a.ptr) return *this; if (a.ptr == NULL) &#123; if (ptr) delete[] ptr; ptr = NULL; size = 0; return *this; &#125; if (size &lt; a.size) &#123; if (ptr) delete[] ptr; ptr = new int[a.size]; &#125; memcpy(ptr, a.ptr, sizeof(int)*a.size); size = a.size; return *this;&#125;void CArray::push_back(int v) &#123; if (ptr) &#123; int *tmpPtr = new int[size + 1]; memcpy(tmpPtr, ptr, sizeof(int)*size); delete[] ptr; ptr = tmpPtr; &#125; else ptr = new int[1]; ptr[size++] = v;&#125; 5.流插入和流提取运算符的重载 cout是在iostream中定义的，ostream类的对象。 “&lt;&lt;” 能用在cout上是因为在iostream里对”&lt;&lt;”进行了重载 cin是在iostream中定义的，istream类的对象。 “&gt;&gt;” 能用在cin上是因为在istream里对”&gt;&gt;”进行了重载 例子：假设c是Complex复数类的对象，实现cout&lt;&lt;c; 能输出”a+bi”形式，cin&gt;&gt;c 能从键盘接受”a+bi”形式的输入。 为此我们需要把&lt;&lt;和&gt;&gt;重载成全局函数，因为它们已经是ostream和istream的成员函数了；又因为它们需要访问Complex类的私有成员，因此要声明成Complex类的友元函数。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;class Complex &#123; double real, imag;public: Complex(double r = 0, double i = 0) :real(r), imag(i) &#123; &#125;; friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Complex &amp;c); friend istream &amp; operator&gt;&gt;(istream &amp;is, Complex &amp;c);&#125;;ostream &amp; operator&lt;&lt;(ostream &amp; os, const Complex &amp;c) &#123; os &lt;&lt; c.real &lt;&lt; \"+\" &lt;&lt; c.imag &lt;&lt; \"i\"; //以“a+bi”的形式输出 return os;&#125;istream &amp; operator&gt;&gt;(istream &amp; is, Complex &amp;c) &#123; string s; is &gt;&gt; s; //将\"a+bi\"作为字符串读入，\"a+bi\"中间不能有空格 int pos = s.find(\"+\", 0); string sTmp = s.substr(0, pos); //分离出代表实部的字符串 c.real = atof(sTmp.c_str()); //atof库函数能将const char* 指针指向的内容转换成float sTmp = s.substr(pos + 1, s.length() - pos - 2); //分离出代表虚部的字符串 c.imag = atof(sTmp.c_str()); return is;&#125;int main() &#123; Complex c; int n; cin &gt;&gt; c &gt;&gt; n; cout &lt;&lt; c &lt;&lt; \",\" &lt;&lt; n; return 0;&#125; 运行结果示例： 6.自加/自减运算符的重载 自加++/自减—运算符有前置/后置之分： 前置++（++a）：先加1，再执行语句 后置++（a++）：先执行语句，再加1 前置运算符作为一元运算符重载： 重载为成员函数：T operator++(); ， T operator--(); 重载为全局函数：T operator++(T); ， T operator--(T); 如++obj，obj.operator++()，operator++(obj)都是调用上述前置运算符 后置运算符作为二元运算符重载：（多写的参数只是标记重载的运算符为后置，并无具体意见） 重载为成员函数：T operator++(int); ， T operator--(int); 重载为全局函数：T operator++(T, int); ， T operator--(T, int); 如obj++，obj.operator++(0)，operator++(obj, 0)都是调用上述前置运算符 例子：我们希望设计一个CDemo对象来实现下面的功能： 123456789101112int main() &#123; CDemo d(5); cout &lt;&lt; (d++) &lt;&lt; \",\"; //等价于d.operator++(0); cout &lt;&lt; d &lt;&lt; \",\"; cout &lt;&lt; (++d) &lt;&lt; \",\"; //等价于d.operator++(); cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; (d--) &lt;&lt; \",\"; //等价于operator--(d,0); cout &lt;&lt; d &lt;&lt; \",\"; cout &lt;&lt; (--d) &lt;&lt; \",\"; //等价于operator--(0); cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 程序运行结果： 我们首先需要设计CDemo对象的自加自减运算符，再注意cout&lt;&lt;d语句它会将CDemo对象直接输出为整型数，而cout并没有这样的功能，它不支持任意自定义类型的输出，因此要设计一个强制类型转换符的一个运算符重载。 123456789101112131415161718192021222324252627282930class CDemo &#123;private: int n;public: CDemo(int i=0):n(i)&#123; &#125; CDemo operator++(); //前置++，重载为成员函数 CDemo operator++(int); //后置++ operator int() &#123; return n; &#125; friend CDemo operator--(CDemo &amp;); //前置--，重载为全局函数(仅做示例，重载为成员函数亦可） friend CDemo operator--(CDemo &amp;, int); //后置--&#125;;CDemo CDemo::operator++() &#123; //前置++ n++; return *this;&#125;CDemo CDemo::operator++(int k) &#123; //后置++ CDemo tmp(*this); n++; return tmp; //返回修改前的对象&#125;CDemo operator--(CDemo &amp; d) &#123; //前置++ d.n--; return d;&#125;CDemo operator--(CDemo &amp;d,int k) &#123; //后置++ CDemo tmp(d); d.n--; return tmp; //返回修改前的对象&#125; 注意语句operator int() { return n; } ： 此时Int作为一个类型强制转换运算符被重载（而不是整型类型了） 12CDemo s;(int)s; //等效于s.int(); 类型强制转换运算符重载时： 不能写返回值类型 实际上返回值类型——类型强制转换运算符代表的类型 运算符重载的注意事项： C++不允许定义新的运算符 重载后运算符的含义应该符合日常习惯 运算符重载不改变运算符的优先级 一下运算符不能被重载：’.‘，’.*‘，’::‘，’?:‘，sizeof 重载运算符()，[]，-&gt;，=时，重载函数必须声明为类的成员函数","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"数据结构与算法（6）选择排序与插入排序","slug":"数据结构与算法（6）选择排序与插入排序","date":"2020-02-15T11:22:47.000Z","updated":"2020-02-16T02:22:47.000Z","comments":true,"path":"2020/02/15/数据结构与算法（6）选择排序与插入排序/","link":"","permalink":"http://nekomoon404.github.io/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1.选择排序与向量那一章的做法一样列表这一章的接下来几节，也将针对列表这种结构的特点介绍几种典型的排序算法，这一节要介绍的是选择排序。 1.1.构思选择排序在生活中其实很常见，举个例子，假设有一篮子苹果或大或小，如果你需要从小到大把它们排成一个序列，那你会怎么做呢？常用的一种方法应该是这样的：首先在其中挑选出最大的，接下来在剩下的中挑选出最大的，即整体中次大的，如此反复，直到篮子中只剩下最后那只苹果。 可以看出在这个过程中我们所采用的策略，原则非常的简单，就是每一次只需在篮子中找出当前最大的那只苹果，并且随即将它转移到桌子上。这里每一步所做的实质的关键动作就是所谓的选择select，而基于这样一种选择过程和策略的排序算法就叫作选择排序（selection sort）。 回顾一下此前所介绍过的起泡排序bubble sort，其实它也是selection sort。在起泡算法的过程中它的不变性可以表述为整个序列总是可以分成前后两个部分，其中后面的一个部分是由一系列已经就位的元素组成的，它们构成了一个有序的sorted的部分；而前半部分的元素数值的分布是随机的或大或小，但是就数值而言它们都绝对不会超过图中的黄线。这个算法是由一趟又一趟的扫描交换构成的，在接下来的一趟扫描交换中最实质的操作实际上是当前最大的那个元素和其后的元素不断地交换，直到它最终被移送到黄色区域的末尾。于是这个有序的S部分就可以向左侧拓展，这也就是起泡排序算法的单调性。 纵观这个过程并且与上面的选择排序做一对比，我们会发现二者之间的相似之处：也就是每一次扫描交换的作用其实实质上都等价于找到这个最大节点，并且随即将它转移至有序和无序子序列的分界点。从这个角度来看起泡排序确实就是一个不折不扣的选择排序。 那反过来既然如此还有什么必要去专门讨论选择排序呢？原因在于起泡排序的效率太低，在最坏情况下它需要$O(n^2)$的时间，而借助列表结构这个效率是完全可以改进的。在起泡排序的过程中所执行的计算无非两类，一类就是相邻元素的比较，另一类才是元素位置的交换。然而很遗憾在这里将最大元素转移至合适的位置这样一个任务，是由一系列的短距离实际上是相邻元素之间的移动构成的，这种“小步慢跑式”的移动正是低效率的来源。 所以既然我们最终无非就是要将这个最大的元素挪到最终的位置，为何不直接一次性地来完成这项工作呢？这正是我们改进的思路。 1.2.实现选择排序selection sort可以实现为下面一段代码： 123456789//列表的选择排序算法：对起始于位置p的n个元素排序，valid(p) &amp;&amp; rank(p) + n &lt;= sizetemplate &lt; typename T&gt; void List&lt;T&gt;::selectionSort(Posi(T) p, int n) &#123; Posi(T) head = p-&gt;pred; ePosi(T) tail = p; //待排序区间为(head, tail) for (int i = 0; i &lt; n; i++) tail = tail-&gt;succ; //head/tail可能是头/尾哨兵 while (1 &lt; n) &#123; //反复从（非平凡的）待排序区间内找出最大者，并将其移至无序区间末尾 insertBefore(tail, remove(selectMax(head-&gt;succ, n))); tail = tail-&gt;pred; n--; //待排序区间、有序区间的范围、均同步更新 &#125;&#125; 注意一下这个接口的语义，待排序的元素实际上是在列表中起始于位置p的连续n个元素，在下面的图示中，如果L是整个的列表那么待排序的区间，从节点p开始第n个节点是用虚线表示的，言下之意这里依然采用了此前左闭右开的区间定义习惯。相应地 这里引入了两个界桩head和tail。 经过入口处预处理的两步，head和tail分别对应的位置就是在这个图中的h以及p+n，在接下来的循环中 head始终不变，而tail会每次向前移动一个节点。而从tail开始到最初的界桩之间的范围正是已经排序的区间，而尚未排序的的前缀U是从p一直到T左闭右开的区间，这也是这个算法的不变性。 从算法可以看出每次我们都调用selectMax的接口，从前缀U这个区间中找到当前的最大者，n会随着迭代地进行相应地下降，从记录前缀U的宽度。在这个图中被选取出来的最大节点以M来表示，我们将M节点摘出来插入至S区间的首节点，tail的前端，相当于将M移动到此前的T的紧邻左侧，并且随即将T移动到新的这个节点处（M处），从而使有序的部分向左拓展一个单元。这个算法将持续地迭代下去，直到n最终缩减到平凡的情况，从而完成整个指定区域的排序。 1.3.推敲现在来重新审视一下这个算法并且对其中的几个细节来做一推敲，第一个问题是算法中套用了此前所实现的remove和insert这两个标准的操作接口，使整个代码实现更加简洁，但从效率而言还是值得推敲的。这其中的原因在于，这两个操作都要使用到动态空间分配，也就是insert的时候必须要用new，remove的时候需要delete。 虽然这两个操作都可以大致认为依然是常数的时间复杂度，但是从实际的时间消耗而言它大致是通常的基本操作的一百倍，也就是说要高出两个数量级，因此在实际中这一对操作应该尽可能少的使用。就这个意义而言，或许应该改用另外一种实现方式，比如可以只通过对M处和T处局部引用的修改，来实现同样的功能；另外一种可行的方式就是只需将M与T当前的前驱直接交换它们的数据域即可。 另一问题是有些情况下，对M的搬动操作其实是不必进行的，如果这个最大节点M恰好正是tail的直接前驱那么它自然已经就位，当然也就无需搬动了。基于这个观察，或许你会倾向于去做这样一种优化：在搬运M前加一条if语句。这样一种改进的方式本身的确是可行的，但是我们并不认为这是一个优化，其中的原因在于，在通常的随机分布下这种情况出现的概率极低（$\\ln n/n \\to 0$），以致于我们这里所做的这种所谓的优化会得不偿失。 1.4.实现：selectMax()selectMax()接口的实现很朴实，从首节点出发逐一地进行比对，并且在这样的一个过程中记录下当前最大的元素，当我们抵达终点时，这个最终的记录就是我们所要找的最大节点。这个过程可以实现为下面的代码： 12345678template &lt; typename T&gt; //从起始于位置p的n个元素中选出最大者Posi(T) List&lt;T&gt;::selectMax(Posi(T) p, int n) &#123; Posi(T) max = p; //最大者暂定为首节点p for (Posi(T) cur = p; 1 &lt; n; n--) //从首节点p出发，将后续节点逐一与max比较 if (!lt((cur = cur-&gt;succ)-&gt;data, max-&gt;data)) //若当前元素不小于max，则 max = cur; //更新最大元素位置记录 return max; //返回最大节点位置&#125; 注意到我们这里所采用的比较器是not less than ，也就是不小于（当前元素不小于max），只要当前的这个节点大于或等于目前的max，就需要做相应的更新。这是接口语义要求的，如果序列有最大的元素有多个的话，这样可以返回其中最靠后的那个（秩最大的那个），而这个元素也相应地会被优先地转移到sorted的那部分，就总体效果而言所有的这些重复元素都会依次地转移到相应的位置上去，从而保证算法的稳定性。 1.5性能选择排序的性能如何呢？这个算法仍是由n次迭代完成的，在第k次迭代中： selectMax()为$\\Theta(n-k)$，算术级数 remove()和insertBefore()均为$O(1)$ 故总体复杂度为$\\Theta(n^2)$。（无论最大元素在哪都需要$n^2$，不分最好最坏情况，因此用$\\Theta$） 选择排序居然和起泡排序的效果一样嘛？其实还是有区别的，就这里所涉及的两类操作：节点的移动以及比较大小而言，前者在实际效果也就是常系数的意义下要复杂的多得多，需要花费远远更多的时间，因此这里能够对移动次数做改进，使得每一趟扫描所需要的移动操作从原来的n降至1，实际上是一个非常了不起的改进。那么比较操作同样可以进一步地改进，等到后面的第十章优先级队列中，将会借助精巧的数据结构，使selectMax()可以$\\log n$而不是$n$的时间内完成。 2.插入排序2.1经验插入排序也是一种生活中很常见的排序算法，比如在发牌时整理手上的牌[・_・?]，我们可能会这样做：将手牌先按大小整理好，接下来拿到新牌后再按照大小插入到手牌中相应的位置，这其实就是插入排序。 在每次这样的过程中，我们所做的工作无非两步：第一步就是由这条绿色的线所标明的去做一个定位，即寻找到要插入的位置；接下来的动作实际上是两个更小的步骤的组合，首先将更小的牌向左移动以腾出一个空余位置，然后将新牌插入到那个位置。 2.2构思在插入排序算法的整个过程中我们始终将输入序列视作两个部分：有序部分+无序部分 Sorted + Unsorted L[0, r) + L[r, n) 接下来是迭代的过程，在每一次迭代中将当前秩为r的元素e插入到前面的Sorted部分的合适位置，使之保持有序，这样待解决问题的规模就减一，这也是这个算法的不变性。 【初始化】置$S_0$为空序列（长度为0） //空序列自然有序 【迭代】在有序的$S_r$ = S[0, r)中确定适当位置 //有序序列的查找 ​ 插入S[r]，得到有序的$S_{r+1}$ = S[0, r] //有序序列的插入 如此，可逐步得到：$S_0,S_1,\\dots,S_n$，最终，$S_n$ = S[0, n)即排序序列 正确性基于以下不变性：$\\forall$ 0&lt;= r &lt;= n，$S_r$ = 前r个元素组成的有序序列 2.3对比介绍到这你可能会有疑问，排序排序和选择排序看起来是一回事啊？但其实它们是截然不同的两种算法，这里先来看一下两者在整体策略上的区别。 第一个区别：insertion sort有序部分和无序部分的次序左右颠倒，而在selection sort中 有序部分是后缀，无序的部分才是前缀，当然这不是很重要φ(&gt;ω&lt;*) 。 第二个区别：在选择排序中，无序的前缀部分始终保持着一个不变性，也就是无序部分的所有元素都不会超过有序部分的最小元素（第一个）；反观插入排序，并没有这样的规定，有序部分的k个元素仅仅是序列中的前k个元素，要插入的元素可能是任意大小。 2.4.实现将插入排序的过程实现为下面一段代码： 1234567//列表的插入排序算法：对起始于位置p的n个元素排序，valid(p) &amp;&amp; rank(p) + n &lt;= sizetemplate &lt; typename T&gt; void List&lt;T&gt;::insertionSort(Posi(T) p, int n) &#123; for (int r = 0; r &lt; n; r++) &#123; //逐一为各节点 insertAfter(search(p-&gt;data, r, p), p-&gt;data); //查找适当的位置并插入 p = p-&gt;succ; remove(p-&gt;pred); //转向下一节点 &#125; //n次迭代&#125; //仅使用O(1)辅助空间，属于就地算法 p一开始指向序列的起点，经过一次迭代p后移一位，它始终是有序部分和无序部分的界点。search(p-&gt;data, r, p)返回有序部分中不大于p的最大元素（最靠后），接着将值为p-&gt;data的节点插入其后（注意这里并不是将p直接插入到那位置），然后将p转向它的后继p-&gt;succ，并删除原来的p。 整个算法过程中，除了输入的列表自己本身以外，只需要$O(1)$的额外辅助空间，这种算法被称为就地算法（in-place algorithm ）。 2.5.性能 最好情况：完全（或几乎）有序 每次迭代，只需1次比较，0次交换；累计$O(n)$时间 ！（而选择排序无论好坏都是$\\Theta(n^2)$） 最坏情况：完全（或几乎）逆序 第k次迭代，需要$O(k)$次比较，1次交换；累计$O(n^2)$时间 你可能会想，既然是在一个有序部分中查找，那为什么不用二分查找呢[・_・?]，可以把比较次数降到$O(\\log k)$。其实是不行的，因为列表不支持这种循秩访问的方式，而向量是可以的。 那为啥不用向量实现插入排序呢[・ヘ・?]。如果用向量的话，在插入操作时，我们必须将所插入元素之后的元素整体向后移一个单位，这样每次迭代仍然是需要$O(n)$时间，所以就最坏的情况而言，改用向量结构对于插入排序的改进于事无补。 2.6.平均性能上节分析插入排序在最好和最坏情况下的时间复杂度，那么在一般情况下呢？ 假定各元素的取值遵守均匀，独立分布，那么平均要做多少次比较呢？ 为此需要采用一种方法：后向分析（backward analysis），我们把时间拉回到某个元素，比如第r个元素刚刚完成插入的那个时刻，在此之前有序前缀长度为r，现在长度为r+1。那么插入这个元素需要花费多少时间呢？由于插入元素的大小是不确定的，而且它插在不同位置上对应的成本也不同。 但是由于我们采用的是均匀独立分布的假设，那么对于现在有序前缀中的r+1个元素中，每个元素都可能是刚刚插入的那个元素，其概率是相等的，为$1/(r+1)$。为了估算刚才那一步迭代的时间成本，我们将每一个元素作为刚插入元素完成插入所对应的成本累计起来，求期望： \\left[ r+(r-1)+\\dots+3+2+1+0\\right]/(r+1)+1=r/2+1于是，整个过程的总体期望是： \\left[ 0+1+\\dots+(n-1)\\right]/2+1=O(n^2)所以插入排序的平均复杂度依然是$O(n^2)$，与它在最坏情况下是同阶的，换而言之，虽然它有最好情况复杂度为$O(n)$，但这种情况发生的概率极低。 2.7.逆序对最后来看一个与插入排序非常相关的一个概念：逆序对（inversion）。实际上在一个由n个元素构成的序列中，任何两个元素都有可能构成逆序对，其逆序对的总数接近$n^2$。逆序对涉及到两个元素，我们不妨把逆序对这个标记记到后边元素上，对应一个节点p，可以用$i(p)$来表示节点p对应的逆序对数的总和，那么整个序列的逆序对总数为： I=\\sum_p i(p) 在插入排序中，当要把节点p插入到前面的有序序列S的适当位置时，p所对应的逆序对的个数就是p要经过的比较的次数，$i(p)$其实就是p所对应的查找长度。因此$I$就对应着整个插入排序算法所需要的比较次数的总和，这是算法所消耗时间的主要部分，再加上每n步插入所需要的时间一共是$n$，那么插入排序的复杂度就是$O(I+n)$。 如果把整个序列的逆序对总数$I$作为序列无序程度的度量尺度，那么插入排序insertion sort就可以理解为是通过一次一次的努力去修复这种无序性。因此它的算法复杂度其实不光是取决于问题的规模，而更多的是取决于输入序列本身所具有的特性即它的无序程度，所以这样一种算法也称作输入敏感的（input-sensitive）。在排序算法家族中并非每一种算法都具有这样的一个特性，而插入排序也正因为它具有这样一个特性，而显得非常的独特。在之后要介绍的希尔排序（Shell sort）中，我们将会看到这种输入敏感的特性对于希尔排序整体的性能，乃至这个算法的有效性都是至关重要的。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（5）列表","slug":"数据结构与算法（5）列表","date":"2020-02-14T12:33:23.000Z","updated":"2020-02-15T12:33:23.000Z","comments":true,"path":"2020/02/14/数据结构与算法（5）列表/","link":"","permalink":"http://nekomoon404.github.io/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/","excerpt":"","text":"本章的主题是列表，与向量一样列表也是典型的最基本的一类线性结构，但是列表结构与向量结构在几乎所有的方面都是对称的、互补的，因此它的特点也十分的鲜明。本文主要介绍列表的接口与实现，无序列表和有序列表。 1.接口与实现1.1.从静态到动态 根据是否修改数据结构，所有操作大致分为两类方式： 静态：仅读取，数据的内容及组成一般不变：get、search 动态：需写入，数据结构的局部或整体将改变：insert、remove 与操作方式相对应地，数据元素的存储于组织方式也分为两种 静态：数据空间整体创建或销毁 ​ 数据元素的物理存储次序与其逻辑次序严格一致 ​ 可支持高效的静态操作 比如向量，元素的物理地址与其逻辑次序线性对应 动态：为各数据元素动态地分配和回收的物理空间 ​ 逻辑上相邻的元素记录彼此的物理地址 ​ 形成一个整体可支持高效的动态操作 这里的代表就是我们这一章的主题：列表 1.2.从向量到列表 列表（list）是采用动态存储策略的典型结构 其中的元素称作节点（node） 各节点通过指针或引用彼此联接，构成一个逻辑上的线性序列：$L=\\{a_0,a_1,\\dots,a_{n-1}\\}$ 相邻节点彼此互称前驱（predecessor）或后继（successor） 前驱或后继若存在，则必然唯一 一个序列中的第一个元素称为首节点（没有前驱），最后一个元素称为末节点（没有后继） 以下图为例，对于任何一个列表而言，首先都有一个入口的位置，所有的元素确实可以从入口开始沿着它们之间的引用，依次地从相对的前驱转向后继以及后继的后继，直到最终的末节点。虽然在逻辑上它们是这样的一个排列的次序，但是在物理上却远远不是。但是这样不妨碍它们定义并且实现这样的一个次序，比如说从某一个位置出发，我们可以找到它的物理位置并且访问它，接下来可以顺着它的后继的引用找到它的后继，以及再顺着后继的引用找到后继的后继，诸如此类直到最终抵达末节点，从而退出这个列表。 1.3.从秩到位置 向量支持循秩访问（call-by-rank）的方式，根据数据元素的秩，可在$O(1)$时间内直接确定其物理地址， V[i] 的物理地址 = V + i × s，s为单个单元占用的空间量 既然同属线性序列，列表固然也可通过秩找到对应的元素 为找到秩为i的元素，须从头（尾）端出发，沿引用前进（后退）i步 然而因为成本过高，此时的循秩访问已不合时宜 以平均分布为例，单次访问的期望复杂度为$(n+1)/2=O(n)$ 因此，应改用循位置访问（call-by-position）的方式访问列表元素，也就是说，应转而利用结点之间的相互引用，找到特定的节点 1.4.实现1.4.1列表节点：ADT接口 作为列表的基本元素，列表节点首先需要独立地“封装”实现。为此，可设置并约定若干基本的操作接口 1.4.2.列表节点：ListNode模板类 123456789101112131415#define Posi(T) ListNode&lt;T&gt;* //列表节点位置（ISO C++.0x，template alias）template &lt;typename T&gt; //简洁起见，完全开放而不再过度封装struct ListNode &#123; //列表节点模板类（以双向链表形式实现） T data; //数值 Posi(T) pred; //前驱 Posi(T) succ; //后继 // 构造函数 ListNode() &#123;&#125; //针对header和trailer的构造 ListNode(T e, Posi(T) p = NULL, Posi(T) s = NULL) : data(e), pred(p), succ(s) &#123;&#125; //默认构造器 // 操作接口 Posi(T) insertAsPred(T const&amp; e); //紧靠当前节点之前插入新节点 Posi(T) insertAsSucc(T const&amp; e); //紧随当前节点之后插入新节点&#125;; 1.4.3列表：ADT接口在给出列表结构的具体实现之前，首先定义一组它所应该提供的操作接口，仔细看会发现它的接口的形式以及对应的功能与第二章中所学过的向量Vector结构颇为类似，这里逐一再展开了，在后边相应的各节将对它们的功能和实现再做详细的介绍。 1.4.4.列表：List模板类接下来介绍列表也就是List这种模板类的具体定义，首先要引入刚才所实现的列表节点类，可以看到List这种模板类也是分为三个层次，其中private 私有的层次与向量类似，记录的都是那些对外不可见的部分，具体包括规模、引入两个哨兵节点。另外也包括一些内部的功能函数，以及刚才我们所定义的那些对外开放的标准ADT接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include \"listNode.h\" //引入列表节点类template &lt;typename T&gt; class List &#123; //列表模板类private: int _size; Posi(T) header; Posi(T) trailer; //规模、头哨兵、尾哨兵 protected: void init(); //列表创建时的初始化 int clear(); //清除所有节点 void copyNodes(Posi(T), int); //复制列表中自位置p起的n项 void merge(Posi(T)&amp;, int, List&lt;T&gt;&amp;, Posi(T), int); //归并 void mergeSort(Posi(T)&amp;, int); //对从p开始连续的n个节点归并排序 void selectionSort(Posi(T), int); //对从p开始连续的n个节点选择排序 void insertionSort(Posi(T), int); //对从p开始连续的n个节点插入排序public:// 构造函数 List() &#123; init(); &#125; //默认 List(List&lt;T&gt; const&amp; L); //整体复制列表L List(List&lt;T&gt; const&amp; L, Rank r, int n); //复制列表L中自第r项起的n项 List(Posi(T) p, int n); //复制列表中自位置p起的n项// 析构函数 ~List(); //释放（包含头、尾哨兵在内的）所有节点// 只读访问接口 Rank size() const &#123; return _size; &#125; //规模 bool empty() const &#123; return _size &lt;= 0; &#125; //判空 T&amp; operator[] (Rank r) const; //重载，支持循秩访问（效率低） Posi(T) first() const &#123; return header-&gt;succ; &#125; //首节点位置 Posi(T) last() const &#123; return trailer-&gt;pred; &#125; //末节点位置 bool valid(Posi(T) p) //判断位置p是否对外合法 &#123; return p &amp;&amp; (trailer != p) &amp;&amp; (header != p); &#125; //将头、尾节点等同于NULL Posi(T) find(T const&amp; e) const //无序列表查找 &#123; return find(e, _size, trailer); &#125; Posi(T) find(T const&amp; e, int n, Posi(T) p) const; //无序区间查找 Posi(T) search(T const&amp; e) const //有序列表查找 &#123; return search(e, _size, trailer); &#125; Posi(T) search(T const&amp; e, int n, Posi(T) p) const; //有序区间查找 Posi(T) selectMax(Posi(T) p, int n); //在p及其n-1个后继中选出最大者 Posi(T) selectMax() &#123; return selectMax(header-&gt;succ, _size); &#125; //整体最大者// 可写访问接口 Posi(T) insertAsFirst(T const&amp; e); //将e当作首节点插入 Posi(T) insertAsLast(T const&amp; e); //将e当作末节点插入 Posi(T) insertA(Posi(T) p, T const&amp; e); //将e当作p的后继插入（After） Posi(T) insertB(Posi(T) p, T const&amp; e); //将e当作p的前驱插入（Before） T remove(Posi(T) p); //删除合法位置p处的节点,返回被删除节点 void merge(List&lt;T&gt;&amp; L) &#123;merge(first(), size, L, L.first(), L._size);&#125;//全列表归并 void sort(Posi(T) p, int n); //列表区间排序 void sort() &#123; sort(first(), _size); &#125; //列表整体排序 int deduplicate(); //无序去重 int uniquify(); //有序去重 void reverse(); //前后倒置（习题）// 遍历 void traverse(void(*) (T&amp;)); //遍历，依次实施visit操作（函数指针，只读或局部性修改） template &lt; typename VST&gt; //操作器 void traverse(VST&amp;); //遍历，依次实施visit操作（函数对象，可全局性修改）&#125;; //List 这样的一个宏观结构可以用下面的图来表示，任何一个List结构都会拥有一个叫作header，以及另一个叫作trailer的哨兵节点，header和trailer对外是不可见的，当然我们后面会看到它们的作用非常巨大。而对外可见的部分主要是介乎header和trailer之间的这样的一系列的元素，其中如果存在的话，第一个元素也就是firstNode，我们称作首元素，而最后一个last我们称作末元素。那么相应的也把名字规范一下，称header叫作头元素，称trailer是尾元素。 等效地，头、首、末和尾这四个节点的“ 秩 ”可以分别理解为是等于-1、0、n-1以及n。 那么它们之间的联系是：头节点和尾节点是与生俱来的，而且二者并不相同，first和last并不见得不相同，甚至不能保证它们存在，但是对外而言first、last是可见的，而trailer和header这两个哨兵都是invisible不可见的。当然从秩的角度来看一个长度为n的列表中，头、首、末和尾这四个节点的秩可以分别理解为是等于-1、0、n-1以及n。 1.4.5.构造如此定义的一个列表结构可以按照这样的过程来创建：首先要为header和trailer分别地分配一个节点使它们真实的存在，接下来要将它们的后继以及前驱引用分别指向对方，从而实现这样一个互联的效果。当然逻辑上看这个时候对外可见的那个列表实际上是没有任何元素的，对应的就是一个空列表。而在接下来的几节里会介绍如何实现在其中插入一些元素，以及再插入一些元素，也可能时不常地从中删除或者是修改某一个元素。总而言之这个列表将有可能会包含一些实在的、对外可见的节点，我们在后面几节再来看这些操作是如何具体实现的。 1234567template &lt;typename T&gt; void List&lt;T&gt;::init() &#123; //列表初始化，在创建列表对象时统一调用 header = new ListNode&lt;T&gt;; //创建头哨兵节点 trailer = new ListNode&lt;T&gt;; //创建尾哨兵节点 header-&gt;succ = trailer; header-&gt;pred = NULL; //互联 trailer-&gt;pred = header; trailer-&gt;succ = NULL; //互联 _size = 0; //记录规模&#125; 2.无序列表2.1.秩到位置这一节讨论无序列表的相关算法，首先关心的一个问题是既然列表和向量同属于线性的序列结构那么是否可以继续沿用向量那种，十分便捷也是我们十分习惯的循序秩访问的方式呢？具体说来，对于任何一个名字叫L的列表，每当我们指定其中一个合法的秩r，都可以以这样的一个形式来直接引用并且访问到对应的这个节点。 答案是可以的，因为我们可以仿照向量的做法对下标操作符进行适当的重载，具体的方法如下： 123456template &lt; typename T&gt; //重载下标操作符，以通过秩直接访问列表节点（虽方便，效率低，需慎用）T List&lt;T&gt;::operator[] (Rank r) const &#123; //assert: 0 &lt;= r &lt; size Posi(T) p = first(); //从首节点出发 while (0 &lt; r--) p = p-&gt;succ; //顺数第r个节点即是 return p-&gt;data; //目标节点，返回其中所存元素&#125; 由此也可以看出这个算法的复杂度是取决于所指定的那个秩r的，即$O(r)$，这个是十分低下的。实际上这种用法虽然很方便，但是我们只能偶尔为之而不能常用。估算它的平均性能为$O(n)$，需要线性的时间，这样一个性能，无论如何我们都是无法接受的。 2.2.查找接下来考虑无序列表的查找算法，这里将这个算法的接口语义定义为在当前的列表L中以位置为p的某一个特定节点为基准，在它的n个真前驱中（不包括它自己在内的n个前驱中）找到某个可能存在的数值为特定值e的节点。 仿照向量的查找算法我们从p这个位置出发，从后向前将每个节点逐一取出并与目标元素进行比对，一旦发现相等也就是命中，即可停止。 这样一个过程可以准确地描述为下面的代码： 123456template &lt; typename T&gt; //在无序列表内节点p（可能是trailer）的n个真前驱中，找到等于e的最后者 Posi(T) List&lt;T&gt;::find(T const&amp; e, int n, Posi(T) p) const &#123; while (0 &lt; n--) //（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左 if (e == (p = p-&gt;pred)-&gt;data) return p; //逐个比对，直至命中或范围越界 return NULL; //p越出左边界意味着区间内不含e，查找失败&#125; //失败时，返回NULL 注意无论是成功的情况所返回的p，还是失败时返回的NULL，都是我们此前所定义的一个节点位置Position。还要注意一种特殊的情况，即目标节点e不仅存在而且可能有多个，那么在这时根据这个算法，它会首先停止于相对而言最靠后的那个节点，因为这正是我们的语义所要求的一个细节。 那么在最坏的情况下，当然这个算法必须一直迭代到最末尾这个位置，累计的宽度是n，所以相应的复杂度也就是最坏情况下$O(n)$。 还需要留意的是，我们这里的三个参数的次序find(T const&amp; e, int n, Posi(T) p)，为什么这里将n放在p的前端呢？实际上这是为了让我们更方便地了解这个算法的功能语义，当使用find(e, n ,p)这样一个方式来调用这个接口的时候，你就很容易理解它是在p的n个前驱中去进行查找。换而言之我们完全可以重载另一个接口find(e, p, n)，它的不同之处就在于p和n的位置恰好交换，这就意味着是在p的n个后继中去查找特定的某一个元素。 2.3.插入本节以insertBefore（前插入）为例介绍列表插入功能的实现，所谓的insert Before就是在当前的列表中以某个位置p为基准，在它的前方也就是作为它的前驱插入一个新的节点，而且这个节点的数值应该是我们指定的e。可以看到实际上它是通过转而由p作为一个节点的对象所支持的一个叫作insert as predecessor这样一个接口来实现的。 123456789101112template &lt; typename T&gt; Posi(T) List&lt;T&gt;::insertBefore(Posi(t) p, T const&amp; e)&#123; _size++; return p-&gt;insertAsPred(e); //e当作p的前驱插入&#125;//前插入算法（后插入算法完全对称）template &lt; typename T&gt; Posi(T) ListNode&lt;T&gt;::insertAsPred(T const&amp; e) &#123; Posi(T) x = new ListNode(e, pred, this); //创建（耗时100倍） pred-&gt;succ = x; pred = x; return x; //建立链接，返回新节点的位置&#125; insertAsPred首先生成一个节点，它的数值为e，这个节点的前驱就是节点this的前驱，而这个新生成出来的节点的后继恰好就是this。所以Posi(T) x = new ListNode(e, pred, this);这样一句不仅创建了一个数值为e的节点，而且完成了这个节点到当前这个列表的正确的连接。 接下来做进一步的调整，也就是既然新的这个节点已经以节点this作为后继，那么当前节点this也就应该以新的这个节点作为前驱。反之新的这个节点既然以原来的那个前驱为前驱，那么原来的这个前驱也就应该以新的这个节点为后继，至此完成了新节点的插入操作。（类似于Cpp基础6中的链表的创建过程） 需要注意的是这样一种操作只是在局部进行，只牵涉到局部的三个节点，与其它的节点没有关系，它的复杂度是常数的，而这一点与向量是迥然不同的（向量插入元素后，原位置其后的元素要整体后移）。 考虑一些特殊的情况，比如说如果当前这个节点this是首节点，以至于它的前驱根本就不存在，那么这个时候这种操作难道不会出问题吗？其实是不会出问题的，因为我们在此前设立过哨兵，即便当前这个节点是首节点，它的前驱在内部依然是存在的，也就是header，那么这个时候的这种操作依然是安全的。 2.4.基于复制的构造有的时候我们也需要以某个已有的列表为蓝本，通过复制来创建一个新的列表，这样的过程可以由下面的代码来实现。 12345678910111213template &lt; typename T&gt; //列表内部方法：复制列表中自位置p起的n项 void List&lt;T&gt;::copyNodes(ListNodePosi(T) p, int n) &#123; //p合法，且至少有n-1个真后继节点 init(); //创建头、尾哨兵节点并做初始化 while (n--) &#123; insertAsLast(p-&gt;data); p = p-&gt;succ; &#125; //将起自p的n项依次作为末节点插入 &#125;template &lt;typename T&gt; ListNodePosi(T) List&lt;T&gt;::insertAsLast ( T const&amp; e )&#123; _size++; return trailer-&gt;insertAsPred ( e ); &#125; //e当作末节点插入 解读下这个算法：可见这里被复制的节点范围是从某一个列表的位置p开始随后地连续n个节点，因此首先我们创建一个空的列表，它只包含内部的头尾哨兵节点，不包含任何实质的节点。接下来我们不断地将当前这个p处所指的那个节点的元素取出来，把它作为当前列表的末节点插入其中，每做完这样一个新节点的引入，我们都会将注意力转向当前这个节点的后继，如此往复直到这个区间中的所有n个节点，都被复制过来。 那么其中的insertAsLast怎么来实现呢？回顾我们所有对外可见的最后那个节点叫作last 即末节点，但是我们还同样配备了一个哨兵节点叫作trailer。所以所谓的insertAsLast其实就是insertBefore trailer。 2.5.删除接下来介绍如何从列表中删除指定的节点。可以通过下面的代码来实现。 12345678template &lt;typename T&gt; T List&lt;T&gt;::remove(ListNodePosi(T) p) &#123; //删除合法节点p，返回其数值 O(1) T e = p-&gt;data; //备份待删除节点的数值（假定T类型可直接赋值） p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; //后继、前驱 delete p; _size--; //释放节点，更新规模 return e; //返回备份的数值 &#125; 首先我们需要将这个节点的数据域取出作一备份，以便在最终能够顺利地将它返回，而删除节点之后整个列表在这个局部的拓扑连接关系的调整则是由第4、5行来完成的，通过下面的图便于理解一下这个过程。 p-&gt;pred-&gt;succ = p-&gt;succ的效果是将p现在的后继当作p现在的前驱的后继，这样等同于将后继的这个引用直接跳过了p。而p-&gt;succ-&gt;pred = p-&gt;pred的过程以及效果与前一句完全对称，具体来说就是将p现在的前驱作为p的现在后继的前驱。这样两句的实质的作用可以理解为是将这个局部的后继引用，以及前驱的引用都跳过节点p，也就是说 p可以认为与原来的列表已经在拓扑上隔离开了。所以当我们将p直接地通过delete操作删除并归还系统之后就实现了指定节点p的删除。 整个这个过程只牵涉到局部的三个节点其余的节点没有任何的影响，由此也可以确认删除算法的复杂度与插入算法一样，都是常数的。 2.6.析构如何销毁一个已有的列表呢？整个过程分为两步，首先要将对外可见的所有节点逐一删除，当所有对外可见的节点都被删除之后，再将内部的两个哨兵也就是header以及trailer给释放了。 所以整个这个算法分为两级：析构方法首先调用一个名为clear的函数，将所有的可见节点删除，接下来再将header和trailer删除掉，那么clear的实质的工作也就是反复的删除header的后继。 1234567891011template &lt;typename T&gt; List&lt;T&gt;::~List() &#123; //列表析构 clear(); //清空列表 delete header; delete trailer; //释放头、尾哨兵节点&#125;template &lt;typename T&gt; List&lt;T&gt;::clean() &#123; //清空列表 int oldSize = _size; while (0 &lt; _size) //反复删除首节点，直至列表变空 remove(header-&gt;succ); return oldSize;&#125; //O(n)，线性正比于列表规模 2.7.唯一化本节介绍列表的唯一化问题，即如何将列表中可能存在的重复元素剔除掉。在接下来要介绍的这个算法中，我们始终将整个列表视作由三部分组成，这个前缀部分作为这个算法的一条不变性，已经能够保证不包含任何重复的节点，而我们当前所要考察的就是接下来的这个节点p，当然此时可能还存在一个非空后缀。 这个算法的关键部分是如果当前那个节点的数值为e，就以e为目标在前缀中对它进行查找，无论查找成功与否我们都可以将问题的规模，有效地降低至少一个单位，具体的算法可以实现为这样一段代码： 12345678910template &lt;typename T&gt; int List&lt;T&gt;::deduplicate() &#123; //剔除无序列表中的重复节点 if (_size &lt; 2) return 0; //平凡列表自然无重复 int oldSize = _size; //记录原规模 LPosi(T) p = first(); Rank r = 1; //p从首节点起 while (trailer != (p = p-&gt;succ)) &#123; //依次直到末节点 Posi(T) q = find(p-&gt;data, r, p); //在p的r个（真）前驱中，查找与之相同者 q ? remove(q) : r++; //若的确存在，则删除之；否则秩递增 &#125; //assert: 循环过程中的任意时刻，p的所有前驱互不相同 return oldSize - _size; //返回列表规模的变化量，即被删除元素总数 &#125; //正确性及效率分析的方法与结论，与Vector::deduplicate()相同 解读一下这段代码：首先是处理平凡情况，确保这个列表中至少包含两个节点，接下来这一步可以认为是初始化，可以看到p最初的时候是指向首节点，即这时的前缀实际上可以认为是空的，所以不变性自然也就满足。接下来算法的主体部分是这个循环，可以看到每一次我们都将p中所存的那个元素在以p为基准的r个真前驱中查找。 在前缀中进行查找无非两种情况：一种就是find操作返回了一个非空的元素，它的数值当然就等于e，这是就把q删除掉了；否则如果q是一个null，那就意味着查找失败，即在这样的一个前缀中根本就不存在语义相同的元素，所以在这之后p这个节点可以归入到前缀中去，使得这个前缀拓展一个单位，在这种情况下就可以将r加1，即前缀的长度增加一个单位，同时p转入它的后继元素继续迭代，直到抵达哨兵trailer也就意味着整个列表全部扫描并且处理完毕。 3.有序列表本节介绍有序列表，我们假设其中的元素不仅可以比较大小而且已经按照这种大小关系有序地排列。在这样的一个条件下很多问题都存在更加高效的解法。 3.1.唯一化：原理以唯一化问题为例，回顾有序向量的唯一化可以比无序向量的唯一化更快地完成，那么有序列表的唯一化是否也能够比无序列表的唯一化完成地更快呢？在介绍出具体的算法之前，我们先来分析一下算法的思路。 回顾在有序向量的去重算法中，曾经介绍过这样一个事实：在任何一个有序的序列中，如果存在重复元素，那么每一组重复元素必然会彼此紧邻地排列成一个又一个的分组，每一个分组都由彼此相同的一组元素构成。而唯一化的任务可以等效地理解成是从每一组中挑选出一个代表，而将其余的元素都剔除掉。于是仿照有序向量的唯一化算法也可以得到一个迭代式的算法。 具体来讲每一次迭代我们都将注意力关注于当前以p指示的那个节点，同时还要考虑p的直接后继q，在经过一次比对之后如果发现p和q相等，就可以将后者剔除掉，这个可以通过列表所提供的remove标准接口来实现。此后q将指向新的后继节点。同样地在接下来的一步迭代中，依然会发现q与p相等，所以可以继续将它删除。 在某一步接下来的迭代中情况可能发生变化，即首次发现一个与p不同的节点，这时就预示着一个新的区段出现了，作为这个新的区段的首节点，我们将保留这个节点。而为了这个算法能够继续计算下去，不妨将p由原来的位置转向这个新发现的不同的节点（图中p由红色转向绿色）。可以看到经过这样一轮迭代之后，刚才相同的一组元素中，除了第一个其余的后继都被删除掉了。 3.2.唯一化：实现上小节的算法思路可以实现为下面一段具体的代码： 12345678910template &lt;typename T&gt; int List&lt;T&gt;::uniquify() &#123; //成批剔除重复元素，效率更高 if (_size &lt; 2) return 0; //平凡列表自然无重复 int oldSize = _size; //记录原规模 Posi(T) p = first(); Posi(T) q; //p为各区段起点，q为其后继 while (trailer != (q = p-&gt;succ)) //反复考查紧邻的节点对(p, q) if (p-&gt;data != q-&gt;data) p = q; //若互异，则转向下一区段 else remove(q); //否则（雷同），删除后者 return oldSize - _size; //列表规模变化量，即被删除元素总数 &#125; 解读一下这段代码：首先是处理平凡的情况，即要确保这个列表至少包含两个元素。我们所关注的总是当前节点p，这个节点从首节点开始，同时还有另一个辅助的引用q指向p的后继。以下是一个循环，每一次我们都令q指向p的直接后继，随后将二者作一比对，如果相同就调用remove接口将q删除掉；反过来 一旦遇到一个与p不同的后继节点，那么就意味着抵达了下一个区段的首节点，这个时候我们就可以直接将注意力转向这个下一个区段的首节点也就是q。此后发生的情况将与刚才那样一轮迭代完全相同，迭代持续进行直到最终q试图越过边界，这时整个算法也就宣告结束。 整个算法过程主体的复杂度来源是while，可以看到每经过一步迭代p都会转入一个新的节点，所以整个迭代至多经过线性步就会停止，所有这个算法的时间复杂度为$O(n)$，这相对于无序列表也是一个很大的改进。 3.3.查找有序列表的去重操作相对于无序列表而言可以更快地进行，那么其它的操作呢？比如我们最最关心的查找呢？ 有序的列表的查找操作可以由下面一段代码实现： 12345678template &lt; typename T&gt; //在有序列表内节点p的n个（真）前驱中，找到不大于e的最后者Posi(T) List&lt;T&gt;::search(T const&amp; e, int n, Posi(T) p) const &#123;// assert: 0 &lt;= n &lt;= rank(p) &lt; _size while (0 &lt;= n--) //对于p的最近的n个前驱，从右向左 if (((p = p-&gt;pred)-&gt;data) &lt;= e) //逐个命中 break; return p; //直至命中，数值越界或范围越界后，返回查找终止的位置&#125; //最好O(1)，最坏O(n)；等概率时平均O(n)，正比于区间宽度 我们发现这个算法与无序列表居然没有太多的差异，同样它在最好情况下也是常数，比如在开始的位置就发现命中目标；反过来最坏也可能多达$O(n)$，即一直查找到最后才得出是否命中的结论。在整个查找范围也就是p之前的n个前驱中，每一个元素对应的查找成本将呈算数级数趋势变化，总体而言是线性的。 这样的结论多少会令人失望，因为尽管我们这里已经将列表中的元素按顺序进行了重新组织，但是查找的效率居然没有实质的改进。这并不是我们实现不当，而根本的原因在于列表的循位置访问这种方式。这种访问方式与向量的循秩访问有着本质的差异。 Vector这种结构在访问数据的时候，所依据的实际上是秩rank，而列表结构所依据的是位置position。在此前所介绍过的计算模型，实际上对于RAM模型来说，它所对应的其实就是循秩访问的方式。对于RAM模型来说每给出一个编号i，都可以在$O(1)$的时间内找到对应的寄存器，读取其中的数值或者对其进行修改。 再来看图灵机模型，虽然“纸带”长度无限，但在任何时候我们所能够操纵的只是其中某一个特定的单元，而且更重要的是在接下来只可能向左或者向右移动一格。如果的确需要访问一个相距很远的单元，我们将不得不亦步亦趋地逐步地通过多步的迭代才能够抵达目标，这正是我call-by-position，而不是RAM那种call-by-rank。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Cpp基础（8）数据的共享与保护","slug":"Cpp基础（8）数据的共享与保护","date":"2020-02-13T12:58:24.000Z","updated":"2020-02-15T12:58:24.000Z","comments":true,"path":"2020/02/13/Cpp基础（8）数据的共享与保护/","link":"","permalink":"http://nekomoon404.github.io/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/","excerpt":"","text":"标识符的作用域与可见性作用域是一个标识符在程序正文中的有效区域。作用域可以分为以下几类： 函数原型作用域：函数原型中的参数，其作用域始于”(“，结束语”)”，如： 1double area(double radius) 局部作用域： 函数的形参、在块中声明的标识符 其作用域自声明处起，限于块中 类作用域： 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员） 文件作用域： 不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束语文件尾。 可见性： 可见性是从对标识符的引用的角度来谈的概念 可见性表示从内层作用域向外层作用域“看”时能看见什么 如果标识在某处可见，就可以在该处引用此标识符 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。 12345678910111213#include&lt;iostream&gt;using namespace std;int i; //全局变量，文件作用域int main()&#123; i = 5; &#123; int i; //局部变量，局部作用域 i = 7; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; //输出7 &#125; cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; endl; //输出5 return 0;&#125; 对象的生存期静态生存期： 静态生存期与程序的运行期间相同; 在文件作用于中声明的对象具有这种生存期 在函数内部声明静态生存期对象，要冠以关键字static 动态生存期： 开始于程序执行到声明点时，结束语命名该标识符的作用域结束处 块作用域中声明的，没有用static修饰的对象时动态生存期的对象（习惯称局部生存期对象） 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int i = 1; //i为全局变量，具有静态生存期void other() &#123; static int a = 2; static int b; //a, b为静态局部变量，具有全局寿命，局部可见 //只第一次进入函数时被初始化 int c = 10; //C为局部变量，具有动态生存期， //每次进入函数时都初始化 a += 2; i += 32; c += 5; cout &lt;&lt; \"---OTHER---\\n\"; cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \" a; \" &lt;&lt; a &lt;&lt; \" b: \" &lt;&lt; b &lt;&lt; \" c: \" &lt;&lt; c &lt;&lt; endl; b = a;&#125;int main() &#123; static int a; //静态局部变量，有全局寿命，局部可见（实际中尽量不使用重名的变量） int b = -10; //b,c为局部变量，具有动态生存期 int c = 0; cout &lt;&lt; \"---MAIN---\\n\"; cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \" a; \" &lt;&lt; a &lt;&lt; \" b: \" &lt;&lt; b &lt;&lt; \" c: \" &lt;&lt; c &lt;&lt; endl; c += 8; other(); cout &lt;&lt; \"---MAIN---\\n\"; cout &lt;&lt; \"i: \" &lt;&lt; i &lt;&lt; \" a; \" &lt;&lt; a &lt;&lt; \" b: \" &lt;&lt; b &lt;&lt; \" c: \" &lt;&lt; c &lt;&lt; endl; i += 10; other(); return 0;&#125; 类的静态成员静态成员：在定义前面加了static关键字的成员 1234567891011class CRectangle&#123; private: int w,h; static int nTotalArea; static int nTotalNUmber; //静态成员变量 public: CRectangle(int _w,int _h); ~CRectangle(); static void PrintTotal(); //静态成员函数&#125;； 基本概念 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享 ​ 注意：sizeof运算符不会计算静态成员变量，如下例中sizeof(Myclass)等于4 1234class Myclass&#123; int n; static int s&#125; 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。 因此静态成员不需要通过对象就能访问 如何访问静态成员： 类名::成员名 1CRectangle::PrintTotal(); 对象名.成员名（并不意味着静态成员或静态成员函数只作用于该对象,，它们是被所有的CRentangle对象所共享的） 1CRectangle r; r.PrintTotal(); 指针-&gt;成员名 1CRectangle *p = &amp;r; p-&gt;PrintTotal(); 引用.成员名 1CRectangle &amp;ref = r; int n = ref.nTotalNumber; 静态成员变量本质上是全局变量，哪怕一个对象都不存在，类的静态成员变量也存在。 静态成员函数本质上是全局函数 设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。 示例：考虑一个需要随时知道矩阵总数和总面积的图像处理程序，可以用全局变量来记录总数和总面积，同静态成员将这两个变量封装进类中，就更容易理解和维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;class CRectangle&#123;private: int w, h; static int nTotalArea; static int nTotalNUmber; //静态成员变量public: CRectangle(int _w, int _h); ~CRectangle(); static void PrintTotal(); //静态成员函数&#125;;CRectangle::CRectangle(int _w, int _h)&#123; w = _w; h = _h; nTotalNUmber++; nTotalArea += w * h;&#125;CRectangle::~CRectangle()&#123; nTotalNUmber--; nTotalArea -= w * h;&#125;void CRectangle::PrintTotal()&#123; cout &lt;&lt; nTotalNUmber &lt;&lt; \", \"&lt;&lt;nTotalArea &lt;&lt; endl;&#125;int CRectangle::nTotalNUmber = 0;int CRectangle::nTotalArea = 0;//必须在定义类的文件中对静态成员变量进行一次说明或初始化。//否则编译能通过，链接不能通过int main()&#123; CRectangle r1(3, 3), r2(2, 2); //cout&lt;&lt;CRectangle::nTotalNUmber; //Wrong,私有成员不能在类外访问 CRectangle::PrintTotal(); r1.PrintTotal(); //与上一句等价 return 0;&#125; 注意事项： 在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数（因为其可能访问非静态成员变量），例如下面的定义就是错误的。 1234void CRectangle::PrintTotal()&#123; cout &lt;&lt; w &lt;&lt;\", \"&lt;&lt; nTotalNUmber &lt;&lt; \", \"&lt;&lt;nTotalArea &lt;&lt; endl; &#125; //Wrong，因为PrintTotal是静态成员函数，而w属于非静态成员变量 我们回过头来再看之前的CRectangle类的写法，其实它是有严重缺陷的，那么这个缺陷是如何产生的呢？ 问题就出在我们忽略了复制构造函数，在程序需要它时，会调用自动生成的复制构造函数，自然就不会对nTotalNUmber和nTotalArea作相应的增加。 在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象 调用一个以CRectangle类对象作为参数的函数时 调用一个以CRectangle类对象作为返回值的函数时 临时对象在消亡时会调用析构函数，减少nTotalNUmber和nTotalArea的值，可是这些临时对象在生成时却没有增加nTotalNUmber和nTotalArea的值。 解决办法：为CRectangle类写一个复制构造函数 123456CRectangle::CRectangle(CRectangle &amp;r)&#123; w=r.w; h=r.h; nTotalNUmber++; nTotalArea += w * h;&#125; 类的友元 友元是C++提供的一种破坏数据封装和数据隐藏的机制 通过将一个模块声明为另一个模块的友元，一个模块能引用到另一个模块中很是被隐藏的信息 可以使用友元函数和友元类 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元 友元函数 友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体重能够通过对象名访问private和protected成员。 作用：增加灵活性，时程序员可以在封装和快速性方面做合理的选择。 访问对象中的成员必须通过对象名 123456789101112131415161718192021222324252627#include&lt;iostram&gt;using namespace std;class CCar; //提前声明CCar类，因为后面CDriver类要前向引用class CDriver &#123; public: void ModifyCar(CCar *pCar); //改装汽车&#125;;class CCar&#123; private: int price; friend int MostExpensiveCar(CCar cars[], int total); //类外函数声明为友元函数 friend void CDriver::ModifyCar(CCar *pCar); //其他类的成员函数声明为友元函数&#125;;void CDriver::ModifyCar(CCar *pCar) //求最贵汽车的价格&#123; pCar-&gt;price += 1000; //汽车改装后价格增加&#125;int MostExpensiveCar(CCar cars[], int total)&#123; int tmpMax = -1; for (int i = 0; i &lt; total; ++i) if (cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax;&#125; 友元类 若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员 声明语法：将友元类名在另一个类中使用friend修饰说明 1234567891011121314class CCar&#123; private: int price; friend class CDriver; //声明CDriver为CCar的友元类&#125;;class CDriver &#123; public: CCar myCar; void ModifyCar()&#123; //改装汽车 myCar.price += 1000; //CDriver是CCar的友元类-&gt;可以访问其私有成price &#125; &#125;; 主要注意的是：类的友元关系是单向的： 如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数不能访问B类的私有、保护数据，即友元类的关系不能传递，不能继承。 this指针在C++刚推出的时候，编译器在编译C++程序课程时先把一段C++程序翻译成C程序，然后再用C的编译去编译。比如说我们把下面的CCar的类的C++程序翻译成C程序，class对应C中的struct结构体，而C中没有成员函数，因此需要借助this指针来实现SetPrice的功能。 C++代码： 12345678910111213class CCar &#123;public: int price; void SetPrice(int p);&#125;;void CCar::SetPrice(int p) &#123; price = p;&#125;int main() &#123; CCar car; car.SetPrice(20000); return 0;&#125; C代码： 1234567891011struct CCar &#123; int price;&#125;;void SetPrice(struct CCar *this, int p) &#123; this-&gt;price = p;&#125;int main() &#123; struct CCar car; SetPrice( &amp;car, 20000 ); return 0;&#125; this指针作用：非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针。 12345678910111213141516class Complex &#123;public: double real, imag; void Print() &#123; cout &lt;&lt; real &lt;&lt; \"+\" &lt;&lt; imag &lt;&lt; \"i\"; &#125; Complex(double r,double i):real(r),imag(i) &#123;&#125; Complex AddOne() &#123; this-&gt;real++; this-&gt;Print(); return *this &#125;&#125;;int main() &#123; Complex c1(1, 1), c2(0, 0); c2 = c1.AddOne(); //输出 2+1i return 0;&#125; 注意静态成员函数不能使用this指针，因为静态成员函数并不具体作用于某个对象。 常量const 常量对象：如果不希望某个对象的植被改变，则定义该对象时在其前面加const关键字。 常量成员函数：在类的成员函数说明后面加const关键字 常量成员函数执行期间不应该修改其作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。 若有两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载，而不是冲突定义。 常引用：引用前加const，不能通过常引用，修改其引用的变量；常引用经常作为函数的参数 当传递一个对象的效率较低（因为需要调用复制构造函数生成一个新的对象），又要确保实际参数的值不能在函数内部被修改时，可以将参数的类型声明为常引用 12345678class Rectangle&#123;public: int w, h;&#125;;int getArea(const Rectangle &amp;rect)&#123; //rect.w = rect.h + 2; 非法 return rect.w * rect.h;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"ML:Week2","slug":"ML-Week2","date":"2020-02-13T09:43:58.000Z","updated":"2020-02-15T09:43:58.000Z","comments":true,"path":"2020/02/13/ML-Week2/","link":"","permalink":"http://nekomoon404.github.io/2020/02/13/ML-Week2/","excerpt":"","text":"Multivariate Linear RegressionMultiple FeaturesLinear regression with multiple variables is also known as “multivariate linear regression”. We now introduce notation for equations where we can have any number of input variables. \\begin{align*}x_j^{(i)} &= \\text{value of feature } j \\text{ in the }i^{th}\\text{ training example} \\newline x^{(i)}& = \\text{the input (features) of the }i^{th}\\text{ training example} \\newline m &= \\text{the number of training examples} \\newline n &= \\text{the number of features} \\end{align*}The multivariable form of the hypothesis function accommodating these multiple features is as follows: h_θ(x)=θ_0+θ_1x_1+θ_2x_2+θ_3x_3+⋯+θ_nx_nIn order to develop intuition about this function, we can think about $\\theta_0$ as the basic price of a house, $\\theta_1$ as the price per square meter, $\\theta_2$ as the price per floor, etc. $x_1$ will be the number of square meters in the house, $x_2$ the number of floors, etc. Using the definition of matrix multiplication, our multivariable hypothesis function can be concisely represented as: \\begin{align*}h_\\theta(x) =\\begin{bmatrix}\\theta_0 \\hspace{2em} \\theta_1 \\hspace{2em} ... \\hspace{2em} \\theta_n\\end{bmatrix}\\begin{bmatrix}x_0 \\newline x_1 \\newline \\vdots \\newline x_n\\end{bmatrix}= \\theta^T x\\end{align*}This is a vectorization of our hypothesis function for one training example; see the lessons on vectorization to learn more. Remark: Note that for convenience reasons in this course we assume $x^{(i)}_0=1 $ for $(i\\in 1,\\dots,m)$. This allows us to do matrix operations with theta and x. Hence making the two vectors $’\\thetaθ’$ and $x^{(i)}$match each other element-wise (that is, have the same number of elements: n+1).] Gradient Descent for Multiple VariablesThe gradient descent equation itself is generally the same form; we just have to repeat it for our ‘n’ features: \\begin{align} & \\text{repeat until convergence:} \\; \\lbrace \\newline \\; & \\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_0^{(i)}\\newline \\; & \\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_1^{(i)} \\newline \\; & \\theta_2 := \\theta_2 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_2^{(i)} \\newline & \\cdots \\newline \\rbrace \\end{align}In other words: \\begin{align*}& \\text{repeat until convergence:} \\; \\lbrace \\newline \\; & \\theta_j := \\theta_j - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m} (h_\\theta(x^{(i)}) - y^{(i)}) \\cdot x_j^{(i)} \\; & \\text{for j := 0...n}\\newline \\rbrace\\end{align*}The following image compares gradient descent with one variable to gradient descent with multiple variables: Python代码示例： 计算代价函数：$J\\left( \\theta \\right)=\\frac{1}{2m}\\sum\\limits_{i=1}^{m}{\\left( h_{\\theta}\\left( x^{(i)} \\right)-y^{(i)} \\right)}^2$其中：$h_{\\theta}\\left( x \\right)=\\theta^{T}X=\\theta_{0}x_{0}+\\theta_{1}x_{1}+\\theta_{2}x_{2}+…+\\theta_{n}x_{n}$ 123def computeCost(X, y, theta): inner = np.power(((X * theta.T) - y), 2) return np.sum(inner) / (2 * len(X)) Gradient Descent in Practice I -Feature ScalingWe can speed up gradient descent by having each of our input values in roughly the same range. This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven. The way to prevent this is to modify the ranges of our input variables so that they are all roughly the same. Ideally: −1 ≤ $x_{(i)}$≤ 1 or −0.5 ≤ $x_{(i)}$ ≤ 0.5 Two techniques to help with this are feature scaling(特征缩放) and mean normalization(均值归一化). Feature scaling involves dividing the input values by the range (maximum value - minimum value) of the input variable, resulting in a new range of just 1. Mean normalization involves subtracting the average value for an input variable from the values for that input variable resulting in a new average value for the input variable of just zero. To implement both of these techniques, adjust your input values as shown in this formula: x_i:=\\frac{x_i-\\mu_i}{s_i}Where $\\mu_i$ is the average of all the values for feature (i) and $s_i$ is the range of values (max - min), or $s_i$ is the standard deviation(标准差). （量化后的特征将分布在[-1, 1]，服从标准正态分布） Gradient Descent in Practice II - Learning RateDebugging gradient descent(调试梯度下降): Make a plot with number of iterations on the x-axis. Now plot the cost function, J(θ) over the number of iterations of gradient descent. If J(θ) ever increases, then you probably need to decrease α. Automatic convergence test(自动收敛测试): Declare convergence if J(θ) decreases by less than E in one iteration, where E is some small value such as 10−3. However in practice it’s difficult to choose this threshold value It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration. To summarize: If $\\alpha$ is too small: slow convergence. If $\\alpha$ is too large: ￼may not decrease on every iteration and thus may not converge. Features and Polynomial RegressionWe can improve our features and the form of our hypothesis function in a couple different ways. We can combine multiple features into one. For example, we can combine $x_1$ and $x_2$ into a new feature $x_3$ by taking $x_1⋅x_2$. Our hypothesis function need not be linear (a straight line) if that does not fit the data well. We can change the behavior or curve of our hypothesis function by making it a quadratic, cubic or square root function (or any other form). For example, if our hypothesis function is $h_\\theta (x) = \\theta_0 + \\theta_1 x_1$ then we can create additional features based on $x_1$, to get the quadratic function $h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_1^2$ or the cubic function $h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_1^2 + \\theta_3 x_1^3$ In the cubic version, we have created new features $x_2$ and $x_3$ where $x_2 = x_1^2$ and $x_3 = x_1^3$. To make it a square root function, we could do: $h_\\theta(x) = \\theta_0 + \\theta_1 x_1 + \\theta_2 \\sqrt{x_1}$. One important thing to keep in mind is, if you choose your features this way then feature scaling becomes very important. eg. if $x_1$ has range 1 - 1000 then range of $x_1^2$ becomes 1 - 1000000 and that of $x_1^3$ becomes 1 - 1000000000 Normal EquationGradient descent gives one way of minimizing J. Let’s discuss a second way of doing so, this time performing the minimization explicitly and without resorting to an iterative algorithm. In the “Normal Equation“ (正规方程) method, we will minimize J by explicitly taking its derivatives with respect to the θj ’s, and setting them to zero: $\\frac{\\partial J\\left( \\theta \\right)}{\\partial \\theta }=0$. This allows us to find the optimum theta without iteration. The normal equation formula is given below: \\theta = (X^T X)^{-1}X^T y There is no need to do feature scaling with the normal equation. The following is a comparison of gradient descent and the normal equation: 总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数$\\theta $的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。 随着学习算法越来越复杂，例如，分类算法，像逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及特征变量的数量，这两种算法都是值得学习的。 正规方程的python实现： 1234567import numpy as np def normalEqn(X, y): theta = np.linalg.inv(X.T@X)@X.T@y #X.T@X等价于X.T.dot(X) return theta Noninvertibility(不可逆性)When implementing the normal equation in octave we want to use the pinv function rather than inv. The ‘pinv‘ function will give you a value of $\\theta$ even if $X^TX$ is not invertible. If $X^TX$ is noninvertible, the common causes might be having : Redundant features, where two features are very closely related (i.e. they are linearly dependent) Too many features (e.g. m ≤ n). In this case, delete some features or use “regularization“（正则化） (to be explained in a later lesson). Solutions to the above problems include deleting a feature that is linearly dependent with another or deleting one or more features when there are too many features. 补充：$\\theta = (X^T X)^{-1}X^T y$的 证明： 代价函数： J\\left( \\theta \\right)=\\frac{1}{2m}\\sum\\limits_{i=1}^{m}{\\left( h_{\\theta}\\left( x^{(i)} \\right)-y^{(i)} \\right)}^2其中：$h_{\\theta}\\left( x \\right)=\\theta^{T}X=\\theta_{0}x_{0}+\\theta_{1}x_{1}+\\theta_{2}x_{2}+…+\\theta_{n}x_{n}$ 将向量表达形式转为矩阵表达形式，则有$J(\\theta )=\\frac{1}{2}{\\left( X\\theta -y\\right)}^2$ ，其中$X$为$m$行$n$列的矩阵（$m$为样本个数，$n$为特征个数），$\\theta$为$n$行1列的矩阵，$y$为$m$行1列的矩阵，对$J(\\theta )$进行如下变换 \\begin{align}J(\\theta )&=\\frac{1}{2}{\\left( X\\theta -y\\right)}^{T}\\left( X\\theta -y \\right) \\\\ &=\\frac{1}{2}\\left( {\\theta }^{T}{X^T}-{y}^{T} \\right)\\left(X\\theta -y \\right)\\\\&=\\frac{1}{2}\\left( {\\theta }^T{X}^{T}X\\theta -{\\theta}^{T}{X}^{T}y-{y}^{T}X\\theta -{y}^{T}y \\right) \\end{align}接下来对$J(\\theta )$偏导，需要用到以下几个矩阵的求导法则 \\begin{align} \\frac{dAB}{dB}&={A^T}\\\\\\frac{dX^TAX}{dX}&=2AX \\end{align}所以有: \\begin{align} \\frac{\\partial J\\left( \\theta \\right)}{\\partial \\theta }&=\\frac{1}{2}\\left(2{X^T}X\\theta -{X^T}y -({y^T}X )^{T}-0 \\right)\\\\&=\\frac{1}{2}\\left(2{X^T}X\\theta -{X^T}y -{X^T}y -0 \\right)\\\\&={X^T}X\\theta -{X^T}y \\end{align}令：$\\frac{\\partial J\\left( \\theta \\right)}{\\partial \\theta }=0$ 则有：$\\theta =\\left( X^{T}X \\right)^{-1}{X^T}y$。 ———————————————————————————————————————————————— PS：Week2的第三部分是Octave语言教程，看了一遍视频发现Octave的语法和Matlab基本是一样的，有很方便的矩阵运算，而且Octave是完全开源的，但正版的Matlab确实很贵，这大概也是老师这门课用Octave的原因之一吧。（Andrew Ng 永远滴神！）","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://nekomoon404.github.io/categories/Machine-Learning/"}],"tags":[]},{"title":"数据结构与算法（4）气泡排序与归并排序","slug":"数据结构与算法（4）气泡排序与归并排序","date":"2020-02-12T12:45:52.000Z","updated":"2020-02-13T12:45:52.000Z","comments":true,"path":"2020/02/12/数据结构与算法（4）气泡排序与归并排序/","link":"","permalink":"http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"通过之前的两篇文章我们可以知道有序向量相对于无序向量有着更多的优势，比如它的去重操作以及查找操作都可以更快速地完成，然而我们遗留下一个问题，就是如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法，即起泡算法与归并算法。 排序器：统一接口1234567891011template &lt;typename T&gt; void Vector&lt;T&gt;::sort ( Rank lo, Rank hi ) &#123; //向量区间[lo, hi)排序 switch ( rand() % 6 ) &#123; case 1: bubbleSort ( lo, hi ); break; //起泡排序 case 2: selectionSort ( lo, hi ); break; //选择排序（习题） case 3: mergeSort ( lo, hi ); break; //归并排序 case 4: heapSort ( lo, hi ); break; //堆排序（第12章） case 5: quickSort ( lo, hi ); break; //快速排序（第14章） default: shellSort ( lo, hi ); break; //希尔排序（第14章） &#125; //随机选择算法以充分测试。实用时可视具体问题的特点灵活确定或扩充&#125; 起泡排序1234567template &lt;typename T&gt; //向量的起泡排序（基本版）void Vector&lt;T&gt;::bubbleSort( Rank lo, Rank hi ) &#123; //assert: 0 &lt;= lo &lt; hi &lt;= size while( lo &lt; --hi ) //反复起泡扫描 for( Rank i = lo; i &lt; hi; i++ ) //逐个检查相邻元素 if( _elem[i] &gt; _elem[i + 1] ) //若逆序，则 swap( _elem[i], _elem[i + 1] ); //经交换使局部有序&#125; 在第一章曾以这个算法为例介绍过如何证明算法的正确性，这里按照刚才统一定义的形式将它整理为一个名为bubbleSort的算法接口。这个算法实际上可以认为是通过调用一个名为bubble的过程迭代地来进行，在每一迭代过程中都会考察当前介于lo和hi之间的所有相邻元素，只要有一对相邻元素是逆序的，就将它们交换，所以整个这样的一个过程也称作扫描交换。 这个算法的不变法具体来说，如果最初的这个向量是一个无序向量的话，那么每经过这样一趟对bubble的调用都会有一个新的元素就位，比如对于第一次而言就是全局最大的那个元素，这里用红色来表示就位的元素，那么当然互补地其它的部分也就是接下来要考察的问题的范围，就会相应地缩小一个单元，这也是减而治之。再接下来有序的部分会继续地拓展，而无序的部分会继续地缩减，整个呈现为一个不断此消绿色的这部分，和彼涨红色的这部分这样一个过程，直到无序的部分只剩下一个元素。 不难看出每一趟对bubble的调用所需要的时间都线性正比于绿色无序部分的宽度，整体地呈现为一个算术级数的形式，所以它的总体量与它的末项成平方关系，即$O(n^2)$。然而我们并不满足于这样的结果，至少在很多情况下都是有可能改进的。 改进可以看到这里的红色部分确实必然是有序的，但是绿色的部分未必都是无序的，事实上比如这个时候有可能其中会有一部分元素，甚至所有的元素都是有序的。那么如何尽早地判定出这种情况，从而提前结束这个算法呢？这里依赖的准则与算法最初的判定准则是一样的，也就是一个向量包括一个区间如果是完全有序的，当且仅当其中任何一对相邻的元素都是彼此顺序的，而实际上在刚刚进行完的前一次迭代中我们在某种意义上已经做过这种类似的检查了。 由此可以得出一个改进的策略：在每一次扫描交换的过程中不妨记录一下是否曾经真的存在逆序元素，如果存在的话它的充要条件是在此前做过一次交换，所以我们只要来记录一下在当下这趟扫描交换过程中是否曾经做过至少一次扫描交换，如果没有做过那么后续的各趟其实都可以省略掉，从而在实际的运行时间上有可能会有所减少，甚至大大减少。这是一个很好的策略，我们不妨把这个策略整理为下面的一段代码。 123456789101112template&lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while (!bubble(lo, hi--));&#125; //逐趟做扫描交换，直至全序template&lt;typename T&gt; void Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; bool sorted = ture; //整体有序标志 while(++lo &lt; hi)&#123; //自左向右，逐一检查各相邻元素 if (_elem[lo - 1] &gt; _elem[lo]) &#123; //若逆序，则 sorted = false; //意味着尚未整体有序，并需要 swap(_elem[lo - 1], _elem[lo]); //交换 &#125; return sorted; //返回有序标志&#125; 原算法整体运行时间确实可以度量为一个三角形的面积，那么对于新的改进的这个算法，它固然要做第一趟扫描交换也许还需进行若干次扫描交换，但是在某些情况下它有可能会发现不光此后的部分已经有序了，而且这个前缀也已经完全有序了，所以这时它就会及时地跳转到最后，聪明地绕过这些完全可以绕过的计算量。因此与刚才那样对比新的这个算法所执行的计算量可以度量为这样一个梯形，而不是原来的三角形，也就是说很多情况下都可以节省一定的甚至是相当多的时间。不过我们对这个算法的改进并不满足于此因为我们发现在一些其它或者说在更多的情况下，这个算法依然存在继续改进的空间。 再改进考察这样一个向量，假设它可以分为长度相差悬殊的一个前缀以及后缀，而且后缀中的元素都已按顺序排列并严格地就位，当然相应地所有的乱序元素都集中分布于这样一个相对更短的前缀中。对于这样的一个实例，上节中已经做过优化的起泡排序算法会如何表现呢？ 首先它需要做第一趟完整地扫描交换，并且确认在最后这个位置有一个元素就位，虽然它原本就是就位的。请注意虽然这个时候在这个后缀中，存在着大量的就位元素，但因为在前缀中刚才存在交换，bubble算法会返回false，那么算法接下来还会继续下去。尽管能够判定的就位元素数目会继续增加，但是与刚才同理，我们依然不能确认可以提前退出，接下来还需要进行若干次的扫描交换。那么对于这样的一个例子，总体而言需要的扫描交换的趟数不会超过这个前缀的长度r。 因为此前所做的各趟扫描交换，与其说是在对绿色的范围做处理，不如说实际影响的是这个前缀中的倒数第一个倒数第二个 以及倒数第三个，即是在这个前缀中后面的那些元素。每一趟扫描交换所起的实质作用无非是在这样一个前缀中，令其中的一个一个的后缀元素依次就位，直到整个这个前缀中的元素完全就位。 因此这个算法总体消耗的时间应该是n乘以r，如果r取作根号n，相应地也就是n的1.5次方，即$O(n^{1.5})$。但如果能及时地检测出这样一种情况，也就是实质需要排序的元素集中在一个宽度仅为$\\sqrt{n}$的区间中，而不是整个向量。那么即使套用最原始的起泡排序算法，所需要的时间也无非是$O((\\sqrt{n})^2)=O(n)$。问题是如何才能够完成从1.5次方到一次方的优化转换呢？ 重新审视上面的例子，所多余出来的时间消耗无非是在后缀中，对这些已就位元素的反复扫描交换，不难理解这些元素都是不必扫描交换的，可惜此前的算法版本未能及时地将它们分解出来，但它们实际上是可以分解出来的。 比如说如果我们通过某一种方法记录在上一趟扫描交换过程中所进行的最后一次交换，就很容易确定在上一趟扫描的区间中有一个多长的后缀实际上没有做过任何交换，也就是说它们中的元素都是已经就位了的。如果能这样只需要将原先的右侧标志hi直接地指向这个新的位置，而不是像刚才那样亦步亦趋地、逐个地收缩。 基于以上的分析不难得到下面的新的改进的方法，从结构上看跟刚才大体类似，依然是逐个地检查所有的相邻对，如果是逆序的就做交换，不同之处在于这里我们所记录的不再只是一个逻辑性变量，而是一个名为last的整型或者说是秩，它的初值是取作lo，而每当需要交换就将这个last更新为新的位置。在整个算法的过程中lo这个变量是持续递增的，所以当它在返回的时候，last确实名副其实地记录了最右侧也就是最后一对逆序对的位置。 123456789101112template&lt;typename T&gt; void Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123; while (!bubble(lo, hi--));&#125; //逐趟做扫描交换，直至全序template&lt;typename T&gt; void Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123; Rank last = lo; //最右侧的逆序对初始化为[lo-1, lo] while(++lo &lt; hi)&#123; //自左向右，逐一检查各相邻元素 if (_elem[lo - 1] &gt; _elem[lo]) &#123; //若逆序，则 last = lo; //更新最右侧逆序对位置记录，并 swap(_elem[lo - 1], _elem[lo]); //交换 &#125; return last; //返回有序标志&#125; //前一版本中的逻辑型标志sorted，改为秩last 这样我们就可以有效地来处理刚才那种情况，回到刚才那个实例，我们构造了一个足够短的乱序前缀再加一个非常长但是已经就绪了的后缀。新的算法首先也会做一趟扫描交换，当然为此花费的时间是$O(n)$。但是与刚才那个版本的不同，在这个时候它会检测出发生的最后一次扫描交换绝对不会超过绿色末尾的位置，将扫描交换的右侧界桩hi一次性地挪到那里，这等效于判断出了此后的这些元素包括最后那个元素都是已经就位的。 从算法的流程来说我们的下一趟扫描交换的区间，就不再是原先整个那个绿色的区间，而是相对要短很多的一个区间。接下来等效于只是对这样一段区间做扫描交换，因此需要花费的时间除了刚才的$O(n)$以外，主要是对应于这样的一个更小的三角形，如果边长是$\\sqrt{n}$，累计也不过是再加上一个$O(n)$，与刚才的$O(n)$合并，总体不过是$O(n)$，更有意思的是这种情况在整个排序过程中有可能会多次出现。 我们也可以通过图形的方式，形象地将新的这个算法版本与之前的原始版本在时间效率上做一个对比。这个三角形 代表的是原始的起泡排序算法所需要的时间。新版本的算法所需要执行的扫描交换将会呈现为连续的一段。然后再间或地跳跃到下面一段以及再间或地有可能会跳跃到下面一段（深色部分）。换而言之这个算法的时间成本将取决于这样一个一个若干个梯形的面积总和，相对于此前那个梯形来说这种梯形的划分更加的精细，所以它节省下来的时间也会在通常的情况下相对更多。 当然在最坏的情况下这个算法依然是于事无补的，起泡排序依然注定需要$O(n^2)$的时间。 综合评价 三种起泡排序在最好和最坏情况下的效率相同：最好$O(n)$，最坏$O(n^2)$ 输入含重复元素时，算法的稳定性（stability）是更为细致的要求 重复元素在输入，输出序列中的相对次序，是否保持不变？（在某些问题中很敏感） ​ 输入：$6,7_a,3,2,7_b,1,5,8,7_c,4$ ​ 输出：$1,2,3,4,5,6,7_a,7_b,7_c,8$ //stable ​ $1,2,3,4,5,6,7_a,7_c,7_b,8$ //unstable 三种起泡排序算法都是稳定的，因为在起泡排序中，元素$7_a$和$7_b$的相对位置发生变化，只有一种可能： ​ 经分别与其他元素的交换，二者相互接近直至相邻 ​ 在接下来一轮扫描交换中，二者因逆序而交换位置 而起泡排序中交换，即if的判断条件是_elem[lo - 1] &gt; _elem[lo])，严格大于，因此不会出现上面的情况 虽然起泡排序可以做大量的改进，但从最坏情况而言它依然是注定也需要$O(n^2)$的时间，所以我们非常希望能够得到一个即便在最坏情况下也能够效率更高的排序算法，这也就是下一节所要介绍的内容。 归并排序采用包括Bubble sort在内的常规的基于比较式的算法（Comparison Based Algorithm），求解排序问题都存在一个下界$nlogn$。那么在$n^2$的上界到$nlogn$的下界之间是否存在一些其它的，相对于$n^2$而言更好的算法,甚至于是否有一个算法即使在最坏的情况下也只需要$nlogn$的时间就能完成排序呢？答案就蕴含在这一节的主题里也就是归并排序（Merge Sort）。 归并排序算法是分治策略在算法设计中应用的又一个典型，这个算法最初是由冯·诺依曼编码实现的，所谓的分治策略在这里就是说将待排序的那个序列（向量或者列表）一分为二，这种分法很快捷只需要$O(1)$的时间，接下来 对于划分出的两个子序列分别去做递归地求解，也就是递归地排序。而当两个子序列已经分别有序之后，我们接下来要解决的一个问题就是将它们合并准确地讲是归并merge，从而构成一个完整的有序序列。 对于上面这样一个由8个元素组成的向量，首先是分沿左右划分为左和右两个子序列，这两个子序列递归地求解的过程中依然还是相对比较大，所以它们会继续递归地、各自地进行划分继续分为左左、左右以及右左和右右四个子序列。同样 它们还是不够平凡所以我们最后还要对这四个子序列继续地一分为二，最终八个元素各自成为一个独立的序列，这个时候从递归地角度讲就抵达了递归基，所有这些元素都已经不需要再继续划分下去了，因为它们各自有序了。 所以如果说前面半层是做无序向量的递归分解，接下来就要通过逐层的合并使之逐渐地变成一个大一点的，更大一点的，直到最后那个有序的序列。我们可以看到每一次都是将两个已经是有序的子序列合并为一个有序的子序列，然后再继续相邻的子序列逐对地合并构成再更大的序列，最后左右这两个各自有序的子序列再逐对地合并最终得到整体的序列。 那么如果果真能像这里所说的那样，我们就应该能够得到一个总体是$nlogn$的算法，可由下面的递推式证明，其中$O(n)$是分与并累计的时间。 T(n)=2\\cdot T(n/2)+O(n)可以得到：$T(n)=O(nlogn)$。 接下来的技术细节就是如何来兑现这一点呢？可以看到从这里的划分的过程是非常简单，递归也可以交给递归的机制去做，所以这里核心的任务是在怎么进行合并，或者准确地讲是怎么将两个已经有序的序列归并成一个更大的序列，这也是这个算法最关键的细节和技巧。 主算法把刚才的思路实现为这样一段具体的代码，和所有的递归程序一样首先要处理递归基，接下来开始实质的分也就是除二取到中点，这样的话我们可以将整体的一个序列分成左和右两部分，分别由lo和mi，以及mi和hi来界定。对于这两个序列，分别是递归调用自己，mergeSort前一个序列，mergeSort后一个序列。接下来最重要的实质的工作是在merge，下面不妨来通过一个实例来理解merge算法的原理 12345678template &lt;typename T&gt; //向量归并排序void Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; //0 &lt;= lo &lt; hi &lt;= size if ( hi - lo &lt; 2 ) return; //单元素区间自然有序，否则... int mi = ( lo + hi ) / 2; //以中点为界 mergeSort ( lo, mi ); mergeSort ( mi, hi ); //分别排序 merge ( lo, mi, hi ); //归并&#125; 原理 2-way merge：将两个有序序列合并为一个有序序列 S[lo, hi) = S[lo, mi) + S[mi, hi) 首先（a）图给出了两个各自有序的子序列，二路归并算法的要诀就是我们只需要把注意力关注在这两个序列的首元素上，这样一个虚线的方框是我们的关注焦点，其余的元素可以暂时不用顾及。那么我们取出这两个序列各自的首元素的时候，都要从中挑选出更小的那个元素，如果是两者相等的话，可以任意取一个。比如 就这个例子而言 就这个例子而言首先取出的是这个2，我们将它择出来，相应地在摘除了首元素以后，后续的元素将逐次递补，也就是关注到新顶替上来的这个首元素上。同样在接下来的一轮比对中，我们考察这两个首元素的大小，并且同样地取出其中的更小的那个，4依然比5小所以4被取出，同样它的后继们会顶替上来对这个例子而言就是10。就这样逐步进行到图（h），直到最终一旦有一个向量已经变成空的，那么另一个向量所剩余的元素无论多少都直接串接在后边（因为剩余那部分必然是有序的）。 按照这样的原理，我们确实可以得到一个更大的单调序列，这种二路归并的算法实际上是非常通用的一个版本，但在这里针对于归并排序而言的，我们实际上用到的是其中的一种特例，在这个时候参与归并的两个序列实际上是来自于同一个更大的向量，只不过是由其中的三个界桩也就是lo、mi和hi来联合定义的。如果左侧的这个向量称作B，右侧的称作C的话，那么合并起来的整体的这个向量就是A。那下一小节介绍针对这样一种特殊情况，二路归并算法应该如何实现。 实现1234567891011121314template &lt;typename T&gt; //有序向量（区间）的归并void Vector&lt;T&gt;::merge ( Rank lo, Rank mi, Rank hi )&#123;//各自有序的子向量[lo, mi)和[mi, hi) T* A = _elem + lo; //合并后的向量A[0, hi - lo) = _elem[lo, hi) int lb = mi - lo; T* B = new T[lb]; //前子向量B[0, lb) = _elem[lo, mi) for ( Rank i = 0; i &lt; lb; i++ ) B[i] = A[i]; //复制前子向量 int lc = hi - mi; T* C = _elem + mi; //后子向量C[0, lc) = _elem[mi, hi) for (Rank i = 0, j = 0, k = 0; (j &lt; lb) || (k &lt; lc); ) &#123; if ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) A[i++] = B[j++]; //B更小，C[k]已无或不小 if ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt; B[j]))) A[i++] = C[k++]; //C更小，或B[j]已无或更大 &#125; //该循环实现紧凑；但就效率而言，不如拆分处理 delete [] B; //释放临时空间B&#125; 解读一下上面的代码：首先需要将定义两个向量的三个界桩也就是lo、mi和hi作为参数传入，接下来要定义清楚ABC三个向量：首先A向量在这里将继续地保存在它输入的位置，准确地讲就是在_elem整个数据区中起自于最左侧的界桩lo的一段区间，可以直接令A指向这个区间的起点。 1T* A = _elem + lo; //合并后的向量A[0, hi - lo) = _elem[lo, hi) 接下来是左侧的子向量B，我们需要为这个子向量申请一段空间，它的宽度应该是mi到lo之间的距离，当然还需要将A中对应的那些元素，也就是左半部分的那些元素，逐一地取出来并且复制到新开辟的这段空间中去，从而完成整体的这个子向量B的一个缓冲。 12int lb = mi - lo; T* B = new T[lb]; //前子向量B[0, lb) = _elem[lo, mi)for ( Rank i = 0; i &lt; lb; i++ ) B[i] = A[i]; //复制前子向量 最后是C，C非常的简单，实际上定义的就是在_elem数据区中，起始于mi的这段数据，那么不同的在于右侧的子向量C并不需要另辟空间进行缓存，尽管在这里为了说明的方便，还是将它画在了上边作为一个单独的子向量。 1int lc = hi - mi; T* C = _elem + mi; //后子向量C[0, lc) = _elem[mi, hi) 接下来就是最主要的这个循环，这也就是上节实例子所给的过程，具体来讲就是每一次我们都比较两个子向量当前的首元素取出其中更小的那个，比如说在for循环体中上面一句的情况下B更小，而在下面一句的情况下C更小，无论谁更小都把它转入到A中去。B和C首元素是由j和k这两个秩来标定的，在最初始的情况下它们都是0，分别指向B和C的第一个元素，在随后 每当有一个元素转移到A中，它们各自都会自加，从而指向下一个替补的新的首元素。而A每次纳入新元素由i指示，其初值也是0。 123456for (Rank i = 0, j = 0, k = 0; (j &lt; lb) || (k &lt; lc); ) &#123; if ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) A[i++] = B[j++]; //B更小，C[k]已无或不小 if ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt; B[j]))) A[i++] = C[k++]; //C更小，或B[j]已无或更大 &#125; 当B更小的情况：严格来讲是由一系列的逻辑判断构成的，首先是一个and，我们要确定j &lt; lb，即B中的首元素的秩应该至少没有越过它的右侧的边界，它还是合法的，也就是B[j]指向的还是一个实在的而不是虚拟的元素，接下来地有两种情况，要么C中的k已经越界，要么就是k没有越界，但是B[j]更小B[j] &lt;= C[k]，这里我们运用了C++语言里头的“短路求值”的语法特性，否则在不满足的情况下还去进行比较求值，实际上这个k因为已经越界就会造成程序运行过程中的错误。当C更小的情况也是同理。 当然整个这个循环的退出条件也值得揣摩的，这里的条件(j &lt; lb) || (k &lt; lc)可以理解为是这两个位置j和k同时越界之后算法才会退出，而在这个时候无论是B还是C中的元素都已经完整地归入到了A中，成为了一个整体的序列。 正确性为了更好地理解算法的过程，我们不妨分几种情况来给出具体的图示作进一步解释。 首先来考虑第一种情况（a)，i还是介于lo和mi之间没有越过mi这个界线，还没有进入到C这个子向量的范围，这种情况显然i不可能居于j的左侧，顶多是平齐，所以每次迭代中如果需要发生数据转移的话，无论是B[j]转移到A[i]，还是C[k]转移到A[i]，整个数据从内容来讲都不会发生覆盖，是安全的，功能上讲也是正确的。 再来看相对复杂一点的情况(b)，也就是当i在持续增加之后，终会越过mi，进入C的区域。表面看这样会侵犯到C的区域，但实际上不要紧，因为在这个时候k绝对不会位于i的左侧，所以介于mi和i之间的这些元素，其实作为C中原来的元素必然已经归入到A中，当然是它的左侧在i之前的这部分中的某一个适当的位置。所以这种情况依然是安全的，无论是C[k]、还是B[j]转移到A[i]中去，都不会导致C中已有的元素被无意中覆盖掉，从而导致错误。 再来看最后两种更为复杂的情况，如图（c），B这个子向量已经提前耗尽，它其中的元素已经完全地归入到A中当然也是就位了，而在C中还残存有部分的元素没有转移和就位。这种情况下我们的逻辑其实相当于等效地是在B的最右侧，就是lb这个位置上增加了一个哨兵节点，而且它的数值就是正无穷。因此即便C的右侧还残存有若干个元素它们也会在接下来的各次迭代中，因为是与这样一个正无穷相比而被认为是更小，从而顺利地转移到A中适当的位置，直到两个子向量都同时耗尽。 反过来另一种对称的情况（d）就是C也可能会提前耗尽，也相当于等效地 在C的最右侧增加了一个数值为正无穷的哨兵，它的秩是lc，所以即便在B的尾部 还残存有部分的元素也不要紧，它们也等效于和这样一个数值为正无穷的哨兵相比，总是会被认为是更小，所以按照算法的逻辑会等效地转移到A中剩余的对应区域中去，整个这个过程也是会顺利地进行，不会出现我们所说的数据遗漏或者数据被无意中覆盖。 需要注意的是（c）和（d）这两种情况其实并不对等，因为按照这里的设计，其实向量C和B地位本来就是不等的。B是完全复制出来的一个缓冲部分，而C虽然是独立的绘制出来但实际上它就在A中，占据右端，换而言之如果是C提前耗尽，我们确实需要把B尾部的这些元素悉数转移到A的尾部，但如果是B提前耗尽那么对C尾部这些元素的转移其实都是多余的，因为它们原来就在那，完全没有必要。注意到这样一个现象的话，我们就不难对刚才表面上很规范的逻辑进一步的精简： 123456for (Rank i = 0, j = 0, k = 0; j &lt; lb; ) &#123; if ( lc &lt;= k || (B[j] &lt;= C[k]) ) A[i++] = B[j++]; //B更小，C[k]已无或不小 if ((k &lt; lc) &amp;&amp; (C[k] &lt; B[j]) ) A[i++] = C[k++]; //C更小，或B[j]已无或更大 &#125; 这里最重要的改进就是并不需要考虑C提前耗尽的那种情况，我们只需要考虑B提前耗尽的情况，一旦B提前耗尽我们就可以直接终止这个循环包括这个算法，这样可以使这个算法效率进一步的提高，尽管不是从渐进角度而言的一种实质的提高。 那么这个算法在原来以及包括这样精简之后，从渐进意义上讲 复杂度是多少呢？是否能像我们最初所预期的那样能够有大幅度的提高呢？ 复杂度 算法的运行时间主要消耗于for循环，共有两个控制变量 ​ 初始：j = 0, k = 0 ​ 最终：j = lb, k = lc ​ 亦即：j + k = lb + lc =hi - lo = n 观察：每经过一次迭代，j和k中至少有一个会加一（j + k 也至少加一） 故知：merge()总体迭代不过$O(n)$次，累计只需线性时间 这一结论与排序算法的$\\Omega(nlogn)$下界并不矛盾——毕竟这里的B和C均已各自有序 归并算法在最坏情况下的复杂度：$T(n)=2\\cdot T(n/2)+O(n)$ ——&gt;$T(n)=O(nlogn)$ 注意：待归并子序列不必等长 亦即：允许lb $\\ne$ lc，mi $\\ne$ (lo + hi) / 2 实际上，这一算法及结论也适用于另一类序列——列表","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"ML:Week1","slug":"ML-Week1","date":"2020-02-11T02:15:57.000Z","updated":"2020-02-13T02:15:57.000Z","comments":true,"path":"2020/02/11/ML-Week1/","link":"","permalink":"http://nekomoon404.github.io/2020/02/11/ML-Week1/","excerpt":"","text":"IntroductionWhat is Machine LearningTwo definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition. Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.” Example: playing checkers. E = the experience of playing many games of checkers T = the task of playing checkers. P = the probability that the program will win the next game. In general, any machine learning problem can be assigned to one of two broad classifications: Supervised learning and Unsupervised learning. Supervised LearningIn supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output. Supervised learning problems are categorized into “regression“ and “classification“ problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories. Example 1: Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem. We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories. Example 2: (a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture (b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign. Unsupervised LearningUnsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables. We can derive this structure by clustering the data based on relationships among the variables in the data. With unsupervised learning there is no feedback based on the prediction results. Example: Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on. Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party). Model and Cost FunctionModel RepresentationTo establish notation for future use, we’ll use $x^{(i)}$to denote the “input” variables (living area in this example), also called input features, and $y^{(i)}$ to denote the “output” or target variable that we are trying to predict (price). A pair $(x^{(i)} , y^{(i)} )$ is called a training example, and the dataset that we’ll be using to learn—a list of m training examples $(x^{(i)},y^{(i)});i=1,…, m$—is called a training set. Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ. To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a hypothesis. Seen pictorially, the process is therefore like this: When the target variable that we’re trying to predict is continuous, such as in our housing example, we call the learning problem a regression problem. When y can take on only a small number of discrete values (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a classification problem. Cost FunctionWe can measure the accuracy of our hypothesis function by using a cost function. This takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s. J(\\theta_0, \\theta_1) = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left ( \\hat{y}_{i}- y_{i} \\right)^2 = \\dfrac {1}{2m} \\displaystyle \\sum _{i=1}^m \\left (h_\\theta (x_{i}) - y_{i} \\right)^2To break it apart, it is $\\frac{1}{2} \\bar{x}$， where\\bar{x}$$ is the mean of the squares of $h_\\theta (x_{i}) - y_{i}$, or the difference between the predicted value and the actual value. This function is otherwise called the “Squared error function“, or “Mean squared error“. The mean is halved $\\left(\\frac{1}{2}\\right) $as a convenience for the computation of the gradient descent, as the derivative term of the square function will cancel out the$ \\frac{1}{2}$ term. The following image summarizes what the cost function does: Intuition 1If we try to think of it in visual terms, our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by $h_\\theta(x)$) which passes through these scattered data points. Our objective is to get the best possible line. The best possible line will be such so that the average squared vertical distances of the scattered points from the line will be the least. Ideally, the line should pass through all the points of our training data set. In such a case, the value of $J(\\theta_0, \\theta_1)$will be 0. The following example shows the ideal situation where we have a cost function of 0. When $\\theta_1 = 1$, we get a slope of 1 which goes through every single data point in our model. Conversely, when $\\theta_1 = 0.5$, we see the vertical distance from our fit to the data points increase. This increases our cost function to 0.58. Plotting several other points yields to the following graph: Thus as a goal, we should try to minimize the cost function. In this case, $\\theta_1 = 1$=1 is our global minimum. Intuition 2A contour plot（等高线，轮廓线） is a graph that contains many contour lines. A contour line of a two variable function has a constant value at all points of the same line. An example of such a graph is the one to the right below. Taking any color and going along the ‘circle’, one would expect to get the same value of the cost function. For example, the three green points found on the green line above have the same value for $J(\\theta_0,\\theta_1)$ and as a result, they are found along the same line. The circled x displays the value of the cost function for the graph on the left when $\\theta_0$ = 800 and $\\theta_1$= -0.15. Taking another h(x) and plotting its contour plot, one gets the following graphs: When $\\theta_0$ = 360 and $\\theta_1$ = 0, the value of $J(\\theta_0,\\theta_1)$ in the contour plot gets closer to the center thus reducing the cost function error. Now giving our hypothesis function a slightly positive slope results in a better fit of the data. The graph above minimizes the cost function as much as possible and consequently, the result of $\\theta_1$ and $\\theta_0$ tend to be around 0.12 and 250 respectively. Plotting those values on our graph to the right seems to put our point in the center of the inner most ‘circle’. Parameter LearningGradient DescentSo we have our hypothesis function and we have a way of measuring how well it fits into the data. Now we need to estimate the parameters in the hypothesis function. That’s where gradient descent comes in. Imagine that we graph our hypothesis function based on its fields $\\theta_0$ and $\\theta_1$ (actually we are graphing the cost function as a function of the parameter estimates). We are not graphing x and y itself, but the parameter range of our hypothesis function and the cost resulting from selecting a particular set of parameters. We put $\\theta_0$ on the x axis and $\\theta_1$ on the y axis, with the cost function on the vertical z axis. The points on our graph will be the result of the cost function using our hypothesis with those specific theta parameters. The graph below depicts such a setup. We will know that we have succeeded when our cost function is at the very bottom of the pits in our graph, i.e. when its value is the minimum. The red arrows show the minimum points in the graph. The way we do this is by taking the derivative (the tangential line to a function) of our cost function. The slope of the tangent is the derivative at that point and it will give us a direction to move towards. We make steps down the cost function in the direction with the steepest descent. The size of each step is determined by the parameter α, which is called the learning rate. For example, the distance between each ‘star’ in the graph above represents a step determined by our parameter α. A smaller α would result in a smaller step and a larger α results in a larger step. The direction in which the step is taken is determined by the partial derivative of J(\\theta_0,\\theta_1)J(θ0,θ1). Depending on where one starts on the graph, one could end up at different points. The image above shows us two different starting points that end up in two different places. The gradient descent algorithm is: repeat until convergence: \\theta_j := \\theta_j - \\alpha \\frac{\\partial}{\\partial \\theta_j} J(\\theta_0, \\theta_1)where $j=0,1$ represents the feature index number. At each iteration j, one should simultaneously update the parameters $\\theta_1, \\theta_2,…,\\theta_n$. Updating a specific parameter prior to calculating another one on the $j^{(th)}$ iteration would yield to a wrong implementation. IntuitionIn this part we explored the scenario where we used one parameter $\\theta_1$ and plotted its cost function to implement a gradient descent. Our formula for a single parameter was : Repeat until convergence: \\theta_1 := \\theta_1 - \\alpha \\frac{\\partial}{\\partial \\theta_1} J(\\theta_1)Regardless of the slope’s sign for $\\frac{d}{d\\theta_1} J(\\theta_1)$, $\\theta_1$ eventually converges to its minimum value. The following graph shows that when the slope is negative, the value of $\\theta_1$ increases and when it is positive, the value of $\\theta_1$ decreases. On a side note, we should adjust our parameter $\\alpha$ to ensure that the gradient descent algorithm converges in a reasonable time. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong. How does gradient descent converge with a fixed step size $\\alpha$? The intuition behind the convergence is that $\\frac{d}{d\\theta_1} J(\\theta_1)$ approaches 0 as we approach the bottom of our convex function. At the minimum, the derivative will always be 0 and thus we get: \\theta_1 := \\theta_1 - \\alpha*0 Gradient Descent For Linear RegressionWhen specifically applied to the case of linear regression, a new form of the gradient descent equation can be derived. We can substitute our actual cost function and our actual hypothesis function and modify the equation to : Repeat until convergence: \\begin{align*} & \\newline \\theta_0 := & \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}(h_\\theta(x_{i}) - y_{i}) \\newline \\theta_1 := & \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{m}\\left((h_\\theta(x_{i}) - y_{i}) x_{i}\\right) \\newline & \\end{align*}where m is the size of the training set, $\\theta_0$ a constant that will be changing simultaneously with $\\theta_1$ and $x_i$, $y_i$ are values of the given training set (data). The point of all this is that if we start with a guess for our hypothesis and then repeatedly apply these gradient descent equations, our hypothesis will become more and more accurate. So, this is simply gradient descent on the original cost function J. This method looks at every example in the entire training set on every step, and is called batch gradient descent. Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have posed here for linear regression has only one global, and no other local, optima; thus gradient descent always converges (assuming the learning rate α is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function. The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (48,30). The x’s in the figure (joined by straight lines) mark the successive values of θ that gradient descent went through as it converged to its minimum.","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://nekomoon404.github.io/categories/Machine-Learning/"}],"tags":[]},{"title":"数据结构与算法（3）有序向量","slug":"数据结构与算法（3）有序向量","date":"2020-02-10T02:58:38.000Z","updated":"2020-02-12T02:58:38.000Z","comments":true,"path":"2020/02/10/数据结构与算法（3）有序向量/","link":"","permalink":"http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/","excerpt":"","text":"唯一化有序向量是相对于无序向量而言，无序向量要求元素之间至少应该能比较是否相等，我们称作比对操作；而有序向量更为复杂，它需要能够判定任何一对元素孰大孰小，这叫作比较操作。元素之间可以相互比较只是有序向量的一个必要条件，如果要成为一个真正的有序向量，还必须要求其中的元素确实是按照顺序排列的，因此就存在一个如何甄别一个向量是否有序的问题。 有序性及其甄别 与起泡排序算法的理解相同： ​ 有序序列中，任意一对相邻元素顺序；无序序列中，总有一对相邻元素逆序。 因此，逆序相邻元素的数目，可用以度量向量的逆序程度。 无序向量经预处理转换为有序向量之后，相关算法多可优化。 1234567template &lt;typename T&gt; //返回逆序相邻元素对的总数int Vector&lt;T&gt;::disordered() const &#123; int n = 0; //计数器 for (int i = 1; i &lt; _sizei++) //逐一检查各对相邻元素 n += (_elem[i - 1] &gt; _elem[i]); //逆序则计数 return n; //向量有序当且仅当 n = 0&#125; //若只需判断是否有序，则首次遇到逆序对之后，即可立即终止 根据上面的分析可以知道，一个向量是有序的，当且仅当经过disordered()判断以后返回的值是零。实际上只要向量中的元素本身是支持大小比较的，就有一定的办法将它转化为有序向量。其中的原因在于经过这样的一个转换以后虽然我们花费了一定的成本，但此后涉及到的很多操作也就是相关算法，大多都可以优化，相应地所得要远远比转换时所花费的成本大的多。 低效算法上一篇文章介绍了无序向量的去重操作，现在我们希望把这种去重操作推广到有序向量，即将一个有序向量中的重复元素（如果存在）全部剔除掉，同样地每一组重复元素只保留一个副本。有序向量其实相对于无序向量而言，具有更好的规范性。这种规范性是指在有序向量中，彼此重复的元素必然会依次相互紧邻地构成一个一个的区间，比如就下图中的例子而言，这些元素相互重复，它们彼此紧邻，会紧密地排列成一个区间，其它元素也有这种规律。所以既然我们需要从每一组元素中保留一个副本，等价于从其中找出一个代表并且保留下来。 具体到一个算法，可以大致用一个线性扫描过程来描述：每次都观察并比对一对相邻的元素，如果二者相等就将后者删除掉，并且继续比较，如果后者还相等就把它继续删除掉，直到遇到一个不相重复的元素，这个时候我们才把注意力后移，再去考虑下一对紧邻的元素，如果依然出现这种情况再删除，直到又转到下一对。这样确实可以顺利地把所有重复的元素都剔除掉，但是不倾向与使用，因为其效率低。 12345678template &lt;typename T&gt;int Vector&lt;T&gt;::uniquify() &#123; int oldSize = _size; int i = 0; //从首元素开始 while (i &lt; _size - 1) //从前向后，逐一比对各相邻元素 //若雷同，则删除后者；否则，转至后一个元素 (_elem[i] == _elem[i + 1]) ? remove(i + 1) : i++; return oldSize - _size; //返回向量规模变化量，即删除元素总数&#125; //注意：其中_size的减小，由remove()内隐式地完成 低效算法的复杂度 算法的运行时间主要取决去while循环，次数共计: _size - 1 = n -1 最坏情况下：每次都需调用remove()，耗时$O(n-1)\\sim O(1)$，累计$O(n^2)$ ​ 尽管省去fine()，总体竟与无序向量的deduplicate()相同。 高效算法需要首先对原有的算法进行反思，我们发现造成低效率的根源在于：其中的同一个元素有可能会作为被删除元素的后继，而多次地参与前移操作，对于这样的一个元素来说虽然它每次都是向前移动，但是很可惜它的每一次移动只会移动一个单元，而不是一次性地一步到达它最终的位置。 反过来这就启示我们，如果能够将每一个重复的区间作为一个整体来考虑，成批地删除雷同的元素而不是像刚才那样逐个地去删除，并且逐个地移动，就有可能实现这种一步到位式的移动，从而使得整体的性能大大地改进。 这个新算法的思路可以由上面的图来表示，在任何时刻我们关注的都是i和j两个元素，而且这里有一个不变性，也就是在i之后 j之前的所有这些元素都与i重复，这个算法一直扫描直到发现第一个与i不同的元素。如果它确实是不同的话我们就只需将j向前移到与i紧邻于右侧的这个位置，这是一个很高明的删除算法，因为在这样的一个过程中虽然没有显式地去做这些重复元素的删除，但是实际上已经无形中将它们忽略掉了，等效于做删除。 1234567891011template &lt;typename T&gt;int Vector&lt;T&gt;::uniquify() &#123; Rank i = 0, j = 0; //各对互异“相邻”元素的秩 while (++j &lt; _size) //逐一扫描，直至末元素 //跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧 if (_elem[i] != _elem[j]) _elem[++i] = _elem[j]; _size = ++i; shrink(); //直接截除尾部多余元素 return j - i; //向量规模变化量，即被删除元素总数&#125; //注意：通过remove(lo,hi)批量删除，依然不能达到高效率 高效算法的复杂度下面通过一个例子来分析新算法的复杂度： 共计n-1次迭代，每次常数时间，累计$O(n)$时间。 算法首先考虑的i和j元素，其实就是0和1号元素，对这个例子而言它们是彼此重复的元素，所以在那个循环中将会通过那个隐藏着看不见的else直接将它忽略掉，并且使得j进而转向下一个单元，以及在接下来的一个循环中再下一个单元，以及再下一个单元。执行到3和5出现了第一次的不同，按照刚才算法的逻辑会把i++到1号位置，然后把第j号元素取出来复制到对应的1号位置上，这就是为什么变成了3和5相邻。注意，在这个过程中我们并没有做显式的删除操作。 接下来的操作与之类似，直到j第一次越过右侧的边界的时候循环退出，算法也就终止。这个时候我们已经无形中将后边的这些元素统一地给删除掉了，这种删除非常的高明，因为我们没有做任何的一次显式的删除操作，而只是通过合理的计算得知了最终的向量规模之后，对_size这个量重新进行了一次设置。 通过这个例子可以得出，算法过程中只是经过了i+1次的迭代，每次移动j必然总是会往后移动一位。而且在每一次过程中，所做的操作无非就是一次比对，只有在比对不同的情况下才会做一次复制，即便是最坏的情况下既比对而且也复制的话，累计起来也不过是常数的时间。所以换而言之，整个这个新的算法只需要$O(n)$线性的时间。 二分查找（版本A）在上一篇文章中介绍了无序向量的查找算法，它的格式为Vector::find(e, lo, hi)，第一个参数指明查找的对象，第二和第三个参数lo和hi指示查找的区间范围。这种算法从思路上来说大体是从一端出发不断地逐个比对，直到发现某一个特定的元素就是e，或者一直到lo-1这个位置在左侧越界，即是查找失败。所以最好情况它只需$O(1)$的时间，但是从最坏的情况以及从一般e的概率分布的平均情况而言，都不得不需要线性的时间。 那么在进入有序向量之后，我们应该可以得到更快的一种解决方案，不妨重新起一个名字叫search()，以示与无序向量的那个find()的区别。当然从操作的参数以及接口的语义来说都是类似的，即我们同样要在lo到hi这样一个左闭右开的区间里找到一个特定的元素。 统一接口123456template &lt;typename T&gt; //查找算法统一接口，0 &lt;= lo &lt; hi &lt;= _sizeRank Vector&lt;T&gt;::search(T const&amp; e, Rank lo, Rank hi) const&#123; return(rand() % 2) ? //按各50%的概率随机选用 binSearch(_elem, e, lo, hi) //二分查找算法，或者 : fibSearch(_elem, e, lo, hi); //Fibonacci查找算法&#125; 这里所提供的search()接口从形式上看是统一的，即ADT。从内部讲，它的具体实现算法却不见得完全一样，后面的的各节将会分别介绍二分查找算法以及Fibonacci查找算法，而且对每一种算法都有不同的版本。 为了做测试这里采用了一个随机的方法，也就是在0和1之间随机地取一个数，从而随机地调用这两个算法。在实际应用中可以针对不同的情况在这几种算法中选择其一。 seach()的简要的操作语义就是在lo和hi所确定的这个区间找出目标元素e（如果它确实存在的话）。这里需要处理很多特殊的情况，比如，目标元素并不存在与规定的区间中，这就叫失败。在此前学习的无序向量的find的接口中我们只是简单地返回了一个标志-1，但严格地说这样做是不够的。反过来有可能目标元素存在多个，既然作为有序向量，一旦有多个e的话，那么它肯定会连续地分布构成一个区间。在这种情况下，到底是返回最前边的一个，最后的一个？还是中间的某一个？这些都是我们需要进一步地从语义上予以约定的。 语义约定在语义上的细致约定是非常有必要的，否则search()接口将只能作为一个孤立的功能，而不能有效地、便捷地为其它的算法，作为一个基本的部件而利用。search()接口至少应该使得有序向量自身的动态维护变得非常便利，比如在有序向量不断插入元素过程中，我们希望往往能够采用这样一种形式：当插入某一个元素时，首先要通过search()来确定一个适当的位置，例如查找返回的那个值再加1，然后再将e插入于这个秩所对应位置，并且同时使得这个有序向量继续是一个有序向量。 1V.insert(1 + V.search(e), e); 幸运的是前人已经帮我们设计出了这样的语义约定，比如下面就是其中的一种约定： 在有序向量区间V[lo, hi)中，确定不大于e的最后一个元素 -∞ &lt; e &lt; V[lo] 时，返回 lo-1 （左侧哨兵） V[hi-1] &lt; e &lt; +∞ 时，返回hi-1（右侧哨兵的前一个） 按照这个约定，对于要查找的元素有重复元素的情况，即有多个元素是与目标的元素是重复的，应该返回的所谓的不大于e的最后一个元素，也就是这个区段的右端点。如果我们要做一个插入，把新的元素插入这个位置同加1后的位置，即重复元素区间右端点的后面，正是再合适不过的。 这里的合适是指：第一，它继续保持了整体的有序性；第二，它以及与它雷同的那些元素会保持它们插入到这个向量中的先后的次序。所以这种语义约定是非常好的，它涵盖了我们几乎所有的情况包括特殊情况。所以接下来我们在实现这些具体的算法的时候，必须最终落实到能够符合这种语义的要求。 原理这个版本只是为了说明原理，从严格的意义上讲，它还不能完全地符合刚才的语义要求，在后面的小节就会对它进行改进。 减而治之：以任一元素x = S[mi] 为界，都可将待查找的区间分为三部分 S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi) // S[mi] 称作轴点 只需将目标元素e与x做比较，即可分三种情况进一步处理： e &lt; x：则e若存在，必属于左侧子区间S[lo, mi)，故可递归深入 x &gt; e：则e若存在，必属于右侧子区间S(mi, hi)，亦可递归深入 x = e：已在此处命中，可随即返回 //若有多个，返回哪个？后面会介绍 二分（折半）策略：轴点mi总是取作中点（至少能保证不是最坏情况） 于是每经过至多两次比较，或者能够命中，或者将问题规模减一半 实现12345678910template &lt;typename T&gt; //在有序向量区间[lo, hi)内查找元素estatic Rank binSearch(T* A, T const&amp; e, Rank lo, Rank hi) &#123; while (lo &lt; hi) &#123; Rank mi = (lo + hi) &gt;&gt; 1; //每步迭代可能要做两次比较判断，有三个分支 if (e &lt; A[mi]) hi = mi; //深入前半段[lo, hi)继续查找 else if (A[mi] &lt; e) lo = mi + 1; //深入后半段(mi, hi) else return mi; //在mi处命中 &#125; return -1; //查找失败&#125; Tips：这里有编写程序的一个小的习惯，可以帮助我们更好地思考问题并且写出算法，更重要的是可以让代码更加好理解，同时也减少一些不必要的失误。我们这里统一地都用了小于号，因为小于号的左右的次序和我们通常所画的这样从小到大的次序是吻合的，所以这里e &lt; A[mi]的解读既可以认为是e小于mi，也可以认为是e存在于当前这个分界点mi的左侧。当这样顺着读下来时，当然我们就应该深入到前半段也就是左半段去，相应地呢，我们应该修改右侧的界桩hi = mi。同样接下来A[mi] &lt; e解读也是这样与其说是mi小于e，不如更直观地说是我们的目标e是处于mi这个分界点的右侧，所以我们应该深入到右半段也就是后半段去继续搜索，相应的操作也就是去修改左侧的界桩lo = mi +1。 实例与复杂度 S.search(8, 0, 7)：共经$2+1+2=5$次比较，在S[4]处命中 S.search(3, 0, 7)：共经$1+1+2=4$次比较，在S[1]处失败 线性递归：$T(n)=T(n/2)+O(1)=O(logn)$，大大优于顺序查找 递归跟踪：轴点总取重点，递归深度$O(logn)$；各递归实例均耗时$O(1)$。 查找长度有序向量的查找是一种非常基本的算法，而且它存在多个版本，因此除了上面利用渐近的复杂度能够从总体上把握它的大体性能以外，我们还需要对不同版本算法的性能做更加细微的评定。具体来说就是考察渐近复杂度$logn$前面的那个常系数，而具体地在统计和分析的时候，更多的是考量关键码的比较操作次数，也就是在其中所执行的if语句的次数，我们将此称作是不同的算法在不同的情况下所对应的查找长度。 如何更为精确地评估查找算法的性能？ 考查关键码的比价次数，即查找长度（search length） 通常，需分别针对成功与失败查找，从最好，最坏，平均等角度评估 例如，成功、失败时的平均查找长度均大致为$O(1.50\\cdot logn)$。 下面是一个一个具体的实例，这是一个由七个元素构成的有序向量，其实它的数值是具体是多少我们并不在意，只要它是非降排列的就可以。如果把算法改写成递归的形式，那么整个的不同情况的递归跟踪将构成下面的递归跟踪图，每条虚线旁边的数字代表由上一步执行到下一步所增加的比较操作的次数，具体位置的方框中的数字代表查找到它所需要总的比较操作次数，即查找长度。需要注意的是，每次递归到左子区间，比较操作次数增加1，而递归到右区间，比较操作次数增加2。 n = 7时，各元素对应的成功查找长度为$\\{4,3,5,2,5,4,6\\}$ ​ 在等概率情况下，平均成功查找长度$=29/7=4.14$； 共有8中失败情况，查找长度分别为$\\{3,4,4,5,4,5,5,6\\}$ 在等概率情况下，平均失败查找长度$=36/8=4.50$； 可见，成功和失败的平均查找长度大致是$1.50\\cdot log_28$ Fibonacci查找改进思路及原理在上一节引入了二分查找（Binary search）这样的一个概念，并且给出了一个基本的算法的版本，这个版本的复杂度从渐近意义而言应该是logn量级的，但如果进一步地细微地来考察前面的系数大致是1.5，我们也指出这个1.5是可以改进的。我们现在就来看看，如何通过一种新的算法：fibonacci查找（fibonaccian search）来对此进行改进。 上一节的末尾以一个长度为7的有序向量为例，具体地给出了在成功和失败情况下平均查找长度的估算的过程。实际上通过那个实例的推而广之，如果考虑更一般的情况，不难发现此前所介绍的版本A，确实还有很大地改进余地。这样一个判断是来自于这样一个观察事实，也就是说版本A这个算法实际上从用意上讲，它是试图通过使各种情况的搜索在迭代次数上的平衡来尽可能地回避掉最坏的情况。 具体讲比如所有的失败情况大部分都会失败在同样深度的，也就是最深的这个位置，所以它表面上看是平衡的，但这其中却蕴涵着很大的不平衡。因为在整个这个查找的过程中我们在任何一个位置上，如果要决定是向左或者是向右深入的话，所花费的成本，也就是比较的次数是不等的。准确地说按照版本A，向左侧只需要一次比较，而向右侧却需要两次比较，所以这样一个表面上看是非常公平的一个平衡，实际上在内部却蕴涵着极大的不平衡，所以我们确实有理由怀疑算法的效率是否已经达到最优。 反过来我们也可以得到改进的一个思路，具体讲就是既然我们已经看到目前的机制中，向左侧确实会成本更低，而向右侧更高。那么为什么不把这个搜索的各种情况画成类似下面的这样一个树状图，做成左侧是更深的，而右侧是相对更浅的。这样一个表面上看的不平衡，却因为它恰好和这种成本互相之间能做一个合适的补偿，反过来有可能从整体上会得到更优，也就是说使得整体的查找平均长度反而会缩短。 具体来讲，越是成本低的转向我们就越希望更多地做，越是成本更高的越是希望它能更少地来做，所以这样的话我们就得到了新的算法的改进的思路。那么具体这个思路怎么来兑现呢？非常有意思的是需要用到fibonacci数。不失一般性，假设有序向量的长度N，就是某个fibonacci数减1的形式。 如下图所示有序向量的长度n = fib(k) - 1，那我们就在其中选择这么样一个特定的切分点mi，mi = fib(k-1) - 1，如果以这个点为切分，那么左边子向量的长度就恰好是fib(k-1) - 1，而右边子向量的长度恰巧是fib(k-2) - 1。可见这样一种切分的好处就是，在任何时候只要按照这样来切分，无论是向左还是向右它都会从长度上保持某个fibonacci数再减1的形式，而这种形式实际上恰好是最优的。 实现首先定义一个Fib类，让其提供一些接口。 12345678910class Fib &#123; //Fibonacci数列类private: int f, g; //f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出public: Fib ( int n ) //初始化为不小于n的最小Fibonacci项 &#123; f = 1; g = 0; while ( g &lt; n ) next(); &#125; //fib(-1), fib(0)，O(log_phi(n))时间 int get() &#123; return g; &#125; //获取当前Fibonacci项，O(1)时间 int next() &#123; g += f; f = g - f; return g; &#125; //转至下一Fibonacci项，O(1)时间 int prev() &#123; f = g - f; g -= f; return g; &#125; //转至上一Fibonacci项，O(1)时间&#125;; Fibonacci查找可以实现为下面的一段代码，可以注意到它的接口还是完全一样的，而且在其中的这个循环，大致来说也是与版本A类似的，即每次都要来判断以保证当前的lo和hi构成一个合法的区间，如果这个区间能够收缩到非法(lo == hi)，那也就意味着查找是失败的，这跟此前的版本A是一样的。 123456789101112131415#include \"fibonacci/Fib.h\" //引入Fib数列类// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _sizetemplate &lt;typename T&gt; static Rank fibSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; Fib fib(hi - lo); //用O(log_phi(n = hi - lo)时间创建Fib数列 while(lo &lt; hi) &#123; while ( hi - lo &lt; fib.get() ) fib.prev(); //自后向前顺序查找（分摊O(1)） Rank mi = lo + fib.get() - 1; //确定形如Fib(k) - 1的轴点 if ( e &lt; S[mi] ) hi = mi; //深入前半段[lo, mi)继续查找 else if ( S[mi] &lt; e ) lo = mi + 1; //深入后半段(mi, hi)继续查找 else return mi; //在mi处命中 &#125; //成功查找可以提前终止 return -1; //查找失败&#125; //有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置 查找长度 fibonacci查找算法的平均查找长度为$O(1.44 \\cdot logn)$，略优于二分查找 仍以n = fib(6) -1 = 7 为例，在等概率情况下： 平均成功查找长度$=(2+3+4+4+5+5+5)/7=28/7=4.00&lt;4.14$ 平均失败查找长度$=(4+5+4+4+5+4+5+4)/7=35/7=4.38&lt;4.50$ 最优性 通用策略：对于任何的A[0, n)，总是选取A[λn]作为轴点，$0\\le \\lambda &lt;1$: 比如二分查找对应于$\\lambda=0.5$，Fibonacci查找对应于$\\lambda=\\phi=(\\sqrt{5}-1)/2=0.6180339\\dots$（黄金分割比） 在[0, 1)内，$\\lambda$如何取值才能达到最优？设平均查找长度为$\\alpha(\\lambda)\\cdot log_2n$，何时$\\alpha(\\lambda)$最小？ 递推式：$\\alpha(\\lambda)\\cdot log_2 n=\\lambda\\cdot [1+\\alpha(\\lambda)\\cdot log_2 (\\lambda n)]+(1-\\lambda)\\cdot [2+\\alpha(\\lambda)\\cdot log_2 \\left((1-\\lambda) n \\right)]$ 整理后：$\\frac{-ln2}{\\alpha(\\lambda)}=\\frac{\\lambda\\cdot ln\\lambda+(1-\\lambda)\\cdot ln(1-\\lambda)}{2-\\lambda}$，当$\\lambda=\\phi$时，$\\alpha(\\lambda)=1.440420\\dots$达到最小。 相对于我们上一节的二分查找$\\alpha(\\lambda)=1.50$，Fabonacci查找又有了一定的改进，而且从本节的分析可以看出这种改进已经达到了极限，如果我们不再改变这个算法的总体模式和框架的话。 二分查找（改进）这一节将介绍另一种思路的改进，这是一种直截了当的改进思路，既然我们已经注意到了此前的版本A中造成效率略低的原因是因为左右分支的转向代价不平衡，那么可以考虑是否能将二者做成是平衡的。 改进思路 二分查找中左、右分支转向代价不平衡的问题，也可直接解决 比如，每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个 同样地，轴点mi取作中点，则查找每深入一层，问题规模也缩减一半 1）e &lt; x： 则e若存在，必属于左侧子空间S[lo, mi)，故可递归深入 2）x &lt;= e：则e若存在，必属于右侧子空间S[mi, hi)，亦可递归深入 只有当元素数目hi - lo = 1时，才判断该元素是否命中，这是该算法做出的牺牲 版本B：实现主要注意代码中与版本A不同的地方。 123456789// 二分查找算法（改进）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _sizetemplate &lt;typename T&gt; static Rank binSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; while ( 1 &lt; hi - lo ) &#123; //每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止 Rank mi = ( lo + hi ) &gt;&gt; 1; //以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移） ( e &lt; S[mi] ) ? hi = mi : lo = mi; //经比较后确定深入[lo, mi)或[mi, hi) &#125; //出口时hi = lo + 1，查找区间仅含一个元素A[lo] return (e == A[lo]) ? lo : -1; //返回命中元素的秩或者-1&#125; 这个算法是封闭的，可以运转，而且可以完全实现此前一样的功能。与此前的版本A对比，它在最好情况下反而有所倒退，原因是在与即使是成功的情况它也一直要推迟到最终，只有在经过最终的这次比对之后才会确定是否成功。此前的版本A它的最好情况是非常好的，最最好的情况莫过于在第一次试图做减而治之的时候，所采用的那个切分点就成功命中，只需要$O(1)$的时间。 本节改进的二分查找无论如何都一直要切分到最后，所以最好的情况的时间复杂度是$O(logn)$。但是反过来最坏的情况又会更好，因为我们这里最坏的情况不会出现每一次都是向右，即每次都要花费两次比较的情况，所以最坏的情况会得到抑制。所以从总体而言此前的那个版本A如果说它在性能上好坏情况相差非常大的话，那么本节中改进的版本在整体性能上，它就会趋于更加的稳定，即差异化不是那么大，当然这还不是它的最大的优势所在。 语义约定 以上的二分查找及Fibonacci查找算法，均未严格地兑现search()接口的语义约定： 返回不大于e的最后一个元素 只有兑现这一约定，才可以有效支持相关算法，比如：V.insert(1 + V.search(e), e) 1）当有多个命中元素时，必须返回最靠右（秩最大）者 2）失败时，应返回小于e的最大者（含哨兵lo-1） 版本C：实现在刚才代码的基础上，我们做进一步的调整，得到一个最终的版本，它可以严格地实现上面定义的语义。 12345678template &lt;typename T&gt; static Rank binSearch ( T* S, T const&amp; e, Rank lo, Rank hi ) &#123; while ( lo &lt; hi ) &#123; //不变性：A[0,lo) &lt;= e &lt; A[hi,n) Rank mi = ( lo + hi ) &gt;&gt; 1; //以中点为轴点 ( e &lt; S[mi] ) ? hi = mi : lo = mi + 1; //经比较后确定深入[lo, mi)或(mi, hi) &#125; //出口时，A[lo = hi]为大于e的最小元素 return --lo; //故循环结束时lo - 1即不大于e的元素的最大秩&#125; //有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置 就算法的结构而言，这个新的算法版本C和此前的版本A，尤其是版本B，似乎没有什么太大的区别。解读一下：当这个区间还是合法之前我们就不断地迭代，每一次也照样是取出它的中点作为轴点，并且经过一次比较从而决定到底是向左侧还是向右侧深入，那么直到区间宽度缩小到足够小的时候，才返回最终的值。 需要注意的是版本C和版本B，虽然在功能上是等效的，但是在很多细节上却有着本质的区别： 待查找区间宽度缩短至0而非1时，算法才结束 转入右侧子向量时，左边界取作mi+1，而非mi //A[mi]会被遗漏？下一小节证明 无论成功与否，返回的秩严格符合接口的语义约定 正确性首先通过下面的图例来具体地了解一下版本C的工作过程，其实最主要的是它的每次迭代的过程都是类似的。如图(a)，在整个向量的区间内，我们关注的是某一个特定的从lo到hi的一个查找区间，每次在这个区间里都要考虑middle point，即图中的x。 我们以它为界，经过一次比较以后有可能会发现目标元素更小所以就深入到如图b所示的左侧的这个子区间；或者对称地，因为目标元素更大而深入到右侧的这个区间，如图(c)。版本C的算法中左侧子区间和右侧的子区间都没有覆盖这个middle point，而且对middle point也没有做显式地判断，所以这也是为什么有理由怀疑它有可能是这个算法的一个疏忽。 接下来我们来证明这样一个模式实际上是安全的，为此同样用我们的两种技巧：第一就是给出这个算法的不变性其次要给出它的一个单调性，而单调性是一目了然，就不再说明了，主要是证明它的不变性： 不变性：A[0, lo) &lt;= e &lt; A[hi, n) //A[hi] 总是大于e的最小者 初始时，lo = 0且 hi = n，A[0, lo) = A[hi, n) = $\\varnothing$，自然成立 数学归纳法：假设不变性一直保持至图(a)的状态，下一步无非两种情况： 第一种情况，也就是深入左侧这个分支的情况，即图(b)。那么此前的判断e &lt; A[mi]返回的是True，之后执行 hi = mi，从而使得右侧的这段区间向左拓展是安全的，因为确实可以断定这个整个区间内的这些元素都是严格地大于e的，因为它们其中最小的那个元素也就是A[mi]都大于e。而A[0, lo)保持不变,所以这种情况是没有问题的。 第二种情况，也就是深入右侧这个分支的情况，即图(c)。那么此前的判断e &lt; A[mi]返回的是False，之后执行 lo = mi，此时e是不小于A[mi]的，而A[mi]元素是左段区间中最大的，所以左段区间都是都是不大于e的。这样一个左侧区间向右拓展的动作在刚才不变性的意义上讲，依然是安全的，它使得不变性得到了延续。所以经过一次迭代以后无论是向左还是向右的深入，不变性都是成立的。 单调性：显而易见，直到最后会出现一个情况，就是整个区间的宽度变成零，可以表示为下图。 从整个的原始的搜索空间开始，经过不断地压缩、压缩、压缩之后，将搜索的范围缩小到一个宽度为零的一个区间，其实它就只是一个分界。它严格地将整个区间分为了左右两部分，由不变性左侧这部分依然是不大于e，而右侧这部分是严格地&gt;e。如果查找的结果是命中的，我们只需要返回左侧这个区间的最右端的那个元素就可以了，而这个元素正是A[lo-1]。这也就是为什么我们在算法的最终返回之前要做一次--lo的操作。 这样的话我们就得到了一个从功能上、从语义上、从性能上都近乎完美的算法！ 插值插值插值查找（Interpolation Search）有序向量查找算法的一个另类的变种，此前所介绍的Fibonacci search或binary search包括它们的各种版本对向量只做了一个假定，即其中的元素是单调有序的，对于其中元素的分布情况并没有做任何的假设，也就是可以是完全理想任意随机的。但是在某些情况下也许不是这样，比如我们可能不仅知道向量是有序的，而且其中的元素是按照某种先验规律随机分布的。 在这里我们考虑一种最常见的随机分布：均匀独立的随机分布，比如在从lo一直到hi的秩的范围之内，所有的元素都是互相不影响，各自独立的，然后从取值来看是均匀的取自于某一个区间范围。如果我们确实知道诸如此类的规律的话，就有可能实现优于此前那些算法$O(logn)$的更高的查找效率，以$o(logn)$的效率来完成一次查找。 原理与算法在均匀且独立的随机分布下，所有的元素在排序之后，即组织成一个有序向量之后，必然大体上是按线性增长的趋势分布的，从最小值lo开始大致是线性增长到最高值hi。这就意味着对于其中的任何一个潜在元素mi，都可以写出这样一个近似的线性等式，它们的秩的比与它们的数值比，二者是近似接近的。 \\frac{mi-lo}{hi-lo}\\approx \\frac{e-A[lo]}{A[hi]-A[lo]}实际上这给了我们一个启示，即在每次确定mi的时候，既不需要固定的用1/2，也不需要固定的用小写的φ（黄金分割比），甚至不需要用某一个一般的λ，而是可以动态的来猜测这样一个轴点，就是根据上面的等式。将这个等式稍微整理一下把mi提到左侧，我们就可以知道根据lo、hi以及它们对应的这两个元素的数值，以及每次动态要查找的那个元素的数值e，就可以大致的估算出mi，这样的话如果整个的减而治之的搜索过程可以认为是一个不断收缩包围圈逐步收敛的一个过程，那么它将会使得收敛的速度极大的加快，从而更快速的完成我们整个的查找。 mi\\approx lo+(hi-lo)\\cdot \\frac{e-A[lo]}{A[hi]-A[lo]} 正如这个图所画的是一本英文词典中abcd一直到z开头的单词各自起始的页码,它大致是1300多页，换而言之如果它确实是一个大致平均分布的话，每一个字母大概占50页，所以我们可以大致估算出来从1到50页大概是a，50页到100页大概是b，100页到150页大概是c，诸如此类。比如说去查binary (b)，那么因为它是第二个字母所以它大概会在整书从2/26这个位置开始，而search,s是第19个元素 所以大概它会位于19/26的位置。正因为这种算法在确定切分点也就是轴点的时候，采用的是近似的插值估算的方法，所以我们也称之为Interpolation Search插值查找，下面是一个实例。 性能从刚才的例子我们可以看出，对于这样一个长度为19的有序向量，只用了3次比较就给出了答案，而在通常的二分查找中这是做不到的，所以我们已经看到它在某些情况下确实很快，但是它总是能很快吗？包括这种很快到底定性是多大呢？ 我们需要做一个严格的界定，首先一个不好的消息是插值查找在某些情况下效率会很低，比如说 可能退化为与平凡的顺序查找没有什么区别，我们此前所做的那种假设也就是均匀独立的分布不满足，或者至少在某些部分不满足以致在全局或某些局部出现一些所谓的病态分布。 最坏情况：$O(hi- lo)=O(n)$ 当然 插值查找的最好情况也是不言而喻的，和其他的查找差不多，也就是说有可能我们在某次，甚至在第一次猜测的时候就直接命中，那么这种我们也不再考虑。我们转而再考虑一般的情况，也就是平均而言会怎么样。 这里我们需要用到一个非常基础类似引理的结论这个结论：在插值查找算法中每经过一次迭代，或者说每经过一次比较，都可以将查找的范围也就是减而治之之后剩余的部分由原先的规模n缩减为$\\sqrt{n}$。 平均情况：每经过一次比较，$n$缩减至$\\sqrt{n}$。 于是，待查找区间宽度将按一下趋势缩减： ​ $n,\\quad\\sqrt{n},\\quad \\sqrt{\\sqrt{n}},\\quad \\sqrt{\\sqrt{\\sqrt{n}}},\\dots,\\quad2$ ​ $n,\\quad n^{(1/2)},\\quad n^{(1/2)^2},\\dots,\\quad n^{(1/2)^k},\\dots,\\quad2$ 经多少次比较之后，有$n^{(1/2)^k}&lt;2$？ $k&gt;loglogn$ 插值查找的时间复杂度为：$O(loglogn)$ 我们同样可以来估算：如果向量的长度或者这个区间的宽度是n的话，考虑这个n按照二进制打印出来以后的位宽就是以的2为底 logn，那么每一次将它变为根号n从二进制的打印宽度来看其实就是变成了1/2的原来那么多宽度，换而言之每一次开方其实同步的是使宽度变成了原来的1/2，这样的过程 从n的数位宽度来说是一个不断折半的过程。 回顾此前的二分查找，如果是对的n的数值每次折半的话，那么这里的插值查找实际上就是对n的二进制位宽度来做二分查找。二分查找所需要的迭代次数是与它的初始值呈一个对数关系的，即$O(logn)$，而插值查找的位宽的初值相当于是logn，所以其需要的迭代次数就是$O(loglogn)$。 从今以后也许我们应该学会忘掉这些复杂的，虽然是精确的数学，而改用这种宏观的大趋势的把握本质的习惯。 综合对比现在将插值查找和其他的算法综合起来进行比对和考量，刚才插值查找所实现的这种改进也就是从logn到loglogn虽然从数学上是一个比较大的改进，但从实际效率来看却值得商榷。 从$O(logn)$到$O(loglogn)$，是否值得？ 通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高。 比如，n = 2^(2 ^ 5) = 2 ^ 32 = 4G时，$log_2(n)=32,\\quad log_2(log_2(n))=5$ 易受小扰动的干扰和“蒙骗”，可能在局部花费非常多的时间 须引入乘法、除法运算，相对而言成本更高（二分查找只需加法，Fibonacci查找只需加法和减法） 所以可行的查找算法也许应该将插值查找以及此前的那些查找算法各自的优势综合结合起来，比如说插值查找更善于在比较大的一个宏观的范围内，将问题的关注点尽可能快的缩小到一定的范围，即它比较擅长于处理那种极大的情况，然后一旦到了比较小的情况，这种容易受到干扰包括蒙骗尤其是乘法除法这样的一些overhead额外计算占得比重就会更大成为不可忽略的因素，而在这个时候二分查找的优势就体现出来了。 实际可行的方法： 首先通过插值查找，将插值范围缩小到一定的范围，然后再进行二分查找，或者顺序查找，即： 大规模：插值查找 中规模：折半查找 小规模：顺序查找","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（2）向量","slug":"数据结构与算法（2）向量","date":"2020-02-08T02:04:27.000Z","updated":"2020-02-09T02:04:27.000Z","comments":true,"path":"2020/02/08/数据结构与算法（2）向量/","link":"","permalink":"http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/","excerpt":"","text":"1.接口与实现我们首先需要辨析一组非常相关但是又非常容易弄混的概念，也就是抽象数据类型以及数据结构。那么什么是Abstract Data Type呢？以及什么是Data Structure呢？可以从字面上给出定义，抽象数据类型就是在一组数据的模型上定义的一组操作。数据结构则是基于某种特定的语言真正实现的一套完整的算法。 Data Type数据类型，比如在高级程序设计语言中int也就是整型，这就是一个数据类型，而float也是，还有char，诸如此类地。这种数据类型能够让我们能定义其中的一个成员，比如n是一个整数，从此以后我们就可以使用它了，我们也可以定义x是一个浮点数，c是一个字符。 123int n;float x;char c; 凡是这样指定了某一个元素是来自于某一个数据类型，或者说属于某一个数据类型，那么它就自然地具有了这种数据类型的特点，包括支持相应地处理方法，比如说运算。那么这里那些操作的运算具体是如何实现的，我们并不知道，我们也并不需要知道，这是最重要的。 把这样的一个概念抽象出来施加到我们所将要实现的数据结构上，比如这一章要介绍的vector。我们希望在使用的时候能够参照数据类型的这种形式，把它等同地当作是一个数据类型，比如可以用类似的方法来定义一个vector结构，包括下一章将要介绍的List。 这种使用方法使得我们可以将数据结构与数据类型等同起来，我们只需要知道它所提供的那些操作，比如说向量的查找、排序，而不需要去关心它其中的细节，比如说这些操作是如何实现的。那么从这个意义上讲，它就是一个经过了抽象以后的数据类型，所以称之为Abstract Data Type。 举个例子：可以将数据结构比喻成某种产品，比如说汽车，相关的有两类人，首先是用户，我们笼统地称之为应用Application，另一类人是汽车这种产品的设计和制造者，称之为实现Implementation。这两类人所关心的以及他们的职责是不同的，作为用户而言，他只关心这种产品的外在特性，能够提供的功能；而实现者则需要对这些功能以及特性具体如何落实负责。在这二者之间实际上是有某种形式的一个协议，也就是使用说明书，产品手册。而这种手册或者说明在数据结构的使用者与数据结构内部算法的设计者之间，达成了这么样一个协议，两类人可能互不见面，互不相识，但是他们通过这样一个规范，可以很好地彼此沟通，并且有效地合作。 1.1.向量ADT1.1.1.从数组到向量向量实际上是C++等高级编程语言中数组这种数据组织形式的一个推广和泛化。实际上在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都与0到n之间的某一个整数编号相互彼此对应。这里我们也同样延用此前已经约定的习惯，虽然最后这个第n个元素，实际上未必存在，我们还是把它虚拟地放在这儿作为哨兵，以帮助我们对很多问题的思考，并且使得我们很多算法的实现能够得以简化。 C/C++语言中，数组A[ ]中的元素与[0,n)内的编号一一对应。 既然每一个这样的元素都与这些编号是一一对应的，所以反过来我们通过合法区间内的编号都可以唯一地来指代并且访问对应的那个元素。一旦知道这个元素的下标i，就可以从A也就是这段存储区域的首地址出发，再向后以s作为间隔去数出i步，就可以得到某一个特定的单元。正因为所有这些元素的物理地址可以按照这样一个线性的方程来确定。所以我们也称之为线性数组（linear array）。 反之每个元素均由（非负）编号唯一指代，并可直接访问。A[i]的物理地址 = A + i×s，s为单个元素占用的空间量。 向量是数组的抽象与泛化，由一组元素按线性次序封装而成： 各元素与[0, n)内的秩（rank）一一对应 元素的类型不限于基本类型 操作、管理维护更加简化、统一于安全 可更为便捷地参与复杂数据结构的定制与实现 1.1.2.向量ADT接口按照抽象数据类型的规范，向量结构必须提供一系列的操作接口，可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作，这里的接口功能非常的丰富。 比如说与其它的数据结构一样向量也可以看作是一组元素的集合，所以size( )实际上返回的是其中元素的总数，称之为这个数据结构的规模。也可以从中取特定的元素get(r)，也可以修改其中特定的元素put(r, e)，甚至插入insert(r, e)或者是删除某个元素remove(r)。我们也可以判定一下其中的元素是否已经有序排列disordered( )，如果没有有序排列，可以调用相应的接口使之有序排列sort( )。 我们也可以在它尚未有序排列的时候，按某种算法找到其中特定的元素find(e)，也可以在已经有序的前提下按照某种方式，来找到其中的元素search(e)。当然为了展示一些算法的实现我们也附加了一些其它的功能，比如说能够在无序和有序的情况下分别剔除这个数据集中的重复元素：deduplicate( )和uniquify( ) 。最后也是非常重要的一个接口就是如何对这个数据集中的元素逐一地进行枚举，并且访问一遍traverse( )，称之为遍历。 1.1.3.ADT接口操作实例下面举例说明ADT接口的实现。 最开始向量与任何一个数据结构一样，初始化的时候都是不包含任何实质的内容的，我们称它是一个空的向量。接下来调用插入操作insert，它在rank为0的这个位置上插入一个元素9，所以向量的组成将由空变成包含一个元素9。接下来继续调用insert接口，在0号这个位置上rank为0的这个位置上插入一个元素4，原来的元素9将会后移一位。同样地，我们也可以调用插入接口在rank为1的位置上插入5，在这个位置上出现了5，而它的后继统一地向后后移了一位。我们也可以调用put接口，这个接口的意思是修改，它会把当前rank为1的那个位置上的元素数值，由原来的5修改为2。我们也可以通过get这个接口获取秩为某一特定值的元素，比如说秩为2的那个元素，实际上就是2这个位置上的9，因此会返回9。 remove接口的参数是2，这说明它希望在原来这个向量中将rank为2的这个元素，把它剔除掉，剔除之后，会把这个被剔除的元素的值作为输出返回，即返回2，同时它的所有的后继与插入时候的操作的现象相反，会向前平移一个单元。当这个时候我们调用size的时候，因为这里所包含的元素总共是6个，所以它会返回6。 我们可以看到在整个这个操作的过程中向量都确实具有这么样一个特点，就是它在逻辑上，甚至在物理上必然是彼此紧邻的排列的，所有的元素之间没有任何的缝隙。需要注意的是无论是此前所介绍的这些接口，还是后面所要介绍的接口，就目前而言，我们并不关心它的具体实现方法，我们关心的只是它的操作语义。 接下来我们可以通过disordered()这个接口来检测向量的有序性，或者更准确地讲它的无序性。在此前介绍bubble sort算法的原理的时候，曾经指出包括向量在内的序列是否有序，当且仅当其中是否存在紧邻的逆序对。那么这里总共有6个元素，共定义了5组紧邻对，其中有3组，也就是4和3、7和4、和9和6是逆序的，disordered会返回逆序对的个数，即是3，只要这个数值不是0，就说明它尚未构成有序的序列。 对于这样的一个无序向量我们已经可以通过find接口，来查找其中特定的某个元素，比如说9。可以看到9号元素是位于rank为4的位置，因此find会返回4。同样地，也可以查找比如说5，我们发现5并不存在，这个时候我们统一地约定返回一个数值是-1，这个-1肯定不是一个合法的rank，表示查找失败。接着我们可以通过sort这个接口对整个向量排序，接下来再调用disordered()这个接口，它已经没有任何逆序的紧邻对了，所以返回0。 对于有序向量，我们可以通过另一套接口，也就是search来进行查找。比如说可以首先通过search，然后引用9来查找数值为9的元素，这个元素的rank为5，因此返回的是5。那么如果查找8会怎么样呢？向量中并没有8，这里我们采用了另一种约定：如果没有找到这个元素，我们要找的是不超过这个元素的最大的那个元素的值。对这个例子而言不超过8的最大的元素实际上就是7，而7的秩是4，所以search(8)会返回4。同样 我们如果要去查找10的话会返回不超过10的最大的那个元素也就是9的秩5，因此search(10)会返回5。 另一种特殊情况：查找一个全局都没有而且小于全局的最小的那个元素的数比如说1，我们会假设在-1的rank这个位置上有一个假想的哨兵，它的数值是负无穷，所以search(1)返回的是-1。这样一套约定可以使得我们在语义上更加的明确，使得我们在后续的操作过程中可以便利地来搭建不同的算法。还有一点要注意的是：在有些时候，我们要查找的元素尽管有，但是它却有多次出现，比如说这个4 出现了两次，那这个时候会返回什么呢？同样跟这里的语义所定义吻合的是，我们要返回其中不超过4这个目标元素的最后边那个元素，所以如果有两个甚至多个4的话，我们会取其中rank最大的那个元素把它的rank返回，对这个例子而言也就是2号元素，因此search(4)会返回2。 最后，uniquify()对于一个有序的向量把所有的重复的元素，比如说4都剔出掉，只保留一个拷贝。 1.2.vector模板类有上述接口规范之后，我们就可以遵照这种规范来学习如任何具体地在C++语言平台上实现这样一种向量模板类vector结构。首先约定用int来定义这里所说的秩这种概念，接下来会首先采用一种基本的扩容方式，它的初始容量需要设定，这里不妨取它的DEFAULT_CAPACITY取作3，在实际应用中完全可以取更大的一个数。 下面通过template这种方式给一个模板参数T，它的意思可以认为是定义了一个vector这样的模板类。其中的元素类型是什么可以是将来指定的任何名字现在叫作T的类型。所以与其说它写的是一个类，不如说这个模板类给的是一系列的类，我们可以根据实际需要直接地生成相应的vector类。在模板类里面有一些私有的，也就是封装和隐藏起来的变量，比如说其内部会记忆它到底有多少个元素有一个_size ，以及它目前的容量_capacity，还有包括真正存放元素的一个空间_elem。其它的内部函数以及公开的接口函数会在后边陆续学到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef int Rank; //秩#define DEFAULT_CAPACITY 3 //默认的初始容量（实际应用中可设置为更大） template &lt;typename T&gt; class Vector &#123; //向量模板类protected: Rank _size; int _capacity; T* _elem; //规模、容量、数据区 void copyFrom ( T const* A, Rank lo, Rank hi ); //复制数组区间A[lo, hi) void expand(); //空间不足时扩容 void shrink(); //装填因子过小时压缩 bool bubble ( Rank lo, Rank hi ); //扫描交换 void bubbleSort ( Rank lo, Rank hi ); //起泡排序算法 Rank max ( Rank lo, Rank hi ); //选取最大元素 void selectionSort ( Rank lo, Rank hi ); //选择排序算法 void merge ( Rank lo, Rank mi, Rank hi ); //归并算法 void mergeSort ( Rank lo, Rank hi ); //归并排序算法 void heapSort ( Rank lo, Rank hi ); //堆排序（稍后结合完全堆讲解） Rank partition ( Rank lo, Rank hi ); //轴点构造算法 void quickSort ( Rank lo, Rank hi ); //快速排序算法 void shellSort ( Rank lo, Rank hi ); //希尔排序算法public:// 构造函数 Vector ( int c = DEFAULT_CAPACITY, int s = 0, T v = 0 ) //容量为c、规模为s、所有元素初始为v &#123; _elem = new T[_capacity = c]; for ( _size = 0; _size &lt; s; _elem[_size++] = v ); &#125; //s&lt;=c Vector ( T const* A, Rank n ) &#123; copyFrom ( A, 0, n ); &#125; //数组整体复制 Vector ( T const* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; //区间 Vector ( Vector&lt;T&gt; const&amp; V ) &#123; copyFrom ( V._elem, 0, V._size ); &#125; //向量整体复制 Vector ( Vector&lt;T&gt; const&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; //区间 // 析构函数 ~Vector() &#123; delete [] _elem; &#125; //释放内部空间 // 只读访问接口 Rank size() const &#123; return _size; &#125; //规模 bool empty() const &#123; return !_size; &#125; //判空 Rank find ( T const&amp; e ) const &#123; return find ( e, 0, _size ); &#125; //无序向量整体查找 Rank find ( T const&amp; e, Rank lo, Rank hi ) const; //无序向量区间查找 Rank search ( T const&amp; e ) const //有序向量整体查找 &#123; return ( 0 &gt;= _size ) ? -1 : search ( e, 0, _size ); &#125; Rank search ( T const&amp; e, Rank lo, Rank hi ) const; //有序向量区间查找// 可写访问接口 T&amp; operator[] ( Rank r ); //重载下标操作符，可以类似于数组形式引用各元素 const T&amp; operator[] ( Rank r ) const; //仅限于做右值的重载版本 Vector&lt;T&gt; &amp; operator= ( Vector&lt;T&gt; const&amp; ); //重载赋值操作符，以便直接克隆向量 T remove ( Rank r ); //删除秩为r的元素 int remove ( Rank lo, Rank hi ); //删除秩在区间[lo, hi)之内的元素 Rank insert ( Rank r, T const&amp; e ); //插入元素 Rank insert ( T const&amp; e ) &#123; return insert ( _size, e ); &#125; //默认作为末元素插入 void sort ( Rank lo, Rank hi ); //对[lo, hi)排序 void sort() &#123; sort ( 0, _size ); &#125; //整体排序 void unsort ( Rank lo, Rank hi ); //对[lo, hi)置乱 void unsort() &#123; unsort ( 0, _size ); &#125; //整体置乱 int deduplicate(); //无序去重 int uniquify(); //有序去重// 遍历 void traverse ( void (* ) ( T&amp; ) ); //遍历（使用函数指针，只读或局部性修改） template &lt;typename VST&gt; void traverse ( VST&amp; ); //遍历（使用函数对象，可全局性修改）&#125;; //Vector vector模板类的原理：整个vector结构是被封装起来，能供来自各种应用的用户使用的操作接口就是interface框中vector，~vector，insert，remove等等，它们就相当于vector结构的使用说明书，它告诉我们这里提供了哪些操作渠道、途径，通过这种接口规范直接使用。经过了这样地一个剥离之后，使得我们的应用和实现相互之间可以很好的分工，又同时很好的协作。那么具体内部怎么实现的呢？可以看出其实是开辟了一个名字叫作_elem的数据区，它的容量至少要足以容纳所存放的有效数据，对外而言的每一个元素都通过某种形式转译为内部这段数据区中的，实际上是这个有效的数据区（_size）中的某一个元素，由此实现了对内部数据项的封装。 1.2.1构造与析构作为一种数据结构与所有的类一样，vector也首先需要解决构造和析构的问题。向量的默认的构造实际上只需指始初始的容量就可以了，如果没有指定会按照默认的容量，指定一个数值。在内部的操作其实就是通过new申请一个长度为c，基本类型就是模板参数T的一段连续的数据空间。在创建了这样一个空间之后，我们把这个空间的首地址交给内部的_elem记下来。这个时候虽然它有一定的空间，但是其中有效的数据是没有的，所以这就是为什么_size初始化是0。 12345Vector(int c = DEFAULT_CAPACITY)&#123; _elem = new T[_capacity = c]; _size = 0;&#125; //默认 当然还有其它的一些构造的方法，比如如果已经有一组以数组的形式存放的数据，我们也可以将其中从lo到hi的这段区间中的元素取出来作为初始向量，可以看到它是通过调用一个叫作copyFrom()的内部接口实现的。同样地 它还重载了其它的一些形式，比如被复制的元素可能是来自于一个数组，而是来自于一个本身已经被封装了的向量，我们可以从这个向量的_elem区域中去读取出来，并且同样调用copyFrom()来做这件事。所以这里有区间的复制，也可以有对整个向量的一个克隆。 123456Vector(T const *A, Rank lo, Rank hi) &#123; copyForm(A, lo, hi);&#125; //数组区间复制Vector(Vector&lt;T&gt; const &amp;V, Rank lo, Rank hi) &#123; copyForm(V._elem, lo, hi);&#125; //向量区间复制Vector(Vector&lt;T&gt; const &amp;V) &#123; copyForm(V._elem, 0, V._size);&#125; //向量整体复制 内部操作接口copyForm( )的工作原理以及过程可以通过下图示意，工作原理以及过程，可以通过这个图来示意。一般地我们需要从一个数组A中将介于lo到hi之间的元素整体复制到当前仍然为空的一个向量中，具体的操作大概分为两步，首先在向量内部开辟出足够的空间，接下来再将区间内的元素逐一地复制过来。 这个过程可以描述并且实现为下面的C++代码：首先申请足够多的空间，这里需要再强调一下这个区间的宽度可以直接通过lo和hi之间的一个减法得到，这是因为当我们在描述一个区间的时候往往是用左闭右开的形式，所以换而言之这个lo是在这个区间中最靠左的那个元素，而hi是在右侧第一个不属于这个区间的那个元素，尽管hi这个元素有可能压根就不存在。但是我们不妨把它统一地理解成是一个哨兵，这样的话我们就可以通过，hi减lo直接得到区间的宽度。 这里给计算出的宽度再乘个2，也就是说我们实际开辟的空间是我们需要复制的空间的两倍，而不是恰好那么多。这样做的主要的目的在于预留了一些空间之后，就可以使得我们在接下来足够长的时间之内，不会因为有必要扩容而打断我们的计算过程。 1234567template &lt;typename T&gt; //元素类型void Vector&lt;T&gt;::copyFrom (T const* A, Rank lo, Rank hi)//以数组区间A[lo, hi)为蓝本复制向量&#123; _elem = new T[_capacity = 2 * ( hi - lo ) ]; _size = 0; //分配空间，规模清零 while ( lo &lt; hi ) //A[lo, hi)内的元素逐一 _elem[_size++] = A[lo++]; //复制至_elem[0, hi - lo)&#125; 接下来还需要对这个向量的有效规模进行初始化 把它清为0。 再接下来 就是复制过程也就是说我们对于lo和hi中间的每一个Rank，都要从A这个数组中取出对应的元素，并将它们顺次的存入到_elem，对应的区间里面去。整体循环构成了这个操作的最重要的部分，所以我们也可以看出算法的复杂度主要是来自于这样一个循环。这样一个主体的复杂度是取决于被复制元素的个数，或者说这个复制区间的宽度，也可以认为是这个向量通过复制被创建之后的初始规模。 析构函数只需要把这个曾经动态分配获得的数据区域释放掉，归还给操作系统。 1~Vector() &#123; delete [] _elem; &#125; //释放内部空间 这样的话我们就完成了向量这种最基本的结构作为一种模板类它的最基本的一些接口，接下来会学习功能更为复杂的其它的接口。 2.可扩充向量与所有的数据结构一样，向量也可以认为是一组数据项的集合，换而言之，它首先必须能够自适应地在规模上适应其中所包含的元素个数的变化，这一节集中讨论它的可扩充性能。向量本身并不具有这种性能，我们需要采取一些策略。就目前的设计方案而言，我们的向量并不具备可扩充的性能，究其原因在于它采用的 实际上是所谓的静态空间管理的策略。 2.1.静态空间管理具体来说，它实际上在内部只不过是设置了一个私有的数组，这个数组所占有的那段连续的地址空间会被用来存放若干个对外界而言可见的，或者是有效的元素。这些元素的总数，或者说它们所占用的逻辑空间的数，用_size来表示，而整个物理空间的大小是由_capacity来确定的。 这里的问题是_capacity一旦确定,按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：第一 是有可能会出现所谓的上溢overflow，也就是说随着有效元素（个数）的增加，总会出现这样的可能，使得整个_elem所占用的物理空间已经不足以存放需要存放的元素组。尽管这个时候在系统的其它的部分仍然有足够多的空间可以用于存放这些元素，但是限于_capacity是固定的，我们不能直接做到这一点。 另一种情况虽然不是很严重，但是也是会造成一定的空间的效率低下，我们称之为下溢underflow。具体来说就是有可能我们开辟了一个比较大的空间，但是在整个这个数据结构的生命期内真正存放于其中的数据却寥寥无几，从而使得装填因子指标会非常非常的小，这个装填因子其实就是有效元素个数，也就是_size ，去除以可用于存放元素的空间总数_capacity，也可以理解成是空间的利用率有可能不到一半，甚至远远地低于一半，那么在这种时候空间效率非常低下。 很遗憾如果我们坚持采用这样一种固定容量的策略，我们在实际的一般应用环境中，很难在事先就预测到我们需要用多少空间，也就是说这种空间不足以及空间浪费的情况，都有可能发生甚至经常发生。 那么如何使得向量可以自适应地根据实际需要来动态地调整自己的容量呢？而且这种调整的过程既能保证足够同时又不致使得因为开辟的空间过多而导致空间效率的低下。 2.2.动态空间管理为了解决上述的问题，我们需要把刚才所采用的静态空间管理策略改变为所谓的动态空间管理策略，就是如果在某个时刻，某一个向量即将发生上溢，那么我们就适当地扩大内部数组的容量，使之足以容纳新的元素。按照这样一种策略向量的生命期可以大致由下面一组图来表示。 最开始的时候向量所存放的有效元素还不是很多，还不致于出现上溢的情况，这时候可以从容应对。但是剩余的空间有可能会逐步地被占用，直到某一个关键时刻，内部数组有可能已经饱和，这时就存在一个风险也就是说再插入一个元素的话，就会导致上溢。为此我们可以动态的申请另一段存放空间，当然它的大小应该比原来的有所增长。接下来我们要把原先已经存放好的那些有效元素，逐一地按次序地复制过来，从而使得它们对外界而言依然保持原貌。新多出来的这些空间就足够用以存放新需要插入的元素，而原来所占用的空间将在此之后被释放并且归还给系统。上述这样一个完整的调整过程可以描述并且实现为下面的c++的代码： 12345678910template&lt;typename T&gt;void Vector&lt;T&gt;::expand() &#123; //向量空间不足时扩容 if (_size &lt; _capacity) return; //尚未满员时，不必扩容 _capacity = max(_capacity, DEFAULT_CAPACITY); //不低于最小容量 T* oldElem = _elem; _elem = new T[_capacity &lt;&lt;= 1]; //容量加倍 for (int i = 0; i &lt; _size; i++) //复制原向量内容 _elem[i] = oldElem[i]; //T为基本类型，或已重载复制操作符'=' delete[] oldElem; //释放原空间&#125; 首先要判断现在是否处于即将发生上溢的临界状态，它的标志就是_size是否还继续严格地小于_capacity。如果是还不存在上溢的风险，可以直接返回，所以这里隐含着有一个else，即接下来_size虽然不一定大于_capacity，但是至少会出现等于_capacity的情况。 这时我们要做的是将原来的那个数据域做一个备份，接下来以原先的容量（注意这里是左移一位，相当于加倍）加倍的一个新的容量来申请一段动态空间，并且将这段空间交由原来的_elem来指示。接下来是复制，对从原先的那个数据域中逐一地取出各项，并且将其转移至新的这个数据域中对应的位置。在整体赋值完之后，原先的这个空间已经没有任何存在的意义了，所以通过delete操作将它释放。 其实对于尚未封装的数组同样可以采用上述的这样的一个策略，而对于向量而言，这里调整的优势体现在向量整体的封装性上。因为对于一般的数组，如果它经过了动态的重新分配地址，那么原先指向它内部的某些元素的一些指针就有可能会出现无效，即虽然它能指向一个地址但其中并没有存放所需要的数值。但是对于向量而言经过了这样的封装以后就安全了，因为无论是此前此后我们在访问某一个具体的元素的时候，在内部都是通过_elem这个统一的指示器来标识空间的起点。从这一点也可以看出进行封装以后的一个好处。 那么为什么要采用一个容量加倍的策略呢？采用其他策略，比如适当增加背部数组的容量，是否也可行呢？ 2.2.1.容量递增策略实际上情况并不那么简单，我们不妨以其中的一种典型的策略，即容量递增策略，来做一个对比。就是每当发现当前的内部数组即将发生上溢我们并不是对它进行容量的加倍，而只是在原来的容量的基础上追加一个固定的数额，这样看起来并没有什么问题。在代码上只需将原来的_capacity*2变成_capacity追加一个固定的数额，记为INCREMENT，简记作$I$。下面来考虑这个策略的效率。 在即将上溢之前，追加固定大小的容量 12T* oldElem = _elem;_elem = new T[_capacity += INCREMENT]; 最坏情况：在初始容量0的空向量中，连续插入$n = m * I$个元素（远大于2） 于是，在第$1, I+1, 2I+1, 3I+1,……$次插入时都需要扩容 即便不计申请空间操作，各次过程中复制原向量的时间成本依次为：$0,I,2I,\\dots,(m-1)I$（算术级数） 总体耗时 = $I\\times(m-1)\\times m/2=O(n^2)$，每次扩容的分摊成本为$O(n)$。 2.2.2.容量加倍策略 在即将上溢之前，使容量加倍 12T* oldElem = _elem;_elem = new T[_capacity &lt;&lt;= 1]; //容量加倍 最坏情况：在初始容量1的的满向量中，连续插入$n=2^m$个元素 于是，在第$1，2,4,8,16,32，\\dots$次插入时都需要扩容 各次扩容过程中复制原向量的时间成本依次为：$1,2,4,8,\\dots,2^m$ （几何级数） 总耗时 = $O(n)$，每次扩容的分摊成本为$O(1)$。 造成两种方法每次扩容分摊成本的时间复杂度出现很大差别的原因，可以用下图说明。实际上在向量规模不断递增达到某一固定的数值之前，如果采用的是递增式的增容策略，那么所需增容的操作必然是按当时的规模呈算数级数的形式分布。反过来如果是以倍增式的策略来进行的扩容，那么只需要进行其中的少数几次扩容就够了，具体来说就是这些以紫色标明的，可以看到要远远小于原先的数目，而且随着数组规模的增加，这种差异会更加的明显。 我们不妨将这两种策略所对应的性能列成如上面的一张表。在时间方面，在达到一个固定的规模n之前，累计所用的扩容时间：递增策略要多达$O(n^2)$，而倍增策略只需要$O(n)$，如果从分摊的意义上讲分摊到每一次扩容所需要的时间：前者是$O(n)$， 而后者是$O(1)$。可以看到就时间而言，容量加倍策略具有巨大的优势。而在空间方面，前一种策略似乎要非常好，因为它总是每次增加一个固定的数额，所以随着向量规模的增加，整个空间的利用率会越来越接近于百分之百。而加倍策略未必能做到百分之百，但是它至少有个底线，至少是50%，只有在它即将发生上溢，而因此刚刚通过加倍扩容的那个瞬间时才会是50%。所以相对而言，可以理解为倍增策略是通过在空间的效率上做了一个适当的牺牲，来换取在时间方面的巨大的收益，显然收益要远远大于损失。 2.3.平均分析 vs. 分摊分析平均复杂度或期望复杂度（average/expected complexity） 根据数据结构各种操作出现概率的分布，将对应的成本加权平均。 各种可能得操作，作为独立事件分别考查； 割裂了操作之间的相关性和连贯性； 往往不能准确地评判数据结构和算法的真实性能。 分摊复杂度（amortized complexity） 对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作。 从实际可行的角度，对一系列操作做整体的考量； 更加忠实地刻画了可能出现的操作序列； 可以更为精确地评判数据结构和算法的真实性能 3.无序向量回顾前两节，我们以向量为例给出了数据结构定义的一种通用方法，即模板，大致格式如下： 1template &lt;typename T&gt; Vector &#123; ...... &#125;; 这种方法实际上定义了 一系列的Vector，在使用的时候可以灵活指定它的类型。如果尖括号里是int的，那这个Vector实际上是a Vector of integers，即由一系列的整数组成的向量。更重要的是 在以后我们将利用这种方式来构造更为复杂的数据结构，比如可以把某些数据结构作为基本的组成元素来构成向量，举个例子在后面的学习中会定义二叉树Binary Tree这样一种数据结构，如果把BinTree作为基本的元素来构成Vector，那我们就可以构成一个由一系列的二叉树构成的一个线性序列，也就是A Vector of Binary Trees，取个形象的名字可以叫它forest 森林。在后面介绍霍夫曼编码的时候也会用到这种技巧，通过采用统一的模板式的方法，可以使得数据结构的定义非常的规范，而且更重要的是它们可以互相的融合组合，便捷地搭建更为复杂的数据结构。 12345Vector&lt;int&gt; myVector1;Vector&lt;float&gt; myVector2;Vector&lt;char&gt; myVector3;Vector&lt;BinTree&gt; forest; 这一节我们将围绕向量的最基本的形式，即无序向量来展开。无序向量不一定是说其中的元素没有顺序，甚至有时候其中的元素是根本就不可能排成顺序。在这样的一个前提下我们将研究如何来定义并且实现相应的操作接口。 3.1.循秩访问通过V.get(r)和V.put(r, e)接口，固然可以读，写向量元素，但便捷性远不如数组元素的下标式访问方式A[r]。通过重载下标操作符“ [ ] “，便可沿用数组的下标方式访问向量元素。对于任何一个指定的Rank r，只需在内部数据区中取出对应的第r号元素，此后凡是需要引用向量中的某个特定的比如说Rank为r的这个元素，就可以直接以这样一种类似于数组下标的形式进行引用。 123template&lt;typename T&gt;T&amp; Vector&lt;T&gt;::operator[](Rank r) const //0 &lt;= r &lt; _size &#123; return _elem[r]; &#125; 此后，对外的V[r]即对应于与内部的V._elem[r]。这种引用可以作为右值，以这种类似数组形式进行运算并且将运算的结果，向左侧赋值给某一变量；而反过来计算的结果也可以赋值给向量中某一个元素，也就是作为左值，因为这个接口返回值是一个引用。 右值：T x = V[r] + U[s] * W[t] 左值：V[r] = （T) (2*x + 3) 需要注意的是这里我们对入口参数r并没有做过多的检查，而是简易地在入口处增设了一个断言，用以提醒使用者保证入口参数r能够在合理的范围之内，但在真正的实际应用中，要做更为严格的处理。 3.2.插入 向量的插入算法具体来说就是如何将某一个特定的元素插入到向量的特定位置，在原来向量中因为所有的元素都必须是紧邻排列的，所以为了能够插入新的元素我们需要做一个调整，也就是将对应这个位置之后的所有的那些元素，称作它的后继，整体的构成一个后缀，进行一个整体的右移操作。这个right shift操作效果就是所有的后缀元素都向右移动一个单元，从而空出一个单，此时才可以将指定的那个元素纳入其中，从而完成插入。 整个算法可以描述并且实现如下的C++代码： 123456789template&lt;typename T&gt; //e作为秩为r的元素插入，0 &lt;= r &lt;= _sizeRank Vector&lt;T&gt;::insert(Rank r, T const&amp; e) &#123; expand(); //若有必要，扩容 for (int i = _size; i &gt; r; i--) //自后向前 _elem[i] = _elem[i - 1]; //后继元素顺次后移一个单元 _elem[r] = e; //置入新元素 _size++; //更新容量 return r; //返回秩&#125; 右移操作可以通过for循环完成，每个元素确实都是后移一位，当所有的后移完成之后，再将新的那个元素纳入到rank所指的位置上，当然同时还要更新整个向量的规模。 有两个需要注意的地方：第一，在for循环的方向是从最后一直向前不断地递减，也就是说整个的移动的方向虽然是向右，但是所有元素移动的先后次序却是后优先的，用图来表示也就是最后这个元素先移动，接下来是次后这个元素，再往前一直直到最前面的那个元素。这是必要的，如果把这个次序颠倒过来会有危险，会出现数据在无意中被覆盖的问题。 第二个主要注意的是expand()，即扩容操作，这是有必要的。因为确实在某些时候这个向量可能已经是满载的，所以为了插入新元素，在后移的过程中必然会出现上溢的情况，在这种时候就需要对向量进行扩容处理，比如上节的容量加倍策略，这样一件事情完全由expand()完成。 3.3.删除3.3.1.区间删除我们先考虑一个通用的一个版本，即区间删除，具体来说就是在某个向量中，我们要将介于lo和hi之间的一系列的元素成批地从中剔除掉。因为向量要求所有的元素始终都是彼此紧邻排列的，所以不应该在删除之后留下这个缝隙，换而言之，我们需要将它后继的那些元素（如果有的话）统一地向前或者说向左移动来填补这段空白。其实可以反过来看到如果能够完成这样的一个左移的话，那么实际上也就相当于把这些元素给剔除或者叫覆盖掉了，所以关键的任务在于如何实现这个左移。 这样的一个过程可以实现为下面代码： 12345678template&lt;typename T&gt; //删除区间[lo, hi)，0&lt;=lo&lt;=hi&lt;=_sizeint Vector&lt;T&gt;::remove(Rank lo, Rank hi) &#123; //O(n-hi) if (lo == hi) return 0; //处于效率考虑，单独处理退化情况 while (hi &lt; _size) _elem[lo++] = _elem[hi++]; //[hi, _size)顺次前移hi-lo个单元 _size = lo; shrink(); //更新闺蜜，若有必要则缩容 return hi - lo; //返回被删除元素的数目&#125; 代码中最关键的是while循环，它会遍历整个后缀，并且将其中的每一个元素逐一地取出，向前转移到合适的位置。比如第一个转移的是hi这个位置上的这个元素，它将被转移到lo这个位置，紧接着是hi+1转移到lo+1，hi+2转移到lo+2，直到最后。 同样有两个问题需要强调说明：第一个问题，在整个移动的过程中，所有这些元素参与移动的先后次序，同样也是很敏感的，或者说不能更改的，与插入算法完全颠倒，插入算法是自后向前，而区间删除算法是越往前的元素越优先参与移动，所以我们也可以认为它是一个自前向后的前移操作。如果把这个次序颠倒过来是有风险的，比如两者，即前缀的原来的那个位置和后来的那个位置中间有相互重叠的部分，如果优先移动后面的那个元素，那么就有可能会造成重叠区间的元素在无意中被覆盖掉。 第二点是shrink()这个历程的调用，它是某种意义上讲的缩容，这种操作在实际应用中并不是必须的，我们往往可以忽略它。 3.3.2.单元素删除上一小节中实现了区间的批量删除的接口，所以我们不妨把单元素的删除视作是整个区间操作的特例。具体来说，就是要将任何一个由单个元素构成的区间视作是由 r 到 r+1所定义的左闭右开的那段区间。这样就可以很简明地调用用此前重载的那个remove接口，只不过这里的参数改变为 r 和 r+1，与我们刚才的那种转换相对应。同理算法所进行的操作就是所有的后缀向前移动一个单位。 123456template&lt;typename T&gt; //删除向量中秩为r的元素，0 &lt;=r &lt; _sizeT Vector&lt;T&gt;::remove(Rank r) &#123; //O(n - r) T e = _elem[r]; //备份被删除的元素 remove(r, r + 1); //调用区间删除算法 return e; //返回被删除的元素&#125; 那么反过来，基于remove(r)接口，通过反复的调用，实现remove(lo, hi)是否可行呢。理论上是可行的，对于一个特定的一段从 lo 到 hi的区间，我们可以对其中的每一个元素分别去调用一次单元素删除接口，从而完成整体的删除操作。但是正如我们一直强调的，数据结构更多关注的是效率，而从效率上看这样做是非常差的。 首先考虑单元素删除本身的效率，最重要的实际上是这段区间也就是被删除元素的那些后继们，统一地要向前移动一次，这也是它的复杂度的来源。因此它的时间复杂度是取决于它的后继的个数，即为n-hi，最坏情况下是$O(n)$。如果按这种方式反复调用，有可能会导致$O(n^2)$的复杂度，在效率上是不能接受的。 3.4.查找查找即是按照某种特定的条件，从向量中找出特定的元素。首先我们要明确两个概念：判等与比较，对于任何的两个元素，我们来判断它们是否是相等，或者是比较它们之间谁大谁小，这两个操作并不是所有的类型都天然支持的。所以这里我们做一个假设：向量中元素的类型是基本类型，或者向量元素这个类已经重载了对应的判等的操作符或者是比较的操作符。无序向量可以一般性地认为它只支持判等操作，而对于有序向量，要求要更高一点，它还需要支持其中的元素能够相互比较大小。 无序向量：T为可判等的基本类型，或已重载操作符=或!= 有序向量：T为可比较的基本类型，或已重载操作符&lt;或&gt; 无序向量的查找过程可以描述为下图，如果查找的区间范围是 lo 到 hi 的话，就从 hi 出发逆向地、逐一地取出向量中的各个元素与目标元素进行比对，如果不相等就忽略它，进而考察它的前驱，所以整个的工作会亦步亦趋地逐个地遍历向量中的所有的元素。 经过这样一个逆向地扫描的过程，我们很有可能在中间的某一步找到所需要的那个目标，即查找成功；如果一直持续到最后，在试图越过lo也就是合法的最左侧的边界的时候，就可以断定整个查找是失败的。这个算法可以通过下面的代码实现： 1234567template&lt;typename T&gt; // 0 &lt;= lo &lt; hi &lt;= _sizeRank Vector&lt;T&gt;::find(T const &amp;e, Rank lo, Rank hi) cosnt&#123; //O(hi - lo) = O(n)，在命中多个元素时可返回秩最大者 while ((lo &lt; hi--) &amp;&amp; (e != _elem[hi])); //逆向查找 return hi; // hi &lt; lo 意味着失败，否则hi即命中元素的秩&#125; // Excel::match(e, range, type) 需要注意的是，find函数返回的都是最终停止的那个位置，有可能是合法的一个位置。也可能是刚刚越过左边界的那个非法的位置。而具体判别是否成功可以交给上层的调用者，因为他通过这个秩是否是合法就可以判断查找是否成功，如果是成功的话这样一个秩将可以被高层的算法进一步地利用。 我们也可以看出这个算法的复杂度有很大的变化空间，在最好的情况下，可能在第一个元素位置上就顺利地命中所以这时复杂度是常数$O(1)$；但是在最坏的情况下，比如一直持续到比较后才发现这个元素，甚至一直持续到最终也没有发现我们的目标元素，为此在这个过程中我们需要扫描的元素可能会与向量的规模相当，复杂度就会是$O(n)$。 这样一种在最好和最坏情况下相差极其悬殊的算法，叫作输入敏感算法（input-sensitive），即它的复杂度具体是多少与输入时候数据的配置紧密相关。 输入敏感（input-sensitive）：最好$O(1)$，最差$O(n)$。（对本例而言） 3.5.唯一化问题无序向量的唯一化问题，即是把其中重复的元素都剔除掉，使得每一组重复的元素只保留一个拷贝。在很多实际的应用中都能够找到唯一化的影子，比如在网络搜索的环境中有很多个不同的结点所分工完成的局部的搜索结果，可能会含有大量的重复的元素，我们需要将其中重复的元素剔除掉，从而得到一份记忆完整同时又不冗余的搜索报告。这样一个算法大致可以通过这样的一个图示来表示它的原理： 对于一个向量，我们总是把它分为三个部分，以当前的这个元素为界，当前这个元素自己是一部分，它的前驱所构成的前缀是一部分，以及对称地，所有的后继是一部分。每一次我们遇到一个新的元素，都在它的前缀中去进行查找，这可以通过find操作来完成的，如果能够找到雷同的元素，比如在某个位置上出现了一个x，就可以把这个元素剔除掉。反之，经过查找以后，如果这个元素没有出现，那么我们就可以把它保留下来，同时再去考察它的下一个元素。这个算法可以由下面的代码实现： 12345678910template&lt;typename T&gt; //删除重复元素，返回被删除元素数目int Vector&lt;T&gt;::deduplicate() &#123; int oldSize = _size; //记录原规模 Rank i = 1; //从_elem[1]开始 while (i &lt; _size) //自前向后逐一考查各元素_elem[i] (find(_elem[i], 0, i) &lt; 0) ? //在前缀中寻找雷同者 i++ //若无雷同者则继续考查其后继 : remove(i); //否则删除雷同者（可以是多个） return oldSize - _size; //返回向量规模变化量，即删除元素总数&#125; 3.5.1.正确性那么我们如何给出这个算法正确性的严格证明呢？同样根据第一章学到的知识，我们通过挖掘算法所具有的不变性和单调性，来证明一个算法最终的正确性。 首先来证明不变性，我们发现在这个算法运行的任何一个时刻，如果当前所对应的是第i个元素V[i]的话，那么在它所对应的那个前缀中所有的元素必然是彼此互异，即不包含重复元素。当算法开始时i=1，它的前缀只有V[0]。 其余的一般情况下可以用数学归纳法来予以证明：假设当时的状态是第i个元素e，它的前缀是从0到i的区间。按照数学归纳法我们假设在此前不变性是成立的话，那么接下来，无非两种情况，即当前的这次对应的查找成功或者失败。 如果是失败，即在它的前缀中不含元素e，算法给出的处理方法是直接令i++，也就是我们已经指向了它的下一个元素，而将刚才那个元素e归入了新的这个前缀中。既然e和此前的那些前缀是互不重复的，所以将e归入这样的一个区间以后，这个区间必然是不含重复元素的。 反之如果如果查找成功，e出现在它的前缀中，按照算法流程会将它剔除掉，也就是通过删除操作使得后继的元素整体地向前移动，从而使得原先它的直接后继变为当前的这个元素，并且算法继续地运转下去。经过了这样一次迭代之后当前的这个元素虽然换了，但是它的前缀并没有换，这个前缀所具有的元素互异的性质也依然会保持下来。 算法运行到最终是覆盖整个向量，到那时我们所说的当前的元素其实就是最末尾的那个哨兵元素，而它的前缀其实就是整个向量，那么它的前缀中不包含重复的元素其实也就相当于整体的向量中不包含重复的元素，这正是我们这个算法的功能唯一化所要求的，所以在最终这个不变性必然会转化为我们所需要的正确性 接着我们证明单调性，这个算法的主体是由一个while循环构成的，随着反复的while迭代: 当前元素前缀的长度单调非降，且迟早增至_size 当前元素后缀的长度严格单调下降，且迟早减至0 所以算法待处理元素的个数会严格单调减少，算法必然终止，且至多迭代$O(n)$轮。 3.5.2.复杂度这个算法的主体是while循环，而在while循环中真正能够造成有效复杂度的是find操作和remove操作，其中find操作是对于当前的元素的整个前缀而言的，而remove操作恰好对称是相对于当前这个元素的后继而言的。所以每一次while循环所需要的成本也就是find和remove两类操作的成本，累计起来也不会超过整个向量的长度，即$O(n)$线性步。而while循环最多会迭代$O(n)$轮，所以这个算法累计起来最多不超过$O(n^2)$的时间复杂度，这也是最坏情况。 这个算法也可以进一步的优化。 3.6.遍历遍历就是按照某种事先约定的操作（称之为visit），对向量中的每一个元素逐一地、统一地执行一次。所以这里涉及到两个问题：第一，如何来指定或者来描述这样一个visit操作；第二，如何将它传递到向量内部的每一个具体的元素。 通常有两种方法：第一种是使用函数指针，也就是说可以对于vector这样一个类定义一个traverse接口，作为它的参数visit本身就是一个函数的指针。所以为了兑现这样的一个遍历操作我们只需要逐一地取出向量中由这个i确定的每一个元素通过这个函数指针找到这个函数，并且对这个元素实施这个函数所指定的操作。 12345template&lt;typename T&gt;void Vector&lt;T&gt;::traverse(void(*visit)(T&amp;))&#123; //函数指针 for (int i = 0; i &lt; _size; i++) vist(_elem[i]);&#125; 第二种方式是使用函数对象，也就是说我们指定的这个参数visit，本身就是一个对象，它的作用就是用来模拟一个操作一个函数的一个行为方式。所以同样地，我们也可以对这个向量中的每一个元素都逐一地取出，并且转交给这样一个函数对象，通过它来实施具体地、统一地操作。 12345template&lt;typename T&gt; template&lt;typename VST&gt;void Vector&lt;T&gt;::traverse(VST&amp; visit) &#123; //函数对象 for (int i = 0; i &lt; _size; i++) vist(_elem[i]);&#125; 这两种方法其实是非常接近，但是也有一些重要的区别，相对而言，后一种方式的通用性更强。 下面通过一个实例来了解如何通过函数对象，实现刚才所说的具体地遍历。比如说，我们可以考虑将向量中的所有的元素统一地各自+1。为此我们只需要实现一个对应功能的函数对象，它本身也是以一个类的形式给出来的。这里为了简化起见使用了struct，而没有进行过多的封装。这个对象最重要的一个作用或者说唯一的作用就是重载了它的圆括号操作符()，从而使得它在行为上与一个函数非常的类似，而具体的功能就是把每一个参数e做一个+1操作。 1234template&lt;typename T&gt; //假设T可直接递增或已重载操作符“++”struct Inciease &#123; //函数对象：通过重载操作符\"()\"实现 virtual void operator()(T &amp; e) &#123; e++; &#125; //加一&#125;; 在实现了这样一个对应的类之后，就可以通过调用vector统一遍历接口traverse，将我们刚刚编写的这个函数对象以参数的形式传入就可以实现相应的功能，也就是把向量中的每一个元素统一地加一。 1234template&lt;typename T&gt;void increase(Vector&lt;T&gt; &amp; V) &#123; V.traverse(Increase&lt;T&gt;()); &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"数据结构与算法（1）","slug":"数据结构与算法（1）","date":"2020-02-05T02:32:06.000Z","updated":"2020-02-07T02:32:06.000Z","comments":true,"path":"2020/02/05/数据结构与算法（1）/","link":"","permalink":"http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/","excerpt":"","text":"计算对象：规律，技巧 目标：高效，低耗 Computer science should be called called computing science, for the same reason why surgery is not called knife science. -E.Dijkstra 计算 = 信息处理 ​ 借助某种工具，遵照一定规则，以明确而机械的形式进行 计算模型 = 计算机 = 信息处理工具 算法所谓算法，即特定计算模型下，旨在解决特定问题的指令序列 ​ 输入：待处理的信息（问题） ​ 输出：待处理的信息（答案） ​ 正确性：的确可以解决指定的问题 ​ 确定性：任一算法都可以描述为一个由基本操作组成的序列 ​ 可行性：每一基本操作都可以实现，且在常数时间内完成 ​ 有穷性：任一算法在执行有限次基本操作之后终止并给出输出 列子：Hailstone序列 \\begin{align*}& 序列Hailstone(n)=\\begin{cases}\\{1\\} &n\\le1\\\\\\{n\\}\\cup Hailstone(n/2) &n为偶数\\\\\\{n\\}\\cup Hailstone(3n+1) &n为奇数\\end{cases}\\\\\\\\&Hailstone(42)=\\{ 42,21,64,32,\\dots,1\\}\\end{align*}12345int hailstone(int n)&#123;//计算序列Hailstone(n)的长度 int length = 1; //从1开始递推 while (n&lt;1) &#123; (n % 2) ? n = 3 * n + 1 : n / = 2; lenth++; &#125; return length; //返回hailstone(n)&#125; 问题：对于任意的n，总有|Hailstone(n)| &lt; ∞ ？ 目前还不能证明 程序不一定是算法 好算法正确：符合语法，能够编译，链接 ​ 能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入 健壮：能辨别不合法的输入并做适当处理，而不致非正常退出 可读性：结构化 + 准确命名 + 注释 + … 效率：速度尽可能快 ；存储空间尽可能少 （最重要的） ​ Algorithms + Data Structures = Programs -N. Wirth, 1976 ​ (Algorithms + Data Structures) × Efficiency = Computation 计算模型好的数据结构和算法才能有高效的计算，从而有好的应用。 算法分析两个主要方面： ​ 正确性：算法功能与问题要求一致？ ​ 数学证明？并不简单 ​ 成本： 运行时间+所需存储空间 ​ 如何度量？如何比较？ 考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。 ​ 意义不大，因为可能出现的问题实例太多。那么如何归纳概括？ 观察：问题实例的规模，往往是决定计算成本的主要因素。 特定算法 + 不同实例 令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。 ​ 讨论特定算法A（及其对应的问题）时，简记作$T(n)$。 然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。 稳妥起见，取$T(n) = max\\{ T(P)| |P| = n \\}$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。 特定问题 + 不同算法 同一问题通常有多种算法，如何评判其优劣？ 实验统计是最直接的方法，但足以准确反映算法的真正效率？ 但实验统计还是不足够的，还要考虑： 不同的算法，可能更适应于不同规模的输入 不同的算法，可能更适应 与不同类型的输入 同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现 同一算法，可能实现并运行与不同的体系结构、操作系统 为给出客观的评判，需要抽象出一个理想的平台或模型 不再依赖于上述种种具体的因素 从而直接而准确地描述，测量并评价算法 图灵机 Turing Machine Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’ Alphabet：字符的种类有限 Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格 State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态 Transition Function ：（q, c; d, L/R, P) ​ 若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格； ​ 转入p状态，一旦转入特定的状 态’h’，则停机。 RAM: Random Access Machine 与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。 在这些模型中： 算法的运行时间 转化为 算法需要执行的基本操作次数 $T(n)$ = 算法为求解规模为n的问题，所需执行的基本操作次数 大$O$记号渐进分析 回到原先的问题：随着问题规模的增长，计算成本如何增长？ ​ 注意：这里更关心足够大的问题，注重考察成本的增长趋势 渐进分析：在问题规模足够大后，计算成本如何增长？ ​ Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法 ​ 需执行的基本操作次数：T(n) = ? ​ 需占用的存储单元数：S(n) = ? //通常可不考虑 大$O$记号（big-$O$ notation） \\begin{align*} &T(n)=O(\\,f(n)\\,)\\quad if \\quad \\exists c>0, 当n>>2后，有T(n)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Cpp基础（7）类和对象","slug":"Cpp基础（7）类和对象","date":"2020-02-04T08:09:38.000Z","updated":"2020-02-14T08:09:38.000Z","comments":true,"path":"2020/02/04/Cpp基础（7）类和对象/","link":"","permalink":"http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象程序设计的基本特点抽象：对同一类对象的共同属性和行为进行概括，形成类。 首先注意问题的本质及描述，其次是实现过程或细节。 数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。 代码抽象：描述某类对象的共有的行为特征或具有的功能。 抽象的实现：类。 12345678class Clock&#123; public: void setTime(int newH, int newM. int newS); void showTiem(); private: int hour, minute, second;&#125; 封装：将抽象出的数据，代码封装在一起，形成类。 目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。 实现封装：类声明中的{ } 继承：在已有类的基础上，进行扩展形成新的类。 多态：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。 类和对象的定义对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。 设计类就是设计类型，需要关注哪些问题： 此类型的“合法值”是什么？ 此类型应该有什么样的函数和操作符？ 新类型的对象该如何被创建和销毁？ 如何进行对象的初始化和赋值？ 对象作为函数的参数如何以值传递？ 谁将使用此类型的对象成员？ 类定义的语法形式123456789class 类名称&#123; public: 公有成员（外部接口） private: 私有成员 protected: 保护型成员&#125; 在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。 12345678class Clock&#123; public: void setTime(int newH, int newM. int newS); void showTiem(); private: int hour = 0, minute = 0, second = 0;&#125; 类成员的访问控制公有类型成员：在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。 私有类型成员：在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字private可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。 保护类型成员：与private类似，其差别表现在继承与派生时对派生类的影响不同。 类中成员之间直接使用成员名互相访问。 从类外访问成员使用“ 对象名.成员”，来访问公有成员。 类的成员函数在类中声明函数原型： 可以直接在类中给出函数体，形成内联成员函数； 12345678910//定义一个矩形的类class Rectangle&#123; private: int w; int h; public: int getArea() &#123; return w*h; &#125; int getPerimeter() &#123; return 2*(w+h); &#125;&#125;; 也可以在类外给出函数体实现，并在函数名前用类名加以限定； 12345678910111213//定义一个矩形的类class Rectangle&#123; private: int w; int h; public: int getArea(); int getPerimeter();&#125;;int Rectangle::getArea() &#123; return w*h; &#125;int Rectangle::getPerimeter() &#123; return 2*(w+h); &#125; 允许声明重载函数和带默认参数值的函数。 例子：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Circle&#123;private: double x; double y; double r;public: void setM(double _x, double _y) &#123; x = _x; y = _y; &#125; void setR(double _r) &#123; r = _r; &#125; double getArea() &#123; return 3.14 * r * r; &#125; double getPerimeter() &#123; return 2 * 3.14 *r; &#125;&#125;;int main()&#123; Circle myCircle; myCircle.setM(1.7, 3.2); myCircle.setR(4.2); double myArea = myCircle.getArea(); double myPeri = myCircle.getPerimeter(); cout &lt;&lt; \"Area = \" &lt;&lt; myArea &lt;&lt; \", Perimeter = \" &lt;&lt; myPeri &lt;&lt; endl; myCircle.setR(8.4); myArea = myCircle.getArea(); myPeri = myCircle.getPerimeter(); cout &lt;&lt; \"Area = \" &lt;&lt; myArea &lt;&lt; \", Perimeter = \" &lt;&lt; myPeri &lt;&lt; endl;&#125; 构造函数当我们定义对象时，如何对对象进行初始化？在定义基本类型的变量时，是可以直接给定初始值的，但是在定义对象时却不是这么简单，因为一个类是我们自己定义的，对类的对象按照什么规则进行初始化，编译器是不会自动知道的，必须由程序员写程序来规定。为此C++中提供了一种特殊的机制：构造函数，在构造函数中我们可以描述如何对类的对象进行初始化。 基础知识构造函数的作用 在对象被创建时使用特点的值构造对象，将对象初始化为一个特定的初始状态 例如：希望在构造一个Clock类对象时，将初始时间设为0:0:0，就可以通过构造函数来设置 构造函数的形式 函数名与类名相同； 不能定义返回值类型，也不能在函数体有return语句； 可以有形式参数，也可以没有形式参数； 可以是内联函数； 可以是重载； 可以带默认参数值。 构造函数的调用时机 在对象创建时被自动调用，但如果没有定义构造函数就进行初始化，那么编译器就会报错。 1Clockk myClock(0,0,0); 默认构造函数调用时可以不需要实参的构造函数： 参数表为空的构造函数 全部参数都有默认值的构造函数 下面两个都是默认构造函数，如在类中同时出现，将产生编译错误，不是合法的函数重载形式 12Clock();Clock(int newH=0, int newM=0, int newS=0) 隐含生成的构造函数如果在程序中未定义构造函数，编译器将在需要时自动生成一个默认的构造函数： 参数列表为空，不为数据成员设置初始值； 如果类内定义了成员的初始值，则使用内类定义的初始值； 如果没有定义类内的初始值，则以默认方式初始化； 基本类型的数据默认初始化的值是不确定的。 如果定义的类的成员不是基本类型的成员，而是其他类的对象，这个就是类组合的情况，其默认的初始化方式由它所属的类决定。 =default如果程序中已定义构造函数，默认情况下编译器就不会再隐含生成默认构造函数。如果此时依然希望编译器隐含生成的默认构造函数，可以使用=default。 1234567class Clock&#123; public: Clock() = default; Clock(int newH, int newM, int newS); private: int hour, minute, second;&#125; 例子1 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;class Clock &#123;public: Clock(int newH, int newM, int newS); void setTime(int newH, int newM, int newS); void showTime();private: int hour, minute, second;&#125;;Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; //初始化列表int main() &#123; Clock c(0, 0, 0); c.showTime(); return 0;&#125; 例子2 1234567891011121314151617class Clock &#123;public: Clock(int newH, int newM, int newS); //构造函数 Clock(); //默认构造函数，如果类要重复使用，一般要提供一个默认构造函数 void setTime(int newH, int newM, int newS); void showTime();private: int hour, minute, second;&#125;;Clock::Clock():hour(0),mintue(0),second(0)&#123;&#125; //默认构造函数Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; int main()&#123; Clock c1(8,10,0); //调用有参数的构造函数 Clock c2; //调用无参数的默认构造函数&#125; 委托构造函数当我们在一个类中重载多个构造函数的时候，往往发现这些构造函数它们只是形参表不同，初始化列表不同，而其他都是一样的，初始化算法都是相同的，函数体都是相同的。那么在这种情况下，如果我们写多个函数体来重载，往往就显得重复了，为了避免这种重复，C++11新标准提供了一种新的机制：委托构造函数，也就是让一个构造函数可以去委托另一个构造函数去帮它完成初始化功能。 回顾Clock类的两个构造函数，第一个构造函数是有三个参数的，第二个构造函数是默认构造函数，没有参数。实际上，这两个构造函数进行初始化的方式是完全一样的，只不过第一个构造函数是用参数表里的参数进行初始化，第二个构造函数用默认状态全部用0进行初始化。那么我们其实没有必要写两个类似的重复的代码。 12Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125; Clock::Clock():hour(0),mintue(0),second(0)&#123;&#125; //默认构造函数 委托构造函数使用类的其他构造函数执行初始化过程，我们用委托构造函数的方法重写上面的代码，这里第二个构造函数调用了另外一个有参数的构造函数，将默认的三个初始化参数传给有参数表的Clock构造函数，这样就不用把同样的初始化方法再写一遍了。 12Clock::Clock(int newH, int newM, int newS) :hour(newH), minute(newM), second(newS) &#123;&#125;Clock::Clock():Clock(0,0,0)&#123;&#125; 用委托构造函数不仅可以减少重复的工作，其最大的好处是可以保持代码实现的一致性，如果想要修改构造函数的初始化算法时，就只需在一处修改，其他的委托这个构造函数来进行初始化的构造函数的算法也就同步修改了。 复制构造函数当我们在定义一个基本类型的变量时，经常会用一个已经存在的已经有值的变量去初始化这个变量；我们在定义对象时可会有这样的需求，即用一个存在的对象去初始化一个新的对象，这时要如何实现这种初始化呢？C++中提供了一种特殊的构造函数，叫复制构造函数。 在复制构造函数中我们可以规定如何用一个已经存在的对象去初始化一个新对象，可以用这个已经存在的对象的引用作为构造函数的参数。如果在定义类的时候没有定义复制构造函数，编译器也生成一个默认的复制构造函数，它会实现类的两个对象的数据成员之间一一对应复制，这些功能在很多时候已经能满足需求，那么我们就不需要再写复制构造函数了。 复制构造函数定义 复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。 由于复制构造函数的目的不会是将原有的那个形参对象给修改了，所以最好是在形参引用前加上const关键字 123456789class 类名&#123; public: 类名(形参)； //构造函数 类名(const 类名 &amp;对象名); //复制构造函数 //......&#125;;类名::类(const 类名 &amp;对象名) //复制构造函数的实现&#123; 函数体 &#125; 复制构造函数的调用除了在定义新对象时，用已有的对象作为参数去初始化它这种情况以外，共有三种情况是典型的要调用复制构造函数的情况： 定义一个对象时，以本类另一个对象作为初始值，发生复制构造； 如果函数的**形参是类的对象**，调用函数时，将使用实参对象初始化形参对象，发生复制构造； 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。 隐含的复制构造函数 如果程序员没有为类拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数； 这个构造函数的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。 如果类的成员中有指针的时候，很多情况下，默认的复制构造函数其浅层的复制功能就不够用了，这是我们就需定义深层的复制构造。 =delete如果我们不希望对象被复制构造，那么可以采用下面的方法: C++98做法：将复制构造函数声明为private，并且不提供函数的实现。 C++11做法：用=delete指示编译器不生成默认复制构造函数。 1234567class Point&#123; public: Point(int xx=0, int yy=0) &#123;x=xx; y=yy&#125; //构造函数，内联 Point(const Point &amp;p) = delete; //指示编译器不生成默认复制构造函数 private: int x, y;&#125; 析构函数当一个对象在存续期间会占用系统资源，当这个对象的生存期结束时，需要进行善后工作将其删除清理掉，C++中提供了这样一种机制：析构函数。当对象被构造时，构造函数会自动调用；当对象要消亡时，其析构函数也会自动调用。 完成对象被删除前的一些清理工作； 在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间； 如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空； 析构函数的原型：~类名( ); 析构函数没有参数，没有返回类型 123456789101112class Point&#123; public: Point(int xx, int yy) //构造函数 ~Point(); //析构函数 private: int x, y;&#125;Point::Point(int xx, int yy)&#123; x=xx; y=yy;&#125;Point::~Point()&#123;&#125; 类的组合在制造业多年来都一直使用部件组装的生产方式，与一切手工从头做起相比，部件组装的生产效率肯定是要高，产品的标准化 它的可靠性也都更好。在程序中我们也可以借用这种部件组装的思想，用已经存在的这些类去组装新的类，C++语言支持类的组合。我们在定义一个新类的时候，可以让它的类成员是已有类的对象，也就是说一些类的对象可以作为另外一个类的部件，这就是类的组合。 类组合的基本概念： 类中的成员是另外其他类的对象； 可以在已有抽象的基础上实现更复杂的抽象。 成员对象：一个类的成员变量是另一个类的对象 包含成员对象的类叫封闭类（Enclosing） 类组合的构造函数设计那么组合类的构造函数如何设计呢？每个类的构造函数都是负责自己本类成员初始化的，如果用另外类的对象作为新定义类的成员，那么这个组合类是没有权利去访问部件对象内部的私有成员。因为一个类的私有成员只有这个类内部的函数可以访问，类外任何地方是不可以访问的，而且部件类的设计者、开发者，跟组合类的设计者 开发者可能不是一个人，甚至不是一个团队。因此在写组合类的构造函数时要考虑，由组合类的构造函数负责将部件对象初始化所需要的初始化参数传递给它，然后编译器会自动去调用部件类的构造函数，来初始化这些部件对象。其语法形式如下： 原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。 声明形式：初始化列表 12345类名::类名(对象成员所需的形参，本类成员形参): 对象1(参数), 对象2(参数),...... &#123; //函数体其他语句 &#125; 构造组合类对象时的初始化次序 首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。 成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造 初始化列表中未出现的成员对象，调用默认构造函数（即无形餐的）初始化 处理完初始化化列表之后，再执行构造函数的函数体 也可以这样理解，构造函数和析构函数的调用顺序： 当封闭类对象生成时： S1：执行所有成员对象的构造函数 S2：执行封闭类的构造函数 成员对象的构造函数调用顺序 和成员对象在类中的说明顺序一致 与在成员初始化列表中出现的顺序无关 当封闭类的对象消亡时 S1：先执行封闭类的析构函数 S2：再执行成员对象的析构函数 析构函数顺序和构造函数的调用顺序相反（先构造的后析构，后构造的先析构） 需要注意的是，我们在写类的构造函数时，最好再写一个无参数的默认构造函数。当这个类的对象被用作其他类的部件成员时，可能组合类中没有写构造函数只使用默认构造函数，这个时候我们上面的操作就显得很必要了。 例子：构造一个Point类，再用Point类构造组合类Line类，通过构造函数和复制构造函数中的“调试信息”（cout&lt;&lt;……）可以更好地理解构造函数和复制构造函数的调用过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Point &#123; //Point类的定义public: Point(int xx = 0, int yy = 0) &#123; x = xx; y = yy; &#125; Point(Point &amp;p); int getX() &#123; return x; &#125; int getY() &#123; return y; &#125;private: int x, y;&#125;;Point::Point(Point &amp;p) &#123; //复制构造函数的实现 x = p.x; y = p.y; cout &lt;&lt; \"Calling the copy constructor of Point\" &lt;&lt; endl;&#125;//类的组合class Line &#123; //Line类的定义public: //外部接口 Line(Point xp1, Point xp2); Line(Line &amp;l); double getLen() &#123; return len; &#125;private: //私有数据成员 Point p1, p2; //Point类的对象p1,p2 double len;&#125;;//组合类的构造函数Line::Line(Point xp1, Point xp2) :p1(xp1), p2(xp2) &#123; cout &lt;&lt; \"Calling constructor of Line\" &lt;&lt; endl; double x = static_cast&lt;double&gt;(p1.getX() - p2.getX()); double y = static_cast&lt;double&gt;(p1.getY() - p2.getY()); len = sqrt(x*x + y * y);&#125;//组合类的复制构造函数Line::Line(Line &amp;l) :p1(l.p1), p2(l.p2) &#123; cout &lt;&lt; \"Calling the copy constructor of Line\" &lt;&lt; endl; len = l.len;&#125;//主函数int main() &#123; Point myp1(1, 1), myp2(4, 5); Line line(myp1, myp2); Line line2(line); cout &lt;&lt; \"The length of the line is: \"; cout &lt;&lt; line.getLen() &lt;&lt; endl; cout &lt;&lt; \"The length of the line2 is: \"; cout &lt;&lt; line2.getLen() &lt;&lt; endl; return 0;&#125; 前向引用声明类应该先声明，后使用，如果需要在某个类的声明之前引用该类，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其他地方。前向引用声明某个类之后，可在之后的其他类的成员函数中将该类作为参数类型使用。 123456789class B; //前向引用声明class A&#123; public: void f(B b);&#125;;class B&#123; public: void g(A a);&#125; 需要注意的是： 使用前向引用声明虽然可以解决一些问题，但它并不是万能的。 在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。 当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。 1234567class Fred; //前向引用声明class Barney&#123; Fred x; //错误：类Fred的声明尚不完整，不能声明该类的对象&#125;;class Fred&#123; Barney y;&#125; 示例 声明一个CPU类，包含等级（rank）、频率（frequency）、电压（voltage）等属性，有两个公有成员函数run、stop。其中，rank为枚举类型CPU_Rank，声明为enum CPU_Rank {P1=1,P2,P3,P4,P5,P6,P7}，frequency为单位是MHz的整型数，voltage为浮点型的电压值。类似地声明一个RAM类。 声明一个简单的Computer类，有数据成员芯片（cpu）、内存（ram），有两个公有成员函数run、stop。cpu为CPU类的一个对象，ram为RAM类的一个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;using namespace std;enum CPU_Rank &#123; P1 = 1, P2, P3, P4, P5, P6, P7 &#125;;class CPU&#123;private: CPU_Rank rank; int frequency; float voltage;public: CPU(CPU_Rank r, int f, float v) //构造函数 &#123; rank = r; frequency = f; voltage = v; cout &lt;&lt; \"构造了一个CPU!\" &lt;&lt; endl; &#125; CPU(CPU &amp;c) //复制构造函数 &#123; rank = c.rank; frequency = c.frequency; voltage = c.voltage; cout &lt;&lt; \"复制构造了一个CPU！\" &lt;&lt; endl; &#125; ~CPU() &#123; cout &lt;&lt; \"析构了一个CPU!\" &lt;&lt; endl; &#125; //析构函数 CPU_Rank GetRank() const &#123; return rank; &#125; //外部接口 int GetFrequency() const &#123; return frequency; &#125; float GetVoltage() const &#123; return voltage; &#125; void SetRank(CPU_Rank r) &#123; rank = r; &#125; void SetFrequency(int f) &#123; frequency = f; &#125; void SetVoltage(float v) &#123; voltage = v; &#125; void Run() &#123; cout &lt;&lt; \"CPU开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; cout &lt;&lt; \"CPU停止运行!\" &lt;&lt; endl; &#125;&#125;;enum RAM_TYPE &#123; DDR2 = 2, DDR3, DDR4 &#125;;class RAM&#123;private: enum RAM_TYPE type; unsigned int frequency; //MHz unsigned int size; //GBpublic: RAM(RAM_TYPE t, unsigned int f, unsigned int s) //构造函数 &#123; type = t; frequency = f; size = s; cout &lt;&lt; \"构造了一个RAM！\" &lt;&lt; endl; &#125; RAM(RAM &amp;c) //复制构造函数 &#123; type = c.type; frequency = c.frequency; size = c.size; cout &lt;&lt; \"复制构造了一个RAM！\" &lt;&lt; endl; &#125; ~RAM() &#123; cout &lt;&lt; \"析构了一个RAM！\" &lt;&lt; endl; &#125; //析构函数 RAM_TYPE GetType() const &#123; return type; &#125; unsigned int GetFrequency() const &#123; return frequency; &#125; unsigned int GetSize() const &#123; return size; &#125; void SetType(RAM_TYPE t) &#123; type = t; &#125; void SetFrequency(unsigned int f) &#123; frequency = f; &#125; void SetSize(unsigned int s) &#123; size = s; &#125; void Run() &#123; cout &lt;&lt; \"RAM开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; cout &lt;&lt; \"RAM停止运行!\" &lt;&lt; endl; &#125;&#125;;//COMPUTER类class COMPUTER&#123;private: CPU my_cpu; RAM my_ram; unsigned int storage_size; //GB unsigned int bandwidth; //MBpublic: COMPUTER(CPU c, RAM r,unsigned int s, unsigned b); //构造函数 ~COMPUTER() &#123; cout &lt;&lt; \"析构了一个COMPUTER！\" &lt;&lt; endl; &#125; //析构函数 void Run() &#123; my_cpu.Run(); my_ram.Run(); cout &lt;&lt; \"COMPUTER开始运行!\" &lt;&lt; endl; &#125; void Stop() &#123; my_cpu.Stop(); my_ram.Stop(); cout &lt;&lt; \"COMPUTER停止运行!\" &lt;&lt; endl; &#125;&#125;;//COMPUTER类的构造函数，内嵌对象采用初始化列表初始化//一共会调用两次复制构造函数，形实结合调用依次，初始化列表调用依次//当COMPUTER构造函数结束以后，形实结合那个形参的生命周期就结束，于是执行析构函数COMPUTER::COMPUTER(CPU c, RAM r, unsigned int s, unsigned int b) :my_cpu(c), my_ram(r)&#123; storage_size = s; bandwidth = b; cout &lt;&lt; \"构造了一个COMPUTER！\" &lt;&lt; endl;&#125;int main()&#123; CPU a(P6, 300, 2.8); a.Run(); a.Stop(); cout &lt;&lt; \"***********************\\n\"; RAM b(DDR3, 1600, 8); b.Run(); b.Stop(); cout &lt;&lt; \"***********************\\n\"; COMPUTER my_computer(a, b, 128, 10); cout &lt;&lt; \"***********************\\n\"; my_computer.Run(); my_computer.Stop(); cout &lt;&lt; \"***********************\\n\"; //return之前会执行析构函数，先析构my_computer，和它的两个内嵌成员，然后析构CPU a和RAM b return 0;&#125; PS：结构体，联合体，枚举类的内容在上一篇文章Cpp基础（6）中。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（6）结构体与链表","slug":"Cpp基础（6）结构体与链表","date":"2020-02-02T09:03:07.000Z","updated":"2020-02-03T09:03:07.000Z","comments":true,"path":"2020/02/02/Cpp基础（6）结构体与链表/","link":"","permalink":"http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/","excerpt":"","text":"结构体结构体是一种特殊形态的类，与类的唯一区别是：类的缺省访问权限是private，结构体的缺省访问权限是public。 那么什么时候用结构体而不用类：定义主要用来保存数据，没没有什么操作的类型。人们习惯将结构体的数据成员设为公有，这时使用结构体更方便。 结构体相当于构造了一个新的数据类型，用一组变量描述同一个“事物”。 123456789struct stduent&#123; int id; char name[20]; char sex; int age; float score; char addr[30];&#125;; //注意大括号后的\" ; \" 定义结构体变量的方式： 直接用已声明的结构体类型定义变量名 1student student1, student2; 在声明类型的同时定义变量 123456789struct stduent&#123; int id; char name[20]; char sex; int age; float score; char addr[30];&#125;student1,student2; 结构体数据类型的特性与普通数据类型的特性是一致的，可以赋值，做函数参数，有指向结构体的指针，结构体数组等等。 定义结构体类型的变量12345678910111213141516#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; mike.id_num = 2123000 + mike.id_num; for (int i = 0; mike.name[i] != '\\0'; i++) mike.name[i] = toupper(mike.name[i]); cout &lt;&lt; mike.id_num &lt;&lt; \" \" &lt;&lt; mike.name &lt;&lt; endl; return 0;&#125; 结构体变量赋值12345678910111213141516171819#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike1 = &#123; 123,\"mike\" &#125;; student mike2; mike2 = mike1; mike2.id_num = 2123000 + mike2.id_num; for (int i = 0; mike2.name[i] != '\\0'; i++) mike2.name[i] = toupper(mike2.name[i]); cout &lt;&lt; mike1.id_num &lt;&lt; \" \" &lt;&lt; mike1.name &lt;&lt; endl; cout &lt;&lt; mike2.id_num &lt;&lt; \" \" &lt;&lt; mike2.name &lt;&lt; endl; return 0;&#125; 结构体做函数参数1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;void renew(student one)&#123; one.id_num = 2123000 + one.id_num; for (int i = 0; one.name[i] != '\\0'; i++) one.name[i] = toupper(one.name[i]); cout &lt;&lt; one.id_num &lt;&lt; \" \" &lt;&lt; one.name &lt;&lt; endl;&#125;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; renew(mike); return 0;&#125; 指向结构体的指针1234567891011121314#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student mike = &#123; 123,\"mike\" &#125;; student *one = &amp;mike; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; return 0;&#125; 结构体数组123456789101112131415161718#include&lt;iostream&gt;using namespace std;struct student&#123; int id_num; char name[10];&#125;;int main()&#123; student myclass[3] = &#123; 123,\"mike\",133,\"tom\", 143,\"jack\"&#125;; student *one = myclass; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; one++; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; one++; cout &lt;&lt; one-&gt;id_num &lt;&lt; \" \" &lt;&lt; one-&gt;name &lt;&lt; endl; return 0;&#125; 枚举类型枚举：如果一个变量只有几种可能的取值，则可以将该变量定义为枚举类型。 枚举类型的定义 1234567//声明一个枚举数据类型weekdayenum weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; //花括号内sun,mon,...,sat等称为枚举元素//定义枚举变量enum weekday workday,weekend;weekday workday,weekend//枚举变量赋值workday = sun; weekend = moon; 需要注意的是： 枚举类型按常量处理，不能对它们赋值。sun = mon; （错误） 枚举类型不能直接输出元素的名字。enum color{red,green,white,black}; color cloth = red; cout&lt;&lt;cloth; //结果为0。 枚举类型可以比较。if(cloth &gt; white) count++ 一个整型不能直接赋给一个枚举变量。workday = 2; （错误） 枚举元素有值： 定义时枚举元素如未指定值，编译系统按定义顺序取默认值依次为0,1,2,3,…. 也可以给枚举元素指定对应的值，enum day {sun=7,mon=1, tue, wed, thu, fri, sat}; 这时有sun=7, mon=1, tue=2, wed=3,...... 若要把整数赋给枚举变量应先进行强制类型转换，workday = (enum weekday) 2; 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;enum color&#123;red,yellow, green=3,blue&#125;;enum color cl;int main()&#123; cl = blue; cout &lt;&lt; \"red=\" &lt;&lt; red &lt;&lt; \" yellow=\" &lt;&lt; yellow &lt;&lt; \" green=\" &lt;&lt; green &lt;&lt; endl; cout &lt;&lt; \"blue=\" &lt;&lt; blue &lt;&lt; \" cl=\" &lt;&lt; cl &lt;&lt; endl; //输出枚举类型的内容 switch (cl) &#123; case red: cout &lt;&lt; \"red\\n\"; break; case yellow: cout &lt;&lt; \"yellow\\n\"; break; case green: cout &lt;&lt; \"green\\n\"; break; case blue: cout &lt;&lt; \"blue\\n\"; break; &#125; return 0;&#125; 例子：计算工资 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; enum day&#123;Mon,Tue,Wed,Thu,Fri,Sat,Sun&#125;; day workDay; double times, wages = 0, hourlyPay, hours; cout &lt;&lt; \"Enter the hourly wages rate.\" &lt;&lt; endl; cin &gt;&gt; hourlyPay; cout &lt;&lt; \"Enter hours worked daily\" &lt;&lt; endl; for (int i = 0; i &lt; 7; i++) &#123; cin &gt;&gt; hours; switch ((day)i) &#123; case Sat:times = 1.5*hours; break; case Sun:times = 2 * hours; break; default:times = hours; &#125; wages = wages + times * hourlyPay; &#125; cout &lt;&lt; \"The wages for the week are \" &lt;&lt; wages &lt;&lt; endl; return 0;&#125; 共用体共用体：为了节省内存空间，可以将几种不同类型的变量存放到同一段内存单元中，这段内存单元所对应的数据结构称为共用体。 共用体的定义：uniom 共用体名{ 成员列表; }变量列表; 12345678union data&#123; int i; char ch; float f;&#125;a,b,c; // 直接定义data a,b,c; //分开定义 共用体的引用：不能引用共用体变量，只能引用共用体变量中的成员。 共用体类型数据的特点： 同一内存段可以存放几种不同类型的成员，但在同一时刻时只能存放其中一种。 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。 共用体变量的地址和它的各成员的地址都是同一地址，如&amp;a, &amp;a.i, &amp;a.ch, &amp;a.f都是同一地址值。 共用体不能初始化，不能对整个共用体赋值。 在函数中，可以使用共用体的指针，但不能使用名字做函数参数。 共用体的空间是所有成员中最大的一个。 例子： 123456789101112struct&#123; int num; char name[10]; char sex; char job; union &#123; int Class; char position[10]; &#125;category;&#125;preson[2]; 链表链表是一种非常常用的动态数据结构，可以用来表示顺序访问的线性群体： 链表头：指向第一个链表结点的指针； 链表结点：链表中的每一个元素，包括：当前结点的数据，下一个结点的地址； 链表尾：不再指向其他结点的结点，其地址部分放一个NULL，表示链表到此结束。 关于new &amp; deletenew：C++运算符，动态地分配内存空间，并将所分配的内存的地址赋给指针变量。 delete：C++运算符，将动态分配的内存空间归还给系统。 用法一： &lt;指针变量&gt; = new&lt;类型&gt;; ​ 分配某种类型大小的一片连续内存空间，并将内存空间的首地址赋给指针变量。 delete&lt;指针变量&gt;; 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = new int; cout &lt;&lt; *p &lt;&lt; endl; *p = 10; cout &lt;&lt; *p &lt;&lt; endl; delete p; return 0;&#125; 用法二： &lt;指针变量&gt; = new&lt;类型&gt;(初值); ​ 分配空间，并将初始值存入所分配的空间中。 delete&lt;指针变量&gt;; 123456789int main()&#123; int *p = new int(10); cout &lt;&lt; *p &lt;&lt; endl; delete p; cout &lt;&lt; *p &lt;&lt; endl; return 0;&#125; 用法三： &lt;指针变量&gt; = new&lt;类型&gt;[&lt;常量表达式&gt;]; ​ 分配指定类型的数组空间，并将数组的首地址赋给指针变量。 delete[ ]&lt;指针变量&gt;; ​ 将指针变量所指向一维数组内存空间归还给系统。 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int *p = new int[5]; memset(p, 0, 20); for(int i=0;i&lt;5;i++) cout &lt;&lt; *(p+i) &lt;&lt; endl; delete p; return 0;&#125; 当new &amp; delete 用于结构体 1234567891011121314#include&lt;iostream&gt;using namespace std;struct Node&#123; int n; Node *next;&#125;;int main()&#123; Node *p = new Node; cout &lt;&lt; p-&gt;n &lt;&lt; endl; cout &lt;&lt; p-&gt;next &lt;&lt; endl; return 0;&#125; 逐步建立链表 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;struct student&#123; int id; student *next;&#125;;student *create()&#123; student *head, *temp; int num, n = 0; head = new student; temp = head; cin &gt;&gt; num; while (num != -1) //-1作为结束符？ &#123; n++; temp-&gt;id = num; temp-&gt;next = new student; temp = temp-&gt;next; cin &gt;&gt; num; &#125; if (n == 0) head = NULL; else temp-&gt;next = NULL; return head;&#125;int main()&#123; student *pointer = create(); while (pointer-&gt;next != NULL) //遍历链表的元素 &#123; cout &lt;&lt; pointer-&gt;id &lt;&lt; endl; pointer = pointer-&gt;next; &#125; return 0;&#125; 删除结点 例子：在链表中将值为n的结点删掉 1234567891011121314151617181920212223242526student *dele(student *head, int n)&#123; student *temp, *follow; temp = head; if (head == NULL) //head为空时，说明链表为空表 return(head); if (head-&gt;id == n) //若第一个节点是要删除的目标 &#123; head = head-&gt;next; delete temp; return(head); &#125; while (temp != NULL &amp;&amp; temp-&gt;id != n) //寻到要删除的目标 &#123; follow = temp; temp = temp-&gt;next; &#125; if (temp == NULL) //若没到找到要删除的目标 cout &lt;&lt; \"not found\"; else &#123; follow-&gt;next = temp-&gt;next; //删除目标结点 delete temp; &#125; return(head);&#125; 插入结点1.将结点unit插入链表的最前面 2.将结点unit插入链表的中间 3.将结点unit插入链表的最后 例子：插入结点值为n的结点（按大小顺序） 12345678910111213141516171819202122232425262728293031323334student *insert(student *head, int n)&#123; student *temp, *unit, *follow; temp = head; unit = new student; unit-&gt;id = n; unit-&gt;next = NULL; if (head == NULL) //如果链表为空，直接插入 &#123; head = unit; return(head); &#125; while ((temp-&gt;next != NULL) &amp;&amp; (temp-&gt;id &lt; n)) //寻找第一个不小于n的结点temp &#123; follow = temp; temp = temp-&gt;next; &#125; if (temp == head) //如果temp为第一个结点 &#123; unit-&gt;next = head; head = unit; &#125; else &#123; if (temp-&gt;next == NULL) //如果temp为最后一个结点 temp-&gt;next = unit; else //如果temp为一个中间结点 &#123; follow-&gt;next = unit; unit-&gt;next = temp; &#125; &#125; return(head);&#125; 单向链表 双向链表 删除结点temp 将结点unit插入到temp之后 例子：约瑟夫环问题问题描述：n个孩子围坐成一圈，并按顺时针编号为1,2,3, ……,n，从编号为p的小孩顺时针依次报数，由1报到m，当报到m时，该小孩从圈中出去，然后下一个小孩再从1报数，当报到m时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号（假设小孩的个数不多于300个）。 关于输入：n,p,m的值在1行内输入，以空格间隔 关于输出：按出圈的顺序输出编号，编号之间以逗号间隔。 思路： 首先定义结点的结构体，列出需要的函数的，然后再考虑每个函数需要完成的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *next; Node *ahead;&#125;;Node *Create(int N);Node *Search(Node *head, int P);Node *Release(Node *head, int M);int main()&#123; int N, P, M = 0; cout &lt;&lt; \"请输入人数N，从几号开始P，报到哪个数M：\" &lt;&lt; endl; cin &gt;&gt; N &gt;&gt; P &gt;&gt; M; Node *head = Create(N); //创建N个结点的环 head = Search(head, P); //找到第P个结点 while (head-&gt;next != head) //不断释放第M个元素，直到只剩一个元素 &#123; head = Release(head, M); &#125; cout &lt;&lt; head-&gt;num; return 0;&#125;Node *Create(int N) //创建包含N个结点的双向循环链表&#123; int n = 1; Node *node = new Node; node-&gt;num = n; Node *head = node; //指向第一节点 Node *tail = head; //指向最后一个节点 while (n++ &lt; N) &#123; node = new Node; //创建新节点 node-&gt;num = n; //赋值 tail-&gt;next = node; //插入新节点 node-&gt;ahead = tail; tail = tail-&gt;next; //尾巴后移一个 &#125; tail-&gt;next = head; head-&gt;ahead = tail; return head;&#125;Node *Search(Node *head, int P) //从head开始寻找第P个节点&#123; while (head-&gt;num != P) &#123; head = head-&gt;next; &#125; return head;&#125;Node *Release(Node *head, int M) //释放Head开始的第M个节点&#123; int count = 1; Node *temp = head; while (count &lt; M) //寻找第M个节点 &#123; temp = temp-&gt;next; count++; &#125; temp-&gt;ahead-&gt;next = temp-&gt;next; //移除第M个节点 temp-&gt;next-&gt;ahead = temp-&gt;ahead; //移除第M个节点 cout &lt;&lt; temp-&gt;num &lt;&lt; \", \"; head = temp-&gt;next; //释放第M个节点所占的内存空间 delete temp; return head;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（5）函数","slug":"Cpp基础（5）函数","date":"2020-01-30T11:41:22.000Z","updated":"2020-02-02T11:41:22.000Z","comments":true,"path":"2020/01/30/Cpp基础（5）函数/","link":"","permalink":"http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数基础函数的定义和声明函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）定义包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。 12345678//计算阶乘int fact(int val)&#123; int ret = 1; while (val &gt; 1) ret* = val--; return ret;&#125; 函数的类型是指函数返回值的数据类型，若函数类型与return语句中表达式的值不一致，则以函数类型为准，系统自动进行类型转换。 1234int bigger(float x, float y)&#123; return (x &gt; y ? x : y); //返回时会转换为整数&#125; 函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作函数原型（function prototype）。 建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 需要注意的是：函数不能嵌套定义，函数间可以互相调用，但不能调用main函数。 函数的调用函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。 123456int main()&#123; int j = fact(5); cout &lt;&lt; \"5! is\" &lt;&lt; j &lt;&lt; endl; return 0;&#125; 一个函数调用的执行过程可以分为3个阶段： 首先把实参值传入被调用函数形参的对应单元中，中断主调函数当前的执行，并且保存返回地点（称为断点）。 执行被调用函数语句，直到return语句返回。若被调用函数中没有return语句，则直到其全部语句执行完毕后自动返回到位于主调函数中的断点处。 从保存的断点处，主调函数继续执行其他剩余语句。 形参和实参实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“值传递”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。 函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名， 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是void，它表示函数不返回任何值。 变量的作用范围根据变量在程序中作用范围的不同，可以将变量分为： 局部变量：在函数内或块内定义，只在这个函数或块内起作用的变量； 全局变量：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。 当全局变量与局部变量同名时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量，即在局部变量的作用范围内，全局变量不起作用。 需要注意的是，不在必要时不要使用全局变量。因为全局变量在程序的全部指向过程中都占用存储单元；过多地使用全局变量，程序的可读性变差；会增加函数之间的“关联性”，降低了函数的独立性，使函数可移植性降低。 自动对象与局部静态对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为自动对象（automatic object）。 形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。 有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。 123456789101112//下面的函数统计它自己被调用了多少次size_t count_calls()&#123; static size_t ctr = 0; return ++ctr;&#125;int main()&#123; for (size_t i=0; i!=10; ++i) cout &lt;&lt; cout_calls() &lt;&lt; endl; return 0;&#125; 指针形参指针用做函数参数，在函数内部改变指针的值只能改变局部变量，不会影响实参原来的值；在函数内部通过解引用操作改变指针所指内容的值，即实参指针所指内容的值也发生了改变。 例子：编写一个函数，使用指针形参交换两个整数的值。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void mySWAP(int *p, int *q)&#123; int tmp = *p; *p = *q; *q = tmp;&#125;int main()&#123; int a = 5, b = 10; int *r = &amp;a, *s = &amp;b; cout &lt;&lt; \"交换前：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; mySWAP(r, s); cout &lt;&lt; \"交换后：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 需要注意的是，下面的函数并不能满足要求，因为在函数内部改变指针的值（改变指针所指的地址）只能改变局部变量。 123456void mySWAP(int *p, int *q)&#123; int *tmp = p; p = q; q = tmp;&#125; 引用形参我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。 与值传递（实参的值被拷贝给形参，形参和实参是两个相互独立的变量）不同的是，引用形参是传引用的方式，形参是对应的实参的别名，形参绑定到初始化它的对象，如果改变了形参的值，也就是改变了对应实参的值。 用引用形参重写上面例子中的程序，引用形参绑定初始化它的对象，p绑定我们传给函数的int对象a，改变p的值也就是改变p所引对象的值。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void mySWAP(int &amp;p, int &amp;q)&#123; int tmp = p; p = q; q = tmp;&#125;int main()&#123; int a = 5, b = 10; cout &lt;&lt; \"交换前：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; mySWAP(a, b); cout &lt;&lt; \"交换后：a=\" &lt;&lt; a &lt;&lt; \"，b=\" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 使用引用形参避免拷贝拷贝大类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 如果函数无须改变引用形参的值，最好将其声明为常量引用。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量s的内容；二是限制了该函数所能接受的实参类型，我们无法把const对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。 123456789101112131415161718192021//比较两个string 对象的长度bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125;//判断一个string对象是否含有大写字母bool HasUpper(const string &amp;str) //无须修改参数的内容，设为常量引用类型&#123; for (auto c : str) if(isupper(c)) return true; return false;&#125;//把字符串的所有大写字母转成小写void ChangeToLower(string &amp;str)&#123; for (auto &amp;c : str) c = tolower(c);&#125; 使用引用形参返回额外信息一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为一次返回多个结果提供了有效的途径。（对于引用的操作实际上是作用在引用所引的对象上） 例子：定义一个名为find_char的函数，返回string对象中某个指定字符第一次出现的位置，同时能“返回”该字符出现的次数。 一种思路是定义一个新的数据类型，包含位置和数量两个成员，显然比较复杂；另一种更简单的方法是，给函数传入一个额外的引用实参。 123456789101112131415string::size_type find_char(const string &amp;s, char c, string::size_type &amp;occurs)&#123; auto ret = s.size(); occurs = 0; for (decltyoe(ret) i = 0; i!=s.size(); i++) &#123; if(s[i] == c) &#123; if(ret == s.size()) ret = i; //记录c第一次出现的位置 ++occurs; &#125; &#125; return ret; //出现次数通过occurs隐式地返回&#125; 数组形参数组有两个特殊性质：不允许拷贝数组，以及使用数组时通常会将其转换成指针。所以我们不能以值传递的方式使用数组参数，当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： 1234//这三个print函数是等价的void print(const int*);void print(const int[]);void print(const int[10]); 当编译器处理对print函数的调用时，只检查传入的参数是否是const int*类型；如果我们传给print函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。以数组为形参的函数也必须确保使用数组时不会越界。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void sum(int *p, int n)&#123; int total = 0; for (int i=0; i&lt;n; i++) &#123; total+=*p++; &#125; cout &lt;&lt; total &lt;&lt; endl;&#125;int main()&#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; sum(a,10); return 0;&#125; 多维数组名做函数参数当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，而多维数组的首元素是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。 123//这两个print等价void print(int (*matrix)[10], int rowSize); //（*matrix)的括号不能少void print(int matrix[][10], int rowSize); 例子：求一个$3\\times 4$的矩阵的所以元素中的最大值。 123456789101112131415int maxvalue(int (*p)[4])&#123; int max = p[0][0]; for(int i=0; i&lt;3; i++) for(int j=0; j&lt;4; j++) if(p[i][j] &gt; max) max = p[i][j]; return max;&#125;int main()&#123; int a[3][4] = &#123;&#123;1,3,5,7&#125;,&#123;9,11,13,15&#125;,&#123;2,4,6,8&#125;&#125;; cout &lt;&lt; \"The Max value is\" &lt;&lt; maxvalue(a); return 0;&#125; 数组引用形参形参也可以是数组的引用，此时引用形参绑定到对应的实参上，也就是绑定到数组上。但此时函数只能作用于固定大小的数组。 12345void print(int (&amp;arr)[10]) //只能将函数作用于大小为10的数组，(&amp;arr)的括号不能少&#123; for(auto elem : arr) cout &lt;&lt; elem &lt;&lt;endl;&#125; 函数的递归什么是递归我们已经知道：函数不能嵌套定义，函数可以嵌套调用。那么一个函数能调用“自己”嘛？答案是可以的 例子：已知 n，求n的阶乘$n!$ \\begin{align*} n!&=(n-1)!*n \\\\ (n-1)!&=(n-2)!*(n-1) \\\\ &\\dots \\\\ 2!&=1!*2 \\\\ 1!&=1 \\end{align*}1234567891011121314#include&lt;iostream&gt;using namespace std;int fact(int n)&#123; if(n==1) return 1; else return n*fact(n-1); //每次调用，数据规模缩小&#125;int main()&#123; cout &lt;&lt; fact(4) &lt;&lt;endl; return 0;&#125; 深入理解递归的过程递归调用与普通调用在实质上是一样的。 通过下面的两个例子来理解递归的过程。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int recur()&#123; char c; c = cin.get(); if (c != '\\n') recur(); cout &lt;&lt; c; return 0;&#125;int main()&#123; recur(); return 0;&#125; 12345678910111213141516#include&lt;iostream&gt;using namespace std;int recur()&#123; char c; c = cin.get(); cout &lt;&lt; c; if (c != '\\n') recur(); return 0;&#125;int main()&#123; recur(); return 0;&#125; 递归的作用用递归来完成递推递归的关注点放在求解目标上，重在表现第i次与第i+1次的关系，让程序变得简明。必须要确定第1次的返回结果。 例子：斐波那契数列 \\begin{align*} fab(n)&=fab(n-1)+fab(n-2) \\\\ fab(1)&=1,\\, fab(2)=1 \\end{align*}123456789int f(int n)&#123; if(n == 1) return 1; if(n == 2) return 1; else return(f(n-1)+f(n-2)); &#125; 模拟连续发生的动作主要是搞清楚连续发生的动作是什么；搞清楚不同动作之间的关系；搞清楚边界条件是什么。 例子1：将一个十进制整数转换成二进制数 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;void convert(int x)&#123; if ((x / 2) != 0) &#123; convert(x / 2); cout &lt;&lt; x % 2; &#125; else cout &lt;&lt; x;&#125;int main()&#123; int x; cin &gt;&gt; x; convert(x); return 0;&#125; 例子2：汉诺塔问题 相传在古代印度有位僧人整天把三根柱子上的金盘倒来倒去，他想把64个一个比一个小的金盘从一根柱子上移到另一个柱子上去。移动过程中恪守下述规则：每次只允许移动一只盘，且大盘不得落在小盘上面。 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;void move(int m, char A, char B, char C) //表示将m个盘子从A经过B移动到C&#123; if (m == 1) &#123; cout &lt;&lt; \"move 1# from\" &lt;&lt; A &lt;&lt; \"to\" &lt;&lt; C &lt;&lt; endl; //直接可解结点 &#125; else //如果m不为1，则要调用move(m-1) &#123; move(m - 1, A, C, B); cout &lt;&lt; \"move 1# from\" &lt;&lt; A &lt;&lt; \"to\" &lt;&lt; C &lt;&lt; endl; move(m - 1, B, A, C); &#125;&#125;int main()&#123; int n; cout &lt;&lt; \"请输入盘数n=\" &lt;&lt; endl; cin &gt;&gt; n; cout &lt;&lt; \"在3根柱子上移\" &lt;&lt; n &lt;&lt; \"个盘子的步骤为：\" &lt;&lt; endl; move(n, 'A', 'B', 'C'); return 0;&#125; 进行“自动的分析”先假设有一个函数能给出答案，再利用这个函数分析如何解决问题；搞清楚最简单的情况下答案是什么。 例子：放苹果 把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？注意：5,1,1和1,5,1是同一种分法。 思路： 假设有一个函数f(m,n)能解决这个问题，那么最简单的情况是m&lt;=1||n&lt;=1，此时只有1种分法。 当n&gt;m时，必有盘子会空着，空着的盘子不影响结果，那么有f(m,n)=f(m,m)。 当n&lt;=m时，分两种情况： (1)如果有盘子空着，那么减少一个盘子也不会影响结果，有f(m,n)=f(m,n-1)。 (2)如果盘子全满，那么每个盘子至少有1个苹果，那么只需考虑剩下m-n个苹果在n个盘子中的分法，则有 f(m,n)=f(m-n,n)。 12345678910111213141516#include&lt;iostream&gt;using namespace std;int count(int m, int n)&#123; if (m &lt;= 1 || n &lt;= 1) return 1; if (m &lt; n) return count(m, m); else return count(m, n - 1) + count(m - n, n);&#125;int main()&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; count(m, n) &lt;&lt; endl;&#125; 递归问题解法小结面对一个问题时： 假设有一个函数f()可以解决问题；接下来考虑这个函数是什么样的？ 找到f^n()与f^n-1()之间的关系； 确定f()的参数； 分析并写出边界条件。 例子1：组合问题 用递归法计算从n个人中选择k个人组成一个委员会，求不同的组合的个数一共是多少？ 思路： 由n个人里选k个人的组合数=由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数； 当n = k或k = 0时，组合数为1。 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int comm(int n, int k)&#123; if (k &gt; n) return 0; else if (n == k || k == 0) return 1; else return comm(n - 1, k) + comm(n - 1, k - 1);&#125;int main() &#123; int n, k; cout &lt;&lt; \"Please enter two integers n and k: \"; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; \"C(n,k) = \" &lt;&lt; comm(n, k) &lt;&lt; endl; return 0;&#125; 探索式递归例子1：下楼问题 从楼上走到楼下共有h个台阶，每一步有3种走法：走1个台阶；走2个台阶；走3个台阶。问可以走出多少种方案？将所有的方案输出。 思路： 既然要列出所有方案，所以需要用一个数组存放每步走的步数，可设为take[99]，步数存放在take[ ]中，满足条件就打印出来； 假设有一个函数Try( )能解决问题，接着寻找Try^n^( )与Try^n+1^( )的关系； Try^n^( )代表走完第n步的状态，即已经填完第n个take[ ]； Try^n( )与Try^n+1( )的关系：在走完第n步后，再走第n+1步时，有三种选择（走1、2、3步），每个选择下有三种可能性： 如果剩下的台阶数小于想要走的步数：返回 如果剩下的台阶数恰好等于要走的步数：打印输出 如果剩下的台阶数大于想要走的步数：走下去 Try( )的参数如何确定：Try^n^( )与Try^n+1^( )之间哪些数据是不一样的？而且是需要由Try^n( )传递给Try^n+1^( )的？ ​ Try^n^( )代表走完第n步的情况，Try^n+1^( )代表走完第n+1步的情况； ​ Try^n^( )需要将走完第 n步后剩余的台阶数传递 给Try^n+1^( )。 ​ 因此可以将Try^n^( )定义为：Try(i, s)，i表示剩余的台阶数，s表示步数。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int take[99]; //记录每一个走的台阶数int num = 0; //num记录解决方案的个数void Try(int i,int s)&#123; for (int j = 1; j &lt;= 3; j++) &#123; if (i &lt; j) continue; take[s] = j; if (i == j) &#123; num++; cout &lt;&lt; \"solution\" &lt;&lt; num &lt;&lt; \": \"; for (int k = 1; k &lt;= s; k++) cout &lt;&lt; take[k]; cout &lt;&lt; endl; &#125; else Try(i - j, s + 1); //take[s]=0; &#125;&#125;int main()&#123; int h = 0; cout &lt;&lt; \"how many stairs:\"; cin &gt;&gt; h; Try(h, 1); cout &lt;&lt; \"There are \" &lt;&lt; num &lt;&lt; \" solutions.\" &lt;&lt; endl; return 0;&#125; 例子2：字母全排列 从键盘读入一个英文单词（全部字母小写，且该单词中各个字母均不相同），输出该单词英文字母的所有全排列。 如输入abc，则打印出abc, acb, bac, bca, cab, cba。 思路： 需要反复做的事情是：选择第n个位置的字母，依次检查每个字母，如果某个字母没被选择过，则进行： 将该字母放第n个位置； 标记该字母已经被选择； 如果全部位置都已选完，打印输出；否则，为下一个位置选择字母； 把刚刚标记过的字母重新标记为“未选择”； 假设一个函数ranker( )能够完成上述事情，每次调用之间的区别在于位置n，ranker(1)—&gt;ranker(2)—&gt;ranker(3)……—&gt;ranker(n)。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;char in[30] = &#123; 0 &#125;; //存放输入的单词char out[30] = &#123; 0 &#125;; //存放准备输出的字符串int used[30] = &#123; 0 &#125;; //记录第i个字母是否已经使用过int length = 0; //记录输入的单词的长度void ranker(int n)&#123; if(n==length) //如果全部字母已经被选择完，则打印输出 &#123; cout &lt;&lt; out &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; length; i++) //依次查看每个字母 &#123; if (!used[i]) //如果某个字母没有被选用 &#123; out[n] = in[i]; //选入该字母 used[i] = 1; //标记该字母已经被选择 ranker(n + 1); //为下一个位置寻找字母 used[i] = 0; //回溯，标记字母未被使用，让其可重新被选择 &#125; &#125;&#125;int main()&#123; cout &lt;&lt; \"Input the word: \"; cin &gt;&gt; in; length = strlen(in); ranker(0); //从第一个字母开始 return 0;&#125; 例子3：分书问题 有编号分别为1, 2, 3, 4, 5的五本书，准备分给A，B，C，D，E五个人，每个人阅读兴趣用一个二维数组加以描述。请写一个程序，输出所有分书方案，让人人都能拿到喜欢的书。 思路： 假设函数trybook( )可以解决问题，从第0个人开始分书，函数trybook(i)应该要完成： 试着给第i个人分书，从0号书开始试，当第i个人喜欢第j个书，且j书还没被选走时（因此要建一个数组记录书被选走的状态），那么第i个人就得到第j本书； 如果不满足上述条件，则什么也不做，返回循环条件； 若满足条件，则做三件事情： 做事：将第j个书分给第i个人，同时记录j书已被选用； 判断：查看是否将所有5个人所要的书分完，若分完，则输出每个人所得之书；若未分完，去寻找其他解决方案； 回溯：让第i个人退回j书，恢复j书尚未被选用的状态。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int like[5][5] = &#123; &#123;0,0,1,1,0&#125;,&#123;1,1,0,0,1&#125;,&#123;0,1,1,0,1&#125;,&#123;0,0,0,1,0&#125;,&#123;0,1,0,0,1&#125; &#125;;int book[5] = &#123; 0 &#125;; //book[5]记录书是否被选用，选用记为1int take[5] = &#123; 0 &#125;; //take[5]记录第i个人领到那本书int num; //num记录分书方案的个数void trybook(int i) //第i个人&#123; for (int j = 0; j &lt;=4; j++) //第j本书 &#123; if ((like[i][j] &gt; 0) &amp;&amp; (book[j] == 0)) //若第i个人喜欢第j本书，且第j本书还没被选用 &#123; take[i] = j; //把第j本书分给第i个人 book[j] = 1; //记录第j本书已经被选用 if (i == 4) //如果第5个人已经拿到书，即书已分完，则输出方案 &#123; num++; cout &lt;&lt; \"第\" &lt;&lt; num &lt;&lt; \"个方案\" &lt;&lt; endl; for (int k = 0; k &lt;= 4; k++) cout &lt;&lt; take[k] &lt;&lt; \"号书给\" &lt;&lt; char(k + 65)&lt;&lt;\" \"; cout &lt;&lt; endl; &#125; else //如果书没分完，则继续给下一个人分书 trybook(i + 1); //take[i] = -1; 把第i个人的书退回，实际上可以不加这一条 book[j] = 0; //回溯，把第j本书标记为未选用 &#125; &#125;&#125;int main()&#123; int n = 0; trybook(0); return 0;&#125; 探索式递归问题的解法第n步需要做什么？对于面前的每种选择： 把该做的事情做了； 判定是否得到解； 递归（调用第n+1步）； 看是否需要回溯。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（4）字符数组与字符串","slug":"Cpp基础（4）字符数组与字符串","date":"2020-01-29T03:08:57.000Z","updated":"2020-01-29T05:08:57.000Z","comments":true,"path":"2020/01/29/Cpp基础（4）字符数组与字符串/","link":"","permalink":"http://nekomoon404.github.io/2020/01/29/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符数组与字符串定义字符型用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 初始化与赋值只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 字符/字符数组/字符串的输入与输出一个字符的输入直接用cin输入字符。cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; char c; cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while(cin&gt;&gt;c) //abc def g cout&lt;&lt;c; //abcdefg return 0;&#125; 用cin.get()函数输入可以用于读入一个字符；有2中形式： 无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( (c=cin.get())!= EOF ) //abc def gcout &lt;&lt; c; //abc def g 一个参数cin.get(char) 12345char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; //读取一个字符赋给字符变量cwhile( cin.get(c) ) //abc def gcout &lt;&lt; c; //abc def g 要注意的是，cin.get()遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。 123456char ch1,ch2; cout&lt;&lt;\"请输入两个字符：\"&lt;&lt;endl; cin.get(ch1);//或ch1 = cin.get(); cin.get(ch2); cout&lt;&lt;ch1&lt;&lt;\" \"&lt;&lt;ch2&lt;&lt;endl; cout&lt;&lt;(int)ch1&lt;&lt;\" \"&lt;&lt;(int)ch2&lt;&lt;endl; 输入a[Enter]，读取到结束符&#39;/n&#39;，其仍在缓冲区中被存入ch2，在输出a之后，第二次输出&#39;/n&#39;即换行，而输出的第二个ASCII码值为10，即&#39;/n&#39;的ASCII值，说明cin.get()遇到结束符并不会将之删除。 用getchar()输入字符1234char c;cout&lt;&lt;\"enter a sentence\"&lt;&lt;endl; while( c = getchar() ) //abc def g 不跳过任何字符cout &lt;&lt; c; //abc def g 字符串的输入直接用cin输入字符123456789#include&lt;iostream&gt;using namespace std;int main() &#123; char str[10]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; while (cin &gt;&gt; str) cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; 用cin.get()函数输入有三个参数的cin.get()函数：cin.get(ch, 10, &#39;/n&#39;) 读取10-1（10减1=9，最后一个为&#39;/0&#39;）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符&#39;/n&#39;，则提前结束读取（如果第3个参数没有指定，则默认为&#39;/n&#39;），而结束符仍在缓冲区中；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。 还要一点要注意，cin.get(ch, 10, &#39;/n&#39;)，当第一个输入字符为结束符时，缓冲区将无该结束符。 1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; char ch1[20]，ch2[20]; cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl; cin.get(ch1,10,'o'); //指定终止符为'o' cin.get(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; return 0;&#125; 输入：we are good friends[Enter]，由于遇到结束符 &#39;o&#39; ，首先读入we are g到ch1，此时ood friends仍在缓冲区，当执行cin.get(ch2,10)会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。 用cin.getline()函数输入用法与上面的cin.get()类似，但也有区别： cin.get()当输入的字符串在结束符之前的长度超过接收长度时，不会引起cin函数的错误，剩余的字符会留在缓冲区，后面若有cin操作，会继续从缓冲区读取；当cin.getline()输入超长时，会引起cin函数的错误，后面的cin操作将不再执行。 cin.get()每次读取一整行并把由Enter键生成的换行符&#39;/n&#39;留在输入队列中，然而cin.getline()每次读取一整行并把由Enter键生成的换行符抛弃。 cin.get()遇到结束符是停止读取，缓冲区指针不移动；cin.getline()遇到结束符时，缓冲区指针移到终止标志字符之后。 123456char ch1[20]，ch2[20];cout &lt;&lt; \"enter a sentence\" &lt;&lt; endl;cin.getline(ch1,10,'o'); //指定终止符为'o' cin.getline(ch2,10); cout &lt;&lt; ch1 &lt;&lt; endl; cout &lt;&lt; ch2 &lt;&lt; endl; //注意与上节的区别 一个需要注意的地方：cin这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。而无参数cin.get()，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的cin.get(ch, 10, &#39;/n&#39;)的不足。 123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区， for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); //当执行cin.getline(a[1],10)时，[Enter]被读取到a[1] for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 12345678910111213#include&lt;iostream&gt;using namespace std;int main() &#123; char a[10][10]; int n = 0; cin &gt;&gt; n; //输入7[Enter]，7存入n，[Enter]仍在缓冲区 cin.get(); //用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了 for (int i = 0; i &lt; n; i++) cin.getline(a[i], 10); for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; endl; return 0;&#125; 字符串的输出用cout输出字符数组12345678#include&lt;iostream&gt;using namespace std;int main()&#123; char a[10] = \"Computer\"; cout &lt;&lt; a; return 0;&#125; 需要注意的是，cout输出有终止条件（一般是碰到&#39;\\0&#39;），当用字面值初始化字符数组时，会自动在串尾加上&#39;\\0&#39;；当用列表初始化字符数组时，若不在串尾加上’\\0’，用cout输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。 12char a[8] = &#123; 'C','o','m','p','u','t','e','r' &#125;;cout &lt;&lt; a; 例子1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main() &#123; char str[200]; while (cin.getline(str, 200)) &#123; for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == 'Z')&#123; str[i] = 'A'; continue; &#125; if (str[i] == 'z')&#123; str[i] == 'a'; continue; &#125; if (str[i] == ' ') continue; str[i]++; &#125; cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数strcat，每个输入的串的长度不超过20。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main() &#123; int len1, len2; char str1[40], str2[40]; cin.getline(str1,20); cin.getline(str2, 20); for (len1 = 0; str1[len1] != '\\0'; len1++); for (len2 = 0; str2[len2] != '\\0'; len2++); if (len1 &gt;= len2) &#123; for (len2 = 0; str2[len2] != '\\0'; len2++) str1[len1++] = str2[len2]; //后置++，先执行表达式，再len+1 str1[len1] = '\\0'; //必须要加，要不然cout&lt;&lt;str1会出错 &#125; else &#123; for (len1 = 0; str1[len1] != '\\0'; len1++) str2[len2++] = str1[len1]; str2[len2] = '\\0'; &#125; cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; str2 &lt;&lt; endl; return 0;&#125; 3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if (str[i] == ' ') flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125; 当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main() &#123; char str[80]; int num = 0, flag = 0; cin.getline(str, 80); for (int i = 0; str[i] != '\\0'; i++) &#123; if ((str[i] &gt;= 'A'&amp;&amp; str[i] &lt;= 'Z') || (str[i] &gt;= 'a'&amp;&amp;str[i] &lt;= 'z')) flag = 0; else if (flag == 0) &#123; flag = 1; num++; &#125; &#125; cout &lt;&lt; \"字符串中有\" &lt;&lt; num &lt;&lt; \"个单词\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（3）数组","slug":"Cpp基础（3）数组","date":"2020-01-28T03:06:06.000Z","updated":"2020-01-28T07:06:06.000Z","comments":true,"path":"2020/01/28/Cpp基础（3）数组/","link":"","permalink":"http://nekomoon404.github.io/2020/01/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 定义和初始化内置数组数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个常量表达式。 123456constexpr unsigned sz = 42; //常量表达式int arr[10];int *parr[sz];unsigned cnt = 42; // 不是常量表达式string bad[cnt]; // 错误：cnt不是常量表达式 默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。 显式初始化数组元素可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。 123456const unsigned sz = 3;int ial[sz] = &#123;0, 1, 2&#125;;int a2[] = &#123;0, 1, 2&#125;;int a3[5] = &#123;0, 1, 2&#125;;string a4[3] = &#123;\"hi\", \"bye\"&#125;;int a5[2] = &#123;0, 1, 2&#125;; //错误 字符数组的特殊性当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。 1234567891011char a1[] = &#123;'C', '+', '+'&#125;; //列表初始化，没有空字符char a2[] = &#123;'C', '+', '+', '\\0'&#125;; //列表初始化，含有显式的空字符char a3[] = \"C++\"; //用字符换字面值初始化，自动添加表示字符串结束的空字符const char a4[6] = \"Daniel\" //错误：没有空间放空字符str1[] = \"China\"; //错误str1 = \"China\"; //错误str2 = str1; //错误//利用二维数组存储多个字符串char weekday[7][11] = &#123;\"Sunday\", \"Monday\",\"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Ssturday\"&#125;; 不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。 复杂的数组声明数组能存放大多数类型的对象，可以定义一个存放指针的数组；又因为数组本身是对象，所以允许定义数组的指针及数组的引用。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。 12345int *ptrs[10]; //ptrs是含有10个整型指针的数组int &amp;refs[10] = /* ？ */ //错误：不存在引用的数组int (*Parray)[10] = &amp;arr; //Parray是一个指针，指向一个含有10个整数的数组int (&amp;arrRef)[10] = arr; //arrRef是一个引用，引用一个含有10个整数的数组int *(&amp;arry)[10] = ptrs; //arry是一个引用，引用一个含有10个指针的数组 练习3.27 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？ 12345unsigned buf_size = 1024;int ia[buf_size]; //非法的，因为buf_size不是一个常量表达式int ia[4*7-14]; //正确，因为4*7-14是一个常量表达式int ia[txt_size()]; //非法的，因为txt_size没有被定义为常量表达式 constexprchar st[11] = \"fundamental\" //非法的，因为用字符串字面值初始化，没有空间存放空字符 访问数组元素与标准库类型vector 和string 一样，数组的元素也能使用范围for 语句或下标运算符来访问。数组的索引从0开始。 数组下标通常定义为size_t类型，size_t是一种机器相关的无符号类型，在cstddef头文件中定义。 1234567//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100unsigned scores[11] = &#123;&#125;; //列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。unsigned grade;while (cin &gt;&gt; grade) &#123; if (grade &lt;= 100) ++scores[grade/10];&#125; 与vector 和string 一样，当需要遍历数组的所有元素时，最好的办法是使用范围for语句。 1234//对于scores中的每个计数值输出当前的计数值for (auto i : scores) cout &lt;&lt; i &lt;&lt; \" \";cout&lt;&lt;endl; 必须要检查数组下标的值在合理范围内，下标越界会产生缓冲区溢出。 练习3.31编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。 123456789101112131415include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(auto val: a) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 3.32 将上一题创建的数组拷贝给另外一个数组，利用vector重写程序，实现类似的功能。 //如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。 1234567891011121314include&lt;iostream&gt;using namespace std;int main()&#123; const int sz = 10; int a[sz], b[sz]; for(int i = 0; i &lt; sz; i++) a[i] = i; for(int j = 0; j &lt; sz: j++) b[j] = a[j]; return 0;&#125; //用vector重写 123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; const int sz = 10; vector&lt;int&gt; vInt, vInt2; for (int i = 0; i &lt; sz; i++) vInt.push_back(i); for (int j = 0; j &lt; sz; j++) vInt2.push_back(vInt[j]); for (auto val: vInt2) cout &lt;&lt; val &lt;&lt; \" \"; cout&lt;&lt;endl; return 0;&#125; 例子：输出100以内的所有素数。 一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足： 1","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（2）引用与指针","slug":"Cpp基础（2）引用与指针","date":"2020-01-27T03:02:17.000Z","updated":"2020-01-27T04:02:17.000Z","comments":true,"path":"2020/01/27/Cpp基础（2）引用与指针/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/","excerpt":"","text":"引用与指针复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。 一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。 引用当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成$d的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。 为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。 允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。 引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 12345678910int ival = 1024;int &amp;refVal = ival; //refVal指向ivalint &amp;refVal2; //错误。引用必须被初始化refVal = 2; //把值赋给了ivalint &amp;refVal3 = refVal; //正确：refVal3绑定到了那个与refVal绑定的对象上，即ivalint i = refVal; //相当于i = ivalint i = 1024, i2 = 2048;int &amp;r1 = i, &amp;r2 = i2; 指针指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同： （1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。 （2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。 指针运算符*，取地址符&amp; 指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 指针变量：专门用于存放指针（某个变量的地址）的变量 1234int c = 76;int *pointer; //定义名字为pointer的指针变量pointer = &amp;c; //将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c//pointer = c; //错误：因为pointer是存放地址的变量，所以只能存放地址 通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。 12345int c = 76;int *pointer = &amp;c; //*pointer为“pointer所指向的存储单元的内容\"，即是变量ccout &lt;&lt; &amp;c &lt;&lt;endl; //取变量c的地址cout &lt;&lt; &amp;pointer &lt;&lt; endl; //取指针变量c的地址 赋值和指针：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。 1234int i = 42;int *pi = 0; //pi被初始化pi = &amp;ival; //pi所存的地址改变，指向ival*pi = 0; //ival的值被改变，指针pi所存的地址没有改变 &amp;与*`的运算优先级：同级 空指针（null pointer）不指向任何对象。 123int *p1 = nullptr //C++11int *p2 = 0; //直接将p2初始化为字面常量0int *p3 = NULL; //需要首先#include&lt;cstdlib&gt; 使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。 void*指针：可用于存放任意对象的地址。利用void*指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个void*指针。不能访问其内存空间中所存的对象。 123double obj = 3.14, *pd = &amp;obj;void *pv = &amp;obj;pv = pd;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Cpp基础（1）基础语法","slug":"Cpp基础（1）基础语法","date":"2020-01-27T02:59:54.000Z","updated":"2020-01-27T13:59:54.000Z","comments":true,"path":"2020/01/27/Cpp基础（1）基础语法/","link":"","permalink":"http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"基础语法Hello world1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello world\" &lt;&lt; endl; //变量创建的语法： 数据类型 变量名 = 变量初始值 int a = 10; cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; endl; system(\"pause\"); return 0;&#125; 变量创建的语法： 数据类型 变量名 = 变量初始值 定义常量的两种方法： #define 宏常量名 常量值 const 修饰的变量 const 数据类型 常量名 = 常量值 定义变量或常量时不要用C++中已经使用的关键字 C++中给标识符（变量，常量）命名时，要注意：1.标识符不可以是关键字2.标识符只能由字母，数字，下划线组成3.标识符的第一个字母只能是字母或者下划线4.标识符中区分大小写5.给变量命名时最好能做到见名知意，方便阅读 数据类型数据类型存在的意义：给不同类型的变量分配合适的内存空间 整型的几种类型：1.短整型 short 2字节 -2^15 - 2^15-12.整型 int 4字节 -2^31 - 2^31-1 //int最常用3.长整型 long 4字节 -2^31 - 2^31-14.长长整型 long long 8字节 -2^63 - 2^63-1 sizeof 关键字可以得到数据类型所占的内存的大小语法： sizeof（数据类型/变量名） 实型/浮点型：用于表示小数1.单精度 float 4字节 7位有效数字2.双精度 double 8字节 15-16位有效数字 字符型：用于表示单个字符 只占用1个字节，将对应的ASCII码放入存储单元语法：char ch = &#39;a&#39;需要注意：1.要用单引号将字符括起来2.单引号内只能有一个字符，不可以是字符串 字符串型：用于表示一串字符两种风格： C风格字符串： char 变量名[] = “字符串值” 要用双引号 C++风格字符串： string 变量名 = “字符串值” 需要加入头文件 #include&lt;string&gt; 转义字符： 用于表示一些不能显示出来的ASCII字符常用的转义字符：/n 换行，将当前位置移到下一行开头 /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符 // 代表一个反斜杠字符 布尔类型bool：代表真或假的值 占用1个字节bool类型只有两个值：true（本质是1） false（本质是0） 数据的输入：用于从键盘获取数据语法：cin &gt;&gt; 变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;using namespace std;int main1() &#123; short num1 = 10; cout &lt;&lt; \"short所占的内存空间为\" &lt;&lt; sizeof(num1) &lt;&lt; endl; float f1 = 3.14f; //编译器会把小数默认为双精度数，所以要在3.14后加上f cout &lt;&lt; \"f1=\" &lt;&lt; f1 &lt;&lt; endl; double d1 = 3.1415926; cout &lt;&lt; \"d1=\" &lt;&lt; d1 &lt;&lt; endl; //显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的 setprecision( ) const double value = 12.3456789; cout &lt;&lt; value &lt;&lt; endl; // 默认以6精度，所以输出为 12.3457 cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35 cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679 cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457 cout.unsetf(ios::fixed); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35 cout &lt;&lt; value &lt;&lt; endl; cout.precision(6); // 恢复成原来的样子，输出为12.3457 cout &lt;&lt; value &lt;&lt; endl; //科学计数法 float f2 = 3e2; cout &lt;&lt; \"f2=\" &lt;&lt; f2 &lt;&lt; endl; //查看字符型变量对应的ASCII码 a-97 A-65 char ch = 'a'; cout &lt;&lt; (int)ch &lt;&lt; endl; ch = 97; cout &lt;&lt; ch &lt;&lt; endl; //字符串 char str1[] = \"hello world\"; cout &lt;&lt; str1 &lt;&lt; endl; string str2 = \"hello world\"; cout &lt;&lt; str2 &lt;&lt; endl; //布尔类型 bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; flag = false; cout &lt;&lt; flag &lt;&lt; endl; //数据的输入 string str; cout &lt;&lt; \"请输入字符串变量：\" &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; system(\"pause\"); return 0;&#125; 运算符算术运算符：加+ 减- 乘* 除/ 取模（取余）% 只有整型变量可以进行取模运算需要注意：1.进行运算的变量类型，如两个整型相除结果仍是整数2.除数不能为0，取模运算除数也不能为03.只有整型变量可以进行取模运算，小数不可以 赋值运算符：用于将表达式的值赋给变量赋值= 加等于+= 减等于-= 乘等于*= 除等于/= 模等于%= 比较运算符：用于表达式的比较，并返回一个真值或假值相等于== 不等于!= 小于&lt; 大于&gt; 小于等于&lt;= 大于等于&gt;= 逻辑运算符：用于根据表达式的值返回真值或假值非! 与&amp;&amp; 或|| 要注意运算符的优先级 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;int main2() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; // a2=11, b2=110 //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; // a3=11, b3=100 //比较运算符 a = 10; b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(\"pause\"); return 0;&#125; 程序流程结构C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构1.顺序结构：程序按顺序执行，不发生跳转2.选择结构：依据条件是否满足，有选择的执行相应功能3.循环结构：依据条件是否满足，循环多次执行某段代码 选择结构if语句：1.单行格式if语句：if (条件) { 条件满足执行的语句}2.多行格式if语句：if (条件) { 条件满足执行的语句} else{条件不满足执行的语句}3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}4.嵌套if语句注意：if条件后面不要加分号 三目运算符：实现简单的判断语法：表达式1 ? 表达式2 : 表达式3解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果 如果表达式1的值为假，执行表达式3，并返回表达式3的结果注意：C++中三目运算符返回的是变量，可以继续赋值 switch语句：执行多条件分支语句语法：switch(表达式){ case 结果1：执行语句;break; case 结果2：执行语句;break; … default:执行语句;break;}注意：1. switch语句中的表达式的数据类型只能是整型或字符型 2. case里如果没有break，那么程序会一直向下执行 3.对于多条件判断，switch的结构清晰，执行效率高 循环结构while循环结构：满足循环条件，执行循环结构 语法：while (循环条件) {循环结构} 注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环 do … while循环语句：满足循环条件，执行循环语句 语法：do {循环语句} while (循环条件) 注意：do…while先执行一次循环语句，再判断循环条件 for 循环语句：满足循环条件 语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句} 注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体 嵌套循环 跳转语句break 语句：用于跳出选择结构或者循环结构 使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环结构 continue语句：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 注意：continue不会使循环终止，而break会跳出循环 goto语句：可以无条件跳转语句 语法：goto 标记 如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;int main()&#123; //嵌套if语句 int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; \"我考上了北大\" &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; \"我考上了清华\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我考上了人大\" &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; \"我考上了二本大学\" &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; \"我考上了三本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上本科\" &lt;&lt; endl; &#125; //三目运算符 int a = 10, b = 20, c = 0; c = a &gt; b ? a : b; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; //b=100 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //a=10 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //b=100 cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //嵌套循环体 //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; \"*\" &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; //continue语句 for (int i = 0; i &lt; 100; i++)&#123; if (i % 2 == 0) continue; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"搭建自己的博客","slug":"搭建自己的博客","date":"2020-01-18T03:08:31.000Z","updated":"2020-01-18T05:42:11.186Z","comments":true,"path":"2020/01/18/搭建自己的博客/","link":"","permalink":"http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.安装GitGIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：https://gitforwindows.org/，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。 2.安装node.js在官网选择LTS版本下载安装即可：https://nodejs.org/en/download/。 3.安装Hexo在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。 1npm install -g hexo-cli 初始化博客 1hexo init 启动服务：依次执行以下命令 12345npm stallhexo shexo chexo ghexo d 浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决： 1npm install hexo-deployer-git --save 之后每次更新博客内容后都要执行 hexo c —&gt;hexo g —&gt;hexo d，来重新部署。 4.将Hexo部署到GitHub在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式 回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱 12git config --global user.name \"yourname\"git config --global user.email \"youremail\" 创建SSH 1ssh-keygen -t rsa -C \"youremail\" 打开提示已经创建好的.ssh文件夹，其中id_rsa是私人密钥，id_rsa.pub是公共密钥。在GitHub中打开setting —&gt; New SSH key，将id_rsa.pub里面的信息复制进去。 在blog文件夹中打开博客配置文件_config.yml，将最后几行修改为： 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 安装deploy-git 1npm install hexo-deployer-git --save 最后重新部署博客 123hexo chexo ghexo d 这样就可以在 http://yourname.github.io 访问自己的博客了。 5.设置主题我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在blog文件夹下右键GIt Bash Here，下载主题： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 打开blog目录下的博客站点配置文件_config.yml，在开头的Site中添加自己博客的信息，注意将language改为zh-CN： 123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-CNtimezone: 往下拉，将theme改为next： 1theme: next 重新部署博客即可看到主题已经替换。 接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。 设置scheme在\\blog\\themes\\next文件夹中打开主题配置文件_config.yml，找到外观scheme，想使用哪一种就把前面的注释符#去掉，我选用的是Mist。 1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 设置菜单在主题配置文件_config.yml中找到菜单menu，将需要的项前的#去掉，我保留了about关于，categories分类，tags标签，archives归档。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 创建菜单需要的页面： 123hexo new page abouthexo new page tagshexo new page categories 在\\blog\\source下就会生成对应的文件夹，打开其中的index.md文件，将type设置为相应的内容，以about为例： 1234title: aboutdate: 2020-01-17 20:16:07type: \"about\" comments: false 设置背景动画在主题配置文件_config.yml中找到Animation Settings，我使用的是Canvas-nest，将Canvas-nest下的enable状态改为true即可： 123canvas_nest: enable: true onmobile: true # Display on mobile or not —————————————————————————— 到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。 2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-12T02:15:57.000Z","updated":"2020-01-12T03:15:57.000Z","comments":true,"path":"2020/01/12/hello-world/","link":"","permalink":"http://nekomoon404.github.io/2020/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}