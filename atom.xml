<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-07-08T12:49:03.747Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ML笔记（3）Logistic_Regression</title>
    <link href="http://nekomoon404.github.io/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/"/>
    <id>http://nekomoon404.github.io/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/</id>
    <published>2020-07-08T10:48:14.000Z</published>
    <updated>2020-07-08T12:49:03.747Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回顾 Review</strong></p><p>在上一节课 Classification中，讨论了如何通过样本点的均值$u$和协方差$\Sigma$来计算$P(C_1),P(C_2),P(x|C_1),P(x|C_2)$，进而利用$P(C_1|x)=\frac{P(C_1)P(x|C_1)}{P(C_1)P(x|C_1)+P(C_2)P(x|C_2)}$计算得到新的样本点$x$属于class 1的概率，由于是二元分类，属于class 2的概率$P(C_2|x)=1-P(C_1|x)$。</p><p>然后推导了$P(C_1|x)=\sigma(z)=\frac{1}{1+e^{-z}}$，并且在Gaussian distribution下考虑class 1和class 2共用$\Sigma$，可以得到一个线性的z(其实很多其他的Probability model经过化简以后也都可以得到同样的结果)</p><script type="math/tex; mode=display">P_{w,b}(C_1|x)=\sigma(z)=\frac{1}{1+e^{-z}} \\z=w\cdot x+b=\sum\limits_i w_ix_i+b \\</script><p>从上式中我们可以看出，现在这个model(function set)是受$w$和$b$控制的，因此我们不必要再去像前面一样计算那些与概率相关的东西，而是直接计算$w$和$b$，用这个全新的由$w$和$b$决定的model——<strong>Logistic Regression逻辑回归</strong>。</p><h3 id="1-Three-Steps-of-Logistic-Regression"><a href="#1-Three-Steps-of-Logistic-Regression" class="headerlink" title="1.Three Steps of Logistic Regression"></a>1.Three Steps of Logistic Regression</h3><p>现在来用机器学习的“三步走”分析一下逻辑回归。</p><p><strong>Step 1: Function Set</strong></p><p>由所有不同的$w$和$b$组成的函数的集合就是Logistic Regression的Function set。</p><p>$w_i$：weight，$b$：bias，$\sigma(z)$：sigmoid function，$x_i$：input</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708190620.png" style="zoom:67%;"></p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708190653.png" style="zoom: 50%;"></p><p><strong>Step 2：Goodness of a function</strong></p><p>现在我们有N笔Training data，每一笔data都要标注它是属于哪一个class。假设这些Training data是从我们定义的posterior Probability中产生的(后置概率，某种意义上就是概率密度函数)，而w和b就决定了这个posterior Probability，那么就可以去计算某一组w和b去产生这N笔Training data的概率，利用极大似然估计的思想，求出使得似然函数取最大值时的那组参数$w^<em>$和$b^</em>$。</p><p>似然函数只需要将每一个点产生的概率相乘即可，注意，这里假定是二元分类，class 2的概率为1减去class 1的概率。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708191019.png" style="zoom:67%;"></p><p>由于$L(w,b)$是乘积项的形式，为了方便计算，我们将上式做个变换，求$L$的最大值相当于求$-\ln L$的最小值：</p><script type="math/tex; mode=display">\begin{split}&w^*,b^*=\arg \max\limits_{w,b} L(w,b)=\arg\min\limits_{w,b}(-\ln L(w,b)) \\&\begin{equation}\begin{split}-\ln L(w,b)=&-\ln f_{w,b}(x^1)\\&-\ln f_{w,b}(x^2)\\&-\ln(1-f_{w,b}(x^3))\\&\ -...\end{split}\end{equation}\end{split}</script><p>由于class 1和class 2的概率表达式不统一，上面的式子无法写成统一的形式，为了统一格式，这里将Logistic Regression里的所有<strong>Training data都打上0和1的标签</strong>，即output  $\hat{y}=1$代表class 1，output  $\hat{y}=0$代表class 2，于是上式进一步改写成：</p><script type="math/tex; mode=display">\begin{split}-\ln L(w,b)=&-[\hat{y}^1 \ln f_{w,b}(x^1)+(1-\hat{y}^1)ln(1-f_{w,b}(x^1))]\\&-[\hat{y}^2 \ln f_{w,b}(x^2)+(1-\hat{y}^2)ln(1-f_{w,b}(x^2))]\\&-[\hat{y}^3 \ln f_{w,b}(x^3)+(1-\hat{y}^3)ln(1-f_{w,b}(x^3))]\\&\ -...\end{split}</script><p>现在已经有了统一的格式，我们就可以把要minimize的对象写成一个summation的形式：</p><script type="math/tex; mode=display">-\ln L(w,b)=\sum\limits_n -[\hat{y}^n \ln f_{w,b}(x^n)+(1-\hat{y}^n) \ln(1-f_{w,b}(x^n))]</script><p>这里$x^n$表示第n个样本点，$\hat{y}^n$表示第n个样本点的class标签(1表示class 1,0表示class 2)，最终这个summation的形式，里面其实是<strong>两个Bernouli distribution(两点分布)的cross entropy(交叉熵)</strong>。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708191316.png" style="zoom:67%;"></p><p>假设有如上图所示的两个distribution $p$和$q$，它们的交叉熵就是$H(p,q)=-\sum\limits_{x} p(x) \ln (q(x))$，这也就是之前的推导中在$-\ln L(w,b)$前加一个负号的原因。</p><p><strong>cross entropy 交叉熵</strong>的含义是表达这两个distribution有多接近，如果$p$和$q$这两个distribution一模一样的话，那它们算出来的cross entropy就是0，而这里$f(x^n)$表示function的output，$\hat{y}^n$表示预期 的target，因此<strong>交叉熵实际上表达的是希望这个function的output和它的target越接近越好</strong></p><p>总之，我们要找的参数实际上就是：</p><script type="math/tex; mode=display">w^*,b^*=\arg \max\limits_{w,b} L(w,b)=\arg\min\limits_{w,b}(-\ln L(w,b)=\sum\limits_n -[\hat{y}^n \ln f_{w,b}(x^n)+(1-\hat{y}^n) \ln(1-f_{w,b}(x^n))]</script><p><strong>step 3：Find the best function</strong></p><p>实际上就是去找到使loss function即交叉熵之和最小的那组参数$w^<em>,b^</em>$，这里依然可以使用gradient descent的方法。</p><p>sigmoid function $\sigma(z)=\frac{1}{1+e^{-z}}$的微分可以直接作为公式记下来：$\frac{\partial \sigma(z)}{\partial z}=\sigma(z)(1-\sigma(z))$。</p><p>先计算$-\ln L(w,b)=\sum\limits_n -[\hat{y}^n \ln f_{w,b}(x^n)+(1-\hat{y}^n) \ln(1-f_{w,b}(x^n))]$对$w_i$的偏微分，这里$\hat{y}^n$和$1-\hat{y}^n$是常数先不用管它，只需要分别求出$\ln f_{w,b}(x^n)$和$\ln (1-f_{w,b}(x^n))$对$w_i$的偏微分即可，整体推导过程如下：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708191840.png" style="zoom:67%;"></p><p>进一步化简得：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708191844.png" style="zoom:67%;"></p><p>我们发现最终的结果竟然异常的简洁，gradient descent每次update只需要做：</p><script type="math/tex; mode=display">w_i=w_i-\eta \sum\limits_{n}-(\hat{y}^n-f_{w,b}(x^n))x_i^n</script><p>那这个式子到底代表着什么意思呢？现在你的update取决于三件事：</p><ul><li>learning rate，是你自己设定的；</li><li>$x_i$，来自于data；</li><li>$\hat{y}^n-f_{w,b}(x^n)$，代表function的output跟理想target的差距有多大，如果离目标越远，update的步伐就要越大。</li></ul><p>通过上面的分析，我们可以将Logistic Regression和Linear Regression的三个步骤作一个<strong>对比</strong>：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708192230.png" style="zoom:60%;"></p><h3 id="2-Logistic-Regression-Square-error？"><a href="#2-Logistic-Regression-Square-error？" class="headerlink" title="2.Logistic Regression + Square error？"></a>2.Logistic Regression + Square error？</h3><p>这里可能会有一个疑惑，为什么Logistic Regression的loss function不能像linear Regression一样用square error来表示呢？我们试着用square error来定义Loss function重新写一下Logistic Regression的三个步骤：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708192527.png" style="zoom:67%;"></p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708192546.png" style="zoom: 67%;"></p><p>这样就会遇到一个问题：如果第n个点的目标target是class 1，则$\hat{y}^n=1$，此时如果function的output $f_{w,b}(x^n)=1$的话，说明现在离target很接近了，$f_{w,b}(x)-\hat{y}$这一项是0，于是得到的微分$\frac{\partial L}{\partial w_i}$会变成0，这件事情是很合理的；但是当function的output $f_{w,b}(x^n)=0$的时候，说明离target还很遥远，但是由于在step3中求出来的update表达式中有一个$f_{w,b}(x^n)$，因此这个时候也会导致得到的微分$\frac{\partial L}{\partial w_i}$变成0，这样无论function的输出是1还是0，微分项都会是0，导致在做gradient descent时参数无法获得更新。如果举class 2的例子，得到的结果与class 1是一样的。</p><p>如果我们把参数的变化对total loss作图的话，loss function选择cross entropy或square error，参数的变化跟loss的变化情况可视化出来如下所示：(黑色的是cross entropy，红色的是square error)</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708192935.png" style="zoom:67%;"></p><p>假设中心点就是距离目标很近的地方，如果是cross entropy的话，距离目标越远，微分值就越大，参数update的时候变化量就越大，迈出去的步伐也就越大。但当选择square error的时候，过程就会很卡，因为距离目标远的时候，微分也是非常小的，移动的速度是非常慢的。我们之前提到过，实际操作的时候，当gradient接近于0的时候，其实就很有可能会停下来，因此使用square error很有可能在一开始的时候就卡住不动了，而且这里也不能随意地增大learning rate，因为在做gradient descent的时候，你的gradient接近于0，有可能离target很近也有可能很远，因此不知道learning rate应该设大还是设小。</p><p>综上，尽管square error可以使用，但是会出现update十分缓慢的现象，而使用cross entropy可以让你的Training更顺利。</p><h3 id="3-Discriminative-v-s-Generative"><a href="#3-Discriminative-v-s-Generative" class="headerlink" title="3. Discriminative v.s. Generative"></a>3. Discriminative v.s. Generative</h3><p><strong>same model but different currency</strong></p><p>Logistic Regression的方法，称之为Discriminative的方法；而上节课中用Gaussian来描述posterior Probability来建立Generative model的方法，称之为Generative的方法。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708193605.png" style="zoom:67%;"></p><p>实际上它们用的model(function set)是一模一样的，都是$P(C_1|x)=\sigma(w\cdot x+b)$，如果是用Logistic Regression的话，可以用gradient descent的方法直接去把b和w找出来；如果是用Generative model的话，我们要先去算$u_1,u_2,\Sigma^{-1}$，然后算出b和w。</p><p>但是用这两种方法得到的b和w是不同的，尽管我们的function set是同一个，但是由于做了不同的假设，最终从同样的Training data里找出来的参数会是不一样的。</p><p>在Logistic Regression里面，我们<strong>没有做任何实质性的假设</strong>，没有对Probability distribution有任何的描述，我们就是单纯地去找b和w(推导过程中的假设只是便于理解和计算，对实际结果没有影响)。而在Generative model里面，我们对Probability distribution是<strong>有实质性的假设</strong>的，之前我们假设的是Gaussian(高斯分布)，甚至假设在相互独立的前提下是否可以是naive bayes(朴素贝叶斯)，根据这些假设我们才找到最终的b和w</p><p>下图是宝可梦属性分类例子中Generative model和discriminative model的预测结果比较：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708193814.png" style="zoom:67%;"></p><p>实际上Discriminative的方法常常会比Generative的方法表现得更好，这里举一个简单的例子来解释一下：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194028.png" style="zoom: 67%;"></p><p>Testing data的两个feature都是1，凭直觉来说会认为它肯定是class 1。但是如果用naive bayes的方法(朴素贝叶斯假设所有的feature相互独立，方便计算)，却会得到相反的结果：</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194032.png" style="zoom: 67%;"></p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194035.png" style="zoom:67%;"></p><p>Discriminative model在data充足的情况下，它训练出来的model的准确率一般是比Generative model要来的高的。但是Generative的方法也有它自己的优势：它对data的依赖并没有像discriminative model那么严重，在data数量少或者data本身就存在noise的情况下受到的影响会更小，而它还可以做到Prior部分与class-dependent部分分开处理，如果可以借助其他方式提高Prior model的准确率，对整一个model是有所帮助的(比如前面提到的语音辨识)。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194443.png" style="zoom:67%;"></p><h3 id="4-Multi-class-Classification"><a href="#4-Multi-class-Classification" class="headerlink" title="4.Multi-class Classification"></a>4.Multi-class Classification</h3><p>之前讲的都是二元分类的情况，这里讨论一下多元分类问题，其原理的推导过程与二元分类基本一致</p><p>假设有三个class：$C_1,C_2,C_3$，每一个class都有自己的weight和bias，这里$w_1,w_2,w_3$分布代表三个vector，$b_1,b_2,b_3$分别代表三个const，input x也是一个vector</p><blockquote><p>softmax的意思是对最大值做强化，因为在做第一步的时候，对$z$取exponential会使大的值和小的值之间的差距被拉得更开，也就是强化大的值。</p></blockquote><p>我们把$z_1,z_2,z_3$丢进一个<strong>softmax</strong>的function，softmax做的事情是这样三步：</p><ul><li>取exponential，得到$e^{z_1},e^{z_2},e^{z_3}$</li><li>把三个exponential累计求和，得到total sum=$\sum\limits_{j=1}^3 e^{z_j}$</li><li>将total sum分别除去这三项(归一化)，得到$y_1=\frac{e^{z_1}}{\sum\limits_{j=1}^3 e^{z_j}}$、$y_2=\frac{e^{z_2}}{\sum\limits_{j=1}^3 e^{z_j}}$、$y_3=\frac{e^{z_3}}{\sum\limits_{j=1}^3 e^{z_j}}$</li></ul><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194749.png" style="zoom:67%;"></p><p>原来的output $z$可以是任何值，但是做完softmax之后，output $y_i$的值一定是介于0~1之间，并且其和一定是1，$\sum\limits_i y_i=1$。softmax的output，就是拿来当z的posterior probability。</p><p>假设我们用的是Gaussian distribution(共用covariance)，经过一般推导以后可以得到softmax的function，而从information theory也可以推导出softmax function，Maximum entropy本质内容和Logistic Regression是一样的，它是从另一个观点来切入为什么我们的classifier长这样子。</p><h5 id="multi-class-classification的过程："><a href="#multi-class-classification的过程：" class="headerlink" title="multi-class classification的过程："></a><strong>multi-class classification的过程：</strong></h5><p>如下图所示，input $x$经过三个式子分别生成$z_1,z_2,z_3$，经过softmax转化成output $y_1,y_2,y_3$，它们分别是这三个class的posterior probability，由于summation=1，因此做完softmax之后就可以把y的分布当做是一个probability contribution，我们在训练的时候还需要有一个target，因为是三个class，output是三维的，对应的target也是三维的，为了满足交叉熵的条件，target $\hat{y}$也必须是probability distribution，这里我们不能使用1,2,3作为class的区分，为了保证所有class之间的关系是一样的，这里使用类似于one-hot编码的方式，即:</p><script type="math/tex; mode=display">\hat{y}=\begin{bmatrix}1\\0\\0\end{bmatrix}_{x \ ∈ \ class 1}\hat{y}=\begin{bmatrix}0\\1\\0\end{bmatrix}_{x \ ∈ \ class 2}\hat{y}=\begin{bmatrix}0\\0\\1\end{bmatrix}_{x \ ∈ \ class 3}</script><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194751.png" style="zoom:67%;"></p><p>这个时候就可以计算一下output $y$和 target $\hat{y}$之间的交叉熵，即$-\sum\limits_{i=1}^3 \hat{y}_i \ln y_i$，同二元分类一样，多元分类问题也是通过极大似然估计法得到最终的交叉熵表达式的，这里不再赘述。</p><p><strong>Limitation of Logistic Regression</strong></p><p>Logistic Regression其实有很强的限制，给出下图的例子中的Training data，想要用Logistic Regression对它进行分类，其实是做不到的。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194755.png" style="zoom:67%;"></p><p>因为Logistic Regression在两个class之间的boundary就是一条直线，但是在这个平面上无论怎么画直线都不可能把图中的两个class分隔开来。关于这种不可分问题，还有几个点最多可以分几类的问题的深入分析可以看林轩田老师的《机器学习基石》课程的Lecture 5和Lecture 6。</p><p><strong>Feature Transformation</strong></p><p>如果坚持要用Logistic Regression的话，可以使用<strong>Feature Transformation</strong>的方法，原来的feature分布不好划分，那我们可以将之转化以后，找一个比较好的feature space，让Logistic Regression能够处理。</p><p>比如我们可以这样做：假设这里定义$x_1’$是原来的点到$\begin{bmatrix}0\\0 \end{bmatrix}$之间的距离，$x_2’$是原来的点到$\begin{bmatrix}1\\ 1 \end{bmatrix}$之间的距离，重新映射之后如下图右侧(红色两个点重合)，此时Logistic Regression就可以把它们划分开来。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194804.png" style="zoom:67%;"></p><p>但麻烦的是，我们通常并不知道怎么做到有效的feature Transformation，如果在这上面花费太多的时间就得不偿失了，于是我们会希望这个Transformation是机器自己产生的，怎么让机器自己产生呢？</p><p>我们可以让很多<strong>Logistic Regression cascade</strong>(连接)起来，让一个input $x$的两个feature $x_1,x_2$经过两个Logistic Regression的transform，得到新的feature $x_1’,x_2’$，在这个新的feature space上，class 1和class 2是可以用一条直线分开的，那么最后只要再接另外一个Logistic Regression的model(对它来说，$x_1’,x_2’$才是每一个样本点的”feature”，而不是原先的$x_1,x_2$)，它根据新的feature，就可以把class 1和class 2分开。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194801.png" style="zoom:67%;"></p><p>因此着整个流程是，先用n个Logistic Regression做feature Transformation(n为每个样本点的feature数量)，生成n个新的feature，然后再用一个Logistic Regression作classifier</p><p>Logistic Regression的boundary一定是一条直线，它可以有任何的画法，但肯定是按照某个方向从高到低的等高线分布，具体的分布是由Logistic Regression的参数决定的，每一条直线都是由$z=b+\sum\limits_i^nw_ix_i$组成的(二维feature的直线画在二维平面上，多维feature的直线则是画在多维空间上)</p><p>下图是二维feature的例子，分别表示四个点经过transform之后的$x_1’$和$x_2’$，在新的feature space中可以通过最后的Logistic Regression划分开来。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708200056.png" style="zoom:67%;"></p><p>注意，这里的Logistic Regression只是一条直线，它指的是“属于这个类”或“不属于这个类”这两种情况，因此最后的这个Logistic Regression是跟要检测的目标类相关的，当只是二元分类的时候，最后只需要一个Logistic Regression即可，当面对多元分类问题，需要用到多个Logistic Regression来画出多条直线划分所有的类，每一个Logistic Regression对应它要检测的那个类。</p><p><strong>Powerful Cascading Logistic Regression</strong></p><p>通过上面的例子，我们发现，多个Logistic Regression连接起来会产生很powerful的效果(:3_ヽ)_，如果我们把每一个Logistic Regression叫做一个neuron(神经元)，把这些Logistic Regression串起来所形成的network，就叫做Neural Network 类神经网路，那我们已经开始接触到Deep Learning了∠(ᐛ」∠)＿。</p><p><img src="/2020/07/08/ML%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Logistic-Regression/QQ图片20200708194808.png" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      本文介绍了如何用Logisic Regression逻辑回归解决二分类和多分类问题，解释了逻辑回归中为什么不用square error作为loss，以及逻辑回归的局限性，并比较了Discriminative model和Generaive model的区别。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/tags/Machine-Learning/"/>
    
      <category term="Logistic Regression" scheme="http://nekomoon404.github.io/tags/Logistic-Regression/"/>
    
      <category term="Discriminaive model" scheme="http://nekomoon404.github.io/tags/Discriminaive-model/"/>
    
  </entry>
  
  <entry>
    <title>ML笔记（2）Classification</title>
    <link href="http://nekomoon404.github.io/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/"/>
    <id>http://nekomoon404.github.io/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/</id>
    <published>2020-07-01T03:06:27.000Z</published>
    <updated>2020-07-01T13:44:49.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Classification"><a href="#1-Classification" class="headerlink" title="1.Classification"></a>1.Classification</h3><p>这节课的例子是对宝可梦进行分类（老宝可梦训练大师了），宝可梦有18种属性，现在要解决的分类问题就是做一个宝可梦种类的分类器，我们要找一个function，这个function的input是某一只宝可梦，它的output就是这只宝可梦属于这18类别中的哪一个type。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701150638.png" style="zoom: 33%;"></p><p>对每一只宝可梦（比如皮卡丘），可以用7个feature的数值组成的vector来描述它。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701150644.png" style="zoom:33%;"></p><p>把编号400以下的宝可梦当做training data，编号400以上的当做testing data。这里我们先只考虑二分类，只考虑水系Water和一般系Normal宝可梦。</p><h4 id="1-1-Classification-as-Regression？"><a href="#1-1-Classification-as-Regression？" class="headerlink" title="1.1.Classification as Regression？"></a>1.1.Classification as Regression？</h4><p>以binary classification为例，我们在Training时让输入为class 1的输出为1，输入为class 2的输出为-1；那么在testing的时候，regression的output是一个数值，它接近1则说明它是class 1，它接近-1则说明它是class 2。但Regression中对“好，坏”的定义并不适用于Classification。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701151214.png" style="zoom:33%;"></p><h4 id="1-2-Ideal-Alternatives"><a href="#1-2-Ideal-Alternatives" class="headerlink" title="1.2.Ideal Alternatives"></a>1.2.Ideal Alternatives</h4><p>理想的方法是这样的：我们要找的function f(x)里面会有另外一个function g(x)，当我们的input x输入后，如果g(x)&gt;0，那f(x)的输出就是class 1，如果g(x)&lt;0，那f(x)的输出就是class 2，这个方法保证了function的output都是离散的表示class的数值。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701151702.png" style="zoom:33%;"></p><p>把loss function定义成$L(f)=\sum\limits_n\delta(f(x^n)≠\hat{y}^n)$，即这个model在所有的training data上predict预测错误的次数，也就是说分类错误的次数越少，这个function表现得就越好</p><p>但是这个loss function没有办法微分，是无法用gradient descent的方法去解的，当然有Perceptron、SVM这些方法可以用（感知机和支持向量机的内容，在林轩田老师的机器学习基石和技法课程中都有详细的讲解），但这里先用另外一个solution来解决这个问题，即从概率的角度来考虑二分类问题。</p><h3 id="2-Solution-Generative-model"><a href="#2-Solution-Generative-model" class="headerlink" title="2.Solution: Generative model"></a>2.Solution: Generative model</h3><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701152159.png" style="zoom:33%;"></p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701152137.png" style="zoom:33%;"></p><p>这两张图的内容很好理解，就是贝叶斯公式啦。这种想法叫做<strong>Generative model</strong>(生成模型)，因为有这个model，就可以拿它来generate $x$(如果你可以计算出每一个$x$出现的概率，就可以用这个distribution分布来生成$x$、sample $x$出来)。</p><p>接下来考虑怎么计算其中的四项：$P(C_1)，P(C_2)，P(x|C_1)，P(x|C_2)$。</p><h4 id="2-1-Prior"><a href="#2-1-Prior" class="headerlink" title="2.1.Prior"></a>2.1.Prior</h4><p>$P(C_1)$和$P(C_2)$这两个概率，被称为Prior，计算这两个值还是很简单的。</p><p>假设我们还是考虑二元分类问题，编号小于400的data用来Training，编号大于400的data用来testing，如果想要严谨一点，可以在Training data里面分一部分validation出来模拟testing的情况</p><p>在Training data里面，有79只水系宝可梦，61只一般系宝可梦，那么$P(C_1)=79/(79+61)=0.56$，$P(C_2)=61/(79+61)=0.44$</p><h4 id="2-2-Probability-from-Class"><a href="#2-2-Probability-from-Class" class="headerlink" title="2.2.Probability from Class"></a>2.2.Probability from Class</h4><p>计算$P(x|C_1)$和$P(x|C_2)$的值，假设$x$是一只新来的海龟，它显然是水系的，但是在79只水系的宝可梦training data里面根本就没有海龟，那要如何计算$P(x|C_1)$呢。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701111739.png" style="zoom: 33%;"></p><p>每一只宝可梦可以用由特征值组成的向量来表示，每个sample有7个feature，为了方便可视化，这里只考虑Defense和SP Defence两种feature。我们需要用已有的数据去估测海龟出现的可能性，你可以想象说这已有的79只水系宝可梦的data其实只是冰山一角，假定水系神奇宝贝的Defense和SP Defense是从一个Gaussian的distribution里面sample出来的，下图只是采样了79个点之后得到的分布，但是从高斯分布里采样出海龟这个点的几率并不是0。现在的问题是怎么从这79个已有的点计算出Gaussian distribution函数。</p><h4 id="2-3-Gaussian-distribution函数"><a href="#2-3-Gaussian-distribution函数" class="headerlink" title="2.3.Gaussian distribution函数"></a>2.3.Gaussian distribution函数</h4><script type="math/tex; mode=display">f_{u,\Sigma}(x)=\frac{1}{(2\pi)^{\frac{D}{2}}}\frac{1}{|\Sigma|^{\frac{1}{2}}} \exp \{ -\frac{1}{2}(x-u)^T\Sigma^{-1}(x-u) \}</script><p>Input: vector $x$, output: probability of sampling x ；其中$\mu$表示方差均值mean，$\Sigma$表示协方差矩阵covariance matrix。</p><p>从下图中可以看出，同样的$\Sigma$，不同的$u$，概率分布最高点的地方是不一样的：</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701113417.png" style="zoom: 25%;"></p><p>如果是同样的$u$，不同的$\Sigma$，概率分布最高点的地方是一样的，但是分布的密集程度是不一样的：</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701113421.png" style="zoom:25%;"></p><p>Gaussian distribution函数是由$\mu$和$\Sigma$决定的，估计$\mu$和$\Sigma$可以使用极大似然估计(Maximum Likelihood)的方法，其思路是找出最特殊的那对$u$和$\Sigma$，从它们决定的高斯函数中再次采样出79个点，使”得到的分布情况与当前已知79点的分布情况相同“这件事情发生的可能性最大。</p><p>实际上任意一组$u$和$\Sigma$对应的高斯函数($u$表示该Gaussian的中心点，$\Sigma$表示该Gaussian的分散程度)都有可能sample出跟当前分布一致的样本点，就像上图中的两个红色圆圈所代表的高斯函数，但肯定存在着发生概率最大的哪一个Gaussian，而这个函数就是我们要找的。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701113858.png" style="zoom:33%;"></p><p>似然函数：</p><script type="math/tex; mode=display">L(u,\Sigma)=f_{u,\Sigma}(x^1)\cdot f_{u,\Sigma}(x^2)...f_{u,\Sigma}(x^{79})</script><p>实际上就是该事件发生的概率就等于每个点都发生的概率之积，要求的$\mu$和$\Sigma$就是使似然函数取极大值的$\mu$和$\Sigma$：</p><script type="math/tex; mode=display">u^*,\Sigma^*=\arg \max\limits_{u,\Sigma} L(u,\Sigma)</script><p>对$\mu$和$\Sigma$分别偏导，使微分等于0，得到的高斯函数的$u$和$\Sigma$的最优解如下：</p><script type="math/tex; mode=display">u^*=\frac{1}{79}\sum\limits_{n=1}^{79}x^n \\ \Sigma^*=\frac{1}{79}\sum\limits_{n=1}^{79}(x^n-u^*)(x^n-u^*)^T</script><p>这样我们由Training Data就可以分别求出Class 1和Class 2的$\mu$和$\Sigma$，从而计算出海龟这个sample的$P(x|C_1),P(x|C_2)$。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701114737.png" style="zoom: 33%;"></p><h4 id="2-4-Do-Classification"><a href="#2-4-Do-Classification" class="headerlink" title="2.4.Do Classification"></a>2.4.Do Classification</h4><p>接着将$P(C_1),P(x|C_1),P(C_2),P(x|C_2)$代入公式计算出$P(C_1|x)$，若大于0.5，则说明sample $x$属于Class 1啦。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701115026.png" style="zoom:33%;"></p><p>将得到的结果在图中表示出来，横轴是Defense，纵轴是SP Defense，蓝色的点是水系的宝可梦的分布，红色的点是一般系的宝可梦的分布，对图中的每一个点都计算出它是class 1的概率$P(C_1|x)$，这个概率用颜色来表示，如果某点在红色区域，表示它是水系宝可梦的概率更大；如果该点在其他颜色的区域，表示它是水系宝可梦的概率比较小</p><p>因为我们做的是分类问题，因此令几率&gt;0.5的点为类别1，几率&lt;0.5的点为类别2，也就是右上角的图中的红色和蓝色两块区域，再把testing data上得到的结果可视化出来，即右下角的图，发现分的不是太好，正确率才是47%。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701120221.png" style="zoom:33%;"></p><p>我们之前用的只是Defense和SP Defense这两个feature，在二维空间上得到的效果不太好，但实际上一开始就提到了宝可梦总共是有7个features的，也许在二维空间上它们是重叠在一起的，但是在六维空间上看它们也许会区分得很好。​考虑7个feature时，$\mu$是一个7-dim的vector，$\Sigma$则是一个7*7的matrix，发现得到的准确率也才54%，这个分类器表现并不好，接下来考虑如何改进这个分类器。</p><h4 id="2-5-Modify-Model"><a href="#2-5-Modify-Model" class="headerlink" title="2.5.Modify Model"></a>2.5.Modify Model</h4><p>上面用到的Gaussian distribution函数，我们给每一个Class的Gaussian都计算了自己的mean和convariance，这种做法其实并不实用，常用的做法是，<strong>不同的class可以share同一个cocovariance matrix</strong>。variance是跟input的feature size的平方成正比的，所以当feature的数量很大的时候，$\Sigma$大小的增长是可以非常快的，在这种情况下，给不同的Gaussian以不同的covariance matrix，会造成model的参数太多，而参数多会导致该model的variance过大，出现overfitting的现象，因此对不同的class使用同一个covariance matrix，可以有效减少参数，减小overfitting。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701140609.png" style="zoom:33%;"></p><p>这样用$\mu_1$、$\mu_2$和$\Sigma$来决定一个总的似然函数，求出其取极大值时的$\mu_1$、$\mu_2$和$\Sigma$，发现得到的$u_1$和$u_2$和原来一样，还是各自的均值，而$\Sigma$则是原先两个$\Sigma_1$和$\Sigma_2$的加权。</p><p>将结果表示在图中，你会发现，class 1和class 2在没有共用covariance matrix之前，它们的分界线是一条曲线；如果共用covariance matrix的话，它们之间的分界线就会变成一条直线，这样的model，我们也称之为linear model(尽管Gaussian不是linear的，但是它分两个class的boundary是linear)。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701141141.png" style="zoom:33%;"></p><p>如果考虑宝可梦的所有的7个feature，且共用covariance的话，正确率会从原来的54%提升到73%。</p><h4 id="2-6-Three-Steps-of-classification"><a href="#2-6-Three-Steps-of-classification" class="headerlink" title="2.6.Three Steps of classification"></a>2.6.Three Steps of classification</h4><p>回顾一下做classification的三个步骤，实际上也就是做machine learning的三个步骤：</p><ul><li><p>Find a function set(model)</p><p>这些required probability $P(C)$和probability distribution $P(x|C)$就是model的参数，选择不同的Probability distribution(比如不同的分布函数，或者是不同参数的Gaussian distribution)，就会得到不同的function，把这些不同参数的Gaussian distribution集合起来，就是一个model，如果不适用高斯函数而选择其他分布函数，就是一个新的model了</p><p>当这个posterior Probability $P(C|x)&gt;0.5$的话，就output class 1，反之就output class 2</p></li><li><p>Goodness of function</p><p>对于Gaussian distribution这个model来说，要评价的是决定这个高斯函数形状的均值$u$和协方差$\Sigma$这两个参数的好坏，而极大似然函数$L(u,\Sigma)$的输出值，就评价了这组参数的好坏</p></li><li><p>Find the best function</p><p>找到的那个最好的function，就是使$L(u,\Sigma)$值最大的那组参数，实际上就是所有样本点的均值和协方差：</p><script type="math/tex; mode=display">u^*=\frac{1}{n}\sum\limits_{i=0}^n x^i \ \ \ \ \Sigma^*=\frac{1}{n}\sum\limits_{i=0}^n (x^i-u^*)(x^i-u^*)^T</script><p>式中的$x$表示一个feature的vector，上标$i$表示第$i$个sample</p></li></ul><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701142029.png" style="zoom: 33%;"></p><h4 id="2-7-Probability-distribution"><a href="#2-7-Probability-distribution" class="headerlink" title="2.7.Probability distribution"></a>2.7.Probability distribution</h4><p>上面的讨论中我们使用的是Gaussian distribution函数，当然你也可以使用其他分布函数，这通常要根据数据集的具体情况来确定，比如一个特征是binary feature，那选择使用伯努利分布Bernoulli distribution比较好。如果选择的是简单的分布函数(参数比较少)，那么bias就偏大，variance就小；如果选择复杂的分布函数，那么bias就偏小，variance就偏大。</p><h5 id="Naive-Bayes-Classifier-朴素贝叶斯分类法"><a href="#Naive-Bayes-Classifier-朴素贝叶斯分类法" class="headerlink" title="Naive Bayes Classifier(朴素贝叶斯分类法)"></a>Naive Bayes Classifier(朴素贝叶斯分类法)</h5><p>考虑这样一件事情，假设$x=[x_1 \ x_2 \ x_3 \ … \ x_k \ … \ ]$中每一个dimension $x_k$的分布都是相互独立的，它们之间的covariance都是0，那我们就可以把x产生的几率拆解成$x_1,x_2,…,x_k$产生的几率之积。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701142630.png" style="zoom:33%;"></p><p>这里每一个dimension的分布函数都是一维的Gaussian distribution，就相当于原高维的Gaussian，它的covariance matrix变成是diagonal(对角的)，在不是对角线的地方，值都是0，这样就可以更加减少需要的参数量，就可以得到一个更简单的model。</p><p>这种方法叫做Naive Bayes Classifier(朴素贝叶斯分类法)，如果真的明确了<u>所有的feature之间是相互独立的</u>，是不相关的，使用朴素贝叶斯分类法的performance是会很好的；如果这个假设是不成立的，那么Naive bayes classfier的bias就会很大，它就不是一个好的classifier(朴素贝叶斯分类法本质就是减少参数)。</p><p>在宝可梦这个例子中（李老师也是个老二次元了|ू･ω･` )），使用朴素贝叶斯的效果并不好，因为不同feature之间还是有相关的，各种feature之间的covariance还是必要的，比如战斗力和防御力它们之间是正相关的，covariance不能等于0。</p><h4 id="2-8-Analysis-Posterior-Probability"><a href="#2-8-Analysis-Posterior-Probability" class="headerlink" title="2.8.Analysis Posterior Probability"></a>2.8.Analysis Posterior Probability</h4><p>接下来我们来分析一下这个后置概率的表达式，会发现一些有趣的现象</p><p>表达式上下同除以分子，再引入变量$z$，得到$\sigma(z)=\frac{1}{1+e^{-z}}$，这个function叫做sigmoid function</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701144150.png" style="zoom: 25%;"></p><p>sigmoid函数真是再熟悉不过了，接下来推导一下$z$的具体表达式，Warning of Math（老师原话：下面这部分推导听不懂的同学可以先睡一会⊙(・◇・)？，之后直接听结论）</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701144720.png" style="zoom:33%;"></p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701144725.png" style="zoom:33%;"></p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701144732.png" style="zoom:33%;"></p><p>推导是有些复杂，但当$\Sigma_1$和$\Sigma_2$相同时，经过化简$z$就变成了一个linear的function，$x$前的一项可以当做vector $w$，后面的几项相加是一个scalar，当做常数$b$。</p><p><img src="/2020/07/01/ML%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89Classification/QQ图片20200701145229.png" style="zoom:33%;"></p><p>$P(C_1|x)=\sigma (w\cdot x+b)$这个式子就解释了，当class 1和class 2共用$\Sigma$的时候，它们之间的boundary会是线性的。</p><p>这样在Generative model里，我们要做的就是用某些方法去找出$N_1,N_2,u_1,u_2,\Sigma$，找出这些以后就算出$w$和$b$，把它们代进$P(C_1|x)=\sigma(w\cdot x+b)$这个式子，计算概率。</p><p>但是为什么要这么麻烦呢(ｷ｀ﾟДﾟ´)？我们的最终目标都是要找一个vector $w$和const $b$，何必先去计算概率，算出一些$u,\Sigma$，然后再回过头来又去算$w$和$b$。那么能不能直接把$w$和$b$计算出来呢，下一节课Logistic Regression将会解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      本文以宝可梦分类为例，从概率的角度来解释一个二元分类问题
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/tags/Machine-Learning/"/>
    
      <category term="Classification" scheme="http://nekomoon404.github.io/tags/Classification/"/>
    
  </entry>
  
  <entry>
    <title>ML笔记（1）Gradient_Descent</title>
    <link href="http://nekomoon404.github.io/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/"/>
    <id>http://nekomoon404.github.io/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/</id>
    <published>2020-06-30T03:05:18.000Z</published>
    <updated>2020-06-30T04:05:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周开始学李宏毅老师的Machine Learning 2020的课程了，从第一节课的课程概述来看，这门课除了会介绍传统的Machine Learning算法外，还会介绍很多Deep Learning的内容，时长也是非常感人(ㄒoㄒ)，希望自己能坚持学下去吧。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212455.png" style="zoom: 60%;"></p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212506.png" style="zoom:50%;"></p><p>前面几节课（p3-p7）分别讲了回归 Regression，误差来源 Where does the error come from，梯度下降 Gradient Descent，老师用的预测宝可梦pokemon的CP值的例子还是蛮有趣的hhh。这部分的理论内容自己是比较熟悉，也有之前做的纸质笔记，在这里就不详细展开了，这里主要写一下使用Gradient Descent的Tips，以及其背后的Theory。</p><h1 id="1-Gradient-Descent-Tips"><a href="#1-Gradient-Descent-Tips" class="headerlink" title="1. Gradient Descent Tips"></a>1. Gradient Descent Tips</h1><h2 id="1-1-Tip-1-Tuning-your-learning-rates"><a href="#1-1-Tip-1-Tuning-your-learning-rates" class="headerlink" title="1.1.Tip 1: Tuning your learning rates"></a>1.1.Tip 1: Tuning your learning rates</h2><p>gradient descent过程中，影响结果的一个很关键的因素就是learning rate的大小</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212510.png" style="zoom: 67%;"></p><p>当参数有很多个的时候(&gt;3)，其实我们很难做到将loss随每个参数的变化可视化出来(因为最多只能可视化出三维的图像，也就只能可视化三维参数)，但是我们可以把update的次数作为唯一的一个参数，将loss随着update的增加而变化的趋势给可视化出来(上图右半部分)</p><p>所以做gradient descent时可以把不同的learning rate下，loss随update次数的变化曲线给可视化出来，它可以提醒你该如何调整当前的learning rate的大小，直到出现稳定下降的曲线</p><h3 id="Adaptive-Learning-rates"><a href="#Adaptive-Learning-rates" class="headerlink" title="Adaptive Learning rates"></a>Adaptive Learning rates</h3><p>显然这样手动地去调整learning rates很麻烦，因此我们需要有一些自动调整learning rates的方法。最基本、最简单的大原则是：learning rate通常是随着参数的update越来越小的。可以这样理解：在起始点的时候，通常是离最低点是比较远的，这时候步伐就要跨大一点；而经过几次update以后，会比较靠近目标，这时候就应该减小learning rate，让它能够收敛在最低点的地方。如可以设置到了第t次update，$\eta^t=\eta/ \sqrt{t+1}$。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212514.png" style="zoom: 67%;"></p><p>这种方法使所有参数以同样的方式同样的learning rate进行update，而最好的状况是每个参数都给他不同的learning rate去update</p><h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p><strong>Adagrad</strong>就是将不同参数的learning rate分开考虑的一种算法(adagrad算法update到后面速度会越来越慢，当然这只是adaptive算法中最简单的一种)。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212519.png" style="zoom:67%;"></p><p>这里的$w$是function中的某个参数，$t$表示第$t$次update，$g^t$表示Loss对$w$的偏微分，而$\sigma^t$是之前所有Loss对$w$偏微分的<strong>均方根 root mean square</strong>这个值对每一个参数来说都是不一样的。</p><script type="math/tex; mode=display">\begin{equation}\begin{split}&Adagrad\\&w^1=w^0-\frac{\eta^0}{\sigma^0}\cdot g^0 \ \ \ \sigma^0=\sqrt{(g^0)^2} \\&w^2=w^1-\frac{\eta^1}{\sigma^1}\cdot g^1 \ \ \ \sigma^1=\sqrt{\frac{1}{2}[(g^0)^2+(g^1)^2]} \\&w^3=w^2-\frac{\eta2}{\sigma^2}\cdot g^2 \ \ \ \sigma^2=\sqrt{\frac{1}{3}[(g^0)^2+(g^1)^2+(g^2)^2]} \\&... \\&w^{t+1}=w^t-\frac{\eta^t}{\sigma^t}\cdot g^t \ \ \ \sigma^t=\sqrt{\frac{1}{1+t}\sum\limits_{i=0}^{t}(g^i)^2}\end{split}\end{equation}</script><p>由于$\eta^t$和$\sigma^t$中都有一个$\sqrt{\frac{1}{1+t}}$的因子，两者相消，即可得到Adagrad的最终表达式：</p><script type="math/tex; mode=display">w^{t+1}=w^t-\frac{\eta}{\sqrt{\sum\limits_{i=0}^t(g^i)^2}}\cdot g^t</script><h3 id="对Adagrad中的contradiction的解释"><a href="#对Adagrad中的contradiction的解释" class="headerlink" title="对Adagrad中的contradiction的解释"></a>对Adagrad中的contradiction的解释</h3><p>Adagrad的表达式$w^{t+1}=w^t-\frac{\eta}{\sqrt{\sum\limits_{i=0}^t(g^i)^2}}\cdot g^t$里面有一件很矛盾的事情：我们在做gradient descent的时候，希望的是当梯度值即微分值$g^t$越大的时候(此时斜率越大，还没有接近最低点)更新的步伐要更大一些，但是Adagrad的表达式中，分母表示梯度越大步伐越大，分子却表示梯度越大步伐越小，两者似乎相互矛盾。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212523.png" style="zoom:67%;"></p><p>在一些paper里是这样解释的：Adagrad要考虑的是，这个gradient有多surprise，即反差有多大，假设t=4的时候$g^4$与前面的gradient反差特别大，那么$g^t$与$\sqrt{\frac{1}{t+1}\sum\limits_{i=0}^t(g^i)^2}$之间的大小反差就会比较大，它们的商就会把这一反差效果体现出来。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212527.png" style="zoom:67%;"></p><p>而且需要注意的是：gradient越大，离最低点越远，这个有点直观的想法在有多个参数的情况下是不一定成立的。如下图所示，$w_1$和$w_2$分别是loss function的两个参数，loss的值投影到该平面中以颜色深度表示大小，分别在$w_2$和$w_1$处垂直切一刀(这样就只有另一个参数的gradient会变化)，对应的情况为右边的两条曲线，可以看出，比起a点，c点距离最低点更近，但是它的gradient却越大。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212530.png" style="zoom:67%;"></p><p>考虑一个简单的情况，对于一个二次函数$y=ax^2+bx+c$来说，最小值点的$x=-\frac{b}{2a}$，而对于任意一点$x_0$，它迈出最好的步伐长度是$|x_0+\frac{b}{2a}|=|\frac{2ax_0+b}{2a}|$(这样就一步迈到最小值点了)，联系该函数的一阶和二阶导数$y’=2ax+b$、$y’’=2a$，可以发现the best step 就是 $|\frac{y’}{y’’}|$，即|一阶导数|/|二阶导数|，可见best step不仅跟一阶导数(gradient)有关，还跟二阶导数有关，用这个best step可以来反映Loss Function上一点到最低点的距离。</p><p>再来回顾Adagrad的表达式：</p><script type="math/tex; mode=display">w^{t+1}=w^t-\frac{\eta}{\sqrt{\sum\limits_{i=0}^t(g^i)^2}}\cdot g^t</script><p>其中，$g^t$是一次微分，而分母中的$\sqrt{\sum\limits_{i=0}^t(g^i)^2}$则反映了二次微分的大小。Adagrad中用root mean square of the previous derivatives of parameter w来近似二次微分的大小，避免引入额外的计算量。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701213759.png" style="zoom:33%;"></p><h2 id="1-2-Tip-2-Stochastic-Gradient-Descent"><a href="#1-2-Tip-2-Stochastic-Gradient-Descent" class="headerlink" title="1.2.Tip 2: Stochastic Gradient Descent"></a>1.2.Tip 2: Stochastic Gradient Descent</h2><p><strong>随机梯度下降 Stochastic Gradient Descent</strong>的方法可以让训练更快速，传统的gradient descent的思路是遍历所有的样本点之后再构建loss function，然后去update参数；而stochastic gradient descent的做法是，看到一个样本点就update一次，因此它的loss function不是所有样本点的error平方和，而是这个随机样本点的error平方。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212538.png" style="zoom: 67%;"></p><p>Stochastic Gradient Descent与传统Gradient Descent的效果对比如下：</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212543.png" style="zoom:67%;"></p><h2 id="1-3-Tip-3-Feature-Scaling"><a href="#1-3-Tip-3-Feature-Scaling" class="headerlink" title="1.3.Tip 3: Feature Scaling"></a>1.3.Tip 3: Feature Scaling</h2><p><strong>特征缩放Feature Scaling</strong>，当多个特征的尺度很不一样时，最好将这些不同feature的范围缩放成一样的。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212548.png" style="zoom:67%;"></p><p>举个例子来解释为什么需要做feature scaling，$y=b+w_1x_1+w_2x_2$，假设$x_1$的值都是很小的，比如1,2…；$x_2$的值都是很大的，比如100,200…。此时去画出loss的error surface，如果对$w_1$和$w_2$都做一个同样的变动$\Delta w$，那么$w_1$的变化对$y$的影响是比较小的，而$w_2$的变化对$y$的影响是比较大的。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212552.png" style="zoom:67%;"></p><p>左边的error surface表示，w1对y的影响比较小，所以w1对loss是有比较小的偏微分的，因此在w1的方向上图像是比较平滑的；w2对y的影响比较大，所以w2对loss的影响比较大，因此在w2的方向上图像是比较sharp的。如果x1和x2的的scale是接近的，那么w1和w2对loss就会有差不多的影响力，loss的图像接近于圆形，那这样做对gradient descent有什么好处呢？</p><p><strong>对Gradient Descent的帮助</strong></p><p>之前我们做的demo已经表明了，对于这种长椭圆形的error surface，如果不使用Adagrad之类的方法，是很难搞定它的，因为在像w1和w2这样不同的参数方向上，会需要不同的learning rate，用相同的learning rate很难达到最低点。如果x1和x2有相同的scale的话，loss在参数w1、w2平面上的投影就是一个正圆形，update参数会比较容易。</p><p>而且gradient descent的每次update并不都是向着最低点走的，每次update的方向是顺着等高线的方向(梯度gradient下降的方向)，而不是径直走向最低点；但是当经过对input的scale使loss的投影是一个正圆的话，不管在这个区域的哪一个点，它都会向着圆心走。因此feature scaling对参数update的效率是有帮助的</p><p><strong>如何做feature scaling</strong></p><p>假设有R个example(上标i表示第i个样本点)，$x^1,x^2,x^3,…,x^r,…x^R$，每一个example，它里面都有一组feature(下标j表示该样本点的第j个特征)</p><p>对每一个feature (demension)  i，都去算出它的平均值mean=$m_i$，以及标准差standard deviation=$\sigma_i$</p><p>对第r个example的第i个feature的值，减掉均值，除以标准差，即：</p><script type="math/tex; mode=display">x_i^r=\frac{x_i^r-m_i}{\sigma_i}</script><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212556.png" style="zoom:67%;"></p><h1 id="2-Gradient-Descent-Theory"><a href="#2-Gradient-Descent-Theory" class="headerlink" title="2.Gradient Descent Theory"></a>2.Gradient Descent Theory</h1><p>考虑当用梯度下降解决问题：</p><script type="math/tex; mode=display">\theta^*=\arg \underset{\theta}{\min} L(\theta)</script><p>每次更新参数 $\theta$，都得到一个新的$ \theta$，它都使得损失函数更小。即：</p><script type="math/tex; mode=display">L(\theta^0)>L(\theta^1)>L(\theta^2)>\dots</script><p>上述结论正确吗？其实是不正确的，我们并不能每次更新$\theta$，都能使损失函数更小。那么如何更新$\theta$才能使损失函数更小呢。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701214114.png" style="zoom: 33%;"></p><p>比如在$\theta^0$ 处，可以在一个小范围的圆圈内找到使损失函数最小的$\theta^1$，不断的这样去寻找。接着就考虑如何在这样一个小圆圈中寻找到$\theta^1$。这里就需要引入泰勒展开式（高数里都有讲啦）。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212559.png" style="zoom:67%;"></p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212603.png" style="zoom:67%;"></p><p>回到刚才的问题上，我们将点(a,b)附件的小圆内的损失函数在点(a,b)处展开：</p><script type="math/tex; mode=display">L(\theta)≈L(a,b)+\frac{\partial L(a,b)}{\partial \theta_1}(\theta_1-a)+\frac{\partial L(a,b)}{\partial \theta_2}(\theta_2-b)</script><p>令</p><script type="math/tex; mode=display">s=L(a,b),\quad u=\frac{\partial L(a,b)}{\partial \theta_1},\quad v=\frac{\partial L(a,b)}{\partial \theta_2}</script><p>则</p><script type="math/tex; mode=display">L(\theta)≈s + u\cdot (\theta_1-a)+v\cdot (\theta_2-b)</script><p>设红色圆圈的半径为d，则有限制条件：</p><script type="math/tex; mode=display">(\theta_1-a)^2+(\theta_2-b)^2≤d^2</script><p>求$L(\theta)_{min}$，这里有个小技巧，把$L(\theta)$转化为两个向量的乘积：</p><script type="math/tex; mode=display">u\cdot (\theta_1-a)+v\cdot (\theta_2-b)=(u,v)\cdot (\theta_1-a,\theta_2-b)=(u,v)\cdot (\Delta \theta_1,\Delta \theta_2)</script><p>显然，当向量$(\theta_1-a,\theta_2-b)$与向量$(u,v)$反向，且刚好到达red circle的边缘时(用$\eta$去控制向量的长度)，$L(\theta)$最小。</p><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212620.png" style="zoom:67%;"></p><p>于是$L(\theta)$局部最小值对应的参数为中心点减去gradient的加权：</p><script type="math/tex; mode=display">\begin{bmatrix}\Delta \theta_1 \\ \Delta \theta_2\end{bmatrix}=-\eta\begin{bmatrix}u \\v\end{bmatrix}=>\begin{bmatrix}\theta_1 \\\theta_2\end{bmatrix}=\begin{bmatrix}a\\b\end{bmatrix}-\eta\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}a\\b\end{bmatrix}-\eta\begin{bmatrix}\frac{\partial L(a,b)}{\partial \theta_1}\\\frac{\partial L(a,b)}{\partial \theta_2}\end{bmatrix}</script><p>这就是gradient descent在数学上的推导，注意它的重要<strong>前提</strong>是，<strong>设定的红色圈圈的范围要足够小</strong>，这样泰勒展开给我们的近似才会精确，而$\eta$的值是与圆的半径成正比的，因此理论上learning rate要无穷小才能够保证每次gradient descent在update参数之后的loss会越来越小。于是当learning rate没有设置好，泰勒近似不成立，就有可能使gradient descent过程中的loss没有越来越小</p><p>当然泰勒展开可以使用二阶、三阶乃至更高阶的展开，但这样会使得运算量大大增加，反而降低了运行效率。</p><h1 id="3-More-Limitation-of-Gradient-Descent"><a href="#3-More-Limitation-of-Gradient-Descent" class="headerlink" title="3.More Limitation of Gradient Descent"></a>3.More Limitation of Gradient Descent</h1><p>之前已经讨论过，gradient descent有一个问题是它会停在local minima的地方就停止update了。事实上还有一个问题是，微分值是0的地方并不是只有local minima，settle point （鞍点）的微分值也是0。以上都是理论上的探讨，到了实践的时候，其实当gradient的值接近于0的时候，我们就已经把它停下来了，但是微分值很小，不见得就是很接近local minima，也有可能是在一个鞍点上。还有个限制就是在”坡度“小的区域update得很慢。总结一下就是下面三点：</p><ul><li>Very slow at the plateau</li><li>Stuck at saddle point</li><li>Stuck at local minima</li></ul><p><img src="/2020/06/30/ML%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89Gradient-Descent/QQ图片20200701212616.png" style="zoom:67%;"></p>]]></content>
    
    <summary type="html">
    
      本文主要介绍了使用Gradient Dsecent时的三个Tips：Tuning your learning rates；Stochastic Gradient Descent；Feature Scaling，以及Gradient Descent背后的数学原理。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/tags/Machine-Learning/"/>
    
      <category term="Gradient Descent" scheme="http://nekomoon404.github.io/tags/Gradient-Descent/"/>
    
  </entry>
  
  <entry>
    <title>单目视觉里程计</title>
    <link href="http://nekomoon404.github.io/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/"/>
    <id>http://nekomoon404.github.io/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/</id>
    <published>2020-06-16T02:15:05.000Z</published>
    <updated>2020-06-27T03:23:39.546Z</updated>
    
    <content type="html"><![CDATA[<p>视觉里程计(Visual Odometry，VO)是一种利用连续的图像序列来估计相机或机器人移动距离的方法，也被称为Visual SLAM问题的前端，是移动机器人定位导航领域中的关键技术之一。作业要求基于OpenCV初步实现一个简单的视觉里程计，我主要参考了高翔的《视觉slam十四讲》来完成，并将项目上传到Github，地址为<a href="https://github.com/nekomoon404/slam-VO" target="_blank" rel="noopener">https://github.com/nekomoon404/slam-VO</a>。下面整理了这次大作业的报告文档。</p><h2 id="视觉里程效果截图"><a href="#视觉里程效果截图" class="headerlink" title="视觉里程效果截图"></a>视觉里程效果截图</h2><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/微信图片_20200616071621.png" style="zoom:80%;"></p><h2 id="程序使用方法"><a href="#程序使用方法" class="headerlink" title="程序使用方法"></a>程序使用方法</h2><p>运行环境：Ubuntu16.04+OpenCV3.4.0</p><p>安装程序所需的依赖库：线性代数库<code>Eigen3</code>，基于图优化的库<code>g2o</code>。</p><p>使用的数据集：KITTI数据集 灰度序列  /00/image_0 中的前2000帧图片</p><p>运行前更改<code>slam-VO.h</code>文件中第137行对应的路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">myfile</span> <span class="params">(<span class="string">"/home/neko/slam-VO/poses/00.txt"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>更改<code>slam-VO.cpp</code>文件中第23到25行，以及第99行对应的路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(filename1, <span class="string">"/home/neko/slam-VO/00/image_0/%06d.png"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(filename2, <span class="string">"/home/neko/slam-VO/00/image_0/%06d.png"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">string</span> pose_path =  <span class="string">"/home/neko/slam-VO/poses/00.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(filename, <span class="string">"/home/neko/slam-VO/00/image_0/%06d.png"</span>, numFrame);</span><br></pre></td></tr></table></figure><p>进入<code>/build</code>文件夹，在终端依次执行来运行程序：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake</span></span> ..</span><br><span class="line">make</span><br><span class="line">./slam-VO</span><br></pre></td></tr></table></figure><h2 id="算法详细介绍"><a href="#算法详细介绍" class="headerlink" title="算法详细介绍"></a>算法详细介绍</h2><p>程序的<strong>整体流程</strong>如下：</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/流程图4.jpg" style="zoom: 67%;"></p><p>单目视觉初始化： </p><ol><li>读取第一、二帧图片，并提取第一帧图片的特征点；</li><li>通过光流跟踪法得到第二帧图片的特征点，删除跟踪失败的点；</li><li>计算本质矩阵，并恢复运动，并以该转换矩阵作为初始值。</li></ol><p>主循环：</p><p>连续读取图片，当读取图片帧数小于设定的最大帧数<code>MAX_FRAME</code>时：</p><ol><li>光流跟踪前一帧图片特征点，得到当前帧特征点，并删除跟踪失败的点;</li><li>计算本质矩阵，并恢复旋转运动$\pmb{R}$和平移运动$\pmb{t}$；</li><li>根据匹配到的两帧特征点，进行三角测量，计算两帧图片之间的距离尺度scale;</li><li>由前一帧图片的位置、当前图片旋转、平移矩阵、距离尺度，计算得到当前图片的位置，生成相机轨迹；</li><li>进行BA优化；</li><li>保存优化后的平移运动结果，画出轨迹；</li><li>判断跟踪后的特征点数目是否大于设定阈值<code>MIN_NUM_FEAT</code>，若小于则重新检测</li></ol><h2 id="1-图片提取"><a href="#1-图片提取" class="headerlink" title="1.图片提取"></a>1.图片提取</h2><p>根据网上的教程资料配置了Ubuntu16.04+OpenCV3.4.0的环境，具体步骤为：</p><ol><li><p>下载OpenCV3.4.0  sources版本，解压</p></li><li><p>安装<code>opencv</code>的依赖库和<code>cmake</code>包，通过<code>sudo apt-get install *</code>命令进行安装</p></li><li><p>进入解压完的<code>opencv</code>文件夹，创建编译文件夹，<code>mkdir build</code>，依次执行<code>cd build</code>， <code>cmake ..</code>，<code>make</code>，<code>make install</code>。</p></li><li><p>配置OpenCV的编译环境，将OpenCV的库添加到路径，从而可以让系统找到，<code>sudo gedit /etc/ld.so.conf.d/opencv.conf</code>，在打开的文本中写入<code>/usr/local/lib</code>，执行<code>sudo ldconfig</code></p></li><li><p>配置bash，执行<code>sudo gedit /etc/bash.bashrc</code>，在文本最末尾添加：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$<span class="symbol">PKG_CONFIG_PATH:</span>/usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">pkgconfig</span></span></span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure><p>保存，执行<code>source /etc/bash.bashrc</code>，使得配置生效：更新<code>sudo updatedb</code> </p></li></ol><p>程序中使用<code>sprintf()</code>函数读入指定路径下的图片序列，用<code>imread()</code>函数读取当前图片，用<code>imshow()</code>函数显示当前图片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(filename, /<span class="built_in">home</span>/neko/slam-VO/<span class="number">00</span>/image_0/%<span class="number">06</span>d.png, numFrame);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Current frame number:"</span>&lt;&lt;numFrame &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">currImage = imread(filename);</span><br><span class="line"></span><br><span class="line">imshow( <span class="string">"CAMERA IMAGE"</span>, currImage);</span><br></pre></td></tr></table></figure><h2 id="2-提取特征点"><a href="#2-提取特征点" class="headerlink" title="2.提取特征点"></a>2.提取特征点</h2><p>视觉里程计的核心问题是如何根据图形估计相机运动，比较方便的做法是：首先从图像中选取比较有代表性的点，这些点在相机视角发生少量变化后会保持不变，于是能在各个图像中找到相同的点。然后在这些点的基础上讨论，讨论相机位姿估计问题，以及这些点的定位问题，这些点被称为图像特征。</p><p>在本次作业中我们提取<strong>FAST关键点</strong>，<strong>FAST</strong> 是一种角点，主要检测局部像素灰度变化明显的地方，以速度快著称。它的思想是：如果一个像素与它邻域的像素差别较大（过亮或过暗）, 那它更可能是角点。它的检测过程如下：</p><ol><li>在图像中选取像素<script type="math/tex">p</script>，假设它的亮度为$I_p$。</li><li>设置一个阈值$T$ (比如$I_p$的20%)。</li><li>以像素$p$为中心, 选取半径为3的圆上的16个像素点。</li><li>假如选取的圆上，有连续的$N$个点的亮度大于$I_p+T$ 或小于$I_p-T$，那么像素$p$可以被认为是特征点。</li><li>循环以上四步，对每一个像素执行相同的操作。</li></ol><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/2.png" style="zoom:80%;"></p><p>​                                                                                <strong>图2-1 FAST特征点</strong></p><p>OpenCV中默认采用Fast-9-16，即在周围取16个像素点，若超过连续9个点与中心点差值大于阈值即成为候选角点。为了更高效，可以进行预处理，检测圆周上第1.5.9.13个像素，当其中有三个及以上的符合阈值，才可以入围，若不符合，便可以直接排除。同时需要搜索局部极大值，抑制非极大值元素来避免角点集中的问题。</p><p>程序中通过<code>featureDetection()</code>函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">featureDetection</span><span class="params">(Mat img_1, <span class="built_in">vector</span>&lt;Point2f&gt;&amp; points1)</span></span>&#123;   </span><br><span class="line">  <span class="built_in">vector</span>&lt;KeyPoint&gt; kps;</span><br><span class="line">  <span class="keyword">int</span> fast_threshold = <span class="number">10</span>;</span><br><span class="line">  Ptr&lt;FastFeatureDetector&gt; detector=FastFeatureDetector::create();</span><br><span class="line">  detector-&gt;detect(img_1,kps);</span><br><span class="line">  KeyPoint::convert(kps, points1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-特征跟踪与估计相机运动"><a href="#3-特征跟踪与估计相机运动" class="headerlink" title="3.特征跟踪与估计相机运动"></a>3.特征跟踪与估计相机运动</h2><h3 id="3-1-光流法特征跟踪"><a href="#3-1-光流法特征跟踪" class="headerlink" title="3.1.光流法特征跟踪"></a>3.1.光流法特征跟踪</h3><p>使用<strong>光流（Optical Flow）</strong>来跟踪特征点的运动。这样可以回避计算和匹配描述子带来的时间。光流是一种描述像素随着时间，在图像之间运动的方法。随着时间的经过，同一个像素会在图像中运动。计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。稀疏光流以 Lucas-Kanade 光流为代表，并可以在 SLAM 中用于跟踪特征点位置。</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/QQ图片20200615202025.png" style="zoom:67%;"></p><p>​                                                                           图3-1 LK光流法示意图</p><p>在LK光流中，来自相机的图像是随时间变化的。图像可以看作时间的函数$I(t)$。那么，一个在$t$时刻，位于$(x,y)$处的像素，它的灰度可以写成$I(x,y,t)$。这种方式把图像看成了关于位置与时间的函数，它的值域就是图像中像素的灰度。</p><p>引入<strong>灰度不变假设</strong>：同一个空间点的像素灰度值，在各个图像中是固定不变的。对于t时刻位于$(x,y)$处的像素，设$t+dt$时刻，它运动到$(x + dx, y + dy)$处。由于灰度不变,有：</p><script type="math/tex; mode=display">I(x+dx,y+dy,t+dt)=I(x,y,t)</script><p>通过对左边进行泰勒展开，保留一阶项，两边同时除$dt$，并写成矩阵形式：</p><script type="math/tex; mode=display">\begin{bmatrix} I_x \quad I_y\end{bmatrix} \begin{bmatrix} u \\v \end{bmatrix}=-I_t</script><p>引入额外的约束来计算$u, \,\,v$，假设某一个窗口内的像素具有相同的运动，如一个大小为$w \times w$的窗口，它含有$w^2$数量的像素，因此共有$w^2$个方程：</p><script type="math/tex; mode=display">\begin{bmatrix} I_x \quad I_y\end{bmatrix}_k \begin{bmatrix} u \\v \end{bmatrix}=-I_{tk}, \quad k=1,\dots,w^2</script><p>这是一个关于$u,\,\, v$的超定线性方程，可以使用最小二乘法求解，这样就得到了像素在图像间的运动速度$u,\,\, v$。</p><p>如果相机运动较快，两张图像差异较明显，那么单层图像光流法容易达到一个局部极小值，这种情况可以通过引入图像金字塔来改善。图像金字塔是指对同一个图像进行缩放，得到不同分辨率下的图像。以原始的金字塔作为金字塔底层，每往上一层，就对下层图像进行一定倍率的缩放，就得到一个金字塔。然后在计算光流时，先从顶层的图像开始计算，然后把上一层的追踪结果，作为下一层光流的初始值。OpenCV中的<code>calcOpticalFlowPyrLK()</code>函数正是基于这一原理实现多层光流函数。</p><p>在程序中通过<code>featureTracking()</code>函数来实现特征跟踪：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">featureTracking</span><span class="params">(Mat img_1, Mat img_2, <span class="built_in">vector</span>&lt;Point2f&gt;&amp; points1, <span class="built_in">vector</span>&lt;Point2f&gt;&amp; points2, <span class="built_in">vector</span>&lt;uchar&gt;&amp; status)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;err;   </span><br><span class="line">    calcOpticalFlowPyrLK(img_1, img_2, points1, points2, status, err);  <span class="comment">//调用光流法跟踪特征点</span></span><br><span class="line">    <span class="keyword">int</span> indexCorrection = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;status.<span class="built_in">size</span>(); i++)   <span class="comment">//删除跟踪失败的点</span></span><br><span class="line">    &#123;  </span><br><span class="line">        Point2f pt = points2.at(i- indexCorrection);</span><br><span class="line">     <span class="keyword">if</span> ((status.at(i) == <span class="number">0</span>)||(pt.x&lt;<span class="number">0</span>)||(pt.y&lt;<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">       <span class="keyword">if</span>((pt.x&lt;<span class="number">0</span>)||(pt.y&lt;<span class="number">0</span>))</span><br><span class="line">               &#123;</span><br><span class="line">       status.at(i) = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       points1.erase (points1.<span class="built_in">begin</span>() + (i - indexCorrection));</span><br><span class="line">       points2.erase (points2.<span class="built_in">begin</span>() + (i - indexCorrection));</span><br><span class="line">       indexCorrection++;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-对极几何估计相机运动"><a href="#3-2-对极几何估计相机运动" class="headerlink" title="3.2.对极几何估计相机运动"></a>3.2.对极几何估计相机运动</h3><p>接下来根据匹配的点对估计相机的运动。当相机为单目时，只知道2D的像素坐标，因而问题是根据两组2D点估计运动，可以用<strong>对极几何</strong>来解决。</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/QQ图片20200613125004.png" style="zoom: 80%;"></p><p>​                                                                               图3-2 对极几何约束</p><p>如下图所示，我们希望求取两帧图像$I_1$，$I_2$之间的运动，设第一帧到第二帧的运动为$R$，$t$。两个相机中心分别为$O_1$，$O_2$现在，考虑$I_1$ 中有一个特征点$p_1$，它在$I_2$中对应着特征点$p_2$。根据针孔相机模型，可得两个像素点的$p_1$，$p_2$的像素位置：</p><script type="math/tex; mode=display">s_1p_1=KP,\quad s_2p_2=K(RP+t)</script><p>其中$K$为相机内参，$R$，$t$为两个坐标系的相机运动。使用齐次坐标表示像素点，例如$s_1p_1$和$s_2p_2$成投影关系，它们在齐次坐标下的意义是相等的，称为尺度意义下相等。经推导得到对极约束的表达式：</p><script type="math/tex; mode=display">p_2^Tk^{-T}t^\land RK^{-1}p_1=0</script><p>把中间部分记作两个矩阵：<strong>基础矩阵</strong>（Fundamental Matrix）$F$ 和<strong>本质矩阵</strong>（Essential Matrix）$E$，可以进一步简化对极约束：</p><script type="math/tex; mode=display">E=t ^\land R, \quad F=K^{-T}EK^{-1},\quad x_2^TEx_1=p_2^TFp_1=0</script><p>对极约束简洁地给出了两个匹配点的空间位置关系，相机位姿估计问题变为以下两步：</p><ol><li>根据配对点的像素位置，求出$E$ 或者$F$；</li><li>根据$E$或者$F$，求出$R$，$t$。</li></ol><p>在程序中我们使用本质矩阵$E$求解，然后通过本质矩阵获取摄像机的相对旋转和平移量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算本质矩阵并恢复R,t</span></span><br><span class="line">E = findEssentialMat(prevFeatures, currFeatures, focal_length, principal_point, RANSAC, <span class="number">0.999</span>, <span class="number">1.0</span>, mask);</span><br><span class="line">recoverPose(E, prevFeatures,currFeatures,  R, t, focal_length, principal_point, mask);</span><br></pre></td></tr></table></figure><h3 id="3-3-三角测量"><a href="#3-3-三角测量" class="headerlink" title="3.3.三角测量"></a>3.3.三角测量</h3><p>在单目SLAM 中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量（Triangulation）（或三角化）的方法来估计地图点的深度。三角测量是指，通过在两处观察同一个点的夹角，确定该点的距离。在SLAM 中主要用三角化来估计像素点的距离。</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/图片1.png" style="zoom: 50%;"></p><p>​                                                          图3-2 通过三角测量的方法获得地图点的深度</p><p>论上直线$O_1p_1$ 与 $O_2p_2$在场景中会相交于一点$P$，该点即是两个特征点所对应的地图点在三维场景中的位置。然而由于噪声的影响，这两条直线往往无法相交。因此，可以通过最二小乘去求解。设$x_1$，$x_2$为两个特征点的归一化坐标，那么它们满足：</p><script type="math/tex; mode=display">s_2x_2=s_1Rx_1+t</script><p>如果要算$s_1$，那么先对上式两侧左乘一个$x_2^\land$，得：</p><script type="math/tex; mode=display">s_2x_2^\land x_2=0=s_1x_2 ^\land R x_1 +x_2 ^\land t</script><p>该式左侧为零，右侧可以看成是$s_2$的一个方程，根据它可求出$s_2$，进而能求出$s_1$。这样就得到了两帧下的深度，确定了它们的空间坐标。由于噪声的存在，估得的$R,t$不一定精确使上式为零，所以常用最小二乘法求解。</p><p>在程序中通过<code>triangulation()</code>函数实现三角测量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">triangulation</span> <span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point2f&gt;&amp; points_1, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Point2f&gt;&amp; points_2, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Mat&amp; R, <span class="keyword">const</span> Mat&amp; t, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt; Point3f &gt;&amp; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Mat T1 = (Mat_&lt;<span class="keyword">float</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    Mat T2 = (Mat_&lt;<span class="keyword">float</span>&gt; (<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>,<span class="number">0</span>),</span><br><span class="line">        R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">1</span>), R.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">2</span>), t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    Mat K = ( Mat_&lt;<span class="keyword">double</span>&gt; ( <span class="number">3</span>,<span class="number">3</span> ) &lt;&lt; <span class="number">718.856</span>, <span class="number">0</span>, <span class="number">607.1928</span>, <span class="number">0</span>, <span class="number">718.856</span>, <span class="number">185.2157</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2f&gt; pts_1, pts_2;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> idex=<span class="number">0</span>;idex&lt;points_1.<span class="built_in">size</span>();idex++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将像素坐标转换至相机坐标</span></span><br><span class="line">        pts_1.push_back ( pixel2cam( points_1[idex], K) );</span><br><span class="line">        pts_2.push_back ( pixel2cam( points_2[idex], K) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat pts_4d;</span><br><span class="line">    cv::triangulatePoints( T1, T2, pts_1, pts_2, pts_4d );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换成非齐次坐标</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pts_4d.cols; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Mat x = pts_4d.col(i);</span><br><span class="line">        x /= x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>,<span class="number">0</span>); <span class="comment">// 归一化</span></span><br><span class="line">        <span class="function">Point3f <span class="title">p</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">0</span>), </span></span></span><br><span class="line"><span class="function"><span class="params">            x.at&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>,<span class="number">0</span>) </span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">        points.push_back( p );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-生成相机轨迹与Ground-Truth比较"><a href="#4-生成相机轨迹与Ground-Truth比较" class="headerlink" title="4.生成相机轨迹与Ground Truth比较"></a>4.生成相机轨迹与Ground Truth比较</h2><p>Ground Truth轨迹绘制，通过读取00.txt中的数据绘制，<code>slam-VO.h</code>文件中定义了<code>get_Pose()</code>函数，<code>slam-VO.cpp</code>中函数调用程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&gt; poses = get_Pose(pose_path);</span><br><span class="line">Point2f trace1 = Point2f(<span class="keyword">int</span>(poses[numFrame][<span class="number">3</span>]) + <span class="number">400</span>, <span class="keyword">int</span>(poses[numFrame][<span class="number">11</span>]) + <span class="number">150</span>); <span class="comment">//绘制Ground Truth      </span></span><br><span class="line"><span class="built_in">circle</span>(trace, trace1, <span class="number">1</span>, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>初步未优化得到的相机运动轨迹绘制，在三角测量得到特征点三维信息后，通过判断两帧间是否有一定程度的位移决定该次三角测量精度是否准确，若可以，则绘制当前位置点，程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三角测量</span></span><br><span class="line">triangulation (prevFeatures,currFeatures,R,t,points);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"id&lt;points.size():"</span>&lt;&lt;points.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;        </span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> id=<span class="number">0</span>; id&lt;points.<span class="built_in">size</span>(); id++ )&#123;</span><br><span class="line"> points1.push_back(prevFeatures[id]);</span><br><span class="line">     points2.push_back(currFeatures[id]);</span><br><span class="line">&#125; </span><br><span class="line">        </span><br><span class="line">scale = getAbsoluteScale(numFrame, <span class="number">0</span>, t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>));<span class="comment">//平移的距离     </span></span><br><span class="line"><span class="keyword">if</span> ((scale&gt;<span class="number">0.1</span>)&amp;&amp;(-t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>) &gt; -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>)) &amp;&amp; (-t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>) &gt; -t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>)))&#123;    <span class="comment">//确保有一定程度的平移而不是纯旋转以保证三角测量的精度 </span></span><br><span class="line"> t_f = t_f + scale*(R_f*(-t));</span><br><span class="line">     R_f = R.inv()*R_f;</span><br><span class="line">     <span class="keyword">pre_t</span>=t.clone();</span><br><span class="line">     <span class="keyword">int</span> x = <span class="keyword">int</span>(t_f.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>)) + <span class="number">400</span>;</span><br><span class="line">     <span class="keyword">int</span> y = <span class="keyword">int</span>(t_f.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>)) + <span class="number">150</span>; </span><br><span class="line">     Point2f trace2 = Point2f(x,y) ;     </span><br><span class="line">     <span class="built_in">circle</span>(trace, trace2 ,<span class="number">1</span>, Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">1</span>);<span class="comment">//绘制初步估计的轨迹</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"scale below 0.1, or incorrect translation"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Bundle-Adjustment优化"><a href="#5-Bundle-Adjustment优化" class="headerlink" title="5.Bundle Adjustment优化"></a>5.Bundle Adjustment优化</h2><p>PnP用于求解3D到2D运动的投影位置方法。可以通过线性方法先求解相机位姿再求解空间投影点，但存在的问题是线性解法鲁棒性不太好，并且需要建立线性方程求代数解较为困难。因此，当运动比较连续时，一般选择非线性优化方法来进行迭代求解最优解，通常采用基于最小二乘问题的<strong>Bundle Adjustment(BA, 捆集调整)方法</strong>。针对本文采用的单目相机数据集，必须先对其进行初始化，再使用BA算法。</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/图片1.png" style="zoom:50%;"></p><p>非线性优化将相机位姿、空间特征点等多个参数看作优化变量。如上图所示，根据之前的特征匹配，已知$p_1$、$p_2$为同一空间点的两个投影点，利用最小化重投影误差对相机位姿进行优化，使计算得到的$p_2’$与实际$p_2$不断接近，直到达到精度范围或最大迭代次数。设相机位姿变换为$R$，$t$，对应李代数为$\xi$。相机内参矩阵为$K$。任一三维空间点P的坐标$ \pmb{P}_i=[X_i,Y_i,Z_i]^T$。对应的投影像素坐标为$\pmb{u}_i=[u_i,v_i]^T$。则像素点与空间点存在如下关系：</p><script type="math/tex; mode=display">s_i\begin{bmatrix}u_i\\v_i\\1 \end{bmatrix}=\pmb{K}(\exp(\pmb{\xi}^\land)\begin{bmatrix}X_i\\Y_i\\Z_i\\1 \end{bmatrix})_{1:3}</script><p>即：</p><script type="math/tex; mode=display">s_i\pmb{u}_i=\pmb{K}(\exp(\pmb{\xi}^\land)\pmb{P}_i)_{1:3}</script><p>因此，以相机位姿李代数$\xi$、特征点空间位置等为优化变量，以重投影误差为目标函数，计算将像素坐标观测值与按相机位姿计算得到的像素坐标计算值之间的误差，构建最小二乘问题，利用Gauss-Newton法或Levenburg-Marquadt优化算法寻找最优相机位姿和特征点空间坐标。优化模型如下所示：</p><script type="math/tex; mode=display">\xi^*=\arg \min\limits_{\xi}\frac{1}{2}\sum^n_{i=1}\Arrowvert u_i-\frac{1}{s_i}K\exp (\xi^\land)P_i\Arrowvert_2^2</script><p>在利用优化算法进行迭代的时候，最重要的是计算每次迭代的下降梯度方向，对目标函数误差求导可得：</p><script type="math/tex; mode=display">e(x+\Delta x)\approx e(x)+J\Delta x</script><p>其中，$J$为$2 \times 6$的雅各比矩阵。通过扰动模型求解李代数导数，计算过程如下：由上文已知像素点与空间点的关系，设$\pmb{P}’$为空间点$\pmb{P}$经相机位姿变换后的空间坐标，即$\pmb{P}’=(\exp(\pmb{\xi}^\land)\pmb{P})_{1:3}=[X’,Y’,Z’]^T$。将相机内参$K$展开得：</p><script type="math/tex; mode=display">\begin{bmatrix}su\\ sv \\s \end{bmatrix}=\begin{bmatrix}f_x &0 &c_x\\ 0 &f_y &c_y\\0 & 0 &1 \end{bmatrix} \begin{bmatrix} X' \\ Y' \\Z' \end{bmatrix}</script><p>消元可得：</p><script type="math/tex; mode=display">u=f_x\frac{X'}{Z'}+c_x, \quad v=f_y\frac{Y'}{Z'}+c_y</script><p>将相机位姿李代数左乘扰动量$\delta \pmb{\xi}$，再通过误差变化对扰动量的求导可得：</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \pmb{\xi}}=\lim \limits_{\delta \pmb{\xi}\to0}\frac{\delta \pmb{\xi}\bigoplus \pmb{\xi}}{\delta \pmb{\xi}}=\frac{\partial e}{\partial \pmb{P}'}\frac{\partial \pmb{P}'}{\partial\delta \pmb{\xi}}</script><p>误差变化$e$对于$\pmb{P}’$的求导可以根据之前消元得到的$u$、$v$表达式得到：</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \pmb{P}'}= -\begin{bmatrix} \displaystyle\frac{\partial u}{\partial {X}'} & \displaystyle\frac{\partial u}{\partial {Y}'} & \displaystyle\frac{\partial u}{\partial {Z}'}  \\  \displaystyle\frac{\partial v}{\partial {X}'} & \displaystyle\frac{\partial v}{\partial {Y}'} & \displaystyle\frac{\partial v}{\partial {Z}'} \end{bmatrix} =- \begin{bmatrix} \displaystyle\frac{f_x}{Z'} & 0 & -\displaystyle\frac{f_x X'}{Z'^2}  \\  0 & \displaystyle\frac{f_y}{Z'} & -\displaystyle\frac{f_y Y'}{Z'^2} \end{bmatrix}</script><p>$\pmb{P}’$对扰动量$\delta \pmb{\xi}$求导为：</p><script type="math/tex; mode=display">\frac{\partial \pmb{P}'}{\partial\delta \pmb{\xi}}=[\pmb{I},\,\,-\pmb{P}'^ \land]</script><p>于是最终得到相机位姿导数的雅各比矩阵：</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \pmb{\xi}}=-\begin{bmatrix} \displaystyle\frac{f_x}{Z'} & 0 & -\displaystyle\frac{f_x X'}{Z'^2} & -\displaystyle\frac{f_x X' Y'}{Z'^2} &f_x+\displaystyle\frac{f_x X'}{Z'^2} &-\displaystyle\frac{f_x Y'}{Z'} \\ 0 & \displaystyle\frac{f_y}{Z'} & -\displaystyle\frac{f_y Y'}{Z'^2} &-f_y-\displaystyle\frac{f_y Y'}{Z'^2} & -\displaystyle\frac{f_y X' Y'}{Z'^2} &-\displaystyle\frac{f_y X'}{Z'}\end{bmatrix}</script><p>同理，对于特征点空间位置的优化，还需要将误差$e$对空间点$\pmb{P}$进行求导，可以得到如下计算模型：</p><script type="math/tex; mode=display">\frac{\partial e}{\partial \pmb{P}}=\frac{\partial e}{\partial \pmb{P}'}\frac{\partial \pmb{P}'}{\partial\delta \pmb{P}}</script><script type="math/tex; mode=display">\pmb{P}'=\exp(\pmb{\xi}^\land)\pmb{P}=\pmb{RP}+\pmb{t}</script><script type="math/tex; mode=display">\frac{\partial e}{\partial \delta \pmb{\xi}}=-- \begin{bmatrix} \displaystyle\frac{f_x}{Z'} & 0 & -\displaystyle\frac{f_x X'}{Z'^2}  \\  0 & \displaystyle\frac{f_y}{Z'} & -\displaystyle\frac{f_y Y'}{Z'^2} \end{bmatrix}\pmb{R}</script><p>基于以上推导，采用<code>g2o</code>库实现相机位姿图优化，部分代码如下图所示。图优化时以下一个相机位姿和所有特征点空间坐标为节点，以下一个相机中的投影坐标为边。以<code>RANSAC PnP</code>结果为初值，调用<code>g2o</code>进行优化。</p><p><code>slam-VO.h</code>文件中定义 <code>Bundle Adjustment()</code>函数程序如下：函数输入前一帧的三维信息和后一帧的两维信息，以及相机内参矩阵，则可得到优化后的相机变化位姿矩阵。函数定义中，首先初始化<code>g2o</code>，定义优化求解器，定义图优化的边和节点，定义误差函数等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bundleAdjustment</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt; Point3f &gt; points_3d,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">vector</span>&lt; Point2f &gt; points_2d,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat K,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat R, Mat t,</span></span></span><br><span class="line"><span class="function"><span class="params">    Mat&amp; RR, Mat&amp; tt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化g2o</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;<span class="number">6</span>,<span class="number">3</span>&gt; &gt; Block; </span><br><span class="line">    <span class="comment">// pose 维度为 6, landmark 维度为 3</span></span><br><span class="line">    Block::LinearSolverType* linearSolver = <span class="keyword">new</span> g2o::LinearSolverCSparse&lt;Block::PoseMatrixType&gt;(); <span class="comment">// 线性方程求解器</span></span><br><span class="line">    Block* solver_ptr  = <span class="keyword">new</span> Block (linearSolver);    <span class="comment">// 矩阵块求解器</span></span><br><span class="line">    </span><br><span class="line">    g2o::OptimizationAlgorithmLevenberg* solver = <span class="keyword">new</span> g2o::OptimizationAlgorithmLevenberg (solver_ptr);</span><br><span class="line">    g2o::SparseOptimizer optimizer;</span><br><span class="line">    optimizer.setAlgorithm ( solver );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertex</span></span><br><span class="line">    g2o::VertexSE3Expmap* pose = <span class="keyword">new</span> g2o::VertexSE3Expmap(); <span class="comment">// camera pose</span></span><br><span class="line">    Eigen::Matrix3d R_mat;</span><br><span class="line">    R_mat &lt;&lt;</span><br><span class="line">               R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ),</span><br><span class="line">               R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ),</span><br><span class="line">               R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">1</span> ), R.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">2</span> );</span><br><span class="line">    pose-&gt;setId ( <span class="number">0</span> );</span><br><span class="line">    pose-&gt;setEstimate ( g2o::SE3Quat (R_mat,Eigen::Vector3d ( t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">0</span> ), t.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">2</span>,<span class="number">0</span> ) ) ) );</span><br><span class="line">    optimizer.addVertex ( pose );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">const</span> Point3f p:points_3d )   <span class="comment">// landmarks</span></span><br><span class="line">    &#123;</span><br><span class="line">        g2o::VertexSBAPointXYZ* <span class="built_in">point</span> = <span class="keyword">new</span> g2o::VertexSBAPointXYZ();</span><br><span class="line">        <span class="built_in">point</span>-&gt;setId ( index++ );</span><br><span class="line">        <span class="built_in">point</span>-&gt;setEstimate ( Eigen::Vector3d ( p.x, p.y, p.z ) );</span><br><span class="line">        <span class="built_in">point</span>-&gt;setMarginalized ( <span class="literal">true</span> ); </span><br><span class="line">        optimizer.addVertex ( <span class="built_in">point</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parameter: camera intrinsics</span></span><br><span class="line">    g2o::CameraParameters* camera = <span class="keyword">new</span> g2o::CameraParameters ( K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">0</span> ), Eigen::Vector2d ( K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">0</span>,<span class="number">2</span> ), K.at&lt;<span class="keyword">double</span>&gt; ( <span class="number">1</span>,<span class="number">2</span> ) ), <span class="number">0</span> );</span><br><span class="line">    camera-&gt;setId ( <span class="number">0</span> );</span><br><span class="line">    optimizer.<span class="built_in">addParameter</span> ( camera );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// edges</span></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">const</span> Point2f p:points_2d )</span><br><span class="line">    &#123;</span><br><span class="line">        g2o::EdgeProjectXYZ2UV* edge = <span class="keyword">new</span> g2o::EdgeProjectXYZ2UV();</span><br><span class="line">        edge-&gt;setId ( index );</span><br><span class="line">        edge-&gt;setVertex ( <span class="number">0</span>, <span class="keyword">dynamic_cast</span>&lt;g2o::VertexSBAPointXYZ*&gt; ( optimizer.vertex ( index ) ) );</span><br><span class="line">        edge-&gt;setVertex ( <span class="number">1</span>, pose );</span><br><span class="line">        edge-&gt;setMeasurement ( Eigen::Vector2d ( p.x, p.y ) );</span><br><span class="line">        edge-&gt;setParameterId ( <span class="number">0</span>,<span class="number">0</span> );</span><br><span class="line">        edge-&gt;setInformation ( Eigen::Matrix2d::Identity() );</span><br><span class="line">edge-&gt;setRobustKernel( <span class="keyword">new</span> g2o::RobustKernelHuber() );</span><br><span class="line">        optimizer.addEdge ( edge );</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optimizer.setVerbose ( <span class="literal">false</span> );</span><br><span class="line">    optimizer.initializeOptimization();</span><br><span class="line">    optimizer.optimize ( <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    Eigen::Isometry3d T = Eigen::Isometry3d ( pose-&gt;estimate() );</span><br><span class="line">    <span class="comment">//RR、t为优化后的R和t</span></span><br><span class="line">    RR=(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;</span><br><span class="line">    T(<span class="number">0</span>,<span class="number">0</span>),T(<span class="number">0</span>,<span class="number">1</span>),T(<span class="number">0</span>,<span class="number">2</span>),</span><br><span class="line">    T(<span class="number">1</span>,<span class="number">0</span>),T(<span class="number">1</span>,<span class="number">1</span>),T(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">    T(<span class="number">2</span>,<span class="number">0</span>),T(<span class="number">2</span>,<span class="number">1</span>),T(<span class="number">2</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    tt=(Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">1</span>)&lt;&lt;</span><br><span class="line">    T(<span class="number">0</span>,<span class="number">3</span>),T(<span class="number">1</span>,<span class="number">3</span>),T(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>slam-VO.cpp</code>文件中调用该函数程序如下：输入前后两帧的三维特征信息、相机内参、相机变换位姿，可以返回 优化后的位资矩阵。同样，需要判断两帧间平移是否到达一定程度，否则需要进行尺度修正。然后将每次循环得到的轨迹进行实时绘制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BA优化</span></span><br><span class="line">bundleAdjustment ( points,points2, K,R,t, RR,tt );</span><br><span class="line"><span class="keyword">if</span> ((scale&gt;<span class="number">0.1</span>)&amp;&amp;(-tt.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>) &gt; -tt.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>)) &amp;&amp; (-tt.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>) &gt; -tt.at&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(tt.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>)-t.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>))&lt;<span class="number">0.05</span>)</span><br><span class="line">    &#123;</span><br><span class="line"> t_E = t_E + scale*(R_E*(-tt));</span><br><span class="line">       R_E = RR.inv()*R_E;</span><br><span class="line">         <span class="keyword">pre_t</span>=tt.clone();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"优化失败"</span>&lt;&lt;<span class="built_in">endl</span>;                        </span><br><span class="line"> t_E = t_E + scale*(R_E*(-t));</span><br><span class="line">         R_E = R.inv()*R_E;</span><br><span class="line">         <span class="keyword">pre_t</span>=t.clone();</span><br><span class="line">&#125;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">"scale below 0.1, or incorrect translation"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Point2f trace3 = Point2f(<span class="keyword">int</span>(t_E.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>)) + <span class="number">400</span>, <span class="keyword">int</span>(t_E.at&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>)) + <span class="number">150</span>);</span><br><span class="line"><span class="built_in">circle</span>(trace, trace3, <span class="number">1</span>, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">1</span>);<span class="comment">//绘制BA优化后的轨迹</span></span><br></pre></td></tr></table></figure><p>得到的BA优化轨迹如图中红色轨迹所示，右上角可以看出，累积误差较大的时候，BA优化的轨迹展示出了更好的性能。由于这里只考虑相邻两帧之间的优化，因此随着累积误差的增大，对极约束估计以及BA优化得到的轨迹效果都越来越差，需要通过局部地图以及后端的回环检测等方法来优化。</p><p><img src="/2020/06/16/%E5%8D%95%E7%9B%AE%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/微信图片_20200616071621.png" style="zoom: 67%;"></p>]]></content>
    
    <summary type="html">
    
      整理了一下这学期机器视觉课程的大作业。视觉里程计(Visual Odometry，VO)是一种利用连续的图像序列来估计相机或机器人移动距离的方法，要求基于OpenCV初步实现一个简单的视觉里程计，我主要参考了高翔的《视觉slam十四讲》来完成。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（20）串</title>
    <link href="http://nekomoon404.github.io/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/"/>
    <id>http://nekomoon404.github.io/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/</id>
    <published>2020-04-04T01:24:46.000Z</published>
    <updated>2020-04-05T01:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>串或字符串属于线性结构，自然地可以直接利用向量或列表等序列结构加以实现。但字符串作为一种数据结构，特点极其鲜明，作为字符串基本组成元素的字符，种类通常不多，甚至可能极少。因此，为了高效地处理以字符串形式表示的海量数据，需要设计专门的处理方法。</p><p>本章直接利用C++所提供的字符数组，将重点几种在串匹配算法的设计、实现与优化。在此类应用中，更多地是以某一局部子串为单位，考查其对应的模式（pattern），因此也称作循模式访问（call-by-pattern）。</p><h1 id="1-串及串匹配"><a href="#1-串及串匹配" class="headerlink" title="1.串及串匹配"></a>1.串及串匹配</h1><h2 id="1-1-串"><a href="#1-1-串" class="headerlink" title="1.1.串"></a>1.1.串</h2><p><strong>字符串</strong>：</p><p>由来自字母表$\sum$的字符所组成的有限序列，$S=”a_0\,a_1\,a_2\dots\,a_{n-1}”$，其中$a_i\in \sum, 0 \le i &lt; n$。这里的$\sum$是所有可用字符的集合，称作<strong>字符表（alphabet）</strong>。字符串S所含的字符的总数n，称作S的长度，记作$|S|=n$，长度为0的串称作<strong>空串（null string）</strong>。通常，字符的种类不多，而串长$=n&gt;&gt;|\sum|$。</p><p><strong>子串：</strong></p><p>字符串中任一连续的片段，称作其子串（substring）。对于任意的$0\le i \le i+k &lt;n$，由字符串S中起始于位置i的连续k个字符组成的子串记作：<code>S.substr(i, k) = S[i, i+k)</code>。</p><p>起始于位置0，长度为k的子串称为<strong>前缀（prefix）</strong>：<code>S.prefix(k) = S.substr(0,k) = S[0,k)</code>。</p><p>终止于位置n-1、长度为k的子串称为<strong>后缀（suffix）</strong>：<code>S.suffix(k) = S.substr(n-k,k) = S[n-k,n)</code>。</p><p>空串是任何字符串的子串，也是任何字符串的前缀和后缀；任何字符串都是自己的子串，也是自己的前缀和后缀。此类子串。前缀和后缀分别称作<strong>平凡子串（trivial substring）</strong>、<strong>平凡前缀（trivial prefix）</strong>和<strong>平凡后缀（trivial suffix）</strong>。反之，字符串本身之外的所以非空子串。前缀和后缀，分别称作<strong>真子串（proper substring）</strong>、<strong>真前缀（proper prefix）</strong>和<strong>真后缀（proper suffix）</strong>。</p><p><strong>判等：</strong></p><p>字符串<code>S[0,n)</code>和<code>T[0,m)</code>称作相等，当且仅当二者长度相等（n=m），且对应字符分别相同。</p><p><strong>ADT：</strong></p><p>串结构主要的操作接口可归纳为下表：</p><div class="table-container"><table><thead><tr><th>操作接口</th><th>功能</th></tr></thead><tbody><tr><td><code>length()</code></td><td>查询串的长度</td></tr><tr><td><code>charAt(i)</code></td><td>返回第<code>i</code>个字符</td></tr><tr><td><code>substr(i,k)</code></td><td>返回从第<code>i</code>个字符起，长度为<code>k</code>的子串</td></tr><tr><td><code>prefix(k)</code></td><td>返回长度为<code>k</code>的前缀</td></tr><tr><td><code>suffix(k)</code></td><td>返回长度为<code>k</code>的后缀</td></tr><tr><td><code>equal(T)</code></td><td>判断T是否与当前字符串相等</td></tr><tr><td><code>concat(T)</code></td><td>将T串接在当前字符串之后</td></tr><tr><td><code>indexOf(P)</code></td><td>若P是当前字符串的一个子串，则返回该子串的起始位置；否则返回-1</td></tr></tbody></table></div><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404102415.png" style="zoom: 50%;"></p><p>下面是一些实例：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404102536.png" style="zoom:50%;"></p><h2 id="1-2-串匹配"><a href="#1-2-串匹配" class="headerlink" title="1.2.串匹配"></a>1.2.串匹配</h2><p>在涉及字符串的众多实际应用中，<strong>模式匹配</strong>是最常使用的一项基本操作。如在生物信息处理领域需要在蛋白质序列中寻找特定的氨基酸模式，或在DNA序列中寻找特定的碱基模式。再如邮件过滤器也需要根据事先定义的特征串，通过扫描电子邮件的地址、标题及正文来识别垃圾邮件等等。</p><p>上述所有应用问题，本质上都可转化和描述为如下形式：如何在字符串数据中，检测和提取以字符串形式给出的某一局部特征。这类操作都属于<strong>串模式匹配（string pattern matching）</strong>范畴，简称<strong>串匹配</strong>。一般地，即：</p><ul><li>对基于同一字符表的任何文本串T（|T| = n）和模式串P（|P| = m），判定T中是否存在某一子串与P相同，若存在（匹配），则报告该子串在T中的起始位置。</li></ul><p>串的长度n和m本身通常都很多，但相对而言n更大，即满足$2 \ll m \ll n$。</p><p>根据具体应用的要求不同，串匹配问题有多种形式：</p><ul><li><strong>模式检测（pattern detection）</strong>问题：只关心是否存在匹配而不关心具体的匹配位置，如垃圾邮件的检测；</li><li><strong>模式定位（pattern location）</strong>问题：若经判断的确存在匹配，则还需确定具体的匹配位置；</li><li><strong>模式计数（pattern counting）</strong>问题：若有多处匹配，则统计出匹配子串的总数；</li><li><strong>模式枚举（pattern enumeration）</strong>问题：在有多处匹配时，报告出所有匹配的具体位置。</li></ul><p>鉴于串结构自身的特点，在设计和分析串模式匹配算法时也必须做特殊的考虑，一个重要的问题是：如何对任一串匹配算法的性能作出客观的测量和评估。不幸的是评估算法性能的常规口径和策略并不适用于这一问题，因为若假设文本串T和模式串P都是随机生成的，那么计算得到的匹配成功的概率往往极低。</p><p>实际上，<strong>有效涵盖成功匹配情况的一种简便策略是，随机选取文本串T，并从T中随机取出长度为m的子串作为模式串P</strong>，这即是文本将采用的评价标准。</p><h1 id="2-蛮力算法"><a href="#2-蛮力算法" class="headerlink" title="2.蛮力算法"></a>2.蛮力算法</h1><p>蛮力串匹配是最直接的方法，不妨按自左向右的次序考查子串，逐个字符对比。如下图，模式串P的每一黑色方格对应于字符的一次匹配，每一灰色方格对应于一次失败，白色方格对应于未进行的一次对比。若经过检查，当前的m对字符均匹配，则意味着整体匹配成功，从而返回匹配子串的位置。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404113720.png" style="zoom: 50%;"></p><p>蛮力算法的正确性显而易见，既然只有在某一轮的m次比对全部成功之后才成功返回，故不致于误报；反过来，所有对齐位置都会逐一尝试，故亦不致漏报。</p><p>下面是蛮力算法的两个实现版本，二者原理相同、过程相仿，但分别便于引入后续的不同改进算法，故在此先做一比较。</p><p>版本一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   .   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ***********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-1）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="comment">/*DSA*/</span>&#123;</span><br><span class="line">      <span class="comment">/*DSA*/</span>showProgress ( T, P, i - j, j );   getchar();</span><br><span class="line">      <span class="keyword">if</span> ( T[i] == P[j] ) <span class="comment">//若匹配</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一对字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         &#123; i -= j - <span class="number">1</span>; j = <span class="number">0</span>; &#125; <span class="comment">//文本串回退、模式串复位</span></span><br><span class="line">      <span class="comment">/*DSA*/</span>&#125;</span><br><span class="line">   <span class="keyword">return</span> i - j; <span class="comment">//如何通过返回值，判断匹配结果？i-j&lt;=n-m就表示成功，反之失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   1   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ***********************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-2）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、与模式串首字符的对齐位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++ ) &#123; <span class="comment">//文本串从第i个字符起，与</span></span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; m; j++ ) <span class="comment">//模式串中对应的字符逐个比对</span></span><br><span class="line">         <span class="comment">/*DSA*/</span>&#123;showProgress ( T, P, i, j ); getchar();</span><br><span class="line">         <span class="keyword">if</span> ( T[i + j] != P[j] ) <span class="keyword">break</span>; <span class="comment">//若失配，模式串整体右移一个字符，再做一轮比对</span></span><br><span class="line">         <span class="comment">/*DSA*/</span>&#125;</span><br><span class="line">      <span class="keyword">if</span> ( j &gt;= m ) <span class="keyword">break</span>; <span class="comment">//找到匹配子串</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//如何通过返回值，判断匹配结果？i&lt;=n-m就表示成功，反之失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>从理论上讲，蛮力算法至多迭代n-m+1轮，且各轮至多需要进行m次比对，故总共只需做不超过$(n-m+1)\cdot m$次比对，其中成功的和失败的各有$(m-1)\cdot (n-m+1)+1$和$n-m-2$次。因$m\ll n$，渐进的时间复杂度应为$O(n\cdot m)$。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404115556.png" style="zoom: 45%;"></p><p>蛮力算法的效率也并非总是如此低下，如上右图，若将模式串P左右颠倒，则每经一次比对都可排除文本串中的一个字符，故此类情况下的运行时间将为$O(n)$。实际上，此类最好（或接近最好）情况出现的概率并不很低，尤其是在字符表较大时。</p><h1 id="3-KMP算法"><a href="#3-KMP算法" class="headerlink" title="3.KMP算法"></a>3.KMP算法</h1><h2 id="3-1-构思"><a href="#3-1-构思" class="headerlink" title="3.1.构思"></a>3.1.构思</h2><p>蛮力算法在最坏情况下所需时间，为文本串长度与模式长度的乘积，故无法应用于规模稍大的应用环境，很有必要改进。为此，不妨从最坏情况入手，最坏情况在于这里存在大量的局部匹配：每一轮的m次比对中，仅最后一次可能失配，而一旦发现失配，文本串、模式串的字符指针都要回退，并从头开始下一轮尝试。实际上，这列重复的字符比对操作没有必要。既然这些字符在前一轮迭代中已经接受过比对并且成功，我们也就掌握了它们的所有信息。接下来就要考虑如何利用这些信息，提高匹配算法的效率。</p><p>如下图，用<code>T[i]</code>和<code>P[j]</code>分别表示当前正在接受比对的一对字符。当本轮比对进行到最后一对字符并发现失配后，蛮力算法令两个字符指针同步回退（即令<code>i = i - j + 1</code>和<code>j = 0</code>），然后再从这一位置继续比对，然而事实上，指针<code>i</code>完全不必回退。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404194755.png" style="zoom: 50%;"></p><p>因为经过前一次的比对，我们已经知道子串<code>T[i-j,i)</code>完全由<code>&#39;0&#39;</code>组成，便可预测出：在回退之后紧接着的下一轮对比中，前<code>j-1</code>次比对必然都会成功。因此可直接令<code>i</code>保持不变，令<code>j=j-1</code>，然后继续比对。如此下一轮只需1次比对，共减少<code>j-1</code>次。这个操作可以理解为：令<code>P</code>相对于<code>T</code>右移一个单元，然后从前一失配位置继续比对。实际上这一技巧可以推广：利用以往的成功比对所提供的信息（记忆），不仅可避免文本串字符指针的回退，而且可使模式串尽可能大跨度地右移（经验）。下面是一个更一般的例子：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404195403.png" style="zoom:50%;"></p><h2 id="3-2-next表"><a href="#3-2-next表" class="headerlink" title="3.2.next表"></a>3.2.next表</h2><p>一般地，假设前一轮比对终止于<code>T[i]</code> $\ne$ <code>P[j]</code>，按以上构思，指针<code>i</code>不必回退，而是将<code>T[i]</code>与<code>P[t]</code>对齐并开始下一轮对比。接下来考虑<code>t</code>的值应该取作多少。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404195703.png" style="zoom: 50%;"></p><p>如上图，经过此前一轮的对比，已经确定匹配的范围应为：<code>P[o,j) = T[i-j,i)</code>。</p><p>于是，若模式串P经适当右移之后，能够与T的某一（包含<code>T[i]</code>在内的）子串完全匹配，则一项必要条件就是：<code>P[0,t) = T[i-t,i) = P[j-t,j)</code>，亦即，在<code>P[0,j)</code>中长度为<code>t</code>的真前缀，应与长度为<code>t</code>的真后缀完全匹配，故<code>t</code>必来自集合：</p><script type="math/tex; mode=display">N(P,j)=\{0\le t \le j \,\,\,|\,\,\,P[0,t)=P[j-t,j)\}</script><p>一般地，该集合可能包含多个这样的<code>t</code>，而需要注意的是，<code>t</code>的值仅取决于模式串<code>P</code>以及前一轮比对的首个失配位置<code>P[j]</code>，而与文本串<code>T</code>无关。若下一轮比对将从<code>T[i]</code>与<code>P[t]</code>的比对开始，这等效于将<code>P</code>右移<code>j-t</code>个单元，位移量与<code>t</code>成反比。因此为保证<code>P</code>与<code>T</code>的对齐位置（指针<code>i</code>）绝不倒退，同时又不致遗漏任何可能的匹配，应在集合<code>N(P,j)</code>中挑选最大的<code>t</code>，即当有多个右移方案时，应该保守地选择其中移动距离最短者。</p><p>于是令：<code>next[j] = max( N(P,j) )</code>，则一旦发现P[i]与T[i]失配，即可转而将<code>P[ next[i] ]</code>与<code>T[i]</code>彼此对准，并从这一位置开始继续下一轮比对。</p><p>既然集合<code>N(P,j)</code>仅取决于模式串<code>P</code>以及失配位置<code>j</code>，而与文本串无关，作为其中的最大元素，<code>next[j]</code>也必然具有这一性质。对于任一模式串<code>P</code>，不妨通过预处理提前计算出所有位置<code>j</code>所对应的<code>next[j]</code>值，并整理为表格以表此后反复查询。</p><h2 id="3-3-KMP算法"><a href="#3-3-KMP算法" class="headerlink" title="3.3.KMP算法"></a>3.3.KMP算法</h2><p>上述思路可整理为如下代码，即著名的<strong>KMP算法</strong>。对照此前的蛮力算法，只是在<code>else</code>分支对失配情况的处理手法有所不同，这也是KMP算法的精髓所在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123;  <span class="comment">//KMP算法</span></span><br><span class="line">   <span class="keyword">int</span>* next = buildNext ( P ); <span class="comment">//构造next表</span></span><br><span class="line">   <span class="keyword">int</span> n = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串指针</span></span><br><span class="line">   <span class="keyword">int</span> m = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m  &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="comment">//*DSA*/ &#123;</span></span><br><span class="line">      <span class="comment">//*DSA*/ showProgress ( T, P, i - j, j );</span></span><br><span class="line">      <span class="comment">//*DSA*/ printNext ( next, i - j, strlen ( P ) );</span></span><br><span class="line">      <span class="comment">//*DSA*/ getchar(); printf ( "\n" ); */</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j || T[i] == P[j] ) <span class="comment">//若匹配，或P已移出最左侧（两个判断的次序不可交换）</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         j = next[j]; <span class="comment">//模式串右移（注意：文本串不用回退）</span></span><br><span class="line">      <span class="comment">//*DSA*/ &#125;</span></span><br><span class="line">   <span class="keyword">delete</span> [] next; <span class="comment">//释放next表</span></span><br><span class="line">   <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>next[0] = -1</strong></p><p>只要<code>j&gt;0</code>，则必有$0\in N(P,j)$。此时<code>N(P,j)</code>非空，从而可以保证“ 在其中取最大值 ”这一操作的确可行。但反过来，若<code>j=0</code>，则即便集合<code>N(P,j)</code>可以定义，也必是空集。反观串匹配的过程，若在某一轮比对中首对字符即失配，则应将<code>P</code>直接右移一个字符，然后启动下一轮比对。如下表，不妨假想地在<code>P[0]</code>的左侧“ 附加 ”一个<code>P[-1]</code>，且该字符与任何字符都是匹配的，就实际效果而言，这一处理方法完全等同于“ 令<code>next[0] = -1</code> ”。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404202952.png" style="zoom: 40%;"></p><p><strong>next[j+1]</strong></p><p>若已知<code>next[0,j]</code>，如何才能递推地计算出<code>next[j+1]</code>？若<code>next[j]=t</code>，则意味着在<code>P[0,j]</code>中，自匹配的真前缀和真后缀的最大长度为<code>t</code>，故必有<code>next[j=1]</code> $\le$ <code>next[j]+1</code>，当且仅当<code>P[j]=P[t]</code>时，取等号。如下图：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404203402.png" style="zoom: 50%;"></p><p>一般地，若<code>P[j]</code> $\ne$ <code>P[t]</code>，由<code>next</code>表的功能定义，<code>next[j+1]</code>的下一候选者应该依次是：</p><p><code>next[ next[j] ] + 1</code>，<code>next[ next[ next[j] ] ] + 1</code>，……</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404203727.png" style="zoom: 40%;"></p><p>因此只需反复用<code>next[t]</code>替换<code>t</code>（即令<code>t = next[t]</code>），即可按优先次序遍历以上候选者；一旦发现<code>P[j]</code>与<code>P[t]</code>匹配（含与<code>P[t=-1]</code>的通配），即可令<code>next[j+1] = next[t] + 1</code>。</p><p>既然总有<code>next[t] &lt; t</code>，故在此过程中<code>t</code>必然严格递减；同时，即便<code>t</code>降低至<code>0</code>，亦必然会终止于通配的<code>next[0] = -1</code>，而不致下溢，如此该算法的正确性完全可以保证。</p><p><strong>构造next表：</strong></p><p>按照以上思路，可实现<code>next</code>表构造算法如下。<code>next</code>表的构造算法与KMP算法几乎完全一致，实际上按照以上分析，这一构造过程完全等效于串的自我匹配，因此两个算法在形式上的近似亦不足为怪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         j ++; t ++;</span><br><span class="line">         N[j] = t; <span class="comment">//此句可改进...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="comment">//*DSA*/printString ( P ); printf ( "\n" );</span></span><br><span class="line">   <span class="comment">//*DSA*/printNext ( N, 0, m );</span></span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析：</strong></p><p>由上可见，KMP算法借助<code>next</code>表可避免大量不必要的字符比对操作，但这意味着渐渐意义上的时间复杂度会有实质改进嘛？</p><p>为此的证明需要一些技巧，若令<code>k = 2i - j</code>，并考查<code>k</code>在KMP算法过程中的变化趋势，则不难发现，<code>while</code>循环每迭代一轮，<code>k</code>都会严格递增。对于<code>while</code>循环内部的<code>if - else</code>分支，无非两种情况：若转入<code>if</code>分支，则<code>i</code>和<code>j</code>同时加一，于是<code>k = 2i -j</code>必将增加；反之若转入<code>else</code>分支，则尽管<code>i</code>保持不变，但在赋值<code>j = next[j]</code> 之后<code>j</code>必然减少，于是<code>k = 2i -j</code>也必然增加。</p><p>纵观算法的整个过程：启动时有<code>i =j =0</code>，即<code>k =0</code>；算法结束时$i\le n$或$j \ge 0$，故有$k\le 2n$。在此期间尽管整数k从0开始持续地严格递增，但累计增幅不超过$2n$，故<code>while</code>循环至多执行$2n$轮。另外，<code>while</code>循环体内部不含任何循环或调用，故只需$O(1)$时间，因此若不计构造<code>next</code>表所需的时间，KMP算法本身的运行时间不超过$O(n)$。也就是说，尽管可能有$\Omega(n)$个对齐位置，但就分摊意义而言，在每一对齐位置仅需$O(1)$次对比。</p><p>既然<code>next</code>表构造算法的流程与KMP算法并无实质区别，故仿照上述分析可知，<code>next</code>表的构造仅需$O(m)$时间，综上，<strong>KMP算法的总体运行时间为$O(n+m)$</strong>。</p><h2 id="3-4-改进"><a href="#3-4-改进" class="headerlink" title="3.4.改进"></a>3.4.改进</h2><p>尽管以上KMP算法已可保证线性的运行时间，但在某些情况下仍有进一步改进的余地。如下面的例子，按照此前定义的<code>next</code>表，仍会进行多次本不必要的字符比对操作。前一轮对比因<code>T[i] = &#39;1&#39;</code> $\ne$ <code>&#39;0&#39; = P[3]</code>失配而中断，接下来KMP算法将依次将<code>P[2]</code>、<code>P[1]</code>和<code>P[0]</code>与<code>T[i]</code>对准并做比对。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404211810.png" style="zoom:50%;"></p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200404211822.png" style="zoom:50%;"></p><p>不难发现原因出在 <code>P[3] = P[2] =P[1] = &#39;0&#39;</code>，而此前比对已发现<code>T[i]</code> $\ne$ <code>P[3]</code>，那么继续将<code>T[i]</code>和那些与<code>P[3]</code>相同的字符做比对，就是徒劳无功的。</p><p>就算法策略而言，引入<code>next</code>表的实质作用在于帮助我们利用以往成功比对所提供的“ 经验 ”，而实际上，此前已进行过的比对还远远不止这些，确切地说还包括那些失败的比对——作为“ 教训 ”。为把这类“ 负面 ”信息引入<code>next</code>表，只需将集合$N(P,j)$的定义修改为：</p><script type="math/tex; mode=display">N(P,j)=\{0\le t < j\,\,\,|\,\,\,P[0,t)=P[j-t,j)且P[t] \ne P[j]\}</script><p>也就是说，除“ 对应于自匹配长度 ”以外，t只要还同时满足“ 当前字符对不匹配 ” 的必要条件，方能归入集合$N(P,j)$并作为<code>next</code>表项的候选。</p><p>相应地，原<code>next</code>表构造算法也需稍作修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表（改进版本）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         N[j] = ( P[++j] != P[++t] ? t : N[t] ); <span class="comment">//注意此句与未改进之前的区别</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="comment">/*DSA*/</span>printString ( P ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">   <span class="comment">/*DSA*/</span>printNext ( N, <span class="number">0</span>, <span class="built_in">strlen</span> ( P ) );</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的算法与原算法的唯一区别在于，每次在<code>P[0,j)</code>中发现长度为t的真前缀和真后缀相互匹配之后，还需进一步检查<code>P[j]</code>是否等于<code>P[t]</code>。唯有在<code>P[j]</code> $\ne $ <code>P[t]</code>时，才能将<code>t</code>赋予<code>next[j]</code>；否则需转而代之以<code>next[t]</code>，改进后<code>next</code>表的构造算法同样只需$O(m)$时间。</p><p>将改进后的KMP算法应用于前面的例子，在首轮比对因<code>T[i] = &#39;1&#39;</code> $\ne$ <code>&#39;0&#39; = P[3]</code>失配而中断之后，将随机以<code>P[ next[3] ] = P[-1]</code>与<code>T[i]</code>对齐，并进行下一轮比对。这样就等同于聪明且安全地跳过了三个不必要的对齐位置。</p><h1 id="4-BM算法"><a href="#4-BM算法" class="headerlink" title="4.BM算法"></a>4.BM算法</h1><h2 id="4-1-构思"><a href="#4-1-构思" class="headerlink" title="4.1.构思"></a>4.1.构思</h2><p>KMP算法的思路可概括为：当前比对一旦失配，即利用此前的比对所提供的信息，尽可能长距离地移动模式串。其精妙之处在于，无需显式地反复保存或更新比对的历史，而是独立于具体的文本串，事先根据模式串预测出所有可能出现的失配情况，并将这些信息记录于<code>next</code>表中。</p><p>回顾之前的知识不难发现：串匹配 = x次失败的对齐 + 0/1次成功的对齐，这样与其说要加速匹配，不如说是<strong>要加速失败——尽快排除失败的对齐</strong>。就单个对齐的位置的排除而言：平均仅需常数次比对（只要$|\sum|$不致太小，单次比对成功概率足够低），且具体的比对位置及次序无所谓。然后就排除更多后续对齐位置而言，不同的对比位置及次序，作用差异极大。通常是越靠前的位置，作用越小；越靠后的位置，作用越大。</p><p>BM算法与KMP算法类似，二者的区别仅在于预测和利用“ 历史 ”信息的具体策略与方法。BM算法中，模式串P与文本串T的对准位置依然<strong>“ 自左向右 ”推移</strong>，而在每一对准位置确实<strong>“ 自右向左 ”地逐一比对</strong>各字符。具体地，在每一轮自右向左的比对过程中，一旦发现失配，则将P右移一定距离并再次与T对准，然后重新一轮自右向左的扫描比对。</p><p>BM算法的主题框架，可实现为如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Boyer-Moore算法</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>     <span class="title">ShowProgress</span> <span class="params">( <span class="keyword">String</span>, <span class="keyword">String</span>,  <span class="keyword">int</span>,  <span class="keyword">int</span> )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  CARD_CHAR_SET     256   <span class="comment">//Cardinality of charactor set</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>*     <span class="title">BuildBC</span> <span class="params">( <span class="keyword">String</span> )</span></span>; <span class="comment">//构造Bad Charactor Shift表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>*     <span class="title">suffixes</span> <span class="params">( <span class="keyword">String</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>*     <span class="title">BuildGS</span> <span class="params">( <span class="keyword">String</span> )</span></span>; <span class="comment">//构造Good Suffix Shift表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//Boyer-Morre算法（完全版，兼顾Bad Character与Good Suffix）</span></span><br><span class="line">   <span class="keyword">int</span>* bc = buildBC ( P ); <span class="keyword">int</span>* gs = buildGS ( P ); <span class="comment">//构造BC表和GS表</span></span><br><span class="line">   <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">//模式串相对于文本串的起始位置（初始时与文本串左对齐）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">strlen</span> ( T ) &gt;= i + <span class="built_in">strlen</span> ( P ) ) &#123; <span class="comment">//不断右移（距离可能不止一个字符）模式串</span></span><br><span class="line">      <span class="keyword">int</span> j = <span class="built_in">strlen</span> ( P ) - <span class="number">1</span>; <span class="comment">//从模式串最末尾的字符开始</span></span><br><span class="line">      <span class="keyword">while</span> ( P[j] == T[i + j] ) <span class="comment">//自右向左比对</span></span><br><span class="line">         <span class="keyword">if</span> ( <span class="number">0</span> &gt; --j ) <span class="keyword">break</span>; <span class="comment">/*DSA*/</span>showProgress ( T, P, i, j ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> ); getchar();</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j ) <span class="comment">//若极大匹配后缀 == 整个模式串（说明已经完全匹配）</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//返回匹配位置</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，适当地移动模式串</span></span><br><span class="line">         i += __max ( gs[j], j - bc[ T[i + j] ] ); <span class="comment">//位移量根据BC表和GS表选择大者</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] gs; <span class="keyword">delete</span> [] bc; <span class="comment">//销毁GS表和BC表</span></span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了蛮力算法后一版本的方式，借助整数<code>i</code>和<code>j</code>指示文本串中当前的对齐位置<code>T[i]</code>和模式串中接受比对的字符<code>P[j]</code>。一旦局部失配，采用两种启发式策略确定最大的安全移动距离，为此需要经过预处理，根据模式串<code>P</code>整理出坏字符和好后缀两类信息。与KMP算法一样，算法过程中指针<code>i</code>始终单调递增；相应地，<code>P</code>相对于<code>T</code>的位置也绝不回退。</p><h2 id="4-2-坏字符策略"><a href="#4-2-坏字符策略" class="headerlink" title="4.2.坏字符策略"></a>4.2.坏字符策略</h2><p>如下图中(a)和(b)，若模式串<code>P</code>当前在文本串<code>T</code>中的对齐位置为<code>i</code>，且在这一轮自右向左将<code>P</code>与<code>substr(T,i,m)</code>的比对过程中，在<code>P[j]</code>处首次发现失配：<code>T[i+j] = &#39;X&#39;</code> $\ne$ <code>&#39;Y&#39; = P[j]</code>，则将<code>&#39;X&#39;</code>称作<strong>坏字符（bad character）</strong>。接下来考虑应该选择<code>P</code>中哪个字符对准<code>T[i+j]</code>。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405174258.png" style="zoom: 40%;"></p><p>若<code>P</code>与<code>T</code>的某一（包括<code>T[i+j]</code>在内的）子串匹配，则必然在<code>T[i+j] = &#39;X&#39;</code>处匹配；反之，若与<code>T[i+j]</code>对准的字符不是<code>&#39;X&#39;</code>，则必然失配。故如图(c)，只需找出<code>P</code>中的每一字符<code>&#39;X&#39;</code>，分别于<code>T[i+j] = &#39;X&#39;</code>对准，并执行一轮自右向左的扫描比对。</p><p>若<code>P</code>中包含多个<code>&#39;X&#39;</code>，其实并没有必要逐一尝试，逐一对比并无法确保文本串指针<code>i</code>永不回退。一种简便而高效的做法是：仅尝试<code>P</code>中最靠右的字符<code>&#39;X&#39;</code>（若存在）。如此便可在确保不致遗漏匹配的前提下，始终单向地滑动模式串，如上图(c)若<code>P</code>中最靠右的字符<code>&#39;X&#39;</code>为<code>P[k] = &#39;X&#39;</code>，则<code>P</code>的右移量即为<code>j-k</code>。</p><p><strong>bc[ ]表：</strong></p><p>对于任一给定的模式串<code>P</code>，<code>k</code>值只取决于字符<code>T[i+j] = &#39;X&#39;</code>，因此可将其视作从字符表到整数（<code>P</code>中字符的秩）的一个函数：</p><script type="math/tex; mode=display">bc(c)=\begin{cases}k,\quad &若P[k]=c，且对所有的i>k都有P[i] \ne c\\-1,\quad &若P[\,\,\,]中不含字符c\end{cases}</script><p>故如当前对齐位置为<code>i</code>，则一旦出现坏字符<code>P[j] = &#39;Y&#39;</code>，即重新对齐与：<code>i += j - bc[ T[i+j] ]</code>，并启动下一轮比对。为此可预先将函数<code>bc()</code>整理为一份查询表，称作<strong>BC表</strong>。</p><p>接下来考虑<strong>BC</strong>表中可能出现的两种<strong>特殊情况</strong>：若<code>P</code>根本就不含坏字符<code>&#39;X&#39;</code>，如上图(d)，则模式串整体移过失配位置<code>T[i+j]</code>，用<code>P[0]</code>对准<code>T[i+j+1]</code>，再启动下一轮比对，此类字符在<strong>BC</strong>表的对应项置为-1，其效果也等同于在模式串的最左端，增添一个通配符。若<code>P</code>中含有坏字符<code>&#39;X&#39;</code>，但其中最靠右者的位置也可能太靠右，以至于<code>j-k &lt; 0</code>，相当于左移模式串。显然这是不必要的——匹配算法能进行到此，则此前左侧的所有位置已被显式或隐式地否定排除了，因此只需将P串右移一个单位，然后启动下一轮自右向左的比对。</p><p>以由大写字母和空格组成的字符表为例，与模式串”DATA STRUCTURES”相对应的BC表如下所示：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405182700.png" style="zoom: 40%;"></p><p>按照以上思路，BC表的构造算法可实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//***********************************************************************************</span></span><br><span class="line"><span class="comment">//    0                       bc['X']                                m-1</span></span><br><span class="line"><span class="comment">//    |                       |                                      |</span></span><br><span class="line"><span class="comment">//    ........................X***************************************</span></span><br><span class="line"><span class="comment">//                            .|&lt;------------- 'X' free ------------&gt;|</span></span><br><span class="line"><span class="comment">//***********************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildBC</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造Bad Charactor Shift表：O(m + 256)</span></span><br><span class="line">   <span class="keyword">int</span>* bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//BC表，与字符表等长</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j ++ ) bc[j] = <span class="number">-1</span>; <span class="comment">//初始化：首先假设所有字符均未在P中出现</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j ++ ) <span class="comment">//自左向右扫描模式串P</span></span><br><span class="line">      bc[ P[j] ] = j; <span class="comment">//将字符P[j]的BC项更新为j（单调递增）——画家算法</span></span><br><span class="line">   <span class="comment">/*DSA*/</span>printBC ( bc );</span><br><span class="line">   <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的算法在对BC初始化之后，对模式串<code>P</code>做一遍线性扫描，并不断用当前字符的秩更新BC表中的对应项。因为是按秩递增的次序从左到右扫描，故只要字符<code>c</code>在<code>P</code>中出现过，则最终的<code>bc[c]</code>必会记录下其中最靠右者的秩，这类算法也因此被称作<strong>“ 画家算法 ”（painter’s algorithm）</strong>。</p><p>算法的运行时间可以分为两部分，分别消耗于其中的两个循环：前者是对字符表$\sum$中的每个字符分别做初始化，时间量不超过$O(|\sum|)$；后一循环对模式串P做一轮扫描，其中每个字符消耗$O(1)$时间，需要$O(m)$时间。因此<strong>BC表构造消耗时间为$O(|\sum|+m)$</strong>。</p><p>下面是一个运用BM_BC算法的<strong>实例</strong>：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405184110.png" style="zoom:50%;"></p><p>整个过程总共做过6次成功的比对（黑色字符）和4次失败的比对（白色字符），累计10次，文本串的每个有效字符平均为10/11不足一次。</p><p><strong>复杂度：</strong></p><p>BM算法本身进行串模式匹配所需的时间与具体的输入十分相关，将文本串和模式串的长度分别记为n和m，则在通常情况下的实际运行时间往往低于$O(n)$。在最好情况下，每经过常数次比对，就可以将模式串右移m个字符（即整体右移），如下图中的一类情况（对应蛮力算法中的最坏情况），只需$n/m$次比对算法即可终止，故最好情况下BM算法只需$O(n/m)$时间。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405184826.png" style="zoom:45%;"></p><p>如将模式串P左右颠倒，则对应着最坏的一类情况，在每一轮比对中，P总要完整地扫描一遍才发现失配并向右移动一个字符，运行时间需要$O(n \times m)$。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405211653.png" style="zoom: 80%;"></p><h2 id="4-3-好后缀策略"><a href="#4-3-好后缀策略" class="headerlink" title="4.3.好后缀策略"></a>4.3.好后缀策略</h2><p>参照KMP算法的改进思路不难发现，坏字符策略仅利用了此前（最后一次）失败比对所提供的“ 教训 ”。而实际上在此之前，还做过一系列成功的比对，但这些“ 经验 ”却被忽略了。如上图，每当在<code>P[0] =&#39;1&#39;</code> $\ne$ <code>&#39;0&#39;</code> 处失配，自然地想到应该将其替换成字符<code>&#39;0&#39;</code>。但既然本轮比对过程中已有大量字符<code>&#39;0&#39;</code>的成功匹配，则无论将<code>P[0]</code>对准其中的任何一个都注定会失配。故此时更应明智地将<code>P</code>整体移过这段区间，直接以<code>P[0]</code><strong>对准<code>T</code>中尚未接受比对的首个字符</strong>，如此算法的运行时间将有望降回至$O(n)$。</p><p><strong>好后缀：</strong></p><p>每轮比对中的若干次（连续的）成功匹配，都对应于模式串P的一个后缀，称作<strong>“ 好后缀 ”（good suffix）</strong>，若要改进BM算法，必须利用好后缀提供的“ 经验 ”。一般地，如下图的(a)和(b)所示，设本轮自右向左的扫描终止于失配位置：<code>T[i+j] = &#39;X&#39;</code> $\ne$ <code>&#39;Y&#39; = P[j]</code>。若分别记：</p><ul><li><code>W = substr(T, i+j+1, m-j-1) = T[i+j+1, m+i)</code></li><li><code>U = suffix(P, m-j-1) = P[j+1, m)</code></li></ul><p>好后缀<code>U</code>长度为<code>m-j-1</code>，故只要<code>j &lt;= m-2</code>，则<code>U</code>必非空，且有<code>U = W</code>。接下来就应考虑：根据好后缀所提供的信息应如何确定，<code>P</code>中有哪个（哪些）字符值得与上一失配字符<code>T[i+j]</code>对齐，然后启动下一轮比对呢？</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405213530.png" style="zoom: 45%;"></p><p>如上图(c)设存在一整数<code>k</code>，使得在将<code>P</code>右移<code>j - k</code>个单元，并使<code>P[k]</code>与<code>T[i+j]</code>相互对齐之后，<code>P</code>能够与文本串<code>T</code>的某一（包含<code>T[m+i-1]</code>在内的）子串匹配，亦即：<code>P = substr(T, i+j-k, m) = T[i+k-k, m+i+j-k)</code>。</p><p>于是，若记：<code>V(k) = substr(P, k+1, m-j-1) = P[k+1, m-j+k)</code>，则必然有：<code>V(k) = W = U</code>，也就是说，若值得将P[k]与T[i+j]对齐并做新的一轮比对，则P的子串V(k)首先必须与P自己的后缀U相互匹配。</p><p>还有另一必要条件：<code>P</code>中的这两自匹配子串的前驱字符不得相等，即<code>P[k] != P[j]</code>，否则在对齐位置也注定不会出现与<code>P</code>的整体匹配。若模式串<code>P</code>中同时存在多个满足上述必要条件的子串<code>V(k)</code>，则不妨选取其中最靠右者（对应于最大的<code>k</code>，最小的右移距离<code>j-k</code>），这两点都与KMP算法的处理类似。</p><p><strong>gs[ ]表：</strong></p><p>如上图(c)若满足上述必要条件的子串<code>V(k)</code>起始于<code>P[k+1]</code>，则模式串对应的右移量就是<code>j-k</code>。而<code>k</code>本身仅取决于模式串<code>P</code>以及<code>j</code>值，因此又可仿照KMP算法通过预处理将模式串<code>P</code>转换为另一张查找表<code>gs[0, m)</code>，其中<code>gs[j] = j-k</code>分别记录对应的位移量。</p><p>若P中没有任何子串<code>V(k)</code>可与好后缀<code>U</code>完全匹配，则需要从<code>P</code>的所有前缀中，找出可与<code>U</code>的某一（真）后缀相匹配的最长者，作为<code>V(k)</code>，并取<code>gs[j] = m - |V(k)|</code>。如下例是模式串<code>P = “ICED RICE PRICE”</code>对应的GS表，<code>gs[5] = 12</code> 就意味着：一旦在<code>P[5] = &#39;R&#39;</code>处发生失配，则应将模式串<code>P</code>整体右移12个字符，然后继续启动下一轮比对，也可以等效地认为，以<code>P[5-12] = P[-7]</code>对准文本串中失配的字符，或以<code>P[0]</code>对准文本串中尚未对准过的最左侧字符。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405215841.png" style="zoom: 40%;"></p><p>下面是一个运行好后缀策略进行串匹配的<strong>实例</strong>：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405220307.png" style="zoom: 50%;"></p><p>整个过程中总共做10次成功的比对（黑色字符）和2次失败的比对（灰色字符），累计12次比对，文本串的每个字符，平均（12/13）不足一次。</p><p><strong>复杂度：</strong></p><p>同时结合BC表和GS表两种启发策略，加快模式串相对于文本串的右移速度，可以证明对于匹配失败的情况，总体比对的次数不致超过$O(n)$。若不排除完全匹配的可能，则该算法在最坏情况下的效率，有可能退化至与蛮力算法相当，所幸只要做些简单的改进，依然能够保证总体的比对次数不超过线性。综上<strong>在兼顾了坏字符与好后缀两种策略之后，BM算法的运行时间为$O(n+m)$</strong>。</p><h2 id="4-4-gs-表构造算法："><a href="#4-4-gs-表构造算法：" class="headerlink" title="4.4.gs[ ]表构造算法："></a>4.4.gs[ ]表构造算法：</h2><p><strong>蛮力算法：</strong></p><p>一个很直接的方法就是：对于每个好后缀<code>P(j, m)</code>，按照自后向前（<code>k</code>从<code>j-1</code>递减至0）的次序，将其与<code>P</code>的每个子串<code>P(k ,m+k-j)</code>逐一对齐，并核对是否出现有匹配的子串，一旦发现，对应的位移量即是<code>gs[j]</code>的取值。然而这里共有$O(m)$个好后缀，各需与$O(m)$个子串对齐，每次对齐后在最坏情况下需要比对$O(m)$次，因此该“算法”可能需要$O(m^3)$的时间。</p><p><strong>MS[ ]串与ss[ ]表：</strong></p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405222044.png" style="zoom: 45%;"></p><p>实际上构造<code>gs[ ]</code>表仅需线性的时间，为此需要引入<code>ss[ ]</code>表。如上图，对于任一整数<code>j</code> $\in$ <code>[0, m)</code>，在<code>P[0, j)</code>的所有后缀中，考查那些与<code>P</code>的某一后缀匹配者。若将其中的最长者记作<code>MS[j]</code>，则<code>ss[j]</code>就是该串的长度<code>|MS[j]|</code>。当<code>MS[j]</code>不存在时，取<code>ss[j] = 0</code>。综上可定义<code>ss[j]</code>为：</p><script type="math/tex; mode=display">ss[j]=\max \{ 0\le s \le j+1\,\,\,|\,\,\,P(j-s,j]=P[m-s,m) \}</script><p>特别地，当<code>j =m-1</code>时，必有<code>s = m</code>——此时，有<code>P(-1, m-1] = P[0, m)</code>。如下例是模式串<code>P = &quot;ICED RICE PRICE&quot;</code>所对应的<code>ss[]</code>表：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405222657.png" style="zoom: 45%;"></p><p><strong>由ss[ ]表构造gs[ ]表：</strong></p><p>如下图所示，任一字符<code>P[j]</code>所对应的<code>ss[j]</code>值，可分两种情况提供有效的信息。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405231557.png" style="zoom: 45%;"></p><p>第一种情况如图(a)，设该位置j满足：<code>ss[j] = j+1</code>，即<code>MS[j]</code>就是整个前缀<code>P[0,j]</code>。此时，对于<code>P[m-j-1]</code>左侧的每个字符<code>P[i]</code>而言，对应于4.3节中图11.12(d)所示的情况，<code>m-j-1</code>都应该是<code>gs[i]</code>取值的一个候选。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405213530.png" style="zoom: 45%;"></p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405231602.jpg" style="zoom:67%;"></p><p>第二种情况如图(b)所示，设该位置<code>j</code>满足：<code>ss[j] &lt;= j</code>，即<code>MS[j]</code>只是<code>P[0, j]</code>的一个真后缀。同时既然<code>MS[j]</code>是极长的，故必有：<code>P[ m - ss[j] -1 ] != P[ j - ss[j] ]</code> 。这就意味着此时的字符<code>P[m - ss[j] - 1]</code>恰好对应于如4.3节中的图11.12(c)的情况，因此<code>m-j-1</code>也应是<code>gs[m - ss[j] - 1]</code>取值的一个候选。</p><p>反过来，根据此前的定义，每一位置<code>i</code>所对应的<code>gs[i]</code>值只可能来自与以上候选。进一步地，既然<code>gs[i]</code>的最终取值是上述候选中的最小（最安全者），故仿照构造<code>bc[]</code>表的画家算法，累计用时将不超过$O(m)$。</p><p><strong>ss[ ]表的构造：</strong></p><p><code>ss[]</code>表是构造<code>gs[]</code> 表的基础与关键，若采用蛮力策略，对每个字符<code>P[j]</code>都做一趟扫描比对，直到出现失配，如此累计需要$O(m^2)$时间。</p><p>为了提高效率，不妨自后想前地逆向扫描，并逐一计算出各字符<code>P[j]</code>对应的<code>ss[j]</code>值。如下图所示，此时必有<code>P[j] = P[m-hi+j-1]</code>，故<strong>可利用此前已计算出的<code>ss[m-hi+j-1]</code>，分两种情况快速地导出<code>ss[j]</code></strong>。在此期间，只需动态地记录当前的极长匹配后缀：<code>P(lo, hi] = P[m -hi +lo, m)</code>。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405233543.png" style="zoom: 45%;"></p><p><strong>第一种情况</strong>如图(a)，设：<code>ss[m - hi +j -1] &lt;= j-lo</code>，此时<code>ss[m - hi +j -1]</code>也是<code>ss[j]</code>可能的最大取值，于是便可直接得到：<code>ss[j] = ss[m - hi +j -1]</code></p><p><strong>第二种情况</strong>如图(b)，设：<code>j-lo &lt; ss[m - hi +j -1]</code>，此时至少仍有：<code>P(lo, j] = P[m - hi + lo, m -hi +j)</code>，故只需将<code>P(j - ss[m - hi + j - 1], lo]</code> 与 <code>P[m - hi + j - ss[m -hi + j -1], m - hi + lo)</code>做一比对，也可确定<code>ss[j]</code>。当然这种情况下极大匹配串的边界<code>lo</code>和<code>hi</code>也需要相应左移。</p><p>以上构思只要实现得当，也只需$O(m)$时间即可构造出<code>ss[]</code>表。</p><p><strong>算法实现：</strong></p><p>按照以上思路，<strong>GS表</strong>的构造算法可实现如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildSS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造最大匹配后缀长度表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* ss = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Suffix Size表</span></span><br><span class="line">   ss[m - <span class="number">1</span>]  =  m; <span class="comment">//对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></span><br><span class="line"><span class="comment">// 以下，从倒数第二个字符起自右向左扫描P，依次计算出ss[]其余各项</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> lo = m - <span class="number">1</span>, hi = m - <span class="number">1</span>, j = lo - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">      <span class="keyword">if</span> ( ( lo &lt; j ) &amp;&amp; ( ss[m - hi + j - <span class="number">1</span>] &lt; j - lo ) ) <span class="comment">//情况一</span></span><br><span class="line">         ss[j] =  ss[m - hi + j - <span class="number">1</span>]; <span class="comment">//直接利用此前已计算出的ss[]</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//情况二</span></span><br><span class="line">         hi = j; lo = __min ( lo, hi );</span><br><span class="line">         <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= lo ) &amp;&amp; ( P[lo] == P[m - hi + lo - <span class="number">1</span>] ) ) <span class="comment">//二重循环？</span></span><br><span class="line">            lo--; <span class="comment">//逐个对比处于(lo, hi]前端的字符</span></span><br><span class="line">         ss[j] = hi - lo;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">//*DSA*/ printf ( "-- ss[] Table -------\n" );</span></span><br><span class="line">   <span class="comment">//*DSA*/ for ( int i = 0; i &lt; m; i ++ ) printf ( "%4d", i ); printf ( "\n" );</span></span><br><span class="line">   <span class="comment">//*DSA*/ printString ( P ); printf ( "\n" );</span></span><br><span class="line">   <span class="comment">//*DSA*/ for ( int i = 0; i &lt; m; i ++ ) printf ( "%4d", ss[i] ); printf ( "\n\n" );</span></span><br><span class="line">   <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildGS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造好后缀位移量表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span>* ss = buildSS ( P ); <span class="comment">//Suffix Size table</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* gs = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Good Suffix shift table</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m; j ++ ) gs[j] = m; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; j &lt; UINT_MAX; j -- ) <span class="comment">//逆向逐一扫描各字符P[j]</span></span><br><span class="line">      <span class="keyword">if</span> ( j + <span class="number">1</span> == ss[j] ) <span class="comment">//若P[0, j] = P[m - j - 1, m)，则</span></span><br><span class="line">         <span class="keyword">while</span> ( i &lt; m - j - <span class="number">1</span> ) <span class="comment">//对于P[m - j - 1]左侧的每个字符P[i]而言（二重循环？）</span></span><br><span class="line">            gs[i++] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1都是gs[i]的一种选择</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j ++ ) <span class="comment">//画家算法：正向扫描P[]各字符，gs[j]不断递减，直至最小</span></span><br><span class="line">      gs[m - ss[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1必是其gs[m - ss[j] - 1]值的一种选择</span></span><br><span class="line">   <span class="comment">//*DSA*/ printGS ( P, gs );</span></span><br><span class="line">   <span class="keyword">delete</span> [] ss; <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-算法纵览"><a href="#5-算法纵览" class="headerlink" title="5.算法纵览"></a>5.算法纵览</h1><p>本文针对串匹配问题，依次介绍了<strong>蛮力</strong>、<strong>KMP</strong>、<strong>基于BC表</strong>、<strong>综合BC表与GS表</strong>等四种典型算法，其渐进复杂度的跨度范围，可概括为：</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200405234952.png" style="zoom: 45%;"></p><p>KMP算法相比于蛮力算法的优势在于无论何种情况，时间效率均稳定在$O(n+m)$，因此在蛮力算法效率接近或达到最坏的$O(n<em>m)$时，KMP算法的优势才会十分明显。仅采用坏字符启发策略（BC）的BM算法，时间效率介于$O(n</em>m)$至$O(n/m)$之间，其最好情况与最坏情况相差悬殊。结合了好后缀策略（BC+GS）后的BM算法，则介于$O(n+m)$与$O(n/m)$之间，其在改进最低效率的同时也保持了最高效率的优势。</p><p><strong>单次比对成功概率：</strong></p><p>有趣的是，<strong>单次比对成功的概率，是决定串匹配算法时间效率的一项关键因素</strong>。纵观以串匹配算法，在每一对齐位置所进行的一轮比对中，仅有最后一次可能失败：反之此前的所有比对（若的确进行过）必然都是成功的。而各种算法的最坏情况均可概括为：因启发策略不够精妙甚至不当，在每一对齐位置都需进行多达$\Omega(n)$次成功的比对，另加最后一次失败的比对。</p><p>若<strong>将单次比对成功的概率记作Pr</strong>，以上串匹配算法的时间性能随Pr的变化趋势，大致如下图所示，其中纵坐标为运行时间，分为$O(n/m)$、$O(n+m)$、$O(n*m)$三挡。（图线只是示意大致的增长趋势）由于对于同一算法，消耗于每一对齐位置的平均时间成本随Pr的提高而增加，因此计算时间与Pr都具有单调正相关的关系。</p><p><img src="/2020/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8820%EF%BC%89%E4%B8%B2/QQ图片20200406000219.png" style="zoom: 45%;"></p><p><strong>字符表长度：</strong></p><p>实际上在所有字符均等概率出现的情况下，<strong>Pr的取值将主要决定于字符表的长度</strong>$|\sum|$，<strong>并与之成反比关系</strong>：字符越长，其中任何一对字符匹配的概率越低。在通常情况下，蛮力算法实际的运行效率并不算太低。而不同的串匹配算法也因此有各自适用的场合。</p>]]></content>
    
    <summary type="html">
    
      串或字符串属于线性结构，自然地可以直接利用向量或列表等序列结构加以实现。但字符串作为一种数据结构，特点极其鲜明，作为字符串基本组成元素的字符，种类通常不多，甚至可能极少。因此，为了高效地处理以字符串形式表示的海量数据，需要设计专门的处理方法。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="串匹配" scheme="http://nekomoon404.github.io/tags/%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="KMP算法" scheme="http://nekomoon404.github.io/tags/KMP%E7%AE%97%E6%B3%95/"/>
    
      <category term="BM算法" scheme="http://nekomoon404.github.io/tags/BM%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法（19）优先级队列</title>
    <link href="http://nekomoon404.github.io/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>http://nekomoon404.github.io/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</id>
    <published>2020-03-28T08:42:05.000Z</published>
    <updated>2020-04-01T15:49:07.758Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>此前的搜索树结构和词典结构，都支持覆盖数据全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标，为此搜索树结构需要在所有元素之间定义并维护一个显式的全序关系。<strong>优先级队列</strong>，这类结构则将操作对象限定于当前的全局极值者。这种根据数据对象之间相对优先级对其进行访问的方式，称作<strong>循优先级访问（call-by-priority）</strong>。</p><p>“全局极值”隐含了“所有元素可相互比较”这一性质，但优先级队列并不会也不必动态维护这个全序，却转而维护一个偏序（partial order）关系，如此不仅足以高效地支持仅针对极值对象的接口操作，更可有效地控制整体计算成本。作为不失高效率的轻量数据结构，对于常规的查找、插入或删除操作，优先级队列的效率并不低于此前的结构；而对于数据集的批量构建及相互合并等操作，其性能却更胜一筹。</p><h1 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1.接口定义"></a>1.接口定义</h1><p>除了作为存放数据的容器，数据结构还应能够按某种约定的次序动态地组织数据，以支持高效的查找和修改操作，如遵循“先进先出”原则的队列，而有些实际情况则要按某种优先级原则，如医院抢救最危急的病人。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401094548.png" style="zoom:50%;"></p><p>从数据结构的角度看，无论是待排序节点的数值、超字符的权重，还是时间的发生时间，数据项的某种属性只要可以相互比较大小，则这种大小关系即可称作<strong>优先级（priority）</strong>。而按照事先约定的优先级，可以始终高效查找并访问优先级最高数据项的数据结构，也统称作<strong>优先级队列（priority queue）</strong>。</p><p>仿照词典结构，也讲优先级队列中的数据项称作<strong>词条（entry）</strong>，而与特定优先级相对应的数据属性，也称作<strong>关键码（key）</strong>。作为确定词条优先级的依据，关键码之间必须可以比较大小（词典结构仅要求关键码支持判等操作）。因此对于优先级队列，必须以比较器的形式兑现对应的优先级关系，为了简化起见，这里假定关键码或者可直接比较，或者已重载了对应的操作符。</p><p>优先级队列作为一类独特数据的意义恰恰在于，通过转而维护词条的一个偏序关系，不仅依然可以支持对最高优先级词条的动态访问，而且可将相应的计算成本控制在足以令人满意的范围之内。</p><p>优先级队列接口的定义如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作接口</th><th>功能描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>size()</code></td><td>报告优先级队列的规模，即其中词条的总数</td></tr><tr><td style="text-align:center"><code>insert()</code></td><td>将指定词条插入优先级队列</td></tr><tr><td style="text-align:center"><code>getMax()</code></td><td>返回优先级最大的词条（若优先级队列非空）</td></tr><tr><td style="text-align:center"><code>delMax()</code></td><td>删除优先级最大的词条（若优先级队列非空）</td></tr></tbody></table></div><p>这里以模板类<code>PQ</code>的形式给出优先级队列的操作接口定义，这一组基本的ADT接口可能有不同的实现方式，故这里均以虚函数形式统一描述这些接口，以便在不同的派生类中具体实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ</span> &#123;</span> <span class="comment">//优先级队列PQ模板类</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">( T )</span> </span>= <span class="number">0</span>; <span class="comment">//按照比较器确定的优先级次序插入词条</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> T <span class="title">getMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//取出优先级最高的词条</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> T <span class="title">delMax</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><h2 id="2-1-尝试"><a href="#2-1-尝试" class="headerlink" title="2.1.尝试"></a>2.1.尝试</h2><p>考虑用此前学过的数据结构来实现优先级队列，要兼顾efficiency和cost，以下考虑了向量Vector，有序向量Sorted Vector，列表List，有序列表Sorted List和平衡二叉搜索树BBST，但基于它们实现的优先级队列都不能实现高效率和低cost的兼顾。</p><p><strong>Vector:</strong></p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401103115.png" style="zoom: 67%;"></p><p><strong>Sorted Vector：</strong></p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401103119.png" style="zoom:67%;"></p><p><strong>List：</strong></p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401103122.png" style="zoom:67%;"></p><p><strong>Sorted List：</strong></p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401103125.png" style="zoom:67%;"></p><p><strong>BBST：</strong></p><p>对于AVL、Splay、Red-black这三种数据结构，查找、插入和删除三个接口均只需$O(\log n)$时间，但是BBST的功能却远远超出了PQ的需求，可以这么理解：</p><script type="math/tex; mode=display">PQ=1\times insert()+0.5\times search()+0.5\times remove()=\frac{2}{3}\times BBST</script><p>若只需查找极单元，则不必维护所有元素之间的全序关系，偏序足矣，因此有理由相信，存在某种更为简单、维护成本更低的实现方式，使得各功能接口时间复杂度依然为$O(\log n)$，而且实际效率更高。</p><h2 id="2-2-完全二叉堆"><a href="#2-2-完全二叉堆" class="headerlink" title="2.2.完全二叉堆"></a>2.2.完全二叉堆</h2><p>有限偏序的极值必然存在，借助<strong>堆（heap）</strong>结构可以维护一个偏序，堆有多种实现形式，这里采用一种最基本的形式——<strong>完全二叉堆（complete binary heap）</strong>，它具有结构性与堆序性。</p><p><strong>结构性</strong>：其逻辑结构等同于完全二叉树（complete binary tree），即平衡因子处处非负（只能是0或1）的AVL树。因此由n个词条组成的完全二叉堆的高度$h=\lfloor \log_2 n \rfloor=O(\log n)$。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401105029.png" style="zoom:67%;"></p><p><strong>堆序性：</strong>堆顶以外的每个节点都不大于其父节点，称为<strong>大顶堆</strong>；还可定义为堆顶以外的每个节点都不小于其父节点，称为<strong>小顶堆</strong>。</p><p>尽管二叉树不属于线性结构，但作为特例的完全二叉树，却与向量有着紧密的对应关系。完全二叉堆的拓扑联接结构，完全由其规模n确定。按照<strong>层次遍历</strong>的次序，每个节点都对应于唯一的编号。故若将所有节点组织为一个向量，则堆中所有节点（编号）与向量各单元（秩）也将彼此一一对应。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401105901.png" style="zoom: 60%;"></p><p>这一实现方式的优势首先体现在，各节点在物理上连续排列，故总共仅需$O(n)$空间，而且更重要的是，利用各节点的编号（或秩），也可便捷地判别父子关系，对于任意节点v，必然满足：</p><ul><li>若v有左孩子，则$i (lchild(v))=2*i(v)+1$;</li><li>若v有右孩子，则$i (rchild(v))=2*i(v)+2$;</li><li>若v有父节点，则$i(parent(v))=\lfloor(i(v)-1)/2\rfloor=\lceil i(v)/2)\rceil-1$</li></ul><p>最后，由于向量支持低分摊成本的扩容调整，故随着堆的 规模和内容不断地动态调整，除标准接口以外的操作所需的时间可以忽略不计。</p><h2 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3.实现"></a>2.3.实现</h2><p><strong>宏</strong>：为简化后续算法的描述及实现，可如下代码所示预先设置一系列的宏定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Parent(i)         ( ( ( i ) - 1 ) &gt;&gt; 1 ) <span class="comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="comment">//PQ[i]的左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="comment">//PQ[i]的右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  InHeap(n, i)      ( ( ( -1 ) &lt; ( i ) ) &amp;&amp; ( ( i ) &lt; ( n ) ) ) <span class="comment">//判断PQ[i]是否合法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LChildValid(n, i) InHeap( n, LChild( i ) ) <span class="comment">//判断PQ[i]是否有一个（左）孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RChildValid(n, i) InHeap( n, RChild( i ) ) <span class="comment">//判断PQ[i]是否有两个孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Bigger(PQ, i, j)  ( lt( PQ[i], PQ[j] ) ? j : i ) <span class="comment">//取大者（等时前者优先）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ProperParent(PQ, n, i) <span class="comment">/*父子（至多）三者中的大者*/</span> \</span></span><br><span class="line">            ( RChildValid(n, i) ? Bigger( PQ, Bigger( PQ, i, LChild(i) ), RChild(i) ) : \</span><br><span class="line">            ( LChildValid(n, i) ? Bigger( PQ, i, LChild(i) ) : i \</span><br><span class="line">            ) \</span><br><span class="line">            ) <span class="comment">//相等时父节点优先，如此可避免不必要的</span></span><br></pre></td></tr></table></figure><p><strong>PQ_ComplHeap模板类</strong>：借助多重继承的机制，定义完全二叉堆模板类<strong><code>PQ_ComplHeap</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vector/Vector.h"</span> <span class="comment">//借助多重继承机制，基于向量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PQ/PQ.h"</span> <span class="comment">//按照优先级队列ADT实现的</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ_ComplHeap</span> :</span> <span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> Vector&lt;T&gt; &#123; <span class="comment">//完全二叉堆</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">UniPrint</span>;</span> <span class="comment">//演示输出使用，否则不必设置友类</span></span><br><span class="line">   PQ_ComplHeap() &#123; &#125; <span class="comment">//默认构造</span></span><br><span class="line">   PQ_ComplHeap ( T* A, Rank n ) &#123; copyFrom ( A, <span class="number">0</span>, n ); heapify ( _elem, n ); &#125; <span class="comment">//批量构造</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( T )</span></span>; <span class="comment">//按照比较器确定的优先级次序，插入词条</span></span><br><span class="line">   <span class="function">T <span class="title">getMax</span><span class="params">()</span></span>; <span class="comment">//读取优先级最高的词条</span></span><br><span class="line">   <span class="function">T <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">//删除优先级最高的词条</span></span><br><span class="line">&#125;; <span class="comment">//PQ_ComplHeap</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">heapify</span> <span class="params">( T* A, Rank n )</span></span>; <span class="comment">//Floyd建堆算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Rank <span class="title">percolateDown</span> <span class="params">( T* A, Rank n, Rank i )</span></span>; <span class="comment">//下滤</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Rank <span class="title">percolateUp</span> <span class="params">( T* A, Rank i )</span></span>; <span class="comment">//上滤</span></span><br></pre></td></tr></table></figure><p><strong>getMax()</strong>：既然全局优先级最高的词条总是位于堆顶，因此只需返回向量的首单元，即可在$O(1)$时间内完成<code>getMax()</code>操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::getMax() &#123;  <span class="keyword">return</span> _elem[<span class="number">0</span>];  &#125; <span class="comment">//取优先级最高的词条</span></span><br></pre></td></tr></table></figure><h2 id="2-4-插入算法"><a href="#2-4-插入算法" class="headerlink" title="2.4.插入算法"></a>2.4.插入算法</h2><p>插入算法首先要调用向量的标准插入接口，将新词条接至向量的末尾，得益于向量结构良好的封装性，这里无需关心这一步骤的具体细节，尤其是无需考虑溢出扩容等特殊情况。</p><p>新引入的词条并未破坏堆的结构性，但只要新词条<code>e</code>不是堆顶，就有可能与其父亲违反堆序性，而其他位置的堆序性依然满足，故以下将调用<code>percolateUp()</code>函数，对新接入的词条做适当调整，在保持结构性的前提下恢复整体的堆序性。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401120132.png" style="zoom:67%;"></p><p><strong>上滤：</strong></p><p>根据e在向量中对应的秩，可以简便地确定词条<code>p</code>对应的秩，即$i(parent(v))=\lfloor(i(v)-1)/2\rfloor$。此时若经比较判定$e\le p$，则堆序性在此局部以至全堆均已满足，插入操作因此即告完成。反之，<strong>若$e&gt;p$，则可在向量中令e和p互换位置</strong>。如此不仅全堆的结构性依然满足，而且<code>e</code>和<code>p</code>之间的堆序性也得以恢复。此后<code>e</code>与其新父亲，可能再次违背堆序性，只需继续套用以上方法。</p><p>每交换一次，新词条<code>e</code>都向上攀升一层，故这一过程也形象地称作<strong>上滤（percolate up）</strong>，<code>e</code>至多上滤至堆顶，一旦上滤完成，全堆的堆序性必将恢复。下面是一个实例：</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401121401.png" style="zoom:67%;"></p><p>上滤调整过程中交换操作的累计次数，不致超过全堆的高度$\lfloor \log_2n \rfloor$，而在向量中，每次交换操作只需常数时间，故上滤调整乃至整个词条插入算法整体的时间复杂度，均为$O(\log n)$。</p><p>插入算法和上滤调整的代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//将词条插入完全二叉堆中</span></span><br><span class="line">   Vector&lt;T&gt;::insert ( e ); <span class="comment">//首先将新词条接至向量末尾</span></span><br><span class="line">   percolateUp ( _elem, _size - <span class="number">1</span> ); <span class="comment">//再对该词条实施上滤调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对向量中的第i个词条实施上滤操作，i &lt; _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Rank <span class="title">percolateUp</span> <span class="params">( T* A, Rank i )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; i ) &#123; <span class="comment">//在抵达堆顶之前，反复地</span></span><br><span class="line">      Rank j = Parent ( i ); <span class="comment">//考查[i]之父亲[j]</span></span><br><span class="line">      <span class="keyword">if</span> ( lt ( A[i], A[j] ) ) <span class="keyword">break</span>; <span class="comment">//一旦父子顺序，上滤旋即完成；否则</span></span><br><span class="line">      swap ( A[i], A[j] ); i = j; <span class="comment">//父子换位，并继续考查上一层</span></span><br><span class="line">   &#125; <span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回上滤最终抵达的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-元素删除"><a href="#2-5-元素删除" class="headerlink" title="2.5.元素删除"></a>2.5.元素删除</h2><p>待删除词条<code>r</code>总是位于堆顶，故可直接将其取出并备份，堆的结构性将破坏。为修复这一缺陷，将最末尾的词条<code>e</code>转移至堆顶。而新的堆顶可能与其孩子们违背堆序性——尽管其他位置的堆序性依然满足，故下调用<code>percolateDown()</code>函数调整新堆顶，在保持结构性的前提下，恢复整体的堆序性。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401165655.png" style="zoom: 67%;"></p><p><strong>下滤：</strong></p><p>若新堆顶e不满足堆序性，将e与其（至多）两个孩子中的大者交换位置。此后，堆中可能的缺陷依然只能来自与词条e——它与新孩子可能再次违背堆序性，只需继续套用以上方法。因每进过一次交换，词条e都会下降一层，故这一调整过程也称作下滤（percolate down）。与上滤同理，这一过程也必然终止，全堆的堆序性必将恢复，下滤乃至整个删除算法的时间复杂度也为$O(\log n)$。下面是一个实例：</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401165708.png" style="zoom:67%;"></p><p>删除算法和下滤调整的代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除非空完全二叉堆中优先级最高的词条</span></span><br><span class="line">   T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[ --_size ]; <span class="comment">//摘除堆顶（首词条），代之以末词条</span></span><br><span class="line">   percolateDown ( _elem, _size, <span class="number">0</span> ); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">   <span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对向量前n个词条中的第i个实施下滤，i &lt; n</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">Rank <span class="title">percolateDown</span> <span class="params">( T* A, Rank n, Rank i )</span> </span>&#123;</span><br><span class="line">   Rank j; <span class="comment">//i及其（至多两个）孩子中，堪为父者</span></span><br><span class="line">   <span class="keyword">while</span> ( i != ( j = ProperParent ( A, n, i ) ) ) <span class="comment">//只要i非j，则</span></span><br><span class="line">      &#123; swap ( A[i], A[j] ); i = j; &#125; <span class="comment">//二者换位，并继续考查下降后的i</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-建堆"><a href="#2-6-建堆" class="headerlink" title="2.6.建堆"></a>2.6.建堆</h2><p>很多算法中输入词条都是成批给出，故在初始化阶段往往需要解决一个共同问题：给定一组词条，高效地将它们组织成一个堆，这一过程也称作<strong>“建堆”（heapification）</strong>。</p><p><strong>蛮力算法：</strong></p><p>从空堆起反复调用标准insert()接口，即可将词条逐一插入其中，并最终完成建堆。尽管这一方法无疑正确，但其消耗的时间却过多。具体地，若共有n个词条，则共需迭代n次，第k轮迭代耗时$O(\log k)$，故累计耗时时间量应为：</p><script type="math/tex; mode=display">O(\log 1+\log 2+\dots +\log n)=O(\log n!)=O(n\log n)</script><p>如此多的时间本来足以将所有词条做全排序，而在这里花费同样多的时间所生成的堆却只能提供一个偏序，这也暗示了存在某种更快的建堆方法。</p><p><strong>自上而下的上滤：</strong></p><p>在将所有输入词条纳入长为n的向量之后，首单元处的词条本身即可视作一个规模为1的堆。接下来考查下一单元，只需调用<code>percolateUp()</code>对其上滤，此后前两单元将构成规模为2的堆，如此反复进行，直到最终得到规模为n的堆。</p><p>这一过程可归纳为：对任何一棵完全二叉树，只需自顶而下、自左向右地对其中每个节点实施一次上滤，即可使之成为完全二叉堆。在此过程中，为将每个节点纳入堆中，所需消耗的时间量将线性正比与该节点的深度。不妨考查高度为$h$、规模为$n=2^{h+1}-1$的满二叉树，其中高度为$i$的节点共有$2^i$个，因此整个算法的总体时间复杂度为：</p><script type="math/tex; mode=display">\sum^h_{i=0}(i\cdot 2^i )=(d-1)\times 2^{d+1}+2=(\log_2(n+1)-2)\cdot (n+1)+2=O(n\log n)</script><p><strong>Floyd算法（自下而上的下滤）：</strong></p><p>考虑一个相对简单的问题：任给堆$H_0$和$H_1$，以及另一独立节点<code>p</code>，然后以<code>p</code>为中介将堆$H_0$和$H_1$合并，故称作<strong>堆合并操作</strong>。首先为满足结构性，可将这两个堆当作<code>p</code>的左、右子树，联接成一棵完整的二叉树。此时等效于在<code>delMax()</code>操作中摘除堆顶，再将末位词条（p）转移至堆顶，以下只需对<code>p</code>实施下滤操作，即可将全树转换为堆。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401181605.png" style="zoom:80%;"></p><p>如果将以上过程作为实现堆合并的一个通用算法，则在将所有词条组织为一棵完全二叉树后，只需自底而上地反复套用这一算法，即可不断地将处于下层的堆逐对地合并成更高一层的堆，并最终得到一个完整的堆。按照这构思，即可实现<strong>Floyd建堆算法</strong>。下面是一个实例：</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401182306.png" style="zoom:67%;"></p><p>在前几节知识的基础上，Floyd算法的实现十分简洁：只需自下而上、由深而浅地遍历所有内部节点，并对每个内部节点分别调用一次下滤算法<code>percolateDown()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">heapify</span> <span class="params">( T* A, <span class="keyword">const</span> Rank n )</span> </span>&#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = n/<span class="number">2</span> - <span class="number">1</span>; <span class="number">0</span> &lt;= i; i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateDown ( A, n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong>Floyd算法依然需要做n步迭代，以对所有节点各做一次下滤。这里每个节点的下滤所需的时间正比与其<strong>高度</strong>，故总体运行时间取决于各节点的高度总和。以高度为$h$，规模为$n=2^{h+1}-1$的满二叉树为例，其运行时间为：</p><script type="math/tex; mode=display">\sum^h_{i=0}((d-i)\cdot 2^i)=2^{d+1}-(d+2)=n-\log_2(n+1)=O(n)</script><p>由于在遍历所有词条之前，绝不可能确定堆的结果，故以上已是建堆操作的最优算法。由此反观，蛮力算法低效率的根源，恰在于其“自上而下的下滤”策略。如此，各节点所消耗的时间线性正比于其<strong>深度</strong>——而在完全二叉树中，深度小的节点，远远少于高度小的节点。</p><h2 id="2-7-就地堆排序"><a href="#2-7-就地堆排序" class="headerlink" title="2.7.就地堆排序"></a>2.7.就地堆排序</h2><p>完全二叉堆有另一具体应用：对于向量中的n个词条，如何借助堆的相关算法，实现高效的排序，相应地这类算法也称作堆排序（heapsort）算法。既然此前归并排序算法的渐进复杂度已达到理论上最优的$O(n\log n)$，故这里将更关注与如何降低复杂度常系数。同时也希望空间复杂度能够有所降低，最好是除输入本身以外只需$O(1)$辅助空间。</p><p><strong>原理：</strong></p><p>算法的总体思路和策略与选择排序算法基本相同：将所有词条分成未排序和已排序两类，不断从前一类中取出最大者，顺序加至后一类中。这里不妨将其划分为前缀H和与之互补的后缀S，分别对应于上述未排序和已排序部分。新算法的不同之处在于：整个排序过程中，<strong>无论H包含多少词条，始终都组织为一个堆</strong>。另外，整个算法过程始终满足<strong>不变性</strong>：H中的最大词条不会大于S中的最小词条——除非二者之一为空，比如算法的初始和终止时刻。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401212154.png" style="zoom:67%;"></p><p>首先如图(a)，取出首单元词条M，将其与末单元词条X交换。M即是当前堆中的最大者，同时根据不变性也不大于S中的任何词条，故如此交换之后M必处于正确的排序位置。故如图(b)，此时可等效地认为S向前扩大了一个单元，H相应地缩小了一个单元，注意如此重新分界之后，H和S依然满足以上不变性。最后仿照此前的词条删除算法，只需对X实施一次下滤调整，即可使H整体的堆序性重新恢复，结果如图(c)。</p><p><strong>复杂度：</strong></p><p>在每一步迭代中，交换M和X只需常数时间，对X的下滤调整不超过$O(\log n)$时间，因此全部n步迭代累计耗时不超过$O(n\log n)$，再加上建堆所用时间，整个算法的运行时间也不超过$O(n\log n)$。纵览算法的整个过程，除了用于支持词条交换的一个辅助单元，几乎不需要更多的辅助空间，故的确属于就地算法。</p><p>得益于向量结构的简洁性，几乎所有以上操作都可便捷地实现，因此该算法不仅可简明地编码，其实际运行效率也因此往往要高于其他$O(n \log n)$的算法，这离不开堆这一精巧的数据结构。</p><p><strong>实例：</strong></p><p>以向量$\{4,2,5,1,3\}$的堆排序过程为例，首先采用Floyd算法将该向量整理为一个完全二叉堆，其中虚线示意下滤过程中的词条交换操作。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401213629.png" style="zoom:67%;"></p><p>然后按照堆排序算法只需5步迭代，完成排序。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401213740.png" style="zoom:67%;"></p><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::heapSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   PQ_ComplHeap&lt;T&gt; H( _elem + lo, hi - lo );  <span class="comment">//将待排序区间建成一个完全二叉堆，O(n)</span></span><br><span class="line">   <span class="keyword">while</span> ( !H.empty() ) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">      _elem[--hi] = H.delMax();  <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-左式堆"><a href="#3-左式堆" class="headerlink" title="3.左式堆"></a>3.左式堆</h1><h2 id="3-1-堆合并"><a href="#3-1-堆合并" class="headerlink" title="3.1.堆合并"></a>3.1.堆合并</h2><p> 除了标准的插入和删除操作，堆结构在实际应用中的另一常见操作即为合并，即任给堆A和堆B，如何将二者所含的词条组织为一个堆。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401221347.png" style="zoom:67%;"></p><p>可以想到两种简单的方法：一是反复取出堆B的最大词条并插入堆A中，将两堆的规模分别记为n和m，且$n\ge m$，每一步迭代均需要做一次删除操作和一次插入操作，分别耗时$O(\log m)$和$O(\log(n+m))$，共需m步迭代，故总体运行时间应为：</p><script type="math/tex; mode=display">m\times [O(\log m)+O(\log(n+m))]=O(m\log(n+m))=O(m\log n)</script><p>另一种是将两个堆中的词条视作彼此独立的对象，从而可以借助Floyd算法，将它们组织为一个新的堆H，运行时间为：</p><script type="math/tex; mode=display">O(n+m)=O(n)</script><p>尽管其性能梢优于前一个，但仍无法令人满意。实际上，既然所有词条已分两组各自成堆，则意味着它们<strong>已经具有一定的偏序性</strong>，这样构建一个更大的偏序集，理应比由一组相互独立的词条构建偏序集更为容易。以上尝试均未奏效的原因在于，不能保证合并操作所涉及的节点足够少。为此不妨设想，堆是否也必须与二叉搜索树一样，尽可能地保持平衡？而<strong>对于堆来说，为控制合并操作所涉及的节点数，反而需要保持某种意义上的“不平衡”</strong>。</p><h2 id="3-2-单侧倾斜"><a href="#3-2-单侧倾斜" class="headerlink" title="3.2.单侧倾斜"></a>3.2.单侧倾斜</h2><p><strong>左式堆（leftist heap）</strong>是优先级队列的另一实现方式，可高效地支持堆合并操作。其基本思路是：在保持堆序性的前提下附加新的条件，使得在堆的合并过程中，只需调整很少量的节点。具体地，需参与调整的节点不超过$O(\log n)$个，故可达到极高的效率。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401222049.png" style="zoom:67%;"></p><p>左式堆的整体结构呈单侧倾斜状，其中节点的分布均偏向左侧，左式堆将不再如完全二叉堆那样满足结构性。这也不难理解，毕竟<strong>堆序性才是堆结构的关键条件</strong>，而<strong>结构性只不过是堆的一项附加条件</strong>。在将平衡性替换为左倾性之后，左式堆结构的<code>merge()</code>操作乃至<code>insert()</code>和<code>delMax()</code>操作均可高效地实现。</p><p>按照以上思路，可借助多重继承的机制，定义左式堆模板类<code>PQ_LeftHeap</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PQ/PQ.h"</span> <span class="comment">//引入优先级队列ADT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BinTree/BinTree.h"</span> <span class="comment">//引入二叉树节点模板类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PQ_LeftHeap</span> :</span> <span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> BinTree&lt;T&gt; &#123; <span class="comment">//基于二叉树，以左式堆形式实现的PQ</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">UniPrint</span>;</span> <span class="comment">//演示输出使用，否则不必设置友类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   PQ_LeftHeap() &#123; &#125; <span class="comment">//默认构造</span></span><br><span class="line">   PQ_LeftHeap ( T* E, <span class="keyword">int</span> n ) <span class="comment">//批量构造：可改进为Floyd建堆算法</span></span><br><span class="line">   &#123;  <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) insert ( E[i] );  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">( T )</span></span>; <span class="comment">//按照比较器确定的优先级次序插入元素</span></span><br><span class="line">   <span class="function">T <span class="title">getMax</span><span class="params">()</span></span>; <span class="comment">//取出优先级最高的元素</span></span><br><span class="line">   <span class="function">T <span class="title">delMax</span><span class="params">()</span></span>; <span class="comment">//删除优先级最高的元素</span></span><br><span class="line">&#125;; <span class="comment">//PQ_LeftHeap</span></span><br></pre></td></tr></table></figure><p><code>PQ_LeftHeap</code>模板类借助多重继承机制，由<code>PQ</code>和<code>BinTree</code>结构共同派生而得。既然左式堆的逻辑结构不再等价于完全二叉树，若沿用此前基于向量的实现方法，必将难以控制空间复杂度。因此改用紧凑型稍差，灵活性更强的二叉树结构，将更具针对性。</p><h2 id="3-3-空节点路径长度"><a href="#3-3-空节点路径长度" class="headerlink" title="3.3.空节点路径长度"></a>3.3.空节点路径长度</h2><p>为控制左式堆的倾斜度，可借鉴AVL树和红黑树的技巧，先引入外部节点，将结构转化为真二叉树，然后为各节点引入“ 空节点路径长度 ”指标，并依此确定相关算法的执行方向。节点<code>x</code>的空节点路径长度（null path length），即做<code>npl(x)</code>。若<code>x</code>为外部节点，则约定<code>npl(x) = npl(null) = 0</code>。反之若<code>x</code>为内部节点，则<code>npl(x)</code>可递归地定义为：<code>npl(x) = 1 + min( npl( lc(x) ), npl( rc(x) ) )</code>，即节点<code>x</code>的<code>npl</code>值取决于其左、右孩子<code>npl</code>值中的小者。  </p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401223323.png" style="zoom:67%;"></p><p>不难验证：<strong><code>npl(x)</code>既等于<code>x</code>到外部节点的最近距离，同时也等于以x为根的最大满子树的高度</strong>。</p><p>左式堆是处处满足“ 左倾性 ”的二叉堆，即任一内部节点x都满足：<code>npl( lc(x) )</code> $\ge$ <code>npl( rc(x) )</code>，即<strong>就<code>npl</code>指标而言，任一内部节点的左孩子都不小于其右孩子</strong>。</p><p>由<code>npl</code>及左倾性的定义可以发现，左式堆中任一内节点<code>x</code>都应满足：<code>npl(x) = 1 + npl( rc(x) )</code>，即<strong>左式堆中每个节点的<code>npl</code>值，仅取决于其右孩子</strong>。要注意的是，“ 左孩子的<code>npl</code>值不小于右孩子 ”并不意味着 “ 左孩子的高度比不小于右孩子 ”。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401224135.png" style="zoom: 80%;"></p><h2 id="3-4-最右侧通路"><a href="#3-4-最右侧通路" class="headerlink" title="3.4.最右侧通路"></a>3.4.最右侧通路</h2><p>从<code>x</code>出发沿右侧分支一直前行直至空节点，经过的通路称作<strong>最右侧通路（rightmost path）</strong>，记作<code>rPath(x)</code>。在左式堆中，尽管右孩子高度可能大于左孩子，但由“ 各节点<code>npl</code>值均决定于其右孩子 ”这一事实不难发现，<strong>每个节点的<code>npl</code>值，应恰好等于其最右侧通路的长度</strong>。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401224557.png" style="zoom: 80%;"></p><p>根节点<code>r</code>的最右侧通路，在此扮演的角色极其重要，<strong><code>rPath(r)</code>的终点必为全堆中深度最小的外部节点</strong>，若记：<code>npl(r) = |rPath(r)| = d</code>，则该堆应包含一棵以r为根，高度为d的满二叉树（黑色部分），且该满二叉树至少应包含$2^{d+1}-1$个节点、$2^d-1$个内部节点——这也是堆的规模下限；反之在包含n个节点的左式堆中，最右侧通路必然不会长于：$\lfloor \log_2(n+1) \rfloor-1=O(\log n)$。</p><h2 id="3-5-合并算法"><a href="#3-5-合并算法" class="headerlink" title="3.5.合并算法"></a>3.5.合并算法</h2><p>假设待合并的左式堆分别以<code>a</code>和<code>b</code>为堆顶，且不失一般性地令$a\ge b$。于是可递归地将<code>a</code>的右子堆$a_R$与堆<code>b</code>合并，然后作为节点<code>a</code>的右孩子替换原先的$a_R$。为保证依然满足左倾性条件，最后还需要比较<code>a</code>左、右孩子的<code>npl</code>值——如有必要还需将二者交换，以保证左孩子的<code>npl</code>值不低于右孩子。</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401225555.png" style="zoom: 80%;"></p><p>下面是一个实例：</p><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401231811.png" style="zoom: 67%;"></p><p>按照以上思路，左式堆合并算法可实现为如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">merge</span> <span class="params">( BinNodePosi(T) a, BinNodePosi(T) b )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ! a ) <span class="keyword">return</span> b; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( ! b ) <span class="keyword">return</span> a; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( lt ( a-&gt;data, b-&gt;data ) ) swap ( a, b ); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">   ( a-&gt;rc = merge ( a-&gt;rc, b ) )-&gt;parent = a; <span class="comment">//将a的右子堆，与b合并</span></span><br><span class="line">   <span class="keyword">if</span> ( !a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl ) <span class="comment">//若有必要</span></span><br><span class="line">      swap ( a-&gt;lc, a-&gt;rc ); <span class="comment">//交换a的左、右子堆，以确保右子堆的npl不大</span></span><br><span class="line">   a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">   <span class="keyword">return</span> a; <span class="comment">//返回合并后的堆顶</span></span><br><span class="line">&#125; <span class="comment">//本算法只实现结构上的合并，堆的规模须由上层调用者负责更新</span></span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong></p><p>以上的合并算法中，所有递归实例可排成一个线性序列，因此该算法实质上属于线性递归，其运行时间应线性正比于递归深度。进一步地，递归只可能发生于两个待合并堆的最右侧通路上，若待合并堆的规模分别为n和m，则其两条最右侧通路的长度分别不会超过$O(\log n)$和$O(\log m)$，因此合并算法总体运行时间应不超过：</p><script type="math/tex; mode=display">O(\log n)+O(\log m)=O(\log n+\log m)=O(\log(\max(n,m)))</script><p>若将以上递归版本改写为迭代版本，还可以从常系数的意义上进一步提高效率。</p><h2 id="3-6-基于合并的插入和删除"><a href="#3-6-基于合并的插入和删除" class="headerlink" title="3.6.基于合并的插入和删除"></a>3.6.基于合并的插入和删除</h2><p>若将<strong>merge()</strong>操作当作一项更为基本的操作，则可以反过来实现优先级队列标准的插入和删除等操作。事实上，得益于merge()操作自身的高效率，如此实现的插入和删除操作，在时间效率方面不逊色与常规的实现方式，而其突出的简洁性也使得这一方式在实际中应用广泛。</p><h3 id="3-6-1-delMax"><a href="#3-6-1-delMax" class="headerlink" title="3.6.1.delMax()"></a>3.6.1.delMax()</h3><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401233438.png" style="zoom:80%;"></p><p>基于<code>merge()</code>操作实现<code>delMax()</code>算法，如图设堆顶x及其子堆$H_L$和$H_R$。在摘除x之后，$H_L$和$H_R$即可被视作为两个彼此独立的待合并的堆，只要通过<code>merge()</code>操作将它们合并其来，则效果完全等同于一次常规的<code>delMax()</code>删除操作。算法的时间复杂度依然不超过$O(\log n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::delMax() &#123;</span><br><span class="line">   BinNodePosi(T) lHeap = _root-&gt;lc; <span class="keyword">if</span> (lHeap) lHeap-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//左子堆</span></span><br><span class="line">   BinNodePosi(T) rHeap = _root-&gt;rc; <span class="keyword">if</span> (rHeap) rHeap-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//右子堆</span></span><br><span class="line">   T e = _root-&gt;data; <span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">   _root = merge ( lHeap, rHeap ); <span class="comment">//合并原左、右子堆</span></span><br><span class="line">   <span class="keyword">if</span>( _root ) _root-&gt;parent = <span class="literal">NULL</span>;  <span class="comment">//若堆非空，还需相应设置父子连接</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-1-insert"><a href="#3-6-1-insert" class="headerlink" title="3.6.1.insert()"></a>3.6.1.insert()</h3><p><img src="/2020/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8819%EF%BC%89%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/QQ图片20200401233441.png" style="zoom:80%;"></p><p>基于<code>merge()</code>操作实现<code>insert()</code>算法，假设拟将词条<code>x</code>插入堆H中。实际上，只要将<code>x</code>也视作（仅含单个节点的）堆，则通过调用<code>merge()</code>操作将该堆与堆H合并之后，其效果即完全等同完成了一次词条插入操作，时间复杂度依然不超过$O(\log n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert ( T e ) &#123;</span><br><span class="line">   BinNodePosi(T) v = <span class="keyword">new</span> BinNode&lt;T&gt; (e);  <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">   _root = merge( _root, v);  <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line">   _root-&gt;parent = <span class="literal">NULL</span>;  <span class="comment">//既然此时堆非空，还需相应设置父子连接</span></span><br><span class="line">   <span class="comment">//_root = merge( _root, new BinNode&lt;T&gt;( e, NULL ) ); //将e封装为左式堆，与当前左式堆合并</span></span><br><span class="line">   _size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      此前的搜索树结构和词典结构，都支持覆盖数据全集的访问和操作，为此搜索树结构需要在所有元素之间定义并维护一个显式的全序关系。本文介绍的优先级队列结构，则将操作对象限定于当前的全局极值者。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（18）词典</title>
    <link href="http://nekomoon404.github.io/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/"/>
    <id>http://nekomoon404.github.io/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/</id>
    <published>2020-03-24T07:06:49.000Z</published>
    <updated>2020-03-25T12:29:22.006Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-词典"><a href="#1-1-词典" class="headerlink" title="1.1.词典"></a>1.1.词典</h2><p>借助数据结构来表示和组织的数字信息，可将所有数据视作一个整体统筹处理，进而提高信息访问的规范性和其处理的效率。例如，借助关键码直接查找和访问数据元素的形式，已为越来越多的数据结构所采用，这也成为现代数据结构的一个重要特征。<strong>词典（dictionary）</strong>即是其中最典型的例子。</p><p>逻辑上的词典是由一组数据构成的集合，其中各元素都是由关键码和数据项合成的<strong>词条（entry）</strong>。<strong>映射（map）</strong>结构与词典结构一样，也是词条的集合。二者的差别仅仅在于，映射要求不同词条的关键码互异，而词典则允许多个词条拥有相同的关键码。除了静态查找，映射和词典都支持动态更新，二者统称作<strong>符号表（symbol table）</strong>。本章将不再过分强调二者的差异，而是笼统地称作词典。</p><p>尽管此处词典和映射中的数据元素，仍表示和实现为词条形式，但这一做法并非必须。与搜索树相比，符号表并不要求词条之间能够根据关键码比较大小，甚至也不需要按照大小次序来组织数据项——即便各数据项之间的确定义有某种次序。</p><p>实际上，以散列表为代表的符号表结构，将转而依据数据项的数值，直接做逻辑查找和物理定位。对于此类结构，在作为基本数据单位的词条内部，<strong>关键码（key）</strong>与<strong>数值（value）</strong>的地位等同，二者不必加以区分。此类结构所支持的这种新的数据访问方式，即所谓的<strong>循值访问（call-by-value）</strong>。</p><p>为支持循值访问的方式，在符号表的内部，仍然必须强制地在数据对象的数值与其物理地址之间建立某种关联。而散列，正是在兼顾空间与时间效率的前提下，讨论和研究赖以设计并实现这种关联的一般性原则、技巧与方法。</p><h2 id="1-2-词典ADT"><a href="#1-2-词典ADT" class="headerlink" title="1.2.词典ADT"></a>1.2.词典ADT</h2><h3 id="1-2-1-操作接口"><a href="#1-2-1-操作接口" class="headerlink" title="1.2.1.操作接口"></a>1.2.1.操作接口</h3><p>除通用的接口之外，词典结构主要的操作接口可归纳为下表：<code>get(key)</code></p><div class="table-container"><table><thead><tr><th>操作接口</th><th>功能描述</th></tr></thead><tbody><tr><td><code>get(key)</code></td><td>若词典中存在以key为关键码的词条，则返回该词条的数据对象；否则，返回NULL</td></tr><tr><td><code>put(key,value)</code></td><td>插入词条(key, value)，并报告是否成功</td></tr><tr><td><code>remove(key)</code></td><td>若词典中存在以key为关键码的词条，则删除之并返回true；否则，返回false</td></tr></tbody></table></div><h3 id="1-2-2-接口定义"><a href="#1-2-2-接口定义" class="headerlink" title="1.2.2.接口定义"></a>1.2.2.接口定义</h3><p>首先以如下代码所示模板类的形式定义词典的操作接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Dictionary</span> &#123;</span> <span class="comment">//词典Dictionary模板类</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//当前词条总数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">put</span> <span class="params">( K, V )</span> </span>= <span class="number">0</span>; <span class="comment">//插入词条（禁止雷同词条时可能失败）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> V* <span class="title">get</span> <span class="params">( K k )</span> </span>= <span class="number">0</span>; <span class="comment">//读取词条</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( K k )</span> </span>= <span class="number">0</span>; <span class="comment">//删除词条</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，所有的操作接口均以虚函数形式给出，留待在派生类中予以具体实现。另外，尽管词条关键码类型可能支持大小比较，但这并非词典结构的必要条件，<code>Dictionary</code>模板类中的<code>Entry</code>类只需支持判断等操作。</p><h1 id="2-散列"><a href="#2-散列" class="headerlink" title="2.散列"></a>2.散列</h1><p>散列以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立起映射关系。只要散列表、散列函数以及冲突排解策略设计得当，散列技术可在期望的常数时间内实现词典的所有接口操作。即就平均时间复杂度的意义而言，可以使这些操作所需的运行时间与词典的规模基本无关。尤为重要的是，散列技术完全摒弃了“关键码有序”的先决条件，故就实现词典结构而言，散列所特有的通用型和灵活性是其他方式无法比拟的。</p><h2 id="2-1-散列表"><a href="#2-1-散列表" class="headerlink" title="2.1.散列表"></a>2.1.散列表</h2><p><strong>散列表（hashtable）</strong>是散列方法的底层基础，逻辑上由一系列可存放词条（或其引用）的单元组成，故这些单元也称作<strong>桶（bucket）或桶单元</strong>，各桶单元也应按其逻辑次序在物理上连续排列。因此这种线性的底层结构用向量来实现再自然不过；为简化实现并进一步提高效率，往往直接使用数组，此时的散列表亦称作<strong>桶数组（bucket array）</strong>。若桶数组的容量为<strong>R</strong>，则其中合法秩的区间[0, R)也称作<strong>地址空间（address space）</strong>。</p><p>一组词条在散列表内部的具体分布，取决于所谓的<strong>散列（hashing）方案</strong>——事先在词条与桶地址之间约定的某种映射关系，可描述为从关键码空间到桶数组地址空间的函数：</p><script type="math/tex; mode=display">hash():key \to hash(key)</script><p>这里的hash( )称作<strong>散列函数（hash function）</strong>，反过来，hash(key)也称作key的<strong>散列地址（hashing address）</strong>，亦即与关键码key相对应的桶在散列表中的秩。</p><p><strong>完美散列（perfect hashing）</strong>：在时间和空间性能方面均达到最优的散列，可在$O(1)$时间内确定散列地址，并完成一次查找、插入或删除；空间性能方面，每个桶恰好存放一个词条，即无空余亦无重复。而完美散列实际上并不常见，在更多的应用环境中，为兼顾空间和时间的效率，无论散列表或散列函数都需要经过更为精心的设计。</p><p>在实际应用中往往会遇到一类问题，其共同的特点可归纳为：尽管词典中实际<strong>需要保存的词条数N</strong>（比如25000）远远小于<strong>可能出现的词条数R</strong>（如10^8），但R个词条中的任何一个都有可能出现在词典中。仿照对向量空间利用率的度量方法，可以将散列表中非空桶的数目与桶单元总数的比值称作<strong>装填因子（load factor）</strong>：$\lambda=N/M=$ 存放的词条 / |桶数组| </p><h2 id="2-2-散列函数"><a href="#2-2-散列函数" class="headerlink" title="2.2.散列函数"></a>2.2.散列函数</h2><p>不妨先假定关键码均为[0, R)范围内的整数，将<strong>词典中的词条数记作N</strong>，<strong>散列表长度记作M</strong>，于是通常有：$R&gt;&gt;M&gt;N$，如下图所示，<strong>散列函数hash( )的作用可理解为：将关键码空间[0, R)压缩为散列地址空间[0, M)</strong>。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324211813.png" style="zoom: 80%;"></p><p>好的散列函数<code>hash( )</code>应具备以下的条件：</p><ul><li>确定性，无论所含的数据项如何，词条<code>E</code>在散列表中的映射地址<code>hash(E.key)</code>必须完全取决于其关键码<code>E.key</code>；</li><li>映射过程自身不能过于复杂，唯此方能保证散列地址的计算可快速完成，从而保证查询或修改操作整体的$O(1)$期望执行时间；</li><li>所有关键码经映射后应尽量覆盖整个地址空间[0, M)，唯此方可充分利用有限的散列表空间，即函数<code>hash()</code>最好是满射。</li></ul><p>因定义域规模R远大于取值域规模M，hash()不可能是单射。这就意味着关键码不同的词条被映射到同一散列地址的情况——<strong>散列冲突（collision）</strong>，难以彻底避免。</p><p>最为重要的一条原则就是，<strong>关键码映射到各桶的概率应尽量接近于1/M</strong>——若关键码均匀且独立地随机分布，这也是任意一对关键码相互冲突的概率。就整体而言，这等效于将关键码空间“均匀地”映射到散列地址空间，从而避免导致极端低效的情况。</p><p>总之，随机越强、规律性越弱的散列函数越好，当然完全符合上述条件的散列函数并不存在，我们只能通过先验地消除可能导致关键码分布不均匀的因素，最大限度地模拟理想的随机函数，尽最大可能降低发生冲突的概率。</p><h3 id="2-2-1-除余法"><a href="#2-2-1-除余法" class="headerlink" title="2.2.1.除余法"></a>2.2.1.除余法</h3><p>符合上述要求的一种最简单的映射方法，就是将散列表长度M取作素数，并<strong>将关键码key映射到key关于M整除的余数</strong>：</p><script type="math/tex; mode=display">hash(key)=key \,\,\,mod\,\,\,M</script><p>以校园电话簿为例，若取M = 90001，如下图所示。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324214430.png" style="zoom: 67%;"></p><p>需要注意的是，<strong>采用除余法时，M必须选为素数</strong>，否则关键码被映射至[0, M)范围内的均匀度将大幅降低，发生冲突的概率将随M所含素因子的增多而迅速加大。</p><p>在实际应用中，对统一词典内词条的访问往往具有某种周期性，若其周期与M具有公共的素因子，则冲突的概率将急剧增加。考虑一个例子：某散列表从全空的初始状态开始，插入的前10个词条对应的关键码是等价数列$\{1000,1015,1030,\dots,1135\}$。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324215833.png" style="zoom:67%;"></p><p>如图(a)，若散列表长度取作M = 20，则其中每一关键码，都与另外一个或两个关键码相冲突；而反过来，散列表中80%的桶，此时却处于空闲状态。词条集中到散列表内少数若干桶中（或附近）的现象，称作<strong>词条的聚集（clustering）</strong>。显然好的散列函数应尽可能避免此类现象，而采用素数表长则是降低聚集发生概率的捷径。</p><p>一般地，散列表的长度M与词条关键码间隔T之间的最大公约数越大，发生冲突的可能性也讲越大。因此，若M取素数，则简便对于严格或大致等间隔的关键码序列，也不致出现冲突激增的情况，同时提高空间效率。如图(b)改用表长M = 19，则没有任何冲突，且空间利用率提高至50%以上；再如图(c)，取表长M = 11，则同样不致发生任何冲突，且仅有一个桶空闲。</p><p>若T本身足够大而且恰好可被M整除，则所有被访问词条都将相互冲突。如图(d)将表长取为素数M = 5，且只考虑插入序列中的前5个关键码，则所有关键码都将聚集于一个桶内，但实际中发生这种情况的概率极低。</p><p><strong>除余法的缺陷</strong>：</p><p>以素数为表长的除余法尽管可在一定程度上保证词条的均匀分布，但从关键码空间到散列地址空间映射的角度看，依然残留有某种连续性。比如，相邻关键码所对应的散列地址，总是彼此相邻，称为<strong>零阶均匀</strong>；极小的关键码，通常都被集中映射到散列表的起始区段——其中，特别地，<strong>0值</strong>居然是一个“<strong>不动点</strong>”，其散列表地址总是0，而与散列表长度无关。</p><h3 id="2-2-2-MAD法"><a href="#2-2-2-MAD法" class="headerlink" title="2.2.2.MAD法"></a>2.2.2.MAD法</h3><p>为了弥补除余法的不足，可采用<strong>MAD法（multiply-add-divide method）</strong>，它将关键码key映射为：</p><script type="math/tex; mode=display">(a \times key +b)\,\,\,mod\,\,\,M</script><p>其中，M仍为素数，$a&gt;0,b&gt;0$，且$a\,\,\,mod\,\,\,M \ne 0$</p><p>尽管运算量略有增加，但只要常数a和b选取得当，MAD法可以很好地克服除余法原有的连续性缺陷。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324221245.png" style="zoom:80%;"></p><p>如上图，若采用除余法，将关键码$\{2011,2012,2013,2014,2015,2016\}$插入长度为M = 17的空散列表后，这组词条将存放至地址连续的6个桶中，尽管没有任何关键码的冲突，却可以改善为“更高阶”的均匀性。若采用MAD法，当选取a = 31和b = 2时，各关键码的均匀性相对于图(a)有了很大改善。</p><h3 id="2-2-3-更多的散列函数"><a href="#2-2-3-更多的散列函数" class="headerlink" title="2.2.3.更多的散列函数"></a>2.2.3.更多的散列函数</h3><p>除了上面介绍的两种散列函数，还有很多种形式的散列函数。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324221757.png" style="zoom: 67%;"></p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324221801.png" style="zoom:67%;"></p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200324221752.png" style="zoom:67%;"></p><h2 id="2-3-Hashtable模板类"><a href="#2-3-Hashtable模板类" class="headerlink" title="2.3.Hashtable模板类"></a>2.3.Hashtable模板类</h2><p>按照词典的标准接口，可以模板类的形式，定义<code>Hashtable</code>类，实现如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Dictionary/Dictionary.h"</span> <span class="comment">//引入词典ADT</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bitmap/Bitmap.h"</span> <span class="comment">//引入位图</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="comment">//key、value</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span> :</span> <span class="keyword">public</span> Dictionary&lt;K, V&gt; &#123; <span class="comment">//符合Dictionary接口的Hashtable模板类</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">UniPrint</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Entry&lt;K, V&gt;** ht; <span class="comment">//桶数组，存放词条指针</span></span><br><span class="line">   <span class="keyword">int</span> M; <span class="comment">//桶数组容量</span></span><br><span class="line">   <span class="keyword">int</span> N; <span class="comment">//词条数量</span></span><br><span class="line">   Bitmap* lazyRemoval; <span class="comment">//懒惰删除标记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lazilyRemoved(x)  (lazyRemoval-&gt;test(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> markAsRemoved(x)  (lazyRemoval-&gt;set(x))</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">probe4Hit</span> <span class="params">( <span class="keyword">const</span> K&amp; k )</span></span>; <span class="comment">//沿关键码k对应的查找链，找到词条匹配的桶</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">probe4Free</span> <span class="params">( <span class="keyword">const</span> K&amp; k )</span></span>; <span class="comment">//沿关键码k对应的查找链，找到首个可用空桶</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span></span>; <span class="comment">//重散列算法：扩充桶数组，保证装填因子在警戒线以下</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Hashtable ( <span class="keyword">int</span> c = <span class="number">5</span> ); <span class="comment">//创建一个容量不小于c的散列表（为测试暂时选用较小的默认值）</span></span><br><span class="line">   ~Hashtable(); <span class="comment">//释放桶数组及其中各（非空）元素所指向的词条</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> N; &#125; <span class="comment">// 当前的词条数目</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">put</span> <span class="params">( K, V )</span></span>; <span class="comment">//插入（禁止雷同词条，故可能失败）</span></span><br><span class="line">   <span class="function">V* <span class="title">get</span> <span class="params">( K k )</span></span>; <span class="comment">//读取</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( K k )</span></span>; <span class="comment">//删除</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="散列表构造"><a href="#散列表构造" class="headerlink" title="散列表构造"></a>散列表构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; Hashtable&lt;K, V&gt;::Hashtable ( <span class="keyword">int</span> c ) &#123; <span class="comment">//创建散列表，容量为</span></span><br><span class="line">   M = primeNLT ( c, <span class="number">1048576</span>, <span class="string">"../../_input/prime-1048576-bitmap.txt"</span> ); <span class="comment">//不小于c的素数M</span></span><br><span class="line">   N = <span class="number">0</span>; ht = <span class="keyword">new</span> Entry&lt;K, V&gt;*[M]; <span class="comment">//开辟桶数组（还需核对申请成功），初始装填因子为N/M = 0%</span></span><br><span class="line">   <span class="built_in">memset</span> ( ht, <span class="number">0</span>, <span class="keyword">sizeof</span> ( Entry&lt;K, V&gt;* ) *M ); <span class="comment">//初始化各桶</span></span><br><span class="line">   lazyRemoval = <span class="keyword">new</span> Bitmap ( M ); <span class="comment">//懒惰删除标记比特图</span></span><br><span class="line">   <span class="comment">//*DSA*/printf("A bucket array has been created with capacity = %d\n\n", M);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">primeNLT</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">char</span>* file)</span></span>&#123; <span class="comment">//根据file文件中的记录，在[c, n)内取最小的素数</span></span><br><span class="line">    <span class="function">Bitmap <span class="title">B</span><span class="params">( file n)</span></span>;  <span class="comment">//file 已经按位图格式，记录了n以内的所有素数，因此只要</span></span><br><span class="line">    <span class="keyword">while</span>( c &lt; n)       <span class="comment">//从c开始，逐位地</span></span><br><span class="line">        <span class="keyword">if</span>( B.test( c ) ) c++;   <span class="comment">//测试，即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> c;  <span class="comment">//返回首个发现的素数</span></span><br><span class="line">    <span class="keyword">return</span> c;           <span class="comment">//若没有这样的素数，返回n(实用中不能如此简化处理)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加速素数的选取，事先计算出不超过1049576的所有素数，并存放于文件中备查。于是在创建散列表（或重散列）时，对于在此范围内任意给定的长度下限c，都可通过调用<code>primeNLT()</code>，迅速地从该查询表中找到不小于c的最小素数M作为散列表长度，并依次为新的散列表申请相应数量的空调；同时创建一个同样长度的位图结构，作为懒惰删除标志表。</p><p><code>primeNLT()</code>从长度下限c开始，逐个测试对应的标志位，直到第一个足够大的素数。</p><h4 id="散列表析构"><a href="#散列表析构" class="headerlink" title="散列表析构"></a>散列表析构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; Hashtable&lt;K, V&gt;::~Hashtable() &#123; <span class="comment">//析构前释放桶数组及非空词条</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) <span class="comment">//逐一检查各桶</span></span><br><span class="line">      <span class="keyword">if</span> ( ht[i] ) <span class="built_in">release</span> ( ht[i] ); <span class="comment">//释放非空的桶</span></span><br><span class="line">   <span class="built_in">release</span> ( ht ); <span class="comment">//释放桶数组</span></span><br><span class="line">   <span class="built_in">release</span> ( lazyRemoval ); <span class="comment">//释放懒惰删除标记</span></span><br><span class="line">&#125; <span class="comment">//release()负责释放复杂结构，与算法无直接关系，具体实现详见代码包</span></span><br></pre></td></tr></table></figure><p>在销毁散列表之前，需在逐一释放各桶中的词条（如果存在）之后，释放整个散列表<code>ht[]</code>以及对应的懒惰删除表<code>lazyRemoval[]</code>。</p><h1 id="3-排解冲突"><a href="#3-排解冲突" class="headerlink" title="3.排解冲突"></a>3.排解冲突</h1><p>散列表的基本构思，可以概括为：</p><ul><li>开辟物理地址连续的桶数组<code>ht[]</code>，借助散列函数<code>hash()</code>，将词条关键码<code>key</code>映射；</li><li>为桶地址<code>hash(key)</code>，从而快速地确定待操作词条的物理位置</li></ul><p>然而遗憾的是，无论散列函数设计得如何巧妙，也不可能保证不同的关键码之间互不冲突。比如课堂中的学生，发生生日（birthday）相同的概率，将全年各天视作365个桶，将学生视作词条，只要学生人数$n\ge23$，则至少发生一次冲突的概率$P_{365}(n)\ge 50\%$，而此时的装填因子仅为$\lambda=23/365=6.3\%$。对于更长的散列表，只需更低的装填因子，即友50%概率会发生一次冲突。因此<strong>冲突具有普遍性</strong>。</p><h2 id="3-1-开放散列"><a href="#3-1-开放散列" class="headerlink" title="3.1.开放散列"></a>3.1.开放散列</h2><h3 id="3-1-1-多槽位法（multiple-slots）"><a href="#3-1-1-多槽位法（multiple-slots）" class="headerlink" title="3.1.1.多槽位法（multiple slots）"></a>3.1.1.多槽位法（multiple slots）</h3><p>最直接了当的一种对策是，将彼此冲突的每一组词条组织为一个小规模的子词典，分别存放于它们共同对应的桶单元中。比如一种简便的方法是，统一将各桶细分为更小的称作<strong>槽位（slot）</strong>的若干单元，每一组槽位可组织为向量或列表。</p><p>如对于下图的冲突散列，可将各桶细分为四个槽位，只要相互冲突的各组关键码不超过4个，即可分别保存与对应桶单元内的不同槽位。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325105111.png" style="zoom: 67%;"></p><p>按照这一思路，针对关键码key的任一操作都将转化为对一组槽位的操作。比如<code>put(key,value)</code>操作，将首先通过<code>hash(key)</code>定位对应的桶单元，并在其内部的一组槽位内，进一步查找<code>key</code>。若失败，则创建新词条<code>(key, value)</code>，并将其插至该桶单元内的空闲槽位中。<code>get(key)</code>和<code>remove(key)</code>操作的过程与此类似。</p><p>多槽位的<strong>缺陷</strong>也显而易见：</p><ul><li>绝大多数的槽位通常都处于空闲状态，若每个桶被细分为k个槽位，则当散列表总共存有N个词条时，装填因子：$\lambda’=N/(kM)=\lambda/k$ 将降低至原先的$1/k$。</li><li>很难在事先确定槽位应细分到何种程度，方可保证在任何情况下都够用。比如在极端情况下，有可能所有（或接近所有）的词条都冲突与单个桶单元，此时尽管几乎其余所有的桶都处于空闲状态，该桶却会因冲突过多而溢出。</li></ul><h3 id="3-1-2-独立链法（separate-chaining）"><a href="#3-1-2-独立链法（separate-chaining）" class="headerlink" title="3.1.2.独立链法（separate chaining）"></a>3.1.2.独立链法（separate chaining）</h3><p>独立链法与多槽位法类似，也令相互冲突的每组词条构成小规模的子词典，只不过采用列表来实现各子词典，令各桶内相互冲突的词条串接成一个列表。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325110659.png" style="zoom:67%;"></p><p>既然好的散列函数已能保证通常不致发生极端的冲突，故个子词典的规模往往都不是很大，大多数往往只含单个词条或者甚至是空的，因此采用此前学过的基本列表结构足矣。</p><p><strong>优点</strong>：</p><ul><li>相对于多槽位法，独立链法可更为灵活地动态调整各子词典的容量和规模，从而有效地降低空间消耗。</li></ul><p><strong>缺陷</strong>：</p><ul><li>指针需要额外空间，节点需要动态申请。</li><li>在查找过程中一旦发生冲突，则需要遍历整个序列，导致查找成本的增加。</li></ul><h3 id="3-1-3-公共溢出区法（overflow-area）"><a href="#3-1-3-公共溢出区法（overflow-area）" class="headerlink" title="3.1.3.公共溢出区法（overflow area）"></a>3.1.3.公共溢出区法（overflow area）</h3><p>公共溢出区法是在原散列表之外另设一个词典结构$D_{overflow}$，一旦在插入词条时发生冲突就将该词条转存至$D_{overflow}$。就效果而言，$D_{overflow}$相当于一个存放冲突词条的公共缓冲池，就整体而言，此时的散列表也可理解为是一种递归形式的散列表。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325111159.png" style="zoom:67%;"></p><p>尽管就逻辑结构而言，独立链等策略便捷而紧凑，但也有缺点。比如因需要引如次级关联结构，实现相关算法的代码自身的复杂程度和出错概率都将大大增加。反过来，因不能保证物理上的关联性，对于稍大规模的词条集，查找过程中将需做更多的I/O操作。</p><h2 id="3-2-封闭散列"><a href="#3-2-封闭散列" class="headerlink" title="3.2.封闭散列"></a>3.2.封闭散列</h2><p>实际上，仅仅靠基本的散列结构，且就地排解冲突，反而是更好的选择。即若新词条与已有词条冲突，则只允许在散列表内部为其寻找另一空桶。如此，各桶并非注定只能存放特定的一组词条，从理论上讲每个桶单元都有可能存放任一词条。因为散列地址空间对所有词条开放，故这一新的策略亦称作<strong>开放定址（open addressing）</strong>；同时因可用的散列地址仅限于散列表所覆盖的范围之内，故亦称<strong>闭散列（closed hashing）</strong>。因不得使用附件空间，故装填因子需要适当降低，通常都取$\lambda \le 0.5$。</p><h3 id="3-2-1-线性试探法（linear-probing）"><a href="#3-2-1-线性试探法（linear-probing）" class="headerlink" title="3.2.1.线性试探法（linear probing）"></a>3.2.1.线性试探法（linear probing）</h3><p>开放定址策略最基本的一种形式是：在插入关键码<code>key</code>时，若发现桶单元<code>ht[hash(key)]</code>已被占用，则转而试探桶单元<code>ht[hash(key)+1]</code>；若<code>ht[hash(key)+1]</code>也被占用，则继续试探<code>ht[hash(key)+2]</code>，如此不断直到发现一个可用空桶。为确保桶地址的合法，最后还需统一对M取模，第<code>i</code>次试验的桶单元应为：</p><script type="math/tex; mode=display">ht[(hash(key)+i)\,\,\,mod\,\,\,M],\,\,\,i=1,2,3,\dots</script><p>如此被试探的桶单元在物理空间上一次连贯，其地址构成等差数列</p><h4 id="查找链"><a href="#查找链" class="headerlink" title="查找链"></a>查找链</h4><p>采用开放地址策略时，散列表中每一组相互冲突的词条都将被视作一个有序序列，对其中任何一员的查找都需要借助这一序列，该序列被称作<strong>查找链（probing chain）</strong>。对应的查找过程，可能终止于三种情况：</p><ul><li>在当前桶单元命中目标关键码，则成功返回；</li><li>当前桶单元非空，则其中关键码与目标关键码不等，则须转入下一桶单元继续试探；</li><li>当前桶单元为空，则查找以失败返回。</li></ul><p>如下图，长度为M = 17的散列表，设采用除余法定址，采用线性试探排解冲突。如图(a)，从开表开始依次插入5个相互冲突的关键码$\{2011,2028.2045.2062.2079\}$。此后针对其中任一关键码的查找都将从<code>ht[hash(key)] = ht[5]</code>出发，试探各相邻的桶单元，与这组关键码对应的桶单元<code>ht[5,10)</code>构成一个有序序列，对其中任一关键码的查找都将沿该序列顺序进行。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325114906.png" style="zoom:67%;"></p><p>对应长度为n的查找链，失败查找长度就是n+1，在等概率假设下，平均成功查找长度为$\lceil n/2 \rceil$。需要注意的是，尽管<strong>相互冲突的关键码必属于同一查找链</strong>，但反过来，<strong>同一查找链中的关键码却未必相互冲突</strong>。如将上图中的(a)和(b)合并，并按从大到小的次序逐一插入空散列表如图(c)，对于2079或2082关键码而言，查找链中的关键码未必与它们冲突。原因在于，<strong>多组各自冲突的关键码所对应的查找链，有可能相互交织和重叠</strong>，此时各组关键码的查找长度将会进一步增加。</p><p>由上可见，线性试探法中组成各查找链的词条，在物理上保持一定的连贯性，具有良好的数据局部性，故系统缓存的作用可以充分发挥，查找过程中几乎无需I/O操作。尽管闭散列策略同时也会在一定程度上增加冲突发生的可能，但只要散列表的规模不是很小，装填因子不是很大，则相对于于I/O负担的降低而言，这些问题都将微不足道。因此，相对于独立链等开散列策略，闭散列策略的实际应用更为广泛。</p><h3 id="3-2-2-懒惰删除"><a href="#3-2-2-懒惰删除" class="headerlink" title="3.2.2.懒惰删除"></a>3.2.2.懒惰删除</h3><p>查找链中任何一环的缺失，都会导致后续词条因无法抵达而丢失，表现为有时无法找到实际已存在的词条。因此若采用开放定址策略，则在执行删除操作时，需同时做特别的调整。</p><p>如下图，若为删除词条<code>ht[9]=2031</code>，按常规方法将其清空，则该桶的缺失将导致对应的查找链“断裂”，从而致使五个后续词条“丢失”——尽管它们在词典中的确存在，但查找却会失败。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325123125.png" style="zoom:67%;"></p><p>一种简明而有效的方法是：为每个桶另设一个标志位，指示该桶尽管目前为空，但此前确曾存放过词条。在<code>Hashtable</code>模板类中，名为<code>lazyRemoval</code>的<code>Bitmap</code>对象正是起到了这一作用。删除词条时，只需将对应的桶<code>ht[r]</code>标志位<code>lazilyRemoved(r)</code>，如此该桶虽不存放任何实质的词条，却依然是查找链上的一环。</p><p>带有删除标记的桶所扮演的角色，因具体的操作类型而异：</p><ul><li>查找词条时，被视作“ 必不匹配的非空桶 “，查找链在此得以延续；</li><li>插入词条时，被视作“ 必然匹配的空闲桶 ”，可以用来存放新词条。</li></ul><p>因此采用“ 懒惰删除 ”策略之后，<code>get()</code>，<code>put()</code>和<code>remove()</code> 等操作中的查找算法，都需要做相应的调整。</p><p><strong>词条查找接口<code>get()</code>的实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; V* Hashtable&lt;K, V&gt;::<span class="built_in">get</span> ( K k ) <span class="comment">//散列表词条查找算法</span></span><br><span class="line">&#123;  <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">return</span> ht[r] ? &amp; ( ht[r]-&gt;value ) : <span class="literal">NULL</span>;  &#125; <span class="comment">//禁止词条的key值雷同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment"> * 沿关键码k对应的查找链，找到与之匹配的桶（供查找和删除词条时调用）</span></span><br><span class="line"><span class="comment"> * 试探策略多种多样，可灵活选取；这里仅以线性试探策略为例</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Hit ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="comment">//*DSA*/printf(" -&gt;%d", r);</span></span><br><span class="line">   <span class="keyword">while</span> ( ( ht[r] &amp;&amp; ( k != ht[r]-&gt;key ) ) || ( !ht[r] &amp;&amp; lazilyRemoved ( r ) ) )</span><br><span class="line">      r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链线性试探：跳过所有冲突的桶，以及带懒惰删除标记的桶</span></span><br><span class="line">   <span class="comment">//*DSA*/printf(" -&gt;%d", r);</span></span><br><span class="line">   <span class="comment">//*DSA*/printf("\n");</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//调用者根据ht[r]是否为空，即可判断查找是否成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment"> * 沿关键码k对应的查找链，找到首个可用空桶（仅供插入词条时调用）</span></span><br><span class="line"><span class="comment"> * 试探策略多种多样，可灵活选取；这里仅以线性试探策略为例</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Free ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="comment">//*DSA*/printf(" -&gt;%d", r); //首个试探的桶单元地址</span></span><br><span class="line">   <span class="keyword">while</span> ( ht[r] ) r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链逐桶试探，直到首个空桶（无论是否带有懒惰删除标记）</span></span><br><span class="line"><span class="comment">//*DSA*/   while (ht[r]) &#123; r = (r+1) % M; printf(" -&gt;%d", r); &#125; printf("\n");</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//为保证空桶总能找到，装填因子及散列表长需要合理设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先采用除余法确定首个试探的桶单元，然后按线性试探法沿查找链逐桶试探。这里共有两只试探终止的可能：在一个非空的桶内找到目标关键码（成功），或者遇到一个不带懒惰删除标记的空桶（失败）。否则，无论是当前桶中词条的关键码与目标码不等，还是当前桶为空但带有懒惰删除标记，都意味着有必要沿着查找链前进一步继续查找，该算法同一返回最后被试探桶的秩，上层调用者只需核对该桶是否为空，即可判断查找是否失败。</p><p><strong>词条删除接口<code>remove()</code>的实现如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::<span class="built_in">remove</span> ( K k ) &#123; <span class="comment">//散列表词条删除算法</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">if</span> ( !ht[r] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//对应词条不存在时，无法删除</span></span><br><span class="line">   <span class="built_in">release</span> ( ht[r] ); ht[r] = <span class="literal">NULL</span>; markAsRemoved ( r ); N--; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//否则释放桶中词条，设置懒惰删除标记，并更新词条总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用<code>probe4Hit(k)</code>算法，沿关键码k对应的查找链顺序查找。若在某桶单元命中，则释放其中的词条，为该桶单元设置懒惰删除标记，并更新词典的规模。</p><p><strong>词条插入接口put()的实现如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::<span class="built_in">put</span> ( K k, V v ) &#123; <span class="comment">//散列表词条插入</span></span><br><span class="line">   <span class="keyword">if</span> ( ht[probe4Hit ( k ) ] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//雷同元素不必重复插入</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Free ( k ); <span class="comment">//为新词条找个空桶（只要装填因子控制得当，必然成功）</span></span><br><span class="line">   ht[r] = <span class="keyword">new</span> Entry&lt;K, V&gt; ( k, v ); ++N; <span class="comment">//插入（注意：懒惰删除标记无需复位）</span></span><br><span class="line">   <span class="keyword">if</span> ( N * <span class="number">2</span> &gt; M ) rehash(); <span class="comment">//装填因子高于50%后重散列</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用一下<code>probe4Free(k)</code>算法，若沿关键码k所属查找链能找到一个空桶，则在其中创建对应的词条，并更新词典的规模。</p><h3 id="3-2-3-重散列（rehashing）"><a href="#3-2-3-重散列（rehashing）" class="headerlink" title="3.2.3.重散列（rehashing）"></a>3.2.3.重散列（rehashing）</h3><p>就对散列表性能及效率的影响而言，装填因子$\lambda=N/M$是最为重要的一个因素，随着$\lambda$的上升，词条在散列表中聚集的程度亦将迅速加剧。若同时还采用基本的懒惰删除法，则不带懒惰删除标记的桶单元必将持续减少，这也势必加剧查找成本的进一步增多。理论分析和实验统计均表明，只要能将装填因子$\lambda$控制在适当范围内，闭散列策略的平均效率，通常都可保持在较为理想的水平，比如<strong>一般的建议是保持$\lambda&lt;0.5$</strong>。</p><p>重散列是常用的一种将装填因子控制在一定范围以内的方法，其实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment"> * 重散列算法：装填因子过大时，采取“逐一取出再插入”的朴素策略，对桶数组扩容</span></span><br><span class="line"><span class="comment"> * 因散列函数的定址与表长M直接相关，既然M已改变，就不可简单地批量复制原桶数组</span></span><br><span class="line"><span class="comment"> ***************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">void</span> Hashtable&lt;K, V&gt;::rehash() &#123;</span><br><span class="line">   <span class="keyword">int</span> old_capacity = M; Entry&lt;K, V&gt;** old_ht = ht;</span><br><span class="line">   M = primeNLT ( <span class="number">2</span> * M, <span class="number">1048576</span>, <span class="string">"../../_input/prime-1048576-bitmap.txt"</span> ); <span class="comment">//容量至少加倍</span></span><br><span class="line">   N = <span class="number">0</span>; ht = <span class="keyword">new</span> Entry&lt;K, V&gt;*[M]; <span class="built_in">memset</span> ( ht, <span class="number">0</span>, <span class="keyword">sizeof</span> ( Entry&lt;K, V&gt;* ) * M ); <span class="comment">//新桶数组</span></span><br><span class="line">   <span class="built_in">release</span> ( lazyRemoval ); lazyRemoval = <span class="keyword">new</span> Bitmap ( M ); <span class="comment">//新开懒惰删除标记比特图</span></span><br><span class="line">   <span class="comment">//*DSA*/printf("A bucket array has been created with capacity = %d\n\n", M);</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old_capacity; i++ ) <span class="comment">//扫描原桶数组</span></span><br><span class="line">      <span class="keyword">if</span> ( old_ht[i] ) <span class="comment">//将非空桶中的词条逐一</span></span><br><span class="line">         <span class="built_in">put</span> ( old_ht[i]-&gt;key, old_ht[i]-&gt;value ); <span class="comment">//插入至新的桶数组</span></span><br><span class="line">   <span class="built_in">release</span> ( old_ht ); <span class="comment">//释放原桶数组——由于其中原先存放的词条均已转移，故只需释放桶数组本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重散列的效果，只不过是将原词条集，整体“搬迁”至容量至少加倍的新散列表中。与可扩充向量同理，这一策略也可使重散列所耗费的时间，在分摊至各次操作后可以忽略不计。</p><h3 id="3-2-4-平方试探法（quadratic-probing）"><a href="#3-2-4-平方试探法（quadratic-probing）" class="headerlink" title="3.2.4.平方试探法（quadratic probing）"></a>3.2.4.平方试探法（quadratic probing）</h3><p>线性试探法虽然简明紧凑，但各查找链均由物理地址连续的桶单元组成，因而会加剧关键码的<strong>聚集趋势</strong>。如下图，采用除余法将7个关键码$\{2011,2012,2013,2014,2015,2016,2017\}$依次插入长度M = 17的散列表，则会形成聚集区段<code>ht[5, 12)</code>。接下来若想插入关键码3456和4000，由hash(3456) = hash(4000) = hash(2011) = 5，二者的试探都将起始于桶单元<code>ht[5]</code>，分别经过8次和9次试探，它们将被插入聚集区段右侧的位置，形成更长的聚集区段。如果再考虑到聚集区段的生长还会加剧不同聚集区段之间的相互交叠，查找操作平均的下降程度将会更加严重。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325155206.png" style="zoom:67%;"></p><p>采用2.2.2节的MAD法，可在一定程度上减缓上述聚集现象。而<strong>平方试探法</strong>则是一种更为有效的方法。具体地，在试探过程中若连续发生冲突，则按如下规则确定第<code>i</code>次试探的桶地址：</p><script type="math/tex; mode=display">(hash(key)+j^2)\,\,\,mod\,\,\,M,\,\,\,j=0,1,2,\dots</script><p>各次试探的位置起始位置的距离，以平方速率增长。如上图(c)，为插入3456，将依次试探秩为5、6、9、14的桶单元，插入<code>ht[14]</code>；为插入4000，将依次试探秩为5、6、9、14、21 $\equiv$ 4的桶单元，并最终将其插入<code>ht[4]</code>。</p><p>可见，聚集区段并未扩大，同时针对这两个关键码的后续查找，也分别只需3次和4次试探，速度得以提高至两倍以上。平试探之所以能够有效地缓解聚集现象，是因为充分利用了平方函数的特点——顺着查找链，试探位置的间距将以线性（而不再是常数1的）速度增长。于是一旦发生冲突，即可“ 尽快逃离 ”关键码聚集的区段。</p><p>要注意的是：<strong>装填因子须足够小</strong>。只要散列表长度M为素数且装填因子$\lambda\le50\%$，则平方试探迟早必将终止于某个空桶。</p><h4 id="双向平方试探法"><a href="#双向平方试探法" class="headerlink" title="双向平方试探法"></a>双向平方试探法</h4><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325161008.png" style="zoom: 45%;"></p><p>正向和逆向的子查找链，各包含$\lceil M/2 \rceil$个互异的桶。表长取作素数 $M=4\times k+3$，必然可以保证查找链的前M项均互异。</p><h4 id="再散列法（double-hashing）"><a href="#再散列法（double-hashing）" class="headerlink" title="再散列法（double hashing）"></a>再散列法（double hashing）</h4><p>再散列也是延缓词条聚集趋势的一种有效方法，需选取一个适宜的二级散列函数：</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325161452.png" style="zoom:45%;"></p><p>若取$hash_2(key)=1$即是线性试探。</p><h2 id="3-3-散列码转换"><a href="#3-3-散列码转换" class="headerlink" title="3.3.散列码转换"></a>3.3.散列码转换</h2><p>为扩大散列技术的适用范围，散列函数<code>hash()</code>必须能够将任意类型的关键码<code>key</code>映射为地址空间<code>[0, M)</code>内的一个整数<code>hash(key)</code>，以便确定<code>key</code>所对应的散列地址。由关键码到散列地址的映射，可分解为两步：</p><ul><li>利用某一种散列码转换函数<code>hashCode()</code>，将关键码<code>key</code>统一转换为一个整数——称作<strong>散列码（hash code）</strong></li><li>再利用散列函数将散列码映射为散列地址。</li></ul><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325163716.png" style="zoom:80%;"></p><p>散列码转换函数<code>hashCode()</code>应具备以下的条件：</p><ul><li>取值范围应覆盖系统所支持的最大整数范围；</li><li>各关键码经<code>hashCode()</code>映射后得到的散列码，相互之间的冲突也应可能减少；</li><li><code>hashCode()</code>也应与判等器保持一致，即被判等器判定为相等的词条，对应的散列吗应该相等。</li></ul><h4 id="强制转换为整数"><a href="#强制转换为整数" class="headerlink" title="强制转换为整数"></a>强制转换为整数</h4><p>对于<code>byte</code>、<code>short</code>、<code>int</code>和<code>char</code>等本身即可表示为不超过32位整数的数据类型，可通过类型强制将它们转化为32位的整数。</p><h4 id="对成员对象求和"><a href="#对成员对象求和" class="headerlink" title="对成员对象求和"></a>对成员对象求和</h4><p><code>long long</code>和<code>double</code>之类长度超过32位的基本类型，不宜强制转换为整数。可以将高32位和低32位分别看作两个32位整数，将二者之和作为散列码。这一方法可推广至由任意多个整数构成的组合对象，如可将其成员对象各自对应的整数累加起来，再截取低32位作为散列码。</p><h4 id="多项式散列码"><a href="#多项式散列码" class="headerlink" title="多项式散列码"></a>多项式散列码</h4><p>与一般的组合对象不同，字符串内各字符之间的次序具有特定含义，故在做散列码转换时，务必考虑它们之间的次序。为计入各字符的出现次序，可取常数$a\ge2$，并将字符串$x_0x_1\dots x_{n-1}$的散列码取作：</p><script type="math/tex; mode=display">x_0a^{n-1}+x_1a^{n-2}+\dots x_{n-2}a^{1}+x_{n-1}</script><p>这一转换等效于，依次将字符串中的各个字符，视作一个多项式的各项系数，故亦称作多项式散列码（polynomial hash code）。其中的<strong>常数a非常关键</strong>，为尽可能多地保留原字符串的信息以减少冲突，其低比特位不得全为0。另外，针对不同类型的字符串，应通过实验确定a的最佳取值，如对于英语单词之类的字符串，a = 33、37、39或41都是不错的选择。</p><p>利用重载机制，实现散列码的统一转换方法<code>hashCode()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">hashCode</span> <span class="params">( <span class="keyword">char</span> c )</span> </span>&#123; <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) c; &#125; <span class="comment">//字符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">hashCode</span> <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) k; &#125; <span class="comment">//整数以及长长整数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">hashCode</span> <span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> i )</span> </span>&#123; <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) ( ( i &gt;&gt; <span class="number">32</span> ) + ( <span class="keyword">int</span> ) i ); &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">hashCode</span> <span class="params">( <span class="keyword">char</span> s[] )</span> </span>&#123; <span class="comment">//生成字符串的循环移位散列码（cyclic shift hash code）</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> h = <span class="number">0</span>; <span class="comment">//散列码</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( s ), i = <span class="number">0</span>; i &lt; n; i++ ) <span class="comment">//自左向右，逐个处理每一字符</span></span><br><span class="line">      &#123; h = ( h &lt;&lt; <span class="number">5</span> ) | ( h &gt;&gt; <span class="number">27</span> ); h += ( <span class="keyword">int</span> ) s[i]; &#125; <span class="comment">//散列码循环左移5位，再累加当前字符</span></span><br><span class="line">   <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) h; <span class="comment">//如此所得的散列码，实际上可理解为近似的“多项式散列码”</span></span><br><span class="line">&#125; <span class="comment">//对于英语单词，"循环左移5位"是实验统计得出的最佳值</span></span><br></pre></td></tr></table></figure><h1 id="4-散列应用"><a href="#4-散列应用" class="headerlink" title="4.散列应用"></a>4.散列应用</h1><h2 id="4-1-桶-计数排序"><a href="#4-1-桶-计数排序" class="headerlink" title="4.1.桶/计数排序"></a>4.1.桶/计数排序</h2><p>给定[0, M)内的n个互异整数（$n\le M$），如何高效地对其排序？自然，此前学过的向量排序器或列表排序器中的任一排算法，均可完成这一任务，但CBA式排序算法注定在最坏情况下需要$\Omega(n \log n)$时间。实际上，针对数值类型和取值范围特定的这一具体问题，完全可在更短时间内完成排序。</p><h4 id="简单情况"><a href="#简单情况" class="headerlink" title="简单情况"></a>简单情况</h4><p>为此，引入长度为M的散列表，如下图为M = 10和n = 5的一个实例。可使用最简单的散列函数hash(key) = key，将这些整数视作关键码并逐一插入散列表中。然后顺序遍历一趟该散列表，依次输出非空桶中存放的关键码，即可得到原整数集合的排序结果。该算法借助一组桶单元实现对一组关键码的分拣，故称作<strong>桶排序（bucketsort）</strong>。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325185849.png" style="zoom: 45%;"></p><p>该算法所用散列表共占$O(M)$空间，散列表的创建和初始化耗时$O(M)$，将所有关键码插入散列表耗时$O(n)$，依次读出非空桶中的关键码耗时$O(M)$，故总体运行时间为$O(n+M)$。</p><h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>若将上述问题进一步推广：若允许输入整数重复，又改如何高效地实现排序？</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325190356.png" style="zoom:45%;"></p><p>依然可以沿用以上构思，只不过这次<strong>需要处理散列冲突</strong>。如上图用过独立链法排解冲突，在将所有整数作为关键码插入散列表之后，只需一趟顺序遍历将各非空桶中的独立链依次串接起来即可得到完整的排序结果。而且只要在串联时留意链表方向，甚至可以确保排序结果的稳定，故如此实现的桶排序算法属于稳定算法。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325191108.png" style="zoom:45%;"></p><p>推广之后的桶排序算法，总体运行时间依然为$O(n+M)$。其实这一问题十分常见，它涵盖了众多实际应用中的具体需求，这类问题还具有一个特点：$n\gg M$。</p><p>在$n\gg M$的场合，桶排序算法的运行时间将是：$O(n+M)=O(\max(n,M))=O(n)$，线性正比与于待排序元素的数目，突破了$\Omega(n \log n)$的下界。这是因为，以上基于散列表的桶排序算法，采用的是循秩访问的方式，摒弃了以往基于关键码大小比较式的设计思路，故不在受到CBA式算法固有的下界约束。正因为此，桶排序在算法设计方面也占有其独特的地位。</p><h4 id="桶排序例子：最大间隙"><a href="#桶排序例子：最大间隙" class="headerlink" title="桶排序例子：最大间隙"></a>桶排序例子：最大间隙</h4><p>问题：任意n个互异点均将实轴分为n-1段有界区间，其中哪一段最长？</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325192338.png" style="zoom: 80%;"></p><p>平凡算法：</p><ul><li>对所有点排序，最坏情况下$\Omega(n \log n)$；</li><li>依次计算各相邻点对的间距，保留最大者，$\Theta(n)$。</li></ul><p><strong>利用散列：</strong></p><ul><li><p>通过一趟顺序扫描找到最靠左和最靠右的点，将其坐标分别记作lo和hi；</p></li><li><p>建立一个长度为n的散列表，并使用散列函数 $hash(x)=\lfloor (n-1)*(x-lo)/(hi-lo)\rfloor$，讲各点分别插入对应的桶单元，其中x为各点的坐标值，hash(x)为对应的桶编号；</p></li><li>对散列表做一趟遍历，在每个非空桶（黑色）内部确定最靠左和最靠右的点，并删除所有的空桶（白色）；</li><li>再顺序扫描一趟散列表，即可确定相邻非空桶之间的间隙，记录并报告其中的最大者，即为全局的最大间隙。</li></ul><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325193711.png" style="zoom: 45%;"></p><p><strong>正确性：</strong></p><p>MaxGap至少与相邻的两个桶相交，等价地，定义MaxGap的点不可能属于同一个桶，既有maxGap $\ge$ w = ( hi - lo ) /( n - 1)。这就意味着MaxGap的两个端点绝不可能落在同一个桶单元内，进一步地，它们必然来自两个不同的非空桶，且左端点在前一非空桶的应该最靠右，右端点在后一非空桶中应该最靠左——故在散列过程中只需记录各桶中的最左、最右点。</p><p><strong>复杂度：</strong></p><p>空间上，除了输入本身这里只需维护一个散列表，共占用$O(n)$的辅助空间。</p><p>无论是生成散列表、找出各桶最左和最右点，还是计算相邻非空桶之间的间距，并找出其中的最大者，该算法的每一步均耗时$O(n)$。故即便在最坏情况下，累计运行时间也不超过$O(n)$。</p><h2 id="4-2-基数排序"><a href="#4-2-基数排序" class="headerlink" title="4.2.基数排序"></a>4.2.基数排序</h2><p>实际应用环境中词条的关键码，未必都是整数。比如，一种常见的情形是，关键码由多个域（字段）组合而成，并采用所谓的<strong>字典序（lexicographical order）</strong>确定大小次序：任意两个关键码之间的大小关系，取决于它们第一个互异的域。</p><p>如日期型关键码，可分解为year、month和day三个整数字段，并按常规惯例，以“ 年 - 月 - 日 ”的优先级定义字典序。有时同一关键码内各字段的类型也未必一致，如扑克牌所对应的关键码，可以分解为枚举型的suite（花色）和整型的number（点数），若按桥牌的约定，以“ 花色 - 点数 ”为字典序，则每副牌都可按大小排列为：</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325200124.png" style="zoom: 45%;"></p><p>不妨假定个字段类型所对应的比较器均已就绪。设关键码由t个字段$\{k_t,k_{t-1},\dots,k_1\}$，优先级由高到低。于是以其中任一字段$k_i$为关键码，均可调用以上桶排序算法做一趟排序。只需按优先级递增的次序（从$k_1$到$k_t$）针对每一字段各做一趟桶排序，即可实现按整个关键码字典序的排序。</p><p>这一算法称作<strong>基数排序（radixsort）</strong>，它采用了<strong>低位字段优先（least significant digit first）</strong>的策略，其中所作桶排序的趟数，取决于组成关键码的字段数。</p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325201038.png" style="zoom: 45%;"></p><p><strong>正确性：</strong></p><p><img src="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8818%EF%BC%89%E8%AF%8D%E5%85%B8/QQ图片20200325201242.png" style="zoom:45%;"></p><p><strong>复杂度：</strong></p><p>由以上基数排序的流程，总体运行时间应等于其中各趟桶排序所需时间的总和。设各字段取值范围为$[0,M_i)，1\le i \le t$，若记$M=\max\{M_1,M_2,\dots,M_t\}$。</p><p>则总体运行时间不超过：</p><script type="math/tex; mode=display">O(n+M_1)+O(n+M_2)+\dots O(n+M_t)=O(t*(n+M))</script>]]></content>
    
    <summary type="html">
    
      借助关键码直接查找和访问数据元素的形式，已为越来越多的数据结构所采用，这也成为现代数据结构的一个重要特征。词典（dictionary）即是其中最典型的例子。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（17）红黑树</title>
    <link href="http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-03-18T08:24:28.000Z</published>
    <updated>2020-03-23T14:01:07.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-动机"><a href="#1-1-动机" class="headerlink" title="1.1.动机"></a>1.1.动机</h2><p>平衡二叉搜索树的形式多样，如伸展树实现简便，无需修改节点结构、分摊复杂度低，但最坏情况下的单次操作需要$\Omega(n)$时间；AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识，且删除之后的重平衡可能需做多达$\Omega(\log n)$次旋转，从而频繁地导致全树整体拓扑结构的大幅度变化。</p><p>红黑树即是针对后一不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。尽管最怀情况下需对多达$\Omega(\log n)$个节点重染色，但就分摊意义为言仅为$O(1)$个。</p><p>为此需要在AVL树“适度平衡”标准的基础上，进一步放宽条件，红黑树所采用的<strong>“适度平度”标准</strong>可大致表述为：<strong>任一节点左、右子树的高度，相差不得超过两倍</strong>。</p><p>不论是线性的向量、列表、栈或队列，也无论半线性的树结构 以及非线性的图结构，它们大多呈现这么样一种特征：每当经过一次动态的操作 使得其中的逻辑结构发生变化之后，它都会随即完全的转入新的状态 同时将此前的状态完全的遗忘掉，这类结构也因此称作<strong>ephemeral data structure</strong>，也就是说它们都是随时变化的，每一个状态只会存在于某一个瞬间。</p><p>然而在实际应用中往往可能会有更高的要求，比如若将数据结构比作是人，那么它的每一个瞬间状态都相当于人一生中某一时刻的快照，我们或许会对他的历史档案感兴趣，并希望能够任意调阅甚至修改某个历史时刻的档案。因此无论静态还是动态操作，<strong>除了指定目标关键码</strong>，<strong>还需要同时指定一个版本号</strong>，用以说明我们是在这个数据结构的哪一份历史档案中去查找特定对象。如果一个数据结构能够支持这种类型的需求，就称作是<strong>一致性结构，或持久性结构（persistent structures）</strong>。</p><p>乍看起来任意数据结构的持久化都不是那么困难的一件事，比如一种直接了当的方法就是为数据结构的每一个所需的版本都独立的保存一份快照，同时将所有版本的入口组成一个搜索结构。这里我们针对一棵真实的BBST记录了它整个生命期内的5个版本。这样 一旦指定了版本号，我们就可以转入对应的快照，并按照常规搜索方法在其中定位需要操作的元素。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323171857.png" style="zoom: 45%;"></p><p>从单次访问的效率而言这个结构还可以接受，如果将整个历史快照的数目记作h，那么每次我们只需$O(\log h)$的时间便可确定版本档案的入口，接下来再花费$O(\log n)$的时间，在这份档案中进行定位和操作，即<strong>单次操作</strong>需$O(\log h+\log n)$时间。然而就空间而言这种方法是断乎不可接受的，在这样的一组历史快照中每一个元素都可能会被保存多份，渐近的来说n个元素中的每一个都有可能在这组档案中被保存多达h份，这就意味着空间复杂度将伴随着h成线性的速度增长。空间复杂度自然也构成了时间复杂度的一个下限，因此在整个历史过程中为了生成和记录所有的快照，<strong>累计</strong>所花费的时间也会多达$O(h*n)$这样一个规模，分摊下来为了生成每一组快照都大致需要花费线性的时间来创建一个完整的副本。</p><p>那么我们可否就此做一改进呢，比如除了所有元素各自所占用的空间，是否能够将每一个版本所消耗的均摊空间量控制在$O(\ log n)$的范围内呢，即将复杂度控制在$O(n+h<em>\log n)$内呢？答案是可以，为此我们需要<em>*利用同一数据结构相邻版本之间的关联性</em></em>。</p><p>对于每一组相邻的历史快照而言，后者都是在前者的基础上做过相对少量的更新而得的，即绝大部分的数据对象在二者之中都是相同的，二者的差异只是非常非常小的一部分。因此可以改用这样一种策略：大量的元素都作共享，只有发生变化的少量的数据元素才需要进行更新。</p><p>实际上只要实现方法得当，完全可以将相邻版本之间的差异量控制在$O(\log n)$的范围。比如对于BBST而言 下图就是一种可行的实现方法：每一条红线都对应于一个共享，蓝色的虚线所指示的是在相邻版本之间的更新量，也是我们不得不花费空间来进行存储的量，而这个量可以控制在极低的水平。在《计算几何》课程中会介绍这类高级结构。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323173038.png" style="zoom: 60%;"></p><p>进一步地，我们能否将BBST前后版本的空间差异控制在$O(1)$的范围呢？这样整体的<strong>空间复杂度将进一步优化至$O(n+h)$</strong> 而不是$O(h*\log n)$。答案也是可以的。</p><p>为此所应具备的一项必要条件是非常好理解的，即就BBST的树形拓扑结构而言，相邻版本之间的差异本身不能超过常数。然而很遗憾绝大多数的BBST，包括AVL树都不能保证这一点。所谓的拓扑结构差异无非是来自自调整过程中的旋转操作，每一次局部的旋转都意味着在结构上引入常数的差异。因此反过来如果需要保证前后版本在拓扑结构上的差异不超过常数，也就意味着在<strong>从前一版本转入后一版本的过程中所执行的旋转操作不得超过常数次</strong>。</p><p>反观AVL树的两个动态操作，插入操作是满足这一条的，每次插入之后一旦经过一次旋转，局部乃至全树的高度都会复原；然而删除操作却不满足，从AVL树中删除一个节点之后有可能自底而上逐层引发多达$O(\log n)$次的旋转，从而导致树形拓扑结构的剧烈变化。</p><p>因此为了使得上述的构思能够兑现就需要这样一种BBST，它的<strong>任何动态操作，无论插入还是删除对树形拓扑结构的影响都能控制在常数的范围之内</strong>，而<strong>红黑树（red-black tree）</strong>正是具有这一特性的一个变种。</p><h2 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2.结构"></a>1.2.结构</h2><p>为便于对红黑树的理解、实现与分析，不妨按照此前介绍的B-树的做法，统一地引入n+1个外部节点NULL，以保证原树中每一节点的左、右孩子均非空，如此可将二叉树扩展为真二叉树。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323180432.png" style="zoom: 33%;"></p><p>由红、黑两色节点组成的二叉搜索树若满足一下条件，即为<strong>红黑树（red-black tree）</strong>：</p><p><strong>（1）</strong>树根始终为黑色；</p><p><strong>（2）</strong>外部节点均为黑色；</p><p><strong>（3）</strong>其余节点若为红色，则其孩子节点必为黑色；</p><p><strong>（4）</strong>从任一外部节点到根节点的沿途，黑节点的数目相等。</p><p>其中，条件（1）和（2）意味着红节点均为内部节点，且其父亲点及左、右孩子必然存在。条件（3）意味着红节点之父必为黑色，因此树中任一通路都不含相邻的红节点。可见在从根节点通往任一节点的沿途，黑节点都不少于红节点，除去根节点本身，沿途所经黑节点的总数称作节点的<strong>黑深度（black depth）</strong>——根节点的黑深度为0，故条件（4）可理解为“所有外部节点的黑深度统一”。</p><p>由条件（4）可进一步推知，在从任一节点通往其任一后代外部节点的沿途，黑节点的总数亦必相等。除去（黑色）外部节点，沿途所经黑节点的总数称作该节点的<strong>黑高度（black height）</strong>——所有外部节点的黑高度均为0。特别地，根节点的黑高度亦称作全树的黑高度，在数值上与外部节点的黑深度相等。</p><h4 id="2-4-树-红黑树"><a href="#2-4-树-红黑树" class="headerlink" title="(2,4)树 == 红黑树"></a>(2,4)树 == 红黑树</h4><p>红黑树与B-树之间，存在极其密切的联系，经适当转换之后，二者相互等价。具体地，自顶而下逐层考查红黑树各节点，每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点（必黑）水平对齐，二者之间的联边则相应地调整为横向。如此转换之后，沿水平方向相邻的边至多两条，涉及的节点至多三个，此时若将原红黑树的节点视作关键码，沿水平方向相邻的每一组（父亲至多三个）节点恰好构成4阶B-树的一个节点。</p><p>下图针对所有可能的情况，分别给出了具体的转换过程。按照上述对应关系，每棵红黑树都等价于一棵(2,4)-树：前者的每一节点都对应于后者的一个关键码。通往黑节点的边，对黑高度有贡献，并在(2,4)-树中得以保留；通往红节点的边对黑高度没有贡献，在(2,4)-树中对应于节点内部一对相邻的关键码。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323183129.png" style="zoom: 45%;"></p><p>对照红黑树的条件，(2,4)-树中的每个节点应包含且仅包含一个黑关键码，同时红关键码不得超过两个，而且若某个节点果真包含两个红关键码，则黑关键码的位置必然居中。</p><h4 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h4><p>与所有二叉搜索树一样，红黑树的性能首先取决于其平衡性。包含n个内部节点的红黑树T的高度h也不致超过$O(\log n)$，更严格地有：$\log_2(n+1)\le h\le 2 \cdot \log_2(n+1)$。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323185253.png" style="zoom:67%;"></p><p>若将T的黑高度记作H，则H也是T多对应(2,4)-树，故由关于B-树高度与所含关键码总数关系的结论，有：</p><script type="math/tex; mode=display">H\le 1+\log_{\lceil \frac{4}{2} \rceil} \lfloor \frac{n+1}{2} \rceil \le 1+ \log_2 \lfloor \frac{n+1}{2} \rfloor \le \log _2(n+1)</script><p>既然任一通路都不含相邻的红节点，故必有：</p><script type="math/tex; mode=display">h \le 2H \le 2\cdot \log_2(n+1)=O(\log n)</script><p>尽管红黑树不能如完全树那样可做到理想平衡，也不如AVL树那样可做到较严格的适度平衡，但其高度仍控制在最小高度的两倍以内，从渐进的角度看仍是$O(\log n)$，依然保证了适度平衡——这正是红黑树可高效率支持各种操作的基础。</p><h2 id="1-3-红黑树接口定义"><a href="#1-3-红黑树接口定义" class="headerlink" title="1.3.红黑树接口定义"></a>1.3.红黑树接口定义</h2><p>基于<code>BST</code>模板类，可派生出<code>RedBlack</code>模板类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BST/BST.h"</span> <span class="comment">//基于BST实现RedBlack</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">RedBlack</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//RedBlack树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleRed</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//双红修正</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleBlack</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//双黑修正</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateHeight</span> <span class="params">( BinNodePosi(T) x )</span></span>; <span class="comment">//更新节点x的高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   BinNodePosi(T) insert ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//插入（重写）</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除（重写）</span></span><br><span class="line"><span class="comment">// BST::search()等其余接口可直接沿用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里直接沿用了BST的查找算法<code>search()</code>，并根据红黑树的重平衡规则与算法，重写了<code>insert()</code>和<code>remove()</code>接口；新加的两个内部功能接口<code>solveDoubleRed()</code>和<code>solveDoubleBlack()</code>，分别用于在节点插入或删除之后恢复全树平衡。</p><p>另外还需使用此前二叉树节点模板类<code>BinNode</code>中预留的两个成员变量height和color，可借助辅助宏来检查节点的颜色以及判定是否需要更新（黑）高度记录。这里的确并未真正地实现外部节点，而是将它们统一地直接判定为黑“节点”——尽管它们实际上只不过是<code>NULL</code>，其余节点则一概视作节点。下面是用以简化红黑树算法描述的宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsBlack(p) ( ! (p) || ( RB_BLACK == (p)-&gt;color ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IsRed(p) ( ! IsBlack(p) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BlackHeightUpdated(x) ( <span class="comment">/* RedBlack高度更新条件 */</span> \</span></span><br><span class="line">   ( stature( (x).lc ) == stature( (x).rc ) ) &amp;&amp; \</span><br><span class="line">   ( (x).<span class="built_in">height</span> == ( IsRed( &amp;x ) ? stature( (x).lc ) : stature( (x).lc) + <span class="number">1</span> ) ) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是红黑树节点的黑高度更新的算法实现，此处的height已不再是指常规的树高，而是红黑树的黑高度，节点黑高度需要更新的情况共分三种：左、右孩子的黑高度不等；或者作为红节点，黑高度与其孩子不相等；或者作为黑节点，黑高度不等于孩子的黑高度加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> RedBlack&lt;T&gt;::updateHeight ( BinNodePosi(T) x ) &#123; <span class="comment">//更新节点高度</span></span><br><span class="line">   x-&gt;<span class="built_in">height</span> = __max ( stature ( x-&gt;lc ), stature ( x-&gt;rc ) ); <span class="comment">//孩子一般黑高度相等，除非出现双黑</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 红黑树中各节点左、右孩子的黑高度通常相等</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 这里之所以取更大值，是便于在删除节点后的平衡调整过程中，正确更新被删除节点父亲的黑高度</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="comment">// 否则，rotateAt()会根据被删除节点的替代者（高度小一）设置父节点的黑高度</span></span><br><span class="line">   <span class="keyword">return</span> IsBlack ( x ) ? x-&gt;<span class="built_in">height</span>++ : x-&gt;<span class="built_in">height</span>; <span class="comment">//若当前节点为黑，则计入黑深度</span></span><br><span class="line">&#125; <span class="comment">//因统一定义stature(NULL) = -1，故height比黑高度少一，好在不致影响到各种算法中的比较判断</span></span><br></pre></td></tr></table></figure><h1 id="2-节点插入算法"><a href="#2-节点插入算法" class="headerlink" title="2.节点插入算法"></a>2.节点插入算法</h1><h2 id="2-1-节点插入与双红现象"><a href="#2-1-节点插入与双红现象" class="headerlink" title="2.1.节点插入与双红现象"></a>2.1.节点插入与双红现象</h2><p>假定经调用接口<code>search(e)</code>做查找之后，确认目标节点尚不存在。于是，在查找终止的位置<code>x</code>处创建节点，并随机将其染成红色（除非次时全树仅含一个节点），对照红黑树的四项条件，唯有（3）未必满足——即此时x的父亲可能是红色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) RedBlack&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将e插入红黑树</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span> ); _size++; <span class="comment">//创建红节点x：以_hot为父，黑高度-1</span></span><br><span class="line">   BinNodePosi(T) xOld = x; solveDoubleRed ( x ); <span class="keyword">return</span> xOld; <span class="comment">//经双红修正后，即可返回</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>因新节点的引入，而导致父子节点同时为红色的此类情况，称作“<strong>双红”（double red）</strong>，为修正双红缺陷，可调用<code>solveDoubleRed(x</code>)接口。每引入一个关键码，该接口都可能迭代地调用多次。在此过程红，当前节点x的兄弟及两个孩子（初始时都是外部节点），始终均为黑色。</p><p>将<code>x</code>的父亲与祖父分别记作<code>p</code>和<code>g</code>，既然此前的红黑树合法，故作为红节点<code>p</code>的父亲，<code>g</code>必然存在且为黑色。<code>g</code>作为内部节点，其另一孩子（即p的兄弟、x的叔父）也必然存在，将其记作<code>u</code>。以下，视节点<code>u</code>的颜色不同，分两类情况分别处置。</p><h2 id="2-2-双红修正"><a href="#2-2-双红修正" class="headerlink" title="2.2.双红修正"></a>2.2.双红修正</h2><h3 id="2-2-1-RR-1"><a href="#2-2-1-RR-1" class="headerlink" title="2.2.1. RR-1"></a>2.2.1. RR-1</h3><p>首先，考查<code>u</code>为黑色的情况，此时<code>x</code>的兄弟、两个孩子的黑高度，均与<code>u</code>相等。下图中的(a)和(b)即为此类情况的两种可能（另有两种对称情况）。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323195423.png" style="zoom: 80%;"></p><p>此时红黑树条件（3）的违反，从B-树的角度等效地看，<strong>即同一节点不应包含紧邻的红色关键码</strong>。故只需令黑色关键码与紧邻的红色关键码互换颜色，这等效于按中序遍历次序，对节点<code>x</code>、<code>p</code>和<code>g</code>及其四棵子树，<strong>做一次局部“3+4”重构</strong>。</p><p>如此调整之后，局部子树的黑高度将复原，这意味着全树的平衡也必然得以恢复，同时新子树的根节点b为黑色，也不致引发新的双红现象，至此整个插入操作遂告完成。</p><h3 id="2-2-2-RR-2"><a href="#2-2-2-RR-2" class="headerlink" title="2.2.2. RR-2"></a>2.2.2. RR-2</h3><p>再考查节点<code>u</code>为红色的情况，此时<code>u</code>的左、右孩子非空且均为黑色，其黑高度必与<code>x</code>的兄弟以及两个孩子相等。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323195806.png" style="zoom:75%;"></p><p>此时红黑树条件（3）的违反，从B-树角度等效地看，<strong>即该节点因超过4度而发生上溢</strong>。从图(c)红黑树的角度看，只需将红节点<code>p</code>和<code>u</code>转为黑色，黑节点<code>g</code>转为红色，<code>x</code>保持红色；从图(c’)的角度看，<strong>等效于上溢节点的一次分裂</strong>。</p><p>如此调整之后局部子树的黑高度复原，然而子树根节点<code>g</code>转为红色之后，有可能在更高层再次引发双红现象，对应于在关键码<code>g</code>被移出并归入上层节点之后，进而导致上层节点的上溢——即<strong>上溢的向上传播</strong>。若发生这种传播，可将<code>g</code>视作新插入的节点，同样地分以上两类情况如法处置，每经过一次这样的迭代，节点<code>g</code>都将在B-树中（作为关键码）上升一层，而在红黑树中存在双红缺陷的位置也将相应地上升两层，故累计至多迭代$O(\log n)$次。</p><p>特别地，若最后一步迭代之后导致原树根的分裂，并由<code>g</code>独立地构成新的树根节点，则应遵照红黑树条件（1）的要求，将其转换为黑色，如此，全树的黑高度随机增加一层。</p><h3 id="2-2-3-复杂度"><a href="#2-2-3-复杂度" class="headerlink" title="2.2.3. 复杂度"></a>2.2.3. 复杂度</h3><p>以上情况的处理流程可归纳为下图，其中的重构、染色等局部操作均只需常数时间、故只需统计这些操作在修正过程中被调用的总次数。可知节点插入之后的双红修正，累计耗时不会超过$O(\log n)$，即便计入此前的关键码查找预计节点接入等操作，<strong>红黑树的每次节点插入操作，都可在$O(\log n)$时间内完成</strong>。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323201303.png" style="zoom: 75%;"></p><p>需要指出的是，只有在<strong>RR-1</strong>修复时才需要1~2次旋转，而且一旦旋转后，修复过程必然随即完成，故<strong>就全树拓扑结构而言，每次插入后仅涉及常数次调整</strong>；下小节将要介绍的红黑树的节点删除操作也是如此，而回顾此前学过的AVL树，却只能保证前一点。</p><h3 id="2-2-4-实现"><a href="#2-2-4-实现" class="headerlink" title="2.2.4. 实现"></a>2.2.4. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> * RedBlack双红调整算法：解决节点x与其父均为红色的问题。分为两大类情况：</span></span><br><span class="line"><span class="comment"> *    RR-1：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    RR-2：3次颜色翻转，3次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleRed ( BinNodePosi(T) x ) &#123; <span class="comment">//x当前必为红</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRoot ( *x ) ) <span class="comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span></span><br><span class="line">      &#123;  _root-&gt;color = RB_BLACK; _root-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span>;  &#125; <span class="comment">//否则，x的父亲p必存在</span></span><br><span class="line">   BinNodePosi(T) p = x-&gt;parent; <span class="keyword">if</span> ( IsBlack ( p ) ) <span class="keyword">return</span>; <span class="comment">//若p为黑，则可终止调整。否则</span></span><br><span class="line">   BinNodePosi(T) g = p-&gt;parent; <span class="comment">//既然p为红，则x的祖父必存在，且必为黑色</span></span><br><span class="line">   BinNodePosi(T) u = uncle ( x ); <span class="comment">//以下，视x叔父u的颜色分别处理</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( u ) ) &#123; <span class="comment">//u为黑色（含NULL）时 //*DSA*/printf("  case RR-1:\n");</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *x ) == IsLChild ( *p ) ) <span class="comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span></span><br><span class="line">         p-&gt;color = RB_BLACK; <span class="comment">//p由红转黑，x保持红</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span></span><br><span class="line">         x-&gt;color = RB_BLACK; <span class="comment">//x由红转黑，p保持红</span></span><br><span class="line">      g-&gt;color = RB_RED; <span class="comment">//g必定由黑转红</span></span><br><span class="line"><span class="comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span></span><br><span class="line"><span class="comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//曾祖父（great-grand parent）</span></span><br><span class="line">      BinNodePosi(T) r = FromParentTo ( *g ) = rotateAt ( x ); <span class="comment">//调整后的子树根节点</span></span><br><span class="line">      r-&gt;parent = gg; <span class="comment">//与原曾祖父联接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u为红色 //*DSA*/printf("  case RR-2:\n");</span></span><br><span class="line">      p-&gt;color = RB_BLACK; p-&gt;<span class="built_in">height</span>++; <span class="comment">//p由红转黑</span></span><br><span class="line">      u-&gt;color = RB_BLACK; u-&gt;<span class="built_in">height</span>++; <span class="comment">//u由红转黑</span></span><br><span class="line">      <span class="keyword">if</span> ( !IsRoot ( *g ) ) g-&gt;color = RB_RED; <span class="comment">//g若非根，则转红</span></span><br><span class="line">      solveDoubleRed ( g ); <span class="comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-节点删除算法"><a href="#3-节点删除算法" class="headerlink" title="3.节点删除算法"></a>3.节点删除算法</h1><h2 id="3-1-节点删除与双黑现象"><a href="#3-1-节点删除与双黑现象" class="headerlink" title="3.1. 节点删除与双黑现象"></a>3.1. 节点删除与双黑现象</h2><p>为删除关键码<code>e</code>，首先调用标准接口<code>BST::search(e)</code>进行查找，若查找成功，则调用内部接口<code>removeAt(x)</code>实施删除，按照对该接口所约定的语义，<code>x</code>为实际被摘除者，其父亲为<code>p = _hot</code>，其接替者为<code>r</code>，而<code>r</code>的兄弟为外部节点<code>w = NULL</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> RedBlack&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从红黑树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   BinNodePosi(T) r = removeAt ( x, _hot ); <span class="keyword">if</span> ( ! ( --_size ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//实施删除</span></span><br><span class="line"><span class="comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span></span><br><span class="line">   <span class="keyword">if</span> ( ! _hot ) <span class="comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span></span><br><span class="line">      &#123; _root-&gt;color = RB_BLACK; updateHeight ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）必非根，_hot必非空</span></span><br><span class="line">   <span class="keyword">if</span> ( BlackHeightUpdated ( *_hot ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若所有祖先的黑深度依然平衡，则无需调整</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRed ( r ) ) <span class="comment">//否则，若r为红，则只需令其转黑</span></span><br><span class="line">      &#123; r-&gt;color = RB_BLACK; r-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）均为黑色</span></span><br><span class="line">   <span class="comment">//*DSA*/printBinTree(_hot, 0, 0);</span></span><br><span class="line">   solveDoubleBlack ( r ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//经双黑调整后返回</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><p>因随后的复衡调整位置可能逐层上升，故不妨等效地理解为：<code>w</code>系与<code>r</code>黑高度相等的子红黑树，且随其父亲<code>x</code>一并被摘除，如此可将<code>x</code>统一视作上分支节点，从而更为通用地描述以下算法。不难验证此时红黑树的前两个条件继续满足，但后两个条件却未必。</p><p>当然若<code>x</code>原为树根，则无论<code>r</code>颜色如何，只需将其置为黑色并更新黑高度即可，因此不妨假定<code>x</code>的父亲<code>p</code>存在。可分为下面三种情况：第一种只需进行普通的删除操作，即摘除子树<code>w</code>，并将<code>x</code>替换为<code>r</code>；第二种只需在删除操作之后将<code>r</code>转为黑色；第三种，<code>x</code>与<code>r</code>均为黑色，则在删除操作之后，局部子树的黑高度将会降低一个单位。</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323204458.png" style="zoom: 80%;"></p><p>被删除节点<code>x</code>以其替代者<code>r</code>同为黑色的此类情况，称作<strong>“双黑”（double black）</strong>，此时需调用<code>solveDoubleBlack(r)</code>算法予以修正。为此需考查原黑节点<code>x</code>的兄弟<code>s</code>（必然存在，但可能是外部节点），并视<code>s</code>和<code>p</code>颜色的不同组合，按四种情况分别处置。</p><h2 id="3-2-双黑修正"><a href="#3-2-双黑修正" class="headerlink" title="3.2. 双黑修正"></a>3.2. 双黑修正</h2><h3 id="3-2-1-BB-1-s为黑，且至少有一个红孩子t"><a href="#3-2-1-BB-1-s为黑，且至少有一个红孩子t" class="headerlink" title="3.2.1. BB-1: s为黑，且至少有一个红孩子t"></a>3.2.1. BB-1: s为黑，且至少有一个红孩子t</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323202625.png" style="zoom:80%;"></p><p>既然节点<code>x</code>的另一个孩子<code>w = NULL</code>，故从B-树角度看节点<code>x</code>被删除之后的情况，可等效理解为关键码<code>x</code>原所属的节点发生下溢。此时<code>t</code>和<code>s</code>必然属于B-树的同一节点，且该节点就是下溢节点的兄弟。故可参照B-树，下溢节点从父亲点借出一个关键码<code>p</code>，然后从父亲节点从下溢节点的兄弟节点借出一个关键s。</p><p>上述调整过程等效于，对节点<code>t</code>、<code>s</code>和<code>p</code>实施<strong>“3 + 4 重构”</strong>。若这三个节点按中序遍历次序重命名为<code>a</code>，<code>b</code>和<code>c</code>，则还需将<code>a</code>和<code>c</code>染成黑色，<code>b</code>则继承<code>p</code>此前的颜色。对上图的例子而言，就是将<code>t</code>和<code>p</code>染成黑色，<code>s</code>继承<code>p</code>此前的颜色，整个过程中节点<code>r</code>保持黑色不变。</p><p>经过以上处理之后，红黑树的所有条件，都在这一局部以及全局得到恢复，故删除操作遂高完成。</p><h3 id="3-2-2-BB-2-R：s为黑，且两个孩子均为黑；p为红"><a href="#3-2-2-BB-2-R：s为黑，且两个孩子均为黑；p为红" class="headerlink" title="3.2.2. BB-2-R：s为黑，且两个孩子均为黑；p为红"></a>3.2.2. BB-2-R：s为黑，且两个孩子均为黑；p为红</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323202629.png" style="zoom:80%;"></p><p>与BB-1类似，在对应的B-树中，关键码<code>x</code>的删除导致其所属的节点下溢，但因此时关键码<code>s</code>所在节点只有两个分支，故下溢节点无法从父节点借出关键码<code>p</code>。同样按照B-树平衡算法，将关键码<code>p</code>取出并下降一层，再将原左、右孩子合并为一个节点，如图（b’）。从红黑树角度看，这一过程等效为将<code>s</code>和<code>p</code>颜色互换，如图（b）。</p><p>经过以上处理，红黑树的所有条件都在此局部得以恢复。另外，由于关键码<code>p</code>原为红色，故在关键码p所属节点中，其左或右必然还有一个黑色关键码（不可能左右都有），这意味着在关键码<code>p</code>从其中取出之后，不致引发新的下溢。至此，红黑树条件亦必在全局得以恢复，删除操作即告完成。</p><h3 id="3-2-3-BB-2-B：s为黑，且两个孩子均为黑；p为黑"><a href="#3-2-3-BB-2-B：s为黑，且两个孩子均为黑；p为黑" class="headerlink" title="3.2.3. BB-2-B：s为黑，且两个孩子均为黑；p为黑"></a>3.2.3. BB-2-B：s为黑，且两个孩子均为黑；p为黑</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212616.png" style="zoom:80%;"></p><p>此时，与BB-2-R类似，在对应的B-树中，因关键码x的删除，导致其所属节点发生下溢。如图（b’）可将下溢节点与其兄弟合并，从红黑树的角度来看，这一过程可等效为将节点<code>s</code>转换为红色，如图（b）。</p><p>然后既然<code>s</code>和<code>x</code>在此之前均为黑色，故<code>p</code>原所属的B-树节点必然仅含<code>p</code>这一个关键码，于是在<code>p</code>被借出之后，该节点必将继而发生下溢，从而有待于后续的进一步修正。从红黑树的角度来看，此时的状态则可等效地理解为：节点<code>p</code>的（黑色）父亲刚被删除。</p><p>实际上这也是双黑修正过程中，需要再次迭代的唯一可能。而幸运的是，尽管此类情况可能持续发生，但下溢的位置必然会不断上升，故至多迭代$O(\log n)$次后必然终止。</p><h3 id="3-2-4-BB-3：s为红（其孩子均为黑）"><a href="#3-2-4-BB-3：s为红（其孩子均为黑）" class="headerlink" title="3.2.4. BB-3：s为红（其孩子均为黑）"></a>3.2.4. BB-3：s为红（其孩子均为黑）</h3><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212631.png" style="zoom:80%;"></p><p>此时作为红节点<code>s</code>的父亲，节点<code>p</code>必为黑色，同时<code>s</code>的两个孩子也应均为黑色。从B-树的角度看，如图（b’）令关键码<code>s</code>与<code>p</code>互换颜色，即可得到一棵与之完全等价的B-树，而从红黑树的角度来看，如图（b），这一转换对应于以节点<code>p</code>为轴做一次旋转，并交换节点<code>s</code>与<code>p</code>的颜色。</p><p>虽然经过如此处理之后，双黑缺陷依然存在（子树<code>r</code>的黑高度并未复原），而且缺陷位置的高度也并未上升。然而实际上情况已经发生微妙而本质的变换，观察图（b）可以看到，转换之后的红黑树中，被删除节点<code>x</code>有了一个新的兄弟<code>s&#39;</code>；另外现在的节点<code>p</code>，也已经由黑色转为红色。这就意味着接下来的修正调整只会转入前两种情况：<strong>BB-1</strong>或者<strong>BB-2-R</strong>，即接下来至多再做一次迭代调整，整个双黑修正的任务即可完成。</p><h3 id="3-2-5-复杂度"><a href="#3-2-5-复杂度" class="headerlink" title="3.2.5. 复杂度"></a>3.2.5. 复杂度</h3><p>以上各情况的处理流程，可归纳为下图：</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212700.png" style="zoom:80%;"></p><p>其中涉及的重构、染色等局部操作，均可在常数时间内完成，故为了估计整个双黑修正过程的时间复杂度，也只需统计这些操作各自的累计执行次数，具体归纳为下表：</p><p><img src="/2020/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8817%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91/QQ图片20200323212724.png" style="zoom:80%;"></p><p>可见，前两种情况各自只需做一轮修正，最后一种情况亦不过两轮。情况BB-2-B虽可能需要反复修正，但由于待修正位置的高度严格单调上升，累计也不致过$O(\log n)$轮，故双黑修正过程总共耗时不超过$O(\log n)$。即便计入此前的关键码查找和节点删除操作，<strong>红黑树的节点删除操作总是可在$O(\log n)$时间内完成</strong>。</p><p>从上面的分析可知，一旦在某步迭代中做过节点的旋转调整，整个修复过程便会随机完成。因此与双红修正一样，双黑修正的整个过程，也仅涉及常数次的拓扑结构调整操作。</p><p>这一特性也意味着，<strong>在每次删除操作之后，拓扑联接关系有所变化的节点绝不会超过常数个</strong>——这一点<strong>与AVL树</strong>的删除操作完成不同，也是<strong>二者之间最本质的一项差异</strong>。</p><h3 id="3-2-6-实现"><a href="#3-2-6-实现" class="headerlink" title="3.2.6. 实现"></a>3.2.6. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * RedBlack双黑调整算法：解决节点x与被其替代的节点均为黑色的问题</span></span><br><span class="line"><span class="comment"> * 分为三大类共四种情况：</span></span><br><span class="line"><span class="comment"> *    BB-1 ：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    BB-2R：2次颜色翻转，2次黑高度更新，0次旋转，不再递归</span></span><br><span class="line"><span class="comment"> *    BB-2B：1次颜色翻转，1次黑高度更新，0次旋转，需要递归</span></span><br><span class="line"><span class="comment"> *    BB-3 ：2次颜色翻转，2次黑高度更新，1次旋转，转为BB-1或BB2R</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleBlack ( BinNodePosi(T) r ) &#123;</span><br><span class="line">   BinNodePosi(T) p = r ? r-&gt;parent : _hot; <span class="keyword">if</span> ( !p ) <span class="keyword">return</span>; <span class="comment">//r的父亲</span></span><br><span class="line">   BinNodePosi(T) s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="comment">//r的兄弟</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( s ) ) &#123; <span class="comment">//兄弟s为黑</span></span><br><span class="line">      BinNodePosi(T) t = <span class="literal">NULL</span>; <span class="comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;rc ) ) t = s-&gt;rc; <span class="comment">//右子</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;lc ) ) t = s-&gt;lc; <span class="comment">//左子</span></span><br><span class="line">      <span class="keyword">if</span> ( t ) &#123; <span class="comment">//黑s有红孩子：BB-1</span></span><br><span class="line">         <span class="comment">//*DSA*/printf("  case BB-1: Child ("); print(s-&gt;lc); printf(") of BLACK sibling ("); print(s); printf(") is RED\n");</span></span><br><span class="line">         RBColor oldColor = p-&gt;color; <span class="comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span></span><br><span class="line">      <span class="comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line">         BinNodePosi(T) b = FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//旋转</span></span><br><span class="line">         <span class="keyword">if</span> ( HasLChild ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; updateHeight ( b-&gt;lc ); &#125; <span class="comment">//左子</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; updateHeight ( b-&gt;rc ); &#125; <span class="comment">//右子</span></span><br><span class="line">         b-&gt;color = oldColor; updateHeight ( b ); <span class="comment">//新子树根节点继承原根节点的颜色</span></span><br><span class="line">         <span class="comment">//*DSA*/printBinTree(b, 0, 0);</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑s无红孩子</span></span><br><span class="line">         s-&gt;color = RB_RED; s-&gt;<span class="built_in">height</span>--; <span class="comment">//s转红</span></span><br><span class="line">         <span class="keyword">if</span> ( IsRed ( p ) ) &#123; <span class="comment">//BB-2R</span></span><br><span class="line">            <span class="comment">//*DSA*/printf("  case BB-2R: Both children ("); print(s-&gt;lc); printf(") and ("); print(s-&gt;rc); printf(") of BLACK sibling ("); print(s); printf(") are BLACK, and parent ("); print(p); printf(") is RED\n"); //s孩子均黑，p红</span></span><br><span class="line">            p-&gt;color = RB_BLACK; <span class="comment">//p转黑，但黑高度不变</span></span><br><span class="line">            <span class="comment">//*DSA*/printBinTree(p, 0, 0);</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//BB-2B</span></span><br><span class="line">            <span class="comment">//*DSA*/printf("  case BB-2R: Both children ("); print(s-&gt;lc); printf(") and ("); print(s-&gt;rc); printf(") of BLACK sibling ("); print(s); printf(") are BLACK, and parent ("); print(p); printf(") is BLACK\n"); //s孩子均黑，p黑</span></span><br><span class="line">            p-&gt;<span class="built_in">height</span>--; <span class="comment">//p保持黑，但黑高度下降</span></span><br><span class="line">            <span class="comment">//*DSA*/printBinTree(p, 0, 0);</span></span><br><span class="line">            solveDoubleBlack ( p ); <span class="comment">//递归上溯</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//兄弟s为红：BB-3</span></span><br><span class="line">      <span class="comment">//*DSA*/printf("  case BB-3: sibling ("); print(s); printf(" is RED\n"); //s红（双子俱黑）</span></span><br><span class="line">      s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="comment">//s转黑，p转红</span></span><br><span class="line">      BinNodePosi(T) t = IsLChild ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="comment">//取t与其父s同侧</span></span><br><span class="line">      _hot = p; FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//对t及其父亲、祖父做平衡调整</span></span><br><span class="line">      <span class="comment">//*DSA*/printBinTree&lt;T&gt;(s, 0, 0);</span></span><br><span class="line">      solveDoubleBlack ( r ); <span class="comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      红黑树是针对AVL树的不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可保证：在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（16）B-树</title>
    <link href="http://nekomoon404.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/</id>
    <published>2020-03-13T02:04:15.000Z</published>
    <updated>2020-03-13T07:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-构思"><a href="#1-构思" class="headerlink" title="1.构思"></a>1.构思</h1><h2 id="1-1-分级存储"><a href="#1-1-分级存储" class="headerlink" title="1.1.分级存储"></a>1.1.分级存储</h2><p>从实际应用的需求来看，问题规模的膨胀远远快于存储能力的增长。在同等成本下，存储器的容量越大则访问速度越慢，因此一味地提高存储器容量，亦非解决这一矛盾的良策。实践证明，分级存储才是行之有效的方法。在由内存与外存（磁盘）组成的二阶存储系统中，数据全集往往存放于外存中，计算过程中则可将内存作为外存的高速缓存，存放最常用数据项的复本。借助高效的调度算法，如此便可将内存的“高速度”与外存的“大容量”结合起来。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313164607.png" style="zoom: 40%;"></p><p>两个相邻存储级别之间的数据传输，统称<strong>I/O操作</strong>。各级存储器的访问速度相差悬殊，故应尽可能地减少I/O操作。仍以内存与磁盘为例，其单次访问延迟大致分别在纳秒（ns）和毫秒（ms）级别，相差5至6个数量级。因此在衡量相关算法的性能时，基本可以忽略对内存的访问，转而更多地关注对外存的访问次数。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313164908.png" style="zoom: 40%;"></p><h2 id="1-2-多路搜索树"><a href="#1-2-多路搜索树" class="headerlink" title="1.2.多路搜索树"></a>1.2.多路搜索树</h2><p>当数据规模大道内存已不足以容纳时，常规平衡二叉搜索树的效率将大打折扣，其原因在于，查找过程对外存的访问次数过多。为此，需要充分利用磁盘之类外部存储器的另一特性：就时间成本而言，读取物理地址连续的一千个字节，与读取单个字节几乎没有区别。因此不妨通过时间成本相对较低的多次内存操作，来代替时间成本相对极高的单次外存操作。相应地需要将通常的二叉搜索树，改造为多路搜索树——在中序遍历的意义下，这也是一种等价变换。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313165002.png" style="zoom:40%;"></p><p>如上图，以两层为间隔，将各节点与其左右孩子合并为“大节点”，每个大节点有四个分支，故称作四路搜索树。一般地，以k层为间隔如此重组，可将二叉搜索树转化为等价的2^k路搜索树，统称为<strong>多路搜索树（multi - way search tree）</strong>。</p><p>多路搜索树在逻辑上与BBST等价，同样支持查找等操作，且效果与原二叉搜索树完全等同；然而重要的是，其对外存的访问方式已发生本质变化。实际上，在此时的搜索等下降一层，<strong>都以“大节点”为单位从外存读取一组</strong>（而不再是单个）<strong>关键码</strong>，这组关键码在逻辑上与物理上都彼此相邻，故可以批量方式从外存一次性读出，且所需时间与读取单个关键码几乎一样。而每组关键码的最佳数目，取决于不同外存的批量访问特性。</p><h2 id="1-3-多路平衡搜索树"><a href="#1-3-多路平衡搜索树" class="headerlink" title="1.3.多路平衡搜索树"></a>1.3.多路平衡搜索树</h2><p>所谓m阶B-树（B-tree），即m路平衡搜索树（m$\ge$2）。其中<strong>所有外部节点均深度相等</strong>。同时，<strong>每个内部节点都存有不超过m-1个关键码，以及用以指示对应分支的不超过m个引用</strong>。</p><p>具体地，存有$n\le m-1$个关键码：$K_1&lt;K_2&lt;K_3&lt;K_4&lt;\dots&lt;K_n$的内部节点，同时还配有$n+1&lt;m$个引用：$A_0&lt;A_1&lt;A_2&lt;A_3&lt;A_4&lt;\dots&lt;A_n$。</p><p>反过来，各内部节点的分支数也不能太少，除根以外的所有内部节点，都应满足：$n+1\ge \lceil m/2 \rceil$，而在非空的B-树中，根节点应满足：$n+1\ge2$。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313171704.png" style="zoom:50%;"></p><p>由于个节点的分支数介于$\lceil m/2 \rceil$至$m$之间，故<strong>m阶B-树也称作$(\lceil m/2 \rceil),m)$-树</strong>，如(2,3)-树、(3,6)-树或(7,13)-树等。</p><p>B-树的外部节点（external node）实际上未必意味着查找失败，而可能表示目标关键码存在与更低层的某一次外部存储系统中，顺着该节点的指示，即可深入至下一级存储系统并继续查找。正因如此，在计算B-树高度时，还需要计入其最底层的外部节点。</p><p>作为与二叉搜索树等价的“扁平化”版本，B-树的宽度（亦即最底层外部节点的数目）往往远大于其高度。既然外部节点均同处于最底层，且深度完全一致，故用图表示时在将它们省略，可由下图(a)进一步精简为下图(c)的紧凑形式：</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313172734.png" style="zoom: 45%;"></p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><h2 id="2-1-ADT接口"><a href="#2-1-ADT接口" class="headerlink" title="2.1.ADT接口"></a>2.1.ADT接口</h2><p>按照以上定义，可以模板类的形式描述并实现B-树节点以及B-树结构。B-树节点BTNode类，可实现如以下的代码，这里，同一个节点的所有孩子组织为一个向量，各相邻孩子之间的关键码也组织为一个向量。当然按照B-树的定义，孩子向量的实际长度总是比关键码向量多一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector/vector.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTNodePosi(T) BTNode<span class="meta-string">&lt;T&gt;* //B-树节点位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span> <span class="comment">//B-树节点模板类</span></span><br><span class="line"><span class="comment">// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）</span></span><br><span class="line">   BTNodePosi(T) parent; <span class="comment">//父节点</span></span><br><span class="line">   Vector&lt;T&gt; key; <span class="comment">//关键码向量</span></span><br><span class="line">   Vector&lt;BTNodePosi(T)&gt; child; <span class="comment">//孩子向量（其长度总比key多一）</span></span><br><span class="line"><span class="comment">// 构造函数（注意：BTNode只能作为根节点创建，而且初始时有0个关键码和1个空孩子指针）</span></span><br><span class="line">   BTNode() &#123; parent = <span class="literal">NULL</span>; child.insert ( <span class="number">0</span>, <span class="literal">NULL</span> ); &#125;</span><br><span class="line">   BTNode ( T e, BTNodePosi(T) lc = <span class="literal">NULL</span>, BTNodePosi(T) rc = <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      parent = <span class="literal">NULL</span>; <span class="comment">//作为根节点，而且初始时</span></span><br><span class="line">      key.insert ( <span class="number">0</span>, e ); <span class="comment">//只有一个关键码，以及</span></span><br><span class="line">      child.insert ( <span class="number">0</span>, lc ); child.insert ( <span class="number">1</span>, rc ); <span class="comment">//两个孩子</span></span><br><span class="line">      <span class="keyword">if</span> ( lc ) lc-&gt;parent = <span class="keyword">this</span>; <span class="keyword">if</span> ( rc ) rc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>B-树模板类可实现为如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BTNode.h"</span> <span class="comment">//引入B-树节点类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span> <span class="comment">//B-树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="keyword">int</span> _size; <span class="comment">//存放的关键码总数</span></span><br><span class="line">   <span class="keyword">int</span> _order; <span class="comment">//B-树的阶次，至少为3——创建时指定，一般不能修改</span></span><br><span class="line">   BTNodePosi(T) _root; <span class="comment">//根节点</span></span><br><span class="line">   BTNodePosi(T) _hot; <span class="comment">//BTree::search()最后访问的非空（除非树空）的节点位置</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveOverflow</span> <span class="params">( BTNodePosi(T) )</span></span>; <span class="comment">//因插入而上溢之后的分裂处理</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">solveUnderflow</span> <span class="params">( BTNodePosi(T) )</span></span>; <span class="comment">//因删除而下溢之后的合并处理</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   BTree ( <span class="keyword">int</span> order = <span class="number">3</span> ) : _order ( order ), _size ( <span class="number">0</span> ) <span class="comment">//构造函数：默认为最低的3阶</span></span><br><span class="line">   &#123; _root = <span class="keyword">new</span> BTNode&lt;T&gt;(); &#125;</span><br><span class="line">   ~BTree() &#123; <span class="keyword">if</span> ( _root ) <span class="built_in">release</span> ( _root ); &#125; <span class="comment">//析构函数：释放所有节点</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">order</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _order; &#125; <span class="comment">//阶次</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="keyword">const</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">   BTNodePosi(T) &amp; root() &#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line">   BTNodePosi(T) search ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//查找</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">insert</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//插入</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除</span></span><br><span class="line">&#125;; <span class="comment">//BTree</span></span><br></pre></td></tr></table></figure><p>后面会看到，B-树的关键码插入操作和删除操作，可能会引发节点的上溢和下溢，因此这里设有内部接口<code>solveOverflow()</code>和<code>solveUnderflow()</code>，分别用于修正此类问题。</p><h2 id="2-2-关键码查找"><a href="#2-2-关键码查找" class="headerlink" title="2.2.关键码查找"></a>2.2.关键码查找</h2><p><strong>B-树结构非常适宜于在相对更小的内存中，实现对大规模数据的高效操作</strong>。可以将大数据集组织为B-树并存放与外存，对于活跃的B-树，其根节点会常驻于内存，此外任何时刻通常只有另一节点（称作当前节点）留住于内存。</p><p>B-树的查找过程，与二次搜索树的查找过程基本类似：首先以根节点作为当前节点，然后再逐层深入。若在当前节点（所包含的一组关键码）中能够找到目标关键码，则成功返回。否则必在当前节点中确定某一个引用（“失败”位置），并通过它转至逻辑上处于下一层的另一节点。若该节点不是外部节点，则将其载入内存，并更新为当前节点，然后继续重复上述过程。</p><p>整个过程如下图所示，从根节点开始，通过关键码的比较不断深入至下一层，直到某一关键码命中（查找成功），或者到达某一外部节点（查找失败）。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313175652.png" style="zoom: 40%;"></p><p>与BST的不同之处在于，因此时各节点内通常都包含多个关键码，故有可能需要经过（在内存中的）多次比较，才能确定应该转向下一层的哪个节点并继续查找。</p><p><strong>只有在切换和更新当前节点时才会发生I/O操作</strong>，而在同一节点内部的查找则完全在内存中进行。因内存的访问速度远远高于外存，再考虑到各节点所含关键码数量通常在128~512之间，故可直接使用顺序查找策略，而不必采用二分查找之类的复杂策略。</p><p>B-树的<strong>关键码查找算法实现</strong>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BTNodePosi(T) BTree&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在B-树中查找关键码e</span></span><br><span class="line">   BTNodePosi(T) v = _root; _hot = <span class="literal">NULL</span>; <span class="comment">//从根节点出发</span></span><br><span class="line">   <span class="keyword">while</span> ( v ) &#123; <span class="comment">//逐层查找</span></span><br><span class="line">      Rank r = v-&gt;key.search ( e ); <span class="comment">//在当前节点中，找到不大于e的最大关键码</span></span><br><span class="line">      <span class="keyword">if</span> ( ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( e == v-&gt;key[r] ) ) <span class="keyword">return</span> v; <span class="comment">//成功：在当前节点中命中目标关键码</span></span><br><span class="line">      _hot = v; v = v-&gt;child[r + <span class="number">1</span>]; <span class="comment">//否则，转入对应子树（_hot指向其父）——需做I/O，最费时间</span></span><br><span class="line">   &#125; <span class="comment">//这里在向量内是二分查找，但对通常的_order可直接顺序查找</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//失败：最终抵达外部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与BST的查找实现类似，这里也<strong>约定查找结果由返回的节点位置指代</strong>：成功时返回目标关键码所在的节点，上层调用过程可在该节点内进一步查找以确定准确的命中位置；失败时返回对外部节点，其父亲节点则由变量<code>_hot</code>指代。</p><h3 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h3><p>由上可见，B-树查找操作所需的时间不外乎消耗于两个方面：将某一节点载入内存，以及在内存中对当前节点进行查找。鉴于内存、外存在访问速度上的句法差异，相对于前一类时间消耗，后一类时间消耗可以忽略不计，即<strong>B-树查找操作的效率主要取决于查找过程中的外存访问次数</strong>。</p><p>与BST类似，B-树的每一次查找过程中，在每一高度上至多访问一个节点，即对于高度为h的B-树，外存访问不超过$O(h-1)$。B-树节点的分支数并不固定，故其高度h并不完全取决于树中关键码的总数n，对于包含N个关键码的m阶B-树，高度h的取值范围为：</p><script type="math/tex; mode=display">\log_m(N+1)\le h \le \log_{\lceil m/2 \rceil} \lfloor(N+1)/2 \rfloor+1</script><p>也就是说，存有N个关键码的m阶B-树的高度$h=\Theta(\log_m N)$。因此每次查找过程共需访问$\Theta(\log_m N)$个节点，相应地需要做$\Theta(\log_m N)$次外存读取操作，因此<strong>对存有N个关键码的m阶B-树的每次查找操作，耗时不超过$\Theta(\log_m N)$。</strong></p><p>尽管没有渐进意义上的改进，但相对而言极其耗时的I/O操作的次数，却已大致缩减为原来的$1/ \log_2 m$。鉴于m通常取值在256至1024之间，较之此前大致降低一个数量级，故使用B-树后，实际的访问效率将十分可观的提高。</p><h2 id="2-3-关键码插入"><a href="#2-3-关键码插入" class="headerlink" title="2.3.关键码插入"></a>2.3.关键码插入</h2><p>为在B -树中插入一个新的关键码e，首先调用search(e)在树中查找该关键码。若查找成功，则按照“禁止重复关键码”的约定不予插入，操作完成并返回false。</p><p>否则查找过程必然终止于某一外部节点v，且其父节点由变量_hot指示，此时的 _hot必然指向某一叶节点。接下来在该节点中再次查找目标关键码e，这次查找是失败的但是可以确定e在其中的正确插入位置r，最后只需将e插至这一位置。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313183821.png" style="zoom:67%;"></p><p>B-树的关键码插入算法实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入B树中</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   Rank r = _hot-&gt;key.search ( e ); <span class="comment">//在节点_hot的有序关键码向量中查找合适的插入位置</span></span><br><span class="line">   _hot-&gt;key.insert ( r + <span class="number">1</span>, e ); <span class="comment">//将新关键码插至对应的位置</span></span><br><span class="line">   _hot-&gt;child.insert ( r + <span class="number">2</span>, <span class="literal">NULL</span> ); <span class="comment">//创建一个空子树指针</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   solveOverflow ( _hot ); <span class="comment">//如有必要，需做分裂</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，_hot所指的节点中增加了一个关键码。若该节点关键码的总数依然合法（$\le m-1$），则插入操作随机完成；否则称该节点发生了一次<strong>上溢（overflow）</strong>，此时需要适当的处理，使该节点以及整数重新满足B-树的条件。</p><h3 id="上溢与分裂："><a href="#上溢与分裂：" class="headerlink" title="上溢与分裂："></a>上溢与分裂：</h3><p>一般地，刚发生上溢的节点，应恰好含有m个关键码，若取$s=\lfloor m/2 \rfloor$，则它们依次为：</p><script type="math/tex; mode=display">\{k_0,\dots,k_{s-1};\,k_s;\,k_{s+1},\dots,k_{m-1}\}</script><p>以$k_s$为界，可将该节点分为前、后两个字节点，且二者大致等长。可令关键码k上升一层，归入其父节点（若存在）中的适当位置，并分别以这两个子节点作为其左、右孩子，这一过程称作<strong>节点的分裂（split）</strong>。可以验证如此分裂所得的两个孩子节点，均符合m阶B-树关于节点分支数的条件。</p><p><strong>可能的情况</strong>：</p><p>被提升的关键码，可能有三种进一步的处置方式。</p><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313193429.png" style="zoom: 80%;"></p><p>首先如图(a1)，设原上溢节点的父亲节点存在，且足以接纳一个关键码。此种情况下，只需将被提升的关键码(37)按次序插入父节点中，修复即告完成，修复后的局部如图(a2)。</p><p>其次如图(b1)，尽管上溢节点的父节点存在，但也已处于饱和状态。此时如图(b2)，将被提升的关键码插入父节点之后，会导致父节点也发生上溢，这种现象称作<strong>上溢的向上传递</strong>。每经过一次修复，上溢节点的高度必然上升一层，最远不至超过树根。</p><p>最后如图(c1)，<strong>若上溢传递至树根节点</strong>，则可令被提升的关键码(37)自成一个节点，并作为新的树根，如图(c2)，至此上溢修复完毕，<strong>全树增高一层</strong>。这样新创建的树根仅含关键码，这也正是就B-树节点分支数的下限要求而言，树根节点作为例外的原因。</p><p>可见<strong>整个过程中所作分裂操作的次数，必不超过全树的高度</strong>，即$O(\log_m N)$。</p><p>针对<strong>上溢的处理算法</strong>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码插入后若节点上溢，则做节点分裂处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveOverflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( _order &gt;= v-&gt;child.<span class="built_in">size</span>() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未上溢</span></span><br><span class="line">   Rank s = _order / <span class="number">2</span>; <span class="comment">//轴点（此时应有_order = key.size() = child.size() - 1）</span></span><br><span class="line">   BTNodePosi(T) u = <span class="keyword">new</span> BTNode&lt;T&gt;(); <span class="comment">//注意：新节点已有一个空孩子</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s - <span class="number">1</span>; j++ ) &#123; <span class="comment">//v右侧_order-s-1个孩子及关键码分裂为右侧节点u</span></span><br><span class="line">      u-&gt;child.insert ( j, v-&gt;child.<span class="built_in">remove</span> ( s + <span class="number">1</span> ) ); <span class="comment">//逐个移动效率低</span></span><br><span class="line">      u-&gt;key.insert ( j, v-&gt;key.<span class="built_in">remove</span> ( s + <span class="number">1</span> ) ); <span class="comment">//此策略可改进</span></span><br><span class="line">   &#125;</span><br><span class="line">   u-&gt;child[_order - s - <span class="number">1</span>] = v-&gt;child.<span class="built_in">remove</span> ( s + <span class="number">1</span> ); <span class="comment">//移动v最靠右的孩子</span></span><br><span class="line">   <span class="keyword">if</span> ( u-&gt;child[<span class="number">0</span>] ) <span class="comment">//若u的孩子们非空，则</span></span><br><span class="line">      <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s; j++ ) <span class="comment">//令它们的父节点统一</span></span><br><span class="line">         u-&gt;child[j]-&gt;parent = u; <span class="comment">//指向u</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent; <span class="comment">//v当前的父节点p</span></span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; _root = p = <span class="keyword">new</span> BTNode&lt;T&gt;(); p-&gt;child[<span class="number">0</span>] = v; v-&gt;parent = p; &#125; <span class="comment">//若p空则创建之</span></span><br><span class="line">   Rank r = <span class="number">1</span> + p-&gt;key.search ( v-&gt;key[<span class="number">0</span>] ); <span class="comment">//p中指向u的指针的秩</span></span><br><span class="line">   p-&gt;key.insert ( r, v-&gt;key.<span class="built_in">remove</span> ( s ) ); <span class="comment">//轴点关键码上升</span></span><br><span class="line">   p-&gt;child.insert ( r + <span class="number">1</span>, u );  u-&gt;parent = p; <span class="comment">//新节点u与父节点p互联</span></span><br><span class="line">   solveOverflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><p>若将B-树的阶次m视作常数，则关键码的移动和复制操作所需的时间都可以忽略。而solveOverflow()算法其中的每一递归实例均只需常数时间，递归层数不超过B-树高度。由此可知，对于存有N个关键码的m阶B-树，每次插入操作都可在$O(\log_m N)$时间内完成。</p><p>实际上，因插入操作而导致$\Omega(\log_m N)$次分裂的情况极为罕见，单次插入操作平均引发的分裂次数，远远低于这一估计，故时间通常主要消耗于对目标关键码的查找。</p><h2 id="2-4-关键码删除"><a href="#2-4-关键码删除" class="headerlink" title="2.4.关键码删除"></a>2.4.关键码删除</h2><p>为从B-树中删除关键码e，也首先需要调用<code>search(e)</code>查找<code>e</code>所属的节点。若查找失败，则说明关键码e尚不存在，删除操作即告完成；否则按照代码的出口约定，目标关键码所在的节点必由返回的位置v指示。此时，通过顺序查找，即可进一步确定<code>e</code>在节点 <code>v</code>中的秩r。</p><p>不妨假定v是叶节点，否则，e的直接后继（前驱）在其右（左）子树中必然存在，而且可在$O(height(v))$时间内确定它们的位置，其中$height(v)$为节点<code>v</code>的高度。此处不妨选用直接后继，于是<code>e</code>的直接后继关键码所属的节点<code>u</code>必为叶节点，且该关键码就是其中的最小者u[0]，然后令<code>e</code>与u[0]互换位置，即可确保删除的关键码<code>e</code>所属的节点是叶节点。</p><p>接下来可直接将<code>e</code>从<code>v</code>中删除，节点<code>v</code>中所含的关键码以及（空）分支将分别减少一半。此时，若该节点所含关键码的总数依然合法（$\ge \lceil m/2 \rceil-1$），则删除操作随机完成。否则，称该节点发生了<strong>下溢（underflow）</strong>，并需要通过适当的处置，使该节点以及整数重新满足B-树的条件。</p><p>B-树的关键码删除算法的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BTree树中删除关键码e</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标关键码存在</span></span><br><span class="line">   Rank r = v-&gt;key.search ( e ); <span class="comment">//确定目标关键码在节点v中的秩（由上，肯定合法）</span></span><br><span class="line">   <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) &#123; <span class="comment">//若v非叶子，则e的后继必属于某叶节点</span></span><br><span class="line">      BTNodePosi(T) u = v-&gt;child[r+<span class="number">1</span>]; <span class="comment">//在右子树中一直向左，即可</span></span><br><span class="line">      <span class="keyword">while</span> ( u-&gt;child[<span class="number">0</span>] ) u = u-&gt;child[<span class="number">0</span>]; <span class="comment">//找出e的后继</span></span><br><span class="line">      v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>; <span class="comment">//并与之交换位置</span></span><br><span class="line">   &#125; <span class="comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span></span><br><span class="line">   v-&gt;key.<span class="built_in">remove</span> ( r ); v-&gt;child.<span class="built_in">remove</span> ( r + <span class="number">1</span> ); _size--; <span class="comment">//删除e，以及其下两个外部节点之一</span></span><br><span class="line">   solveUnderflow ( v ); <span class="comment">//如有必要，需做旋转或合并</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下溢与合并："><a href="#下溢与合并：" class="headerlink" title="下溢与合并："></a>下溢与合并：</h3><p>由上，在m阶B-树中，刚发生下溢的节点V必恰好包含$\lceil m/2 \rceil-2$个关键码和$\lceil m/2 \rceil-1$个分支。一下将根据其左、右兄弟所含关键码的数目，分三种情况做相应的处置。</p><ul><li><strong>v的左兄弟L存在，且至少包含$\lceil m/2 \rceil$个关键码：</strong></li></ul><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313233500.png" style="zoom:67%;"></p><p>如图，不妨设L和V分别是其父节点P中关键码v的左、右孩子，L中最大关键码为x(x $\le$ y)。再将y从节点P转移至节点V中（作为最小关键码），再将x从L转移至P中（取代原关键码y）。至此，局部乃至整数都重新满足B-树条件，下溢修复完毕。</p><ul><li><strong>v的左兄弟R存在，且至少包含$\lceil m/2 \rceil$个关键码：</strong></li></ul><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313233559.png" style="zoom:67%;"></p><p>与第一种情况对称。</p><ul><li><strong>V的左、右兄弟L和R或者不存在，或者其包含的关键码均不足$\lceil m/2 \rceil$个：</strong></li></ul><p><img src="/2020/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8816%EF%BC%89B-%E6%A0%91/QQ图片20200313235326.png" style="zoom:67%;"></p><p>实际上，此时的L和R不可能同时存在。如图，不失一般性地设做兄弟节点L存在。当然，此时节点L恰好包含$\lceil m/2 \rceil-1$个关键码。</p><p>于是为修复节点V的下溢缺陷，如图(b)从父亲节点P中抽出介于L和V之间的关键码y，并通过该关键码将节点L和V“粘接”成一个节点——这一过程称作<strong>节点的合并（merge）</strong>。要注意的是，在经如此合并而得新节点中，关键码总数应为：</p><script type="math/tex; mode=display">(\lceil m/2 -1 \rceil)+1+(\lceil m/2-2\rceil)=2\times \lceil m/2 \rceil-2\le m-1</script><p>故原节点V的下溢缺陷得以修复，而且不致于引发上溢。</p><p>接下来，还须检查父节点P——关键码y的删除可能致使该节点出现下溢，这种现象称作<strong>下溢的传递</strong>，可以通过套用上述三种方法来解决。特别地，当下溢传递至根节点且其中不再含有任何关键码时，即可将其删除并代之以其唯一的孩子节点，全树高度也随之下降一层。</p><p>整个下溢修复的过程至多需做$O(\log_m N)$次节点合并操作。</p><p>针对<strong>下溢的处理算法</strong>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码删除后若节点下溢，则做节点旋转或合并处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveUnderflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt;= v-&gt;child.<span class="built_in">size</span>() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未下溢</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent;</span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; <span class="comment">//递归基：已到根节点，没有孩子的下限</span></span><br><span class="line">      <span class="keyword">if</span> ( !v-&gt;key.<span class="built_in">size</span>() &amp;&amp; v-&gt;child[<span class="number">0</span>] ) &#123;</span><br><span class="line">         <span class="comment">//但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"collapse\n"</span> );</span><br><span class="line">         _root = v-&gt;child[<span class="number">0</span>]; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//这个节点可被跳过</span></span><br><span class="line">         v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>; <span class="built_in">release</span> ( v ); <span class="comment">//并因不再有用而被销毁</span></span><br><span class="line">      &#125; <span class="comment">//整树高度降低一层</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Rank r = <span class="number">0</span>; <span class="keyword">while</span> ( p-&gt;child[r] != v ) r++;</span><br><span class="line">   <span class="comment">//确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找</span></span><br><span class="line">   <span class="comment">//另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"\nrank = %d"</span>, r );</span><br><span class="line"><span class="comment">// 情况1：向左兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//若v不是p的第一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; ls-&gt;child.<span class="built_in">size</span>() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">" ... case 1\n"</span> );</span><br><span class="line">         v-&gt;key.insert ( <span class="number">0</span>, p-&gt;key[r - <span class="number">1</span>] ); <span class="comment">//p借出一个关键码给v（作为最小关键码）</span></span><br><span class="line">         p-&gt;key[r - <span class="number">1</span>] = ls-&gt;key.<span class="built_in">remove</span> ( ls-&gt;key.<span class="built_in">size</span>() - <span class="number">1</span> ); <span class="comment">//ls的最大关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( <span class="number">0</span>, ls-&gt;child.<span class="built_in">remove</span> ( ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="comment">//同时ls的最右侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) v-&gt;child[<span class="number">0</span>]-&gt;parent = v; <span class="comment">//作为v的最左侧孩子</span></span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过右旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，左兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况2：向右兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( p-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> &gt; r ) &#123; <span class="comment">//若v不是p的最后一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; rs-&gt;child.<span class="built_in">size</span>() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">" ... case 2\n"</span> );</span><br><span class="line">         v-&gt;key.insert ( v-&gt;key.<span class="built_in">size</span>(), p-&gt;key[r] ); <span class="comment">//p借出一个关键码给v（作为最大关键码）</span></span><br><span class="line">         p-&gt;key[r] = rs-&gt;key.<span class="built_in">remove</span> ( <span class="number">0</span> ); <span class="comment">//ls的最小关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( v-&gt;child.<span class="built_in">size</span>(), rs-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="comment">//同时rs的最左侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) <span class="comment">//作为v的最右侧孩子</span></span><br><span class="line">            v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = v;</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过左旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，右兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//与左兄弟合并</span></span><br><span class="line">      <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">" ... case 3L\n"</span> );</span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      ls-&gt;key.insert ( ls-&gt;key.<span class="built_in">size</span>(), p-&gt;key.<span class="built_in">remove</span> ( r - <span class="number">1</span> ) ); p-&gt;child.<span class="built_in">remove</span> ( r );</span><br><span class="line">      <span class="comment">//p的第r - 1个关键码转入ls，v不再是p的第r个孩子</span></span><br><span class="line">      ls-&gt;child.insert ( ls-&gt;child.<span class="built_in">size</span>(), v-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">         ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入ls</span></span><br><span class="line">         ls-&gt;key.insert ( ls-&gt;key.<span class="built_in">size</span>(), v-&gt;key.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line">         ls-&gt;child.insert ( ls-&gt;child.<span class="built_in">size</span>(), v-&gt;child.<span class="built_in">remove</span> ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>] ) ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span> ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//与右兄弟合并</span></span><br><span class="line">      <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">" ... case 3R\n"</span> );</span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line">      rs-&gt;key.insert ( <span class="number">0</span>, p-&gt;key.<span class="built_in">remove</span> ( r ) ); p-&gt;child.<span class="built_in">remove</span> ( r );</span><br><span class="line">      <span class="comment">//p的第r个关键码转入rs，v不再是p的第r个孩子</span></span><br><span class="line">      rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span> ( v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs; <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入rs</span></span><br><span class="line">         rs-&gt;key.insert ( <span class="number">0</span>, v-&gt;key.<span class="built_in">remove</span> ( v-&gt;key.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line">         rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span> ( v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span> ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125;</span><br><span class="line">   solveUnderflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度：-1"><a href="#复杂度：-1" class="headerlink" title="复杂度："></a>复杂度：</h3><p>与插入操作同理，在存有N个关键码的m阶B-树中的每次关键码删除操作，都可以在$O(\log_m N)$时间内完成。另外同样地，因某一关键码的删除而导致$\Omega(\log_m N)$次合并操作的情况也极为罕见，单词删除操作过程中平均只需做常数次节点的合并。</p>]]></content>
    
    <summary type="html">
    
      B-树是一种多路平衡搜索树，用于多级存储系统中，可针对外部查找，大大减少I/O次数。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（15）伸展树</title>
    <link href="http://nekomoon404.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/</id>
    <published>2020-03-12T12:24:46.000Z</published>
    <updated>2020-03-12T15:49:11.293Z</updated>
    
    <content type="html"><![CDATA[<p>与前一章的AVL树一样，伸展树也是二叉搜索树的一种形式，相对于AVL，伸展树的实现更为简捷。伸展树无需时刻严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡平衡因子或高度之类的额外信息，故适用范围更广。</p><h1 id="1-构思"><a href="#1-构思" class="headerlink" title="1.构思"></a>1.构思</h1><h2 id="1-1-局部性"><a href="#1-1-局部性" class="headerlink" title="1.1.局部性"></a>1.1.局部性</h2><p>信息处理的典型模式是，将所有数据项视作一个集合，并将其组织为某种适宜的数据结构，进而借助操作接口高效访问。通常在任意数据结构的生命周期内，不仅执行不同操作的概率往往极不均衡，而且各操作之间具有极强的相关性，并在整体上多呈现出极强的规律性。其中最为典型的，就是所谓的“数据局部性”（data locality），它包括两个方面的含义：</p><ul><li>刚刚被访问过的元素，极有可能在不久之后再次被访问到；</li><li>将被访问的下一个元素，极有可能就处于不久之前被访问过的某个元素的附近。</li></ul><p>充分利用好此类特性，即可进一步地提高数据结构和算法的效率。就二叉搜索树（BST）而言，数据局部性具体表现为：</p><ul><li>刚刚被访问过的节点，极有可能在不久之后再次被访问到；</li><li>将被访问的下一节点，极有可能就处于不久之前被访问过的某个节点的附近。</li></ul><p>因此需要将刚被访问的节点，及时地“转移”至树根（附近），即可加速后续的操作，转移前后的搜索树必须相互等价，为此仍需借助等价变换的技巧。</p><h2 id="1-2-逐层伸展"><a href="#1-2-逐层伸展" class="headerlink" title="1.2.逐层伸展"></a>1.2.逐层伸展</h2><p>一种直接方式是，每访问过一个节点之后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终成为树根。即自下而上，逐层单旋：<code>zig(v-&gt;parent)</code>或<code>zag(v-&gt;parent)</code>，直至v最终被推送至根。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312211626.png" style="zoom: 67%;"></p><p>以下图为例，深度为3的节点E刚被访问（查找，插入或“删除”），都可通过3次旋转，将概述等价变换为以E为根的另一颗二叉树。随着节点E的逐层上升，两侧子树的结构也不断地调整，故这一过程也形象地称为<strong>伸展（splaying）</strong>。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312211939.png" style="zoom: 67%;"></p><p>但目前的策略仍存在致命的缺陷——对于很多访问序列，单词访问的分摊时间复杂度在极端情况下可能高达$\Omega(n)$。以下图为例，若从空树开始依次插入关键码$\{1,2,3,4,5\}$，全树的拓扑结构始终呈单链条结构，等价于一维列表。接下来若通过search()接口，再由小到大地依次访问各节点依次，则概述在各次访问之后的结构形态将如图（b~f）所示。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312214950.png" style="zoom:67%;"></p><p>可见在各次访问之后，为将对应节点伸展调整至树根，分别需做$4、4、3、2、1$次旋转。一般地，若节点数为n，则旋转操作的总次数应为：</p><script type="math/tex; mode=display">(n-1)+\{(n-1)+(n-2）+\dots+1\}=(n^2+n-2)/2=\Omega(n^2)</script><p><strong>分摊到每次访问平均需要$\Omega(n)$时间</strong>，而这一效率不仅远远低于AVL树，而且甚至与原始的二叉搜索树的最坏情况相当。图(a)与图(f)中二叉树的结构完全相同，也就是说经过以上连续的5次访问之后，<strong>全树的结构将会复原</strong>，这就意味着以上情况可以持续地再现。</p><p>这一访问序列导致$\Omega(n)$平均单次访问时间的原因，可以解释为：在这一可持续重复的过程中，二叉搜索树的高度始终不小于$\lfloor n/2 \rfloor$（向下取整）；而且至少有一半的节点在接受访问时，不仅没有靠近树根，而且反过来恰好处于最底层。从树高的角度看，问题根源也可再进一步地解释为：在持续访问的过程中，树高依算术级数逐步从$n-1$递减到$\lfloor n/2 \rfloor$，然后在逐步递增回到$n-1$。</p><h2 id="1-3-双层伸展"><a href="#1-3-双层伸展" class="headerlink" title="1.3.双层伸展"></a>1.3.双层伸展</h2><p>为克服上述伸展调整策略的缺陷，一种简便且有效的方法就是：将逐层伸展改为双层伸展。具体地，<strong>每次都从当前节点v向上追溯两层</strong>（而不是仅一层），并根据其父亲p以及祖父g的相对位置，进行相应的旋转，可分为三种具体的情况：</p><p><strong>zig - zag / zag - zig</strong>：（与AVL树的双旋等效，与逐层伸展也别无二致）</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312220038.png" style="zoom:67%;"></p><p><strong>zig - zig / zag - zag</strong>：</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312220506.png" style="zoom:67%;"></p><p><strong>注意顺序是先p后g</strong>，若颠倒次序，局部的细微差别将彻底地改变整体（p变成了g的父亲）</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312222038.png" style="zoom:67%;"></p><p><strong>zig / zag</strong>：</p><p>若v最初的深度为奇数，则经过若干次双层调整至最后一次调整时，v的父亲p即是树根r。此时必有parent(v) == root(T)，且每轮调整中这种情况至多（在最后）出现一次。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312223139.png" style="zoom:67%;"></p><p>与逐层伸展相比，双层伸展中的<strong>zig-zag</strong>和<strong>zag-zig</strong>调整与逐层伸展完全一致，而<strong>zig-zig</strong>和<strong>zag-zag</strong>调整则有所不同，事实上后者才是双层伸展策略优于逐层伸展策略的关键所在。</p><p>以下图为例做一个对比，最深节点(1)被访问之后再经过双层调整，不仅同样可将该节点伸展至树根，而且同时可使树的高度接近于减半。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312224920.png" style="zoom: 50%;"></p><p>即树的形态而言，双层伸展策略可“智能”地折叠被访问的子树分支，从而有效地避免对长分支的连续访问，这就意味着即使节点v的深度为$\Omega(n)$，双层伸展策略即可将v推至树根，亦可令对应分支的长度以几何级数（大致折半）的速度收缩。</p><p>通过双层伸展的策略，伸展树虽不能杜绝最坏情况的发生，却<strong>能有效地控制最坏情况发生的频度</strong>，从而在分摊意义上保证整体的高效率。Tarjan等人证明了<strong>伸展树的单次操作均可在分摊的$O(\log n)$时间内完成</strong>。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><h2 id="2-1-接口定义"><a href="#2-1-接口定义" class="headerlink" title="2.1.接口定义"></a>2.1.接口定义</h2><p>基于<code>BST</code>类，可定义伸展树模板类<code>Splay</code>，直接沿用二叉搜索树类，并根据伸展树的平衡规则，重写了上基本操作接口<code>search()</code>，<code>insert()</code>和<code>remove()</code>，另外针对伸展树调整操作，设有一个内部保护型接口<code>splay()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BST/BST.h"</span> <span class="comment">//基于BST实现Splay</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Splay</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//由BST派生的Splay树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   BinNodePosi(T) splay ( BinNodePosi(T) v ); <span class="comment">//将节点v伸展至根</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   BinNodePosi(T) &amp; search ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//查找（重写）</span></span><br><span class="line">   BinNodePosi(T) insert ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//插入（重写）</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除（重写）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-调整算法"><a href="#2-2-调整算法" class="headerlink" title="2.2.调整算法"></a>2.2.调整算法</h2><p>双层伸展的调整方法，可实现为一下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*lc（可能为空）之间建立父（左）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsLChild</span> <span class="params">( NodePosi p, NodePosi lc )</span> </span>&#123; p-&gt;lc = lc; <span class="keyword">if</span> ( lc ) lc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*rc（可能为空）之间建立父（右）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsRChild</span> <span class="params">( NodePosi p, NodePosi rc )</span> </span>&#123; p-&gt;rc = rc; <span class="keyword">if</span> ( rc ) rc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//Splay树伸展算法：从节点v出发逐层伸展</span></span><br><span class="line">BinNodePosi(T) Splay&lt;T&gt;::splay ( BinNodePosi(T) v ) &#123; <span class="comment">//v为因最近访问而需伸展的节点位置</span></span><br><span class="line">   <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">NULL</span>; BinNodePosi(T) p; BinNodePosi(T) g; <span class="comment">//*v的父亲与祖父</span></span><br><span class="line">   <span class="keyword">while</span> ( ( p = v-&gt;parent ) &amp;&amp; ( g = p-&gt;parent ) ) &#123; <span class="comment">//自下而上，反复对*v做双层伸展</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//每轮之后*v都以原曾祖父（great-grand parent）为父</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) )</span><br><span class="line">         <span class="keyword">if</span> ( IsLChild ( *p ) ) &#123; <span class="comment">//zig-zig</span></span><br><span class="line">            <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"\tzIg-zIg :"</span> ); <span class="built_in">print</span> ( g ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">            attachAsLChild ( g, p-&gt;rc ); attachAsLChild ( p, v-&gt;rc );</span><br><span class="line">            attachAsRChild ( p, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//zig-zag</span></span><br><span class="line">            <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"\tzIg-zAg :"</span> ); <span class="built_in">print</span> ( g ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">            attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( g, v-&gt;lc );</span><br><span class="line">            attachAsLChild ( v, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( IsRChild ( *p ) ) &#123; <span class="comment">//zag-zag</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"\tzAg-zAg :"</span> ); <span class="built_in">print</span> ( g ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">         attachAsRChild ( g, p-&gt;lc ); attachAsRChild ( p, v-&gt;lc );</span><br><span class="line">         attachAsLChild ( p, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//zag-zig</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">"\tzAg-zIg :"</span> ); <span class="built_in">print</span> ( g ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> );</span><br><span class="line">         attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( g, v-&gt;rc );</span><br><span class="line">         attachAsRChild ( v, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !gg ) v-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//若*v原先的曾祖父*gg不存在，则*v现在应为树根</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，*gg此后应该以*v作为左或右孩子</span></span><br><span class="line">         ( g == gg-&gt;lc ) ? attachAsLChild ( gg, v ) : attachAsRChild ( gg, v );</span><br><span class="line">      updateHeight ( g ); updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125; <span class="comment">//双层伸展结束时，必有g == NULL，但p可能非空</span></span><br><span class="line">   <span class="keyword">if</span> ( p = v-&gt;parent ) &#123; <span class="comment">//若p果真非空，则额外再做一次单旋</span></span><br><span class="line">      <span class="comment">/*DSA*/</span><span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; <span class="built_in">printf</span> ( <span class="string">"\tzIg :"</span> ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> ); &#125;</span><br><span class="line">      <span class="comment">/*DSA*/</span><span class="keyword">else</span>              &#123; <span class="built_in">printf</span> ( <span class="string">"\tzAg :"</span> ); <span class="built_in">print</span> ( p ); <span class="built_in">print</span> ( v ); <span class="built_in">printf</span> ( <span class="string">"\n"</span> ); &#125;</span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( v, p ); &#125;</span><br><span class="line">      <span class="keyword">else</span>                   &#123; attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( v, p ); &#125;</span><br><span class="line">      updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125;</span><br><span class="line">   v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;</span><br><span class="line">&#125; <span class="comment">//调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根</span></span><br></pre></td></tr></table></figure><h2 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3.查找"></a>2.3.查找</h2><p>在伸展树中查找任一关键e，首先调用二叉搜索树BST的通用算法<code>searchIn()</code>，尝试查找具有关键码e的节点，无论查找是否成功，都继而调用<code>splay()</code>算法，将查找终止位置处的节点伸展到树根。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; Splay&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在伸展树中查找e</span></span><br><span class="line">   BinNodePosi(T) p = searchIn ( _root, e, _hot = <span class="literal">NULL</span> );</span><br><span class="line">   _root = splay ( p ? p : _hot ); <span class="comment">//将最后一个被访问的节点伸展至根</span></span><br><span class="line">   <span class="keyword">return</span> _root;</span><br><span class="line">&#125; <span class="comment">//与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点</span></span><br></pre></td></tr></table></figure><h2 id="2-4-插入"><a href="#2-4-插入" class="headerlink" title="2.4.插入"></a>2.4.插入</h2><p>为将关键码e插至伸展树T中，首先调用伸展树查找接口<code>Splay::search(e)</code>查找该关键码。于是最后被访问的节点t，将通过伸展树被提升为树根，其左右子树分别被记为$T_L$和$T_R$。接下来，根据e与t的大小关系，以t为界将T分裂为两棵子树。如设e大于t，可切断t与其右孩子之间的联系，再将以e为关键码的新节点v作为树根，并以t作为其左孩子，以$T_R$作为其右子树。v小于t的情况与此完全对称。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312232903.png" style="zoom: 50%;"></p><p>伸展树的插入算法的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) Splay&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入伸展树中</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root ) &#123; _size++; <span class="keyword">return</span> _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); &#125; <span class="comment">//处理原树为空的退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( e == search ( e )-&gt;data ) <span class="keyword">return</span> _root; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   _size++; BinNodePosi(T) t = _root; <span class="comment">//创建新节点。以下调整&lt;=7个指针以完成局部重构</span></span><br><span class="line">   <span class="keyword">if</span> ( _root-&gt;data &lt; e ) &#123; <span class="comment">//插入新根，以t和t-&gt;rc为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t, t-&gt;rc ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *t ) ) &#123; t-&gt;rc-&gt;parent = _root; t-&gt;rc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//插入新根，以t-&gt;lc和t为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t-&gt;lc, t ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *t ) ) &#123; t-&gt;lc-&gt;parent = _root; t-&gt;lc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125;</span><br><span class="line">   updateHeightAbove ( t ); <span class="comment">//更新t及其祖先（实际上只有_root一个）的高度</span></span><br><span class="line">   <span class="keyword">return</span> _root; <span class="comment">//新节点必然置于树根，返回之</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有_root-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>尽管伸展树并不需要记录和维护节点的高度，为与其他平衡二叉搜索树的实现保持统一，这里对节点的高度做了及时的更新，在实际应用中可视情况省略这类更新。</p><h2 id="2-5-删除"><a href="#2-5-删除" class="headerlink" title="2.5.删除"></a>2.5.删除</h2><p>为从伸展树T中删除关键码为e的节点，首先亦调用接口Splay::search(e)查找该关键码，且不妨设命中节点为v。于是v将随机通过伸展被提升为树根，其左右子树分别记作$T_L$和$T_R$。接下来将v摘除，然后在$T_R$中再次查找关键码e，尽管这一查找注定失败，却可以将$T_R$中的最小节点m伸展提升为树根。</p><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312234023.png" style="zoom:50%;"></p><p>得益于二叉搜索树的顺序性，此时节点m的左子树必然为空；同时$T_L$中所有节点都小于m，于是只需将$T_L$作为左子树与m相互连接，即可得到一棵完整的二叉搜索树。这样不仅删除了v，而且既然新树根m在原树中是v的直接后继，故数据局部性也得到了利用。当然其中第二次查找也可在$T_L$（若非空）中进行。</p><p>伸展的删除算法的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Splay&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从伸展树中删除关键码e</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root || ( e != search ( e )-&gt;data ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若树空或目标不存在，则无法删除</span></span><br><span class="line">   BinNodePosi(T) w = _root; <span class="comment">//assert: 经search()后节点e已被伸展至树根</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *_root ) ) &#123; <span class="comment">//若无左子树，则直接删除</span></span><br><span class="line">      _root = _root-&gt;rc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *_root ) ) &#123; <span class="comment">//若无右子树，也直接删除</span></span><br><span class="line">      _root = _root-&gt;lc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若左右子树同时存在，则</span></span><br><span class="line">      BinNodePosi(T) lTree = _root-&gt;lc;</span><br><span class="line">      lTree-&gt;parent = <span class="literal">NULL</span>; _root-&gt;lc = <span class="literal">NULL</span>; <span class="comment">//暂时将左子树切除</span></span><br><span class="line">      _root = _root-&gt;rc; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//只保留右子树</span></span><br><span class="line">      search ( w-&gt;data ); <span class="comment">//以原树根为目标，做一次（必定失败的）查找</span></span><br><span class="line"><span class="comment">///// assert: 至此，右子树中最小节点必伸展至根，且（因无雷同节点）其左子树必空，于是</span></span><br><span class="line">      _root-&gt;lc = lTree; lTree-&gt;parent = _root; <span class="comment">//只需将原左子树接回原位即可</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">release</span> ( w-&gt;data ); <span class="built_in">release</span> ( w ); _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line">   <span class="keyword">if</span> ( _root ) updateHeight ( _root ); <span class="comment">//此后，若树非空，则树根的高度需要更新</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回成功标志</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><h2 id="2-6-优缺点"><a href="#2-6-优缺点" class="headerlink" title="2.6.优缺点"></a>2.6.优缺点</h2><p><strong>优点</strong>：</p><ul><li><p>无需记录节点高度或平衡因子；编程实现简单易行 //优于AVL树</p><p>分摊复杂度$O(\log n)$——与AVL树相当</p></li><li><p>局部性强、缓存命中率极高时（即k &lt;&lt; n &lt;&lt; m）</p><p>效率甚至可以更高——自适应的$O(\  log k)$，任何连续的m次查找，都可在$O(m\log k + n \log n)$时间内完成。</p></li></ul><p><img src="/2020/03/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8815%EF%BC%89%E4%BC%B8%E5%B1%95%E6%A0%91/QQ图片20200312234848.png" style="zoom: 33%;"></p><p><strong>缺点</strong>：</p><ul><li>仍不能保证单词最坏情况的出现   //不适用于对效率敏感的场合</li><li>复杂度的分析稍显复杂</li></ul>]]></content>
    
    <summary type="html">
    
      与前一章的AVL树一样，伸展树也是二叉搜索树的一种形式，相对于AVL，伸展树的实现更为简捷。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（14）AVL树</title>
    <link href="http://nekomoon404.github.io/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/</id>
    <published>2020-03-05T01:29:44.000Z</published>
    <updated>2020-03-05T08:40:33.761Z</updated>
    
    <content type="html"><![CDATA[<p>AVL树是由G. M. Adelson-Velsky和E. M. Landis与1962年发明的一种平衡二叉搜索树，并以他们名字的首字母命名。通过合理设定适度平衡的标准，并借助以上等价变换，AVL树可以实现近乎理想的平衡。在渐进意义下，AVL树始终将高度控制在$O(\log n)$以内，从而保证每次查找，插入或删除操作，均可在$O(\log n)$的时间内完成。</p><h1 id="1-定义及性质"><a href="#1-定义及性质" class="headerlink" title="1.定义及性质"></a>1.定义及性质</h1><p>任一节点v的平衡因子（balance factor）定义为“其左、右子树的高度差”，即：</p><p>balFac(v) = height( lc(v) ) - height( rc(v) )</p><p>在AVL树中，任意节点的平衡因子的绝对值不超过1，即|balFac(v)| $\le$ 1，注意空树高度取-1，单节点子树（叶节点）高度取0。AVL树未必理想平衡，但必然<strong>适度平衡</strong>。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305094921.png" style="zoom: 67%;"></p><p>适度平衡要求当节点数固定为n时，树的高度渐进地不超过$O(\log n)$。欲证明AVL树满足适度平衡条件，可转化为证明当树的高度固定时，树中的节点数不会太少。考虑高度为h的所有AVL树，并取S为其中节点数最少的一棵，如下图，$S_L$和$S_R$分别为$S$的左右子树，$S_L$和$S_R$也都是AVL树，而且高度不超过h-1，又因为$S$的节点数最少，所以$S_L$和$S_R$中一个高度为h-1，一个高度为h-2。从而可以得到以下递推关系，并加以整理得到fibonacci数列的形式：</p><script type="math/tex; mode=display">\begin{align*}S(h)&=1+S(h-1)+S(h-2)\\S(h)+1&=[S(h-1)+1]+[S(h-2)+1]\\fib(h+3)&=fib(h+2)+fib(h+1)\end{align*}</script><p>从高度为0，1，2的树的节点数可以推出节点数$S(h)$和fibonacci数的关系，即$S(h)=fib(h+3)$。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305100624.png" style="zoom:80%;"></p><p>可得对于高度为h的AVL数，节点数n满足$n\ge \Omega(\Phi ^h)$，因此对于节点数固定为n的AVL数，其高度h满足$h\le O(\log n)$。</p><p>基于BST模板类，可直接派生出AVL模板类，并根据AVL树的重平衡规则与算法，重写了insert()和remove()接口。另外，为简化对节点平衡性的判断，算法实现时可借用宏定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Balanced(x) ( stature( (x).lc ) == stature( (x).rc ) ) <span class="comment">//理想平衡条件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BalFac(x) ( stature( (x).lc ) - stature( (x).rc ) ) <span class="comment">//平衡因子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AvlBalanced(x) ( ( -2 &lt; BalFac(x) ) &amp;&amp; ( BalFac(x) &lt; 2 ) ) <span class="comment">//AVL平衡条件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">AVL</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123; <span class="comment">//由BST派生AVL树模板类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   BinNodePosi(T) insert ( <span class="keyword">const</span> T&amp; e ); <span class="comment">//插入（重写）</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除（重写）</span></span><br><span class="line"><span class="comment">// BST::search()等其余接口可直接沿用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照BST规则插入或删除节点之后，AVL中节点的高度可能会发生变化，平衡性可能会破坏，以致于不再满足AVL树的条件。如此因节点x的插入或删除而暂时失衡的节点，构成失衡的节点集，记作UT(x)。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305104007.png" style="zoom:67%;"></p><p>为了恢复AVL的平衡性需要借助等价变换，它有以下优势：</p><ul><li>局部性：所有的旋转都在局部进行         //每行只需$O(1)$时间</li><li>快速性：在每一深度只需检查并旋转至多一次          //共$O(\log n)$次</li></ul><h1 id="2-节点插入"><a href="#2-节点插入" class="headerlink" title="2.节点插入"></a>2.节点插入</h1><p>新引入节点x后，<strong>UT(x)中的节点都是x的祖先，且高度不低于x的祖父</strong>。将其中的最深者记为g(x)，在 x与g(x)的通路上，设p为g(x)的孩子，v为p的孩子，既然g(x)不低于x的祖父，则p必是x的真祖先。</p><p>首先需要找到如上定义的g(x)，可以从x出发沿parent指针逐层上行并核对平衡因此，首次遇到的失衡祖先即为g(x)，既然原树是平衡的，故这一过程需要$O(\log n)$。既然g(x)是因x的引入而失衡，则p和v的高度均不低于其各自的兄弟，因此借助宏定义的<code>tallerChild()</code>，即可反过来由g(x)找到p和v。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tallerChild(x) ( \</span></span><br><span class="line">   stature( (x)-&gt;lc ) &gt; stature( (x)-&gt;rc ) ? (x)-&gt;lc : ( <span class="comment">/*左高*/</span> \</span><br><span class="line">   stature( (x)-&gt;lc ) &lt; stature( (x)-&gt;rc ) ? (x)-&gt;rc : ( <span class="comment">/*右高*/</span> \</span><br><span class="line">   IsLChild( * (x) ) ? (x)-&gt;lc : (x)-&gt;rc <span class="comment">/*等高：与父亲x同侧者（zIg-zIg或zAg-zAg）优先*/</span> \</span><br><span class="line">   ) \</span><br><span class="line">   ) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以下根据节点g(x)、p和v之间具体的联接方向，采用不同的局部调整方案。</p><p><strong>单旋</strong>：</p><p>当g、p和v在同一侧时，如下图都在右侧（可称为<strong>zag-zag</strong>，对称地若都在左侧可称为zig-zig），在$T_2$或者$T_3$处插入新的节点，插入的节点在底部以浅灰色表示，g的平衡因子由原来的-1变为-2，失衡。这种情况只需g经单次旋转zag(g(x))，图中的子树高度复原，更高的祖先也比平衡，全树复衡。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305110344.png" style="zoom:67%;"></p><p><strong>双旋</strong>：</p><p>当g、p和v不在同一侧时，如下图中p是g的右孩子，v是p的左孩子（可称为<strong>zag-zig</strong>，对称地若p是g的左孩子，v是p的右孩子可称为zig-zag），在$T_1$或者$T_2$处插入新的节点，插入新节点后，g的平衡因子由原来的-1变为-2，失衡。这种情况需要先做顺时针旋转zig(p)，在做逆时针旋转zag(g)，得到一棵平衡的等价二叉树。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305110410.png" style="zoom:67%;"></p><p>无论单旋还是双旋，经局部调整之后，不仅g(x)能够重获平衡，而且局部子树的高度也必将平衡。这就意味着，g(x)以上所有祖先的平衡因子亦将统一地复原，即在AVL树中插入新节点后，仅需要至多两次旋转，即可使整数恢复平衡。</p><p>AVL树插入节点的<strong>代码实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入AVL树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); _size++; <span class="comment">//创建新节点x</span></span><br><span class="line"><span class="comment">// 此时，x的父亲_hot若增高，则其祖父有可能失衡</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从x之父出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) &#123; <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树</span></span><br><span class="line">         FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//重新接入原树</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整随即结束</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则（g依然平衡），只需简单地</span></span><br><span class="line">         updateHeight ( g ); <span class="comment">//更新其高度（注意：即便g未失衡，高度亦可能增加）</span></span><br><span class="line">   &#125; <span class="comment">//至多只需一次调整；若果真做过调整，则全树高度必然复原</span></span><br><span class="line">   <span class="keyword">return</span> xx; <span class="comment">//返回新节点位置</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，总有AVL::insert(e)-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>效率：该算法首先按照二叉搜索树的常规算法在$O(\log n)$时间内插入新节点x，既然原树是平衡的，故至多坚持$O(\log n)$个节点即可确定g(x)，而至多旋转两次即可使局部乃至全树恢复平衡，因此<strong>AVL树的节点插入操作可以在$O(\log n)$时间内完成</strong>。</p><h1 id="3-节点删除"><a href="#3-节点删除" class="headerlink" title="3.节点删除"></a>3.节点删除</h1><p>与插入操作不同的是，在删除节点x后，以及在随后的调整过程中，失衡节点集UT(x)始终至多只含一个节点。若该节点g(x)存在，其高度必与失衡前相同，而且g(x)有可能就是x的父亲。</p><p>与插入操作同理，从<code>_hot</code>节点出发沿<code>parent</code>指针上行经过$O(\log n)$时间即可确定g(x)位置，作为失衡节点的g(x)在不包含x的一侧必有一个非空孩子p，且p的高度至少为1。选取p的孩子节点v时可按以下规则：若两个孩子不等高，则v取其中的更高者；若两个孩子等高，则取与p同向者。</p><p>以下不妨假设失衡后g(x)的平衡因子为+2，根据g、p和v的关系，通过等价变换，同样可以使得这一局部恢复平衡。</p><p><strong>单旋</strong>：</p><p>如下图g、p和v在同一侧，在$T_3$中删除节点使得节点g(x)失衡，通过一次顺时针旋转zig( g )即可恢复局部的平衡。这里约定图中以虚线连接的灰色方块所对应的节点，不能同时为空；$T_2$底部的灰色方块所对应的节点，可以为空，也可以非空。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305113736.png" style="zoom: 50%;"></p><p><strong>双旋</strong>：</p><p>如下图g、p和v不在同一侧，在$T_3$中删除节点使得节点g(x)失衡，这种情况需要先做一次逆时针旋转zag( p )，再做一次顺时针旋转zig( g )，即可恢复局部平衡。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305113800.png" style="zoom:50%;"></p><p><strong>失衡传播</strong>：</p><p>经过旋转操作使局部恢复平衡后，子树的高度未必复原，如上图中子树的高度降低，因此其更高的祖先可能失衡。在删除节点之后的调整过程中，这种由于低层失衡节点的重平衡而致使其更高层祖先失衡的现象，称作“失衡传播”。</p><p>失衡传播的方向必然是自底而上的，因而不致于影响到狗带节点。在此过程中的任一时刻，至多只有一个失衡的节点；高层的某一节点由平衡转为失衡，只能发生在下层失衡节点恢复平衡之后。因此可沿parent指针逐层遍历所有祖先，每找到一个失衡的祖先节点，即可套用以上方法式使之恢复平衡。</p><p>AVL树删除节点的<strong>代码实现</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从AVL树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//先按BST规则删除之（此后，原节点之父_hot及其祖先均可能失衡）</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从_hot出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将该子树联至</span></span><br><span class="line">         g = FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//原父亲</span></span><br><span class="line">      updateHeight ( g ); <span class="comment">//并更新其高度（注意：即便g未失衡，高度亦可能降低）</span></span><br><span class="line">   &#125; <span class="comment">//可能需做Omega(logn)次调整——无论是否做过调整，全树高度均可能降低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除成功</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><p>效率：较之插入操作，删除操作可能需要在重平衡上要多花费 一些时间，既然需要做重平衡的节点都是x的祖先，故重平衡过程累计只需$O(\log n)$时间，因此<strong>AVL树的节点删除操作总体的时间复杂度依然是$O(\log n)$</strong>。</p><h1 id="4-统一重平衡算法"><a href="#4-统一重平衡算法" class="headerlink" title="4.统一重平衡算法"></a>4.统一重平衡算法</h1><p>这一节主要解决如何实现第2、3节中插入/删除操作实现代码中的重平衡算法<code>rotateAt()</code>，上述重平衡的方法实质上可以转换成一种更简明的方法，无论是插入或删除操作，都要从刚发生修改的位置x出发向上直到遇到最低的失衡节点g(x)，在g(x)更高一侧的子树中，其孩子节点p和孙子节点v必然存在，按中序遍历次序，将其重命名为：$a &lt; b &lt; c$。它们总共拥有互不相交的四棵（可能为空）子树，按中序遍历序列，将其重命中为：$T_0&lt;T_1&lt;T_2&lt;T_3$。</p><p>将原先以g为根的子树S，替换为一棵新子树S’：</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305161322.png" style="zoom: 50%;"></p><p>等价变换后得到的新子树也是一棵AVL树，保持中序遍历次序：$T_0&lt;a&lt;T_1&lt;b&lt;T_2&lt;c&lt;T_3$。实际上，这一理解涵盖了此前两节所有的单旋和双旋情况（就相当于不进行“旋转”操作，而是直接将节点和子树“拆开”来按中序遍历次序保持不变重新拼到一起，使之恢复平衡）。相应的重构过程，仅涉及局部的三个节点及四棵子树，故称作<strong>“ 3 + 4 ”重构</strong>。</p><p>这种重构算法可以实现为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************</span></span><br><span class="line"><span class="comment"> * 按照“3 + 4”结构联接3个节点及其四棵子树，返回重组之后的局部子树根节点位置（即b）</span></span><br><span class="line"><span class="comment"> * 子树根节点与上层节点之间的双向联接，均须由上层调用者完成</span></span><br><span class="line"><span class="comment"> * 可用于AVL和RedBlack的局部平衡调整</span></span><br><span class="line"><span class="comment"> *********************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34 (</span><br><span class="line">   BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">   BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3</span><br><span class="line">) &#123;</span><br><span class="line">   <span class="comment">//*DSA*/print(a); print(b); print(c); printf("\n");</span></span><br><span class="line">   a-&gt;lc = T0; <span class="keyword">if</span> ( T0 ) T0-&gt;parent = a;</span><br><span class="line">   a-&gt;rc = T1; <span class="keyword">if</span> ( T1 ) T1-&gt;parent = a; updateHeight ( a );</span><br><span class="line">   c-&gt;lc = T2; <span class="keyword">if</span> ( T2 ) T2-&gt;parent = c;</span><br><span class="line">   c-&gt;rc = T3; <span class="keyword">if</span> ( T3 ) T3-&gt;parent = c; updateHeight ( c );</span><br><span class="line">   b-&gt;lc = a; a-&gt;parent = b;</span><br><span class="line">   b-&gt;rc = c; c-&gt;parent = b; updateHeight ( b );</span><br><span class="line">   <span class="keyword">return</span> b; <span class="comment">//该子树新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据g、p和v之间的联接关系，可以将g、p和v，以及它们的四棵子树与$a,b,c,T_0,T_1,T_2.T_3$对应起来，如” zig-zig “的联接方式，对应的是<code>connect34(v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc)</code>；而” zig-zag “的联接方式，对应的是<code>connect34(p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc)</code>，总之就是按照中序遍历次序代入就可。</p><p><img src="/2020/03/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8814%EF%BC%89AVL%E6%A0%91/QQ图片20200305162914.png" style="zoom: 50%;"></p><p>利用<code>connect34()</code>算法，即可视不同情况，按如下的代码实现重平衡算法<code>rotateAt()</code>，<code>rotateAt()</code>算法的复杂度依然是$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************************************</span></span><br><span class="line"><span class="comment"> * BST节点旋转变换统一算法（3节点 + 4子树），返回调整之后局部子树根节点的位置</span></span><br><span class="line"><span class="comment"> * 注意：尽管子树根会正确指向上层节点（如果存在），但反向的联接须由上层函数完成</span></span><br><span class="line"><span class="comment"> *********************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt ( BinNodePosi(T) v ) &#123; <span class="comment">//v为非空孙辈节点</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">if</span> ( !v ) &#123; <span class="built_in">printf</span> ( <span class="string">"\a\nFail to rotate a null node\n"</span> ); <span class="built_in">exit</span> ( <span class="number">-1</span> ); &#125;</span><br><span class="line">   BinNodePosi(T) p = v-&gt;parent; BinNodePosi(T) g = p-&gt;parent; <span class="comment">//视v、p和g相对位置分四种情况</span></span><br><span class="line">   <span class="keyword">if</span> ( IsLChild ( *p ) ) <span class="comment">/* zig */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; <span class="comment">/* zig-zig */</span> <span class="comment">//*DSA*/printf("\tzIg-zIg: ");</span></span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zig-zag */</span>  <span class="comment">//*DSA*/printf("\tzIg-zAg: ");</span></span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span>  <span class="comment">/* zag */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRChild ( *v ) ) &#123; <span class="comment">/* zag-zag */</span> <span class="comment">//*DSA*/printf("\tzAg-zAg: ");</span></span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zag-zig */</span>  <span class="comment">//*DSA*/printf("\tzAg-zIg: ");</span></span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对AVL树的<strong>综合评价</strong>：</p><p><strong>优点</strong>：无论查找、插入或删除，最坏情况下的复杂度均为$O(\log n)$，需要$O(n)$的存储空间。</p><p><strong>缺点</strong>：需要借助高度或平衡因子，为此需要改造元素结构，或额外封装。实测复杂度与理论值尚有差距，删除操作后，最多需要重平衡$\Omega(\log n)$次，若需频繁地进行插入/删除操作，未免得不偿失。单次动态调整后，全树的拓扑结构的变化量可能高达$\Omega(\log n)$，我们希望将它们控制到更低，比如在下一章将要介绍的红黑树，则可以将这个变化量严格地控制在每次不超过常数无，论对于插入操作还是删除操作都是如此。</p>]]></content>
    
    <summary type="html">
    
      通过合理设定适度平衡的标准，并借助以上等价变换，AVL树可以实现近乎理想的平衡。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（14）容器</title>
    <link href="http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/"/>
    <id>http://nekomoon404.github.io/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/</id>
    <published>2020-03-03T00:21:37.000Z</published>
    <updated>2020-03-03T02:41:42.312Z</updated>
    
    <content type="html"><![CDATA[<p><strong>容器</strong>是可容纳各种数据类型的数据结构</p><ul><li>包括<strong>顺序容器</strong>和<strong>关联容器</strong></li><li>还有一类不提供真正的用于存储元素的数据结构实现，称作<strong>容器适配器</strong></li><li>容器适配器不支持迭代器，由使用者选择合适的底层数据结构</li></ul><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303083205.png" style="zoom: 67%;"></p><h1 id="1-顺序容器"><a href="#1-顺序容器" class="headerlink" title="1.顺序容器"></a>1.顺序容器</h1><p>在<strong>顺序容器</strong>中，元素的插入位置与<strong>元素的值无关</strong>：</p><ul><li><p><code>vector</code> （声明于 &lt; vector&gt;）</p><p><strong>顺序表</strong>：实现了一个<strong>动态数组</strong>，可以在常数时间内完成随机存取元素，可以自动调整大小，在尾端增删元素时具有较佳的性能</p></li><li><p><code>array</code> （C++11 中新增，声明于 &lt; array&gt;）<br><strong>顺序表</strong>：封装了一个<strong>静态数组</strong>，只能在初始化时指定大小</p></li><li><p><code>deque</code> （声明于 &lt; deque&gt;）<br><strong>双端队列</strong>：实现了一个<strong>动态数组</strong>，可以在常数时间内完成随机存取元素，可以快速地在数组的头尾两端增删元素</p></li><li><p><code>list</code> （声明于 &lt; list&gt;）<br><strong>双向链表</strong>：不支持随机存取，但在任何位置增删元素都能在常数时间完成</p></li><li><p><code>forward_list</code> （ C++11 中新增，声明于 <forward_list>）<br><strong>单向链表</strong>：<code>list</code> 类的单链表版，去掉了一些操作</forward_list></p></li></ul><h2 id="1-1-vector"><a href="#1-1-vector" class="headerlink" title="1.1. vector"></a>1.1. vector</h2><p>vector 实现了一个<strong>动态数组</strong>，在实例化 vector 模板类时，需要在 &lt;&gt; 内指定容器中元素的具体类型，元素可以是基本数据类型，也可以是自定义的类。vector 可以在常数时间内完成随机存取元素，支持随机访问迭代器。</p><p>vector 可以自动调整大小，在尾端增删元素时具有较佳的性能，可以视为在常数时间内完成；在其他位置增删元素时较慢，与具体的位置有关。所有 STL 算法都能对 vector 操作。</p><p><strong>构造</strong> vector 对象时，需要声明具体的数据类型：可以指定一个初始长度，但之后还可以通过其他成员函数改变长度；还可以传入两个参数，分别指定初始长度和元素的初始值。也可以根据一个已有的数组来构造 vector 对象，传入的两个参数分别表示数组的起始和终止位置，是个左闭右开的区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;        <span class="comment">// 长度为 0 的 int 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(<span class="number">5</span>);     <span class="comment">// 长度为 5 的 int 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">4</span>, <span class="number">7</span>);  <span class="comment">// 长度为 4 的 int 数组，且初值都为 7</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v4(<span class="number">3</span>, “Hi”);  <span class="comment">// 长度为 3 且值都为 Hi 的 string 数组</span></span><br><span class="line">    <span class="keyword">double</span> x[] = &#123;<span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">5.8</span>, <span class="number">13.21</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v5(x, x + <span class="number">4</span>);     <span class="comment">// 从 x[0..3] 构造一个 double 数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v6(x + <span class="number">1</span>, x + <span class="number">2</span>); <span class="comment">// 从 x[1] 构造一个 double 数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问</strong>vector中的元素时，可以通过迭代器来访问或修改元素，也可以通过 <code>[]</code> 或 <code>at()</code> 成员函数访问或修改元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(p, p + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        *it = *it * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 5 7 11</span></span><br><span class="line">    v[<span class="number">3</span>] -= <span class="number">2</span>;     <span class="comment">// 修改 v[3]</span></span><br><span class="line">    v.at(<span class="number">4</span>) = <span class="number">17</span>;  <span class="comment">// 修改 v[4]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 5 7 11 13 17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector <strong>在数组尾部增删元素</strong>较快，使用 <code>push_back()</code> 在尾部增加元素，使用 <code>pop_back()</code> 在尾部删除元素。</p><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303084359.png" style="zoom:67%;"></p><p>可以使用 <code>insert()</code> 在任意位置<strong>插入</strong>一个或一段元素，但效率较低，插入的位置由迭代器来表示；<code>erase()</code> 则可以删除一个或一段元素，用法与 insert() 类似，效率也低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; v1, v2(<span class="number">3</span>, <span class="string">'D'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        v1.push_back(i + <span class="string">'A'</span>);</span><br><span class="line">    &#125;  <span class="comment">// 依次加入 A B C D</span></span><br><span class="line">    v1.pop_back();  <span class="comment">// 删除 D</span></span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="string">'Z'</span>);</span><br><span class="line">    v1.insert(v1.<span class="built_in">begin</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 D D D A B Z C</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>resize()</code> 来<strong>修改数组的长度</strong>，若修改后的长度比现有的要小，则舍弃后面的元素，否则添加缺省元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;  <span class="comment">// 依次添加 1 至 10</span></span><br><span class="line">    v.resize(<span class="number">5</span>);      <span class="comment">// 留下 v[0..4]</span></span><br><span class="line">    <span class="comment">// 将长度扩展到 8，用 100 填充新元素</span></span><br><span class="line">    v.resize(<span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 将长度扩展到 12，用缺省值 0 填充新元素</span></span><br><span class="line">    v.resize(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 100 100 100 0 0 0 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-deque"><a href="#1-2-deque" class="headerlink" title="1.2. deque"></a>1.2. deque</h2><p>deque 实现了一个双端队列，通过动态数组来实现，可以快速地在数组的头尾两端增删元素，支持随机存储迭代器，可以在常数时间内完成随机存取元素。</p><p>所有适用于 vector 的操作都适用于 deque，除此之外，deque 还提供了这些成员函数：</p><ul><li><p><code>front()</code> 取第一个元素（队首）的值</p></li><li><p><code>back()</code> 取最后一个元素（队尾）的值</p></li><li><p><code>push_front()</code> 将元素插入到最前面</p></li><li><p><code>pop_front()</code> 删除第一个元素</p></li></ul><h2 id="1-3-list"><a href="#1-3-list" class="headerlink" title="1.3. list"></a>1.3. list</h2><p>list 实现了一个<strong>双向链表</strong>，<strong>不支持随机存取</strong>，<strong>支持双向迭代器</strong>，与 vector 相比，不支持用 [] 来访问任意位置的元素，也不支持将迭代器移动多个单位（即不支持 begin() + i 这样的操作），但<strong>支持向前或向后移动</strong>（即支持 ++ 和 — ），可以在末尾或开头快速增加或删除元素，在任何位置增删元素都能在常数时间完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p + <span class="number">1</span>, p + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 3 5 7</span></span><br><span class="line">    li.pop_back();  li.push_back(<span class="number">11</span>);</span><br><span class="line">    li.pop_front(); li.push_front(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 5 11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 的构造函数与 vector 类似，可以指定一个初始长度，还可以分别指定初始长度和元素的初始值，也可以根据一个已有的数组来构造 list 对象。与 vector 类似，可以使用 <code>insert()</code> /<code>erase()</code> 在任意位置插入/删除一个或一段元素，且效率较高；与 vector 类似，可以使用 <code>resize()</code> 修改长度。</p><p>可以使用成员函数 <code>reverse()</code> <strong>将整个链表反序</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) li.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 5 6</span></span><br><span class="line">    li.reverse();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 6 5 4 3 2 1 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用成员函数 <code>remove()</code> <strong>删除指定值的元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p, p + <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 3 6 6 6</span></span><br><span class="line">    li.<span class="built_in">remove</span>(<span class="number">3</span>);  <span class="comment">// 删除链表中所有的 3</span></span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 6 6 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用成员函数<code>unique()</code> <strong>删除所有和前一个元素相同的元素</strong>，注意删除时只与前一个元素比较是否相同，所以最后得到的链表里仍然可能有重复的元素。还可以通过函数自定义元素相同的含义，将函数值返回 true 时，就删除当前元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p[] = &#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">1.3</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; li(p, p + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it;</span><br><span class="line">    li.unique();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0.1 0.2 0.3 0.1 0.8 1.3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_near</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(d1 - d2) &lt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 相差不超过 0.5 就认为是相同的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p[] = &#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">1.3</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; li(p, p + <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it;</span><br><span class="line">    li.unique(is_near);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0.1 0.8 1.3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 list 不支持随机存取，因此无法使用STL中的 sort 算法模板进行排序，只能使用 list 自己的成员函数<code>sort()</code> 来<strong>排序</strong>，缺省按照 operator <code>&lt;</code> 的含义来排序，可以重载 <code>&lt;</code> 操作符。也可以传入函数指针，通过自定义的函数来重新定义元素的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a % <span class="number">10</span> &lt; b % <span class="number">10</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">11</span>, <span class="number">27</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li(p, p + <span class="number">4</span>);   <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    li.sort();</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 按大小排序，输出 2 9 11 27</span></span><br><span class="line">    li.sort(cmp);</span><br><span class="line">    <span class="keyword">for</span> (it = li.<span class="built_in">begin</span>(); it != li.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 按 % 10 之后的大小排序，输出 11 2 27 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用成员函数 <code>merge()</code> <strong>合并</strong>两个链表，<strong>并清空被合并的那个链表</strong>。合并的两个链表中的元素必须按照某种规则排好序，否则会出错，因此 <code>merge()</code> 经常配合 <code>sort()</code> 一起使用，合并后的链表也是排好序的，可以自定义排序规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li1(p, p + <span class="number">4</span>);      <span class="comment">// 2 3 5 7</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li2(p + <span class="number">2</span>, p + <span class="number">5</span>);  <span class="comment">// 5 7 11</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    li1.merge(li2);  <span class="comment">// li1 和 li2 都是按升序排列好的</span></span><br><span class="line">    <span class="keyword">for</span> (it = li1.<span class="built_in">begin</span>(); it != li1.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 2 3 5 5 7 7 11</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; li2.<span class="built_in">size</span>();  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用成员函数 <code>splice()</code> <strong>在指定位置前面插入另一链表中的一个或多个元素</strong>，并在另一链表中删除这些被插入的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li1(p, p + <span class="number">5</span>), li2(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = li1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) ++it;  <span class="comment">// 找到 li1 中的 7</span></span><br><span class="line">    li2.splice(li2.<span class="built_in">begin</span>(), li1, it);  <span class="comment">// 在 li2 开头插入 7</span></span><br><span class="line">    <span class="keyword">for</span> (it = li2.<span class="built_in">begin</span>(); it != li2.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 7 1 1 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; li1.<span class="built_in">size</span>();  <span class="comment">// li1 中的 7 被删除，输出 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：常用的这<strong>三种顺序容器的主要差别在于访问/修改元素与增加/删除元素的速度上</strong>，因此需要根据实际情况选用合适的容器。</p><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303091409.png" style="zoom:67%;"></p><h1 id="2-关联容器"><a href="#2-关联容器" class="headerlink" title="2.关联容器"></a>2.关联容器</h1><p><strong>在关联容器中，元素的插入位置与元素的值有关</strong>，必须按相应的排序准则来确定，在查找元素时具有非常好的性能:</p><ul><li><p><code>set</code> / <code>multiset</code> （声明于 <code>#include&lt;set&gt;</code>）</p><p>集合：实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）；<code>set</code> 容器中不允许存在相同元素，<code>multiset</code> 容器中允许存在相同的元素</p></li><li><p><code>map</code> / <code>multimap</code> （声明于 <code>#include&lt;map&gt;</code>）<br>映射表：实现了一棵平衡二叉搜索树，存放的是成对的键值和数据（key / value），并根据键值对元素进行排序，可快速地根据键值来检索元素；<code>map</code> 容器中不允许存在键值相同的元素，而 <code>multimap</code> 容器中则允许</p></li><li><p>C++11 中新增的 <code>unordered_set</code> / <code>unordered_multiset</code> （声明于 &lt; unordered_set&gt;）和 <code>unordered_map</code> / <code>unordered_multimap</code> （声明于 &lt; unordered_map&gt;）<br>映射表：通过哈希表实现，功能与 <code>set</code>/<code>multiset</code> 和 <code>map</code>/<code>multimap</code> 相似，但不对键值排序</p></li></ul><p><strong>键值与数据（key-value pair）</strong>：在关联容器中，通过键值来查询对应的数据，对于集合容器来说，键值与数据相等。</p><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303093003.png" style="zoom:67%;"></p><p><strong>pair</strong>：可以使用 pair 模板来生成 key-value 对，pair 声明于 <code>&lt; utility&gt;</code> 头文件中，pair 中有两个成员变量 first 和 second：first 表示 key，second 表示 value。实例化的 pair 模板类可以用来绑定两个对象为一个新的对象。</p><p><strong>比较</strong>两个 pair 对象的大小：</p><ul><li><p><code>p1 &lt; p2</code>：如果 <code>p1.first &lt; p2.first</code> 或者 <code>!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second</code>，则返回 <code>true</code></p></li><li><p><code>p1 == p2</code>：如果 <code>p1.first == p2.first &amp;&amp; p1.second == p2.second</code>，则返回 <code>true</code></p></li></ul><p><strong>声明</strong>一个 pair 对象：</p><ul><li><p><code>pair&lt;T1, T2&gt; p</code>：创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化</p></li><li><p><code>pair&lt;T1, T2&gt; p(v1, v2)</code>：创建一个 pair 对象，它的两个元素分别是 T1 和 T2 类型，其中 first 成员初始化为 v1，second 成员初始化为 v2</p></li><li><p><code>make_pair(v1, v2)</code>：以 v1 和 v2 值创建一个新的 pair 对象，其元素类型分别是 v1 和 v2 的类型</p></li></ul><h2 id="2-1-set-multiset"><a href="#2-1-set-multiset" class="headerlink" title="2.1. set/multiset"></a>2.1. set/multiset</h2><p><code>set</code> / <code>multiset</code> 是集合容器，实现了一棵<strong>平衡二叉搜索树</strong>，使用元素本身作为键值（key）。<code>set</code> 容器中不允许存在相同元素，而 <code>multiset</code> 容器中允许内部元素有序排列，新元素插入的位置取决于其值。</p><p><strong>支持双向迭代器</strong>，不支持 <code>[]</code> 下标访问元素，但可以通过 <code>find()</code> 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为$O( \log n)$。可根据 operator <code>&lt;</code> 来比较两个元素的大小，对于自定义的类，需要重载其 <code>&lt;</code> 操作符。</p><h3 id="2-1-1-set"><a href="#2-1-1-set" class="headerlink" title="2.1.1. set"></a>2.1.1. set</h3><p>可使用成员函数 <code>insert()</code> 向集合中<strong>增加元素</strong>，根据元素对应的 operator <code>&lt;</code> 来确定元素应处的位置，插入容器中已有的元素时，插入操作失败（即不会插入重复的元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) s.insert(i);</span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        s.insert(i * <span class="number">2</span> + <span class="number">1</span>);  <span class="comment">// 想要插入 1 3 5 7 9</span></span><br><span class="line">    &#125;  <span class="comment">// 但是已经存在 1 和 3，不会重复插入</span></span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;  <span class="comment">// 输出 0 1 2 3 4 5 7 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于自定义的类，需要重载 operator <code>&lt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Customer(<span class="keyword">int</span> _a, <span class="built_in">string</span> _n) : age(_a), name(_n) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Customer &amp;c) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age == c.age) <span class="keyword">return</span> name &lt; c.name;</span><br><span class="line">        <span class="keyword">return</span> age &lt; c.age;</span><br><span class="line">    &#125;  <span class="comment">// 若 age 相同则比较 name，否则比较 age 的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Customer&gt; s;</span><br><span class="line">    <span class="function">Customer <span class="title">c1</span><span class="params">(<span class="number">18</span>, <span class="string">"Alice"</span>)</span></span>;  s.insert(c1);</span><br><span class="line">    <span class="function">Customer <span class="title">c2</span><span class="params">(<span class="number">37</span>, <span class="string">"Bob"</span>)</span></span>;    s.insert(c2);</span><br><span class="line">    <span class="function">Customer <span class="title">c3</span><span class="params">(<span class="number">26</span>, <span class="string">"Daisy"</span>)</span></span>;  s.insert(c3);</span><br><span class="line">    <span class="built_in">set</span>&lt;Customer&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) it-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">// 依次输出 Alice 18 、Daisy 26 和 Bob 37</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几种<strong>查找元素</strong>的接口：</p><p>使用成员函数 <code>find()</code> 来<strong>查找</strong>容器中的某个元素 x，若能找到，则返回指向 x 的迭代器，否则返回 <code>end()</code>，在这里，<strong>两个元素的相等是根据 operator &lt; 判断的</strong>（即同时满足 x &lt; y 为假且 x &gt; y 为假），<strong>与 operator == 运算符无关</strong>。</p><p>使用成员函数 <code>lower_bound()</code> 来查找容器中的某个元素 x，<strong>返回第一个大于等于 x 的元素的迭代器</strong>，若找不到则返回 <code>end()</code>。</p><p>使用成员函数 <code>upper_bound()</code> 来查找容器中的某个元素 x，<strong>返回第一个大于 x 的元素的迭代器</strong>，若找不到则返回 <code>end()</code>。</p><p>使用成员函数 <code>equal_range()</code> 来查找容器中的某个元素 x，<strong>返回一个迭代器对（pair）</strong>，其 first 值就是 <code>lower_bound()</code> ，其 second 值就是 <code>upper_bound()</code>。</p><p>使用成员函数 <code>count()</code> 来<strong>计算等于某个值的元素个数</strong>。</p><p>注意通过迭代器访问元素时，<strong>先判断迭代器是否等于 end()</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it == s.<span class="built_in">end</span>()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Find Element "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  s.insert(f, f + <span class="number">6</span>);</span><br><span class="line">    disp(s, s.<span class="built_in">find</span>(<span class="number">3</span>));  <span class="comment">// 输出 Find Element 3</span></span><br><span class="line">    disp(s, s.<span class="built_in">find</span>(<span class="number">4</span>));  <span class="comment">// 输出 Not found.</span></span><br><span class="line">    disp(s, s.lower_bound(<span class="number">8</span>));  <span class="comment">// 输出 Find Element 8</span></span><br><span class="line">    disp(s, s.upper_bound(<span class="number">8</span>));  <span class="comment">// 输出 Find Element 13</span></span><br><span class="line">    disp(s, s.lower_bound(<span class="number">20</span>)); <span class="comment">// 输出 Find Element 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303094230.png" style="zoom:67%;"></p><p>使用成员函数 <code>erase()</code> 来<strong>删除</strong>某个元素，传入的参数可以是元素值，若该元素不存在容器中，则删除失败；也可以是指向容器中某个元素的迭代器，迭代器必须是有效的；还可以传入两个迭代器，表示一段左闭右开的区间。</p><p><code>erase()</code>与 <code>find()</code> 、<code>lower_bound()</code>、<code>upper_bound()</code> 以及 <code>begin()</code>、<code>end()</code>、<code>rbegin()</code>、<code>rend()</code> 等配合使用，可以达到一些常见的效果，使用时注意 <strong>STL 中的区间一般都是左闭右开的</strong>，例如 [ begin(), end() )以及 lower_bound() 与 upper_bound() 在相等元素上的处理区别。</p><p>如下程序，假设普通函数 <code>disp(set&lt; int&gt;)</code> 用于输出容器中的所有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;  s.insert(f, f + <span class="number">6</span>);</span><br><span class="line">    disp(s);     <span class="comment">// 输出 2 3 5 8 13 21</span></span><br><span class="line">    s.erase(<span class="number">8</span>);  <span class="comment">// 删除值为 8 的元素</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 2 3 5 13 21</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>());  <span class="comment">// 删除第一个元素（2）</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 3 5 13 21</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    p = s.lower_bound(<span class="number">5</span>);  <span class="comment">// 找到 5</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>(), p); <span class="comment">// 删除 3</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 5 13 21</span></span><br><span class="line">    p = s.upper_bound(<span class="number">13</span>); <span class="comment">// 找到 13</span></span><br><span class="line">    s.erase(s.<span class="built_in">begin</span>(), p); <span class="comment">// 删除 5 和 13</span></span><br><span class="line">    disp(s);     <span class="comment">// 输出 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-multiset"><a href="#2-1-2-multiset" class="headerlink" title="2.1.2. multiset"></a>2.1.2. multiset</h3><p>multiset 在使用上与 set 基本一致，主要区别在于 multiset <strong>允许插入值相同的元素</strong>。在使用 <code>find()</code> 查找时，会返回第一个等于该查找值的元素，在使用 <code>erase()</code> 删除等于某个值的元素时，会删除所有等于该值的元素<br>假设 <code>multiset&lt; int&gt; s</code> 中的元素如下：</p><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303094800.png" style="zoom:67%;"></p><p>如下程序，假设普通函数 <code>disp()</code> 用于输出容器set&lt; int&gt;和multiset&lt; int&gt;中的所有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;      s1.insert(f, f + <span class="number">8</span>);</span><br><span class="line">    disp(s1);    <span class="comment">// 输出 1 2 3 6</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s2; s2.insert(f, f + <span class="number">8</span>);</span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 2 2 3 3 6</span></span><br><span class="line">    s2.erase(<span class="number">2</span>); <span class="comment">// 删除所有的 2</span></span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 3 3 6</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s2.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    s2.erase(it);  <span class="comment">// 删除第一个 3</span></span><br><span class="line">    disp(s2);    <span class="comment">// 输出 1 1 1 3 6</span></span><br><span class="line">    <span class="comment">// equal_range(1) 找到所有的 1</span></span><br><span class="line">    s2.erase((s2.equal_range(<span class="number">1</span>)).first,</span><br><span class="line">             (s2.equal_range(<span class="number">1</span>)).second);</span><br><span class="line">    disp(s2);    <span class="comment">// 输出 3 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：s1 是一个不允许重复元素的集合，且元素按降序排列，因此输出 9 7 5 3 1；s2 是一个允许有重复元素的容器，缺省将元素按升序排列，因此输出 1 3 3 5 7 9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; s1;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator i1;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator i2;</span><br><span class="line">    s1.insert(p, p + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (i1 = s1.<span class="built_in">begin</span>(); i1 != s1.<span class="built_in">end</span>(); i1++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i1 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s2.insert(p, p + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (i2 = s2.<span class="built_in">begin</span>(); i2 != s2.<span class="built_in">end</span>(); ++i2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i2 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-map-multimap"><a href="#2-2-map-multimap" class="headerlink" title="2.2. map/multimap"></a>2.2. map/multimap</h2><p>map / multimap 是一张<strong>映射表</strong>，通过<strong>平衡二叉搜索树</strong>来实现，存放的是成对的 key-value，实例化时需要在 &lt;&gt; 中依次指定 key 和 value 的类型，根据 key 对元素进行排序，可快速地根据 key 来检索元素。map 容器中不允许存在 key 相同的元素，而 multimap 容器中则允许，用法与 set / multiset 类似。</p><p>支持双向迭代器，可以通过 <code>find()</code> 等成员函数快速查找元素，增加、删除、修改、查询元素的算法时间复杂度均为 $O(\log n)$。根据 operator <code>&lt;</code> 来比较两个元素的大小，对于自定义的类，需要重载其 <code>&lt;</code> 操作符。</p><h3 id="2-2-1-map"><a href="#2-2-1-map" class="headerlink" title="2.2.1. map"></a>2.2.1. map</h3><p>可以使用成员函数 <code>insert()</code> 向 map 容器中<strong>插入元素</strong>，注意插入的元素是成对的 key-value，因此是一个个的 pair。可以通过迭代器访问元素，也可以使用 [] 运算符访问容器中已有的 key 对应的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m.insert(make_pair(<span class="string">"Alice"</span>, <span class="number">18</span>));</span><br><span class="line">    m.insert(make_pair(<span class="string">"Daisy"</span>, <span class="number">26</span>));</span><br><span class="line">    m.insert(make_pair(<span class="string">"Bob"</span>, <span class="number">37</span>));</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  <span class="comment">// 依次输出 Alice-&gt;18  Bob-&gt;37  Daisy-&gt;26</span></span><br><span class="line">    <span class="keyword">int</span> p = m[<span class="string">"Alice"</span>];  <span class="comment">// p = 18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旧一些的编译器只支持通过 <code>make_pair()</code> 的方式插入元素，新一些的编译器则可以直接通过 <code>[]</code> 来插入元素，如 <code>m[“Alice”] = 18;</code> 。因此当使用 <code>[]</code> 访问元素时，如果 <code>[]</code> 中的 key 不存在于容器中，则可能运行出错，也可能访问到一个未正确初始化的元素（其值不一定有意义）。当向容器中插入一个 key 已经存在的元素时，插入失败，但是可以通过 <code>[]</code> 来修改 key 对应的 value。</p><p>使用成员函数 <code>erase()</code> 删除元素，可以传入 key 作为参数，也可以传入指定元素的迭代器；还可以传入两个迭代器，表示删除一个左闭右开的区间内的所有元素。</p><p>使用成员函数 <code>find()</code>、<code>lower_bound()</code>、<code>upper_bound()</code> 或者 <code>begin()</code> 、<code>rbegin()</code> 等时，返回的都是 pair 迭代器，因为返回值对应于容器中的元素，而 map 容器中的元素是一个个 pair。</p><p>成员函数 <code>equal_range()</code> 的返回值则是一个由两个 pair 组成的 pair 迭代器，例如对于 <code>map&lt;string, int&gt;</code> 容器来说，<code>equal_range()</code> 的返回值类型为 <code>pair&lt;map&lt;string, int&gt;::iterator, map&lt;string, int&gt;::iterator&gt;</code>。因为 <code>equal_range()</code> 返回的是 <code>lower_bound()</code> 和 <code>upper_bound()</code> 构成的 pair，而 map 的 <code>lower_bound()</code> 和 <code>upper_bound()</code> 都是 pair 迭代器。</p><h3 id="2-2-2-multimap"><a href="#2-2-2-multimap" class="headerlink" title="2.2.2. multimap"></a>2.2.2. multimap</h3><p>multimap 在使用上与 map 基本一致，主要区别在于 multimap 允许插入 key 相同的元素。multimap 不支持使用 <code>[]</code> 运算符访问元素，因为元素的 key 可能重复，用 <code>[]</code> 访问时可能不知道应该访问哪一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        m1.insert(make_pair(i + <span class="string">'A'</span>, i));</span><br><span class="line">        m1.insert(make_pair(i + <span class="string">'A'</span>, i * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        m2.insert(make_pair(i + <span class="string">'A'</span>, i));</span><br><span class="line">        m2.insert(make_pair(i + <span class="string">'A'</span>, i * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    disp(m1); <span class="comment">// 输出 A-&gt;0 B-&gt;1 C-&gt;2 D-&gt;3</span></span><br><span class="line">    disp(m2); <span class="comment">// 输出 A-&gt;0 A-&gt;1 B-&gt;1 B-&gt;3 C-&gt;2 C-&gt;5 D-&gt;3 D-&gt;7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-容器适配器"><a href="#3-容器适配器" class="headerlink" title="3.容器适配器"></a>3.容器适配器</h1><p>在<strong>容器适配器</strong>中，不提供真正的用于存储元素的数据结构实现，<strong>不支持迭代器</strong>，由使用者选择合适的底层数据结构：</p><ul><li><p><code>stack</code> （声明于 <code>#include&lt;stack&gt;</code>）<br><strong>栈</strong>：是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则</p></li><li><p>queue （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>队列</strong>：插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即按照先进先出的原则</p></li><li><p><code>priority_queue</code> （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>优先队列</strong>：最高优先级元素总是第一个出队，可视作堆</p></li></ul><p>容器适配器可以用某种顺序容器来实现，即让已有的顺序容器以栈/队列的方式工作。</p><h2 id="3-1-stack"><a href="#3-1-stack" class="headerlink" title="3.1. stack"></a>3.1. stack</h2><p>stack 栈是一种<strong>后进先出</strong>的数据结构，<strong>只能插入、删除、访问栈顶元素</strong>。对应的操作为：</p><ul><li><p><code>push()</code> 入栈 / 插入元素</p></li><li><p><code>pop()</code> 出栈 / 删除元素</p></li><li><p><code>top()</code> 返回栈顶元素的引用 / 访问元素</p></li></ul><p>此外还可以通过成员函数 <code>empty()</code> 来判断栈是否为空，如果想要清空一个栈，只能通过 <code>while (!empty()) pop();</code> 这样的方式。如下图依次演示了：1 入栈、2 入栈、3 入栈、3 出栈、1 入栈、4 入栈。</p><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303102746.png" style="zoom:67%;"></p><p>stack 在缺省情况下用 deque 实现：<code>template&lt;class T, class Cont = deque&lt;T&gt; &gt;</code>，例如 <code>stack&lt;int&gt; s;</code> 声明了一个元素为 int 型的栈，用 deque 实现。但也可以用 vector 或 list 来实现，例如 <code>stack&lt;string, vector&lt;string&gt; &gt; s;</code> 声明了一个元素为 string 型的栈，用 vector 实现。在声明时可以同时对栈初始化，初始化方式与 vector / deque / list 类似。</p><h2 id="3-2-queue"><a href="#3-2-queue" class="headerlink" title="3.2. queue"></a>3.2. queue</h2><p>queue 队列是一种<strong>先进先出</strong>的数据结构，只能在<strong>队尾插入元素</strong>，只能<strong>访问或删除队首元素</strong>，对应的操作为：</p><ul><li><p><code>push()</code> 入队 / 插入元素</p></li><li><p><code>pop()</code> 出队 / 删除元素</p></li><li><p><code>front()</code> 返回队首元素的引用 / 访问元素</p></li></ul><p><img src="/2020/03/03/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89%E5%AE%B9%E5%99%A8/QQ图片20200303103248.png" style="zoom:67%;"></p><p>queue 在缺省情况下用 deque 实现：<code>template&lt;class T, class Cont = deque&lt;T&gt; &gt;</code>。例如 <code>queue&lt;int&gt; q;</code> 声明了一个元素为 int 型的队列，用 deque 实现。但也可以用 vector 或 list 来实现，例如 <code>queue&lt;string, vector&lt;string&gt; &gt; q;</code> 声明了一个元素为 string 型的队列，用 vector 实现。在声明时可以同时对队列初始化，初始化方式与 vector / deque / list 类似。</p><h2 id="3-3-priority-queue"><a href="#3-3-priority-queue" class="headerlink" title="3.3. priority_queue"></a>3.3. priority_queue</h2><p>priority_queue 是一个<strong>优先队列</strong>，也可以看做是一个<strong>堆</strong>（heap），<strong>能保证最大的元素总是在最前面</strong>，一些操作为：</p><ul><li><p><code>pop()</code> 删除的是队列中最大的元素（因为最大的元素总是在队首）</p></li><li><p>没有名叫 <code>front()</code> 成员函数，通过 <code>top()</code> 返回最大元素的引用</p></li><li><p>通过 <code>push()</code> 添加元素，每次 <code>push()</code> 之后队首元素可能发生变化</p></li></ul><p>priority_queue用法基本和 queue 类似，可以用 vector 和 deque 实现，缺省情况下用vector 实现。缺省情况是根据 <code>less&lt;T&gt;</code> 模板比较大小的，实例化时是个函数对象。可以使用其他的函数对象类模板来定义大小，或者重载元素的 <code>&lt;</code> 运算符，例如 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;</code> 就声明了一个将最小的元素排在队首的优先队列。</p><p>例如下面声明了三种队列，设 <code>disp()</code> 可以按序输出队列中的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">// 普通的队列</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q2;  <span class="comment">// 优先队列，降序</span></span><br><span class="line">    <span class="comment">// 优先队列，升序</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        q1.push(v[i]);</span><br><span class="line">        q2.push(v[i]);</span><br><span class="line">        q3.push(v[i]);</span><br><span class="line">    &#125;  <span class="comment">// 依次入队 1 3 7 2 6 4 5</span></span><br><span class="line">    disp(q1); <span class="comment">// 输出 1 3 7 2 6 4 5</span></span><br><span class="line">    disp(q2); <span class="comment">// 输出 7 6 5 4 3 2 1</span></span><br><span class="line">    disp(q3); <span class="comment">// 输出 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一章中各容器在数据结构与算法中有详细的介绍，包括原理，实现，效率与优化等等，可以参考我的博客中数据结构与算法categories中的相关文章(┌・ω・)┌✧</p>]]></content>
    
    <summary type="html">
    
      容器是可容纳各种数据类型的数据结构，包括顺序容器和关联容器，还有一类不提供真正的用于存储元素的数据结构实现，称作容器适配器。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（13）二叉搜索树</title>
    <link href="http://nekomoon404.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-03-01T09:53:30.000Z</published>
    <updated>2020-03-03T14:50:58.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>回顾在第二，三章作为基础所介绍的两类基本数据结构：向量和列表，虽然它们都已经可以解决相当多的问题，然而对于进一步的算法设计要求来说它们都显得力不从心。基本的数据结构，可以在一定程度上支持静态查找但很遗憾，并不能高效地兼顾静态查找与动态修改。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200301111235.png" style="zoom: 67%;"></p><p>在第五章我们做了改进的尝试，通过对一维列表的拓展引入了树结构或者说二叉树结构，二叉树结构可以认为是二维的列表，即列表在维度上的一种扩充。</p><p>而这一章要介绍的<strong>二叉搜索树（binary search tree，BST）</strong>，它首先在形式上继承了二叉树也就是列表结构的特点，同时也巧妙地借鉴了向量，或者更准确地讲是有序向量的特点和优势。相对而言后一方面的借鉴更为重要，如果此前对列表结构的借鉴只是外表的形式，那么这种对有序向量特点的借鉴才是一种质的提高，这也是BST相对于其它的数据结构最为 “传神”的部分。实际上BST中所有这些传神的部分都集中体现在其中的一个子集：<strong>平衡二叉搜索树（balanced binary search tree，BBST）</strong>，在接下来的两章中会介绍其中最具代表性的几个变种。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200301105308.png" style="zoom: 33%;"></p><h2 id="1-1-循关键码访问"><a href="#1-1-循关键码访问" class="headerlink" title="1.1.循关键码访问"></a>1.1.循关键码访问</h2><p>二叉搜索树的数据项之间，按照各自的<strong>关键码</strong>彼此区分（call-by-key）。</p><p>前提条件是：关键码之间支持<strong>大小比较</strong>与<strong>相等比对</strong>。</p><p>因此为了简化和抽象不妨将整个数据集中的数据项都已统一地表示和实现为<strong>词条entry</strong>的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span> <span class="comment">//词条模板类</span></span><br><span class="line">   K key; V value; <span class="comment">//关键码、数值</span></span><br><span class="line">   Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) &#123;&#125;; <span class="comment">//默认构造函数</span></span><br><span class="line">   Entry ( Entry&lt;K, V&gt; <span class="keyword">const</span>&amp; e ) : key ( e.key ), value ( e.value ) &#123;&#125;; <span class="comment">//基于克隆的构造函数</span></span><br><span class="line">   <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; ( Entry&lt;K, V&gt; <span class="keyword">const</span>&amp; e ) &#123; <span class="keyword">return</span> key &lt;  e.key; &#125;  <span class="comment">//比较器：小于</span></span><br><span class="line">   <span class="keyword">bool</span> <span class="keyword">operator</span>&gt; ( Entry&lt;K, V&gt; <span class="keyword">const</span>&amp; e ) &#123; <span class="keyword">return</span> key &gt;  e.key; &#125;  <span class="comment">//比较器：大于</span></span><br><span class="line">   <span class="keyword">bool</span> <span class="keyword">operator</span>== ( Entry&lt;K, V&gt; <span class="keyword">const</span>&amp; e ) &#123; <span class="keyword">return</span> key == e.key; &#125; <span class="comment">//判等器：等于</span></span><br><span class="line">   <span class="keyword">bool</span> <span class="keyword">operator</span>!= ( Entry&lt;K, V&gt; <span class="keyword">const</span>&amp; e ) &#123; <span class="keyword">return</span> key != e.key; &#125; <span class="comment">//判等器：不等于</span></span><br><span class="line">&#125;; <span class="comment">//得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码</span></span><br></pre></td></tr></table></figure><p>若二叉树中各节点所对应的词条之间支持大小比较，则在不致歧义的情况下，我们可以不必严格区分树中的节点、节点对应的词条以及词条内部所存的关键码。</p><h2 id="1-2-顺序性"><a href="#1-2-顺序性" class="headerlink" title="1.2.顺序性"></a>1.2.顺序性</h2><p>在二叉搜索树BST中处处中都满足<strong>顺序性</strong>：</p><ul><li><p>任一节点r的左子树中的所有节点都不大于r；</p></li><li><p>任一节点r的右子树中的所有节点都不小于r。</p></li></ul><p>为回避边界情况，这里暂且假设所有节点互不相等，于是上述顺序性便可简化表达为：</p><ul><li>任一节点r的左子树中的所有节点都小于r；</li><li>任一节点r的右子树中的所有节点都大于r。</li></ul><p>当然在实际应用中，对相等元素的禁止既不自然也不必要。顺序性虽然只是对局部特征的刻画，但可由此导出某种全局特征：BST的<strong>中序遍历序列，必然单调非降</strong>。这一性质也是BST的<strong>充要条件</strong>，即任何一颗二叉树是二叉搜索树当且仅当中序遍历序列单调非降。（二叉树图中往下垂直投影就可以得到中序遍历序列）</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200301122208.png" style="zoom: 80%;"></p><p>二叉搜索树属于二叉树的特例，故可以基于<code>BinTree</code>模板类派生出<code>BST</code>模板类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BinTree/BinTree.h"</span> <span class="comment">//引入BinTree</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BST</span> :</span> <span class="keyword">public</span> BinTree&lt;T&gt; &#123; <span class="comment">//由BinTree派生BST模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   BinNodePosi(T) _hot; <span class="comment">//“命中”节点的父亲</span></span><br><span class="line">   BinNodePosi(T) connect34 ( <span class="comment">//按照“3 + 4”结构，联接3个节点及四棵子树</span></span><br><span class="line">      BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),</span><br><span class="line">      BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T) );</span><br><span class="line">   BinNodePosi(T) rotateAt ( BinNodePosi(T) x ); <span class="comment">//对x及其父亲、祖父做统一旋转调整</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//基本接口：以virtual修饰，强制要求所有派生类（BST变种）根据各自的规则对其重写</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">search</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//查找</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">insert</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//插入</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span> <span class="params">( <span class="keyword">const</span> T&amp; e )</span></span>; <span class="comment">//删除</span></span><br><span class="line">   <span class="comment">/*DSA*/</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="function"><span class="keyword">void</span> <span class="title">stretchToLPath</span><span class="params">()</span> </span>&#123; stretchByZag ( _root ); &#125; <span class="comment">//借助zag旋转，转化为左向单链</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="function"><span class="keyword">void</span> <span class="title">stretchToRPath</span><span class="params">()</span> </span>&#123; stretchByZig ( _root ); &#125; <span class="comment">//借助zig旋转，转化为右向单链</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="function"><span class="keyword">void</span> <span class="title">stretch</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="function"><span class="keyword">void</span> <span class="title">imitate</span> <span class="params">( <span class="keyword">const</span> BST&lt;T&gt; &amp; )</span></span>; <span class="comment">//临摹</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在继承原模板类<code>BinTree</code>的同时，<code>BST</code>内部也继续沿用了二叉树节点模板类<code>BinNode</code>。<code>BST</code>中新增了三个接口<code>search()</code>，<code>insert()</code>，和<code>remove()</code>，这三个标准接口的调用参数都是属于元素类型T的对象引用，这正是此类结构“循关键码访问”方式的具体体现。以<code>BST</code>为基类可以进一步派生出二叉搜索树的多个变种，因此这里的三个接口在前面加上virtual定义为虚函数。由于这些操作接口涉及词条的大小和相等的关系，因此这里假定基本元素类型<code>T</code>直接支持比较和判等操作，或者已重载过对应的操作符。</p><h1 id="2-算法及实现"><a href="#2-算法及实现" class="headerlink" title="2.算法及实现"></a>2.算法及实现</h1><h2 id="2-1-BST：查找"><a href="#2-1-BST：查找" class="headerlink" title="2.1. BST：查找"></a>2.1. BST：查找</h2><p>二叉搜索树的查找算法，亦采用了<strong>减而治之</strong>的思路与策略，其执行过程可描述为：从树根出发，逐步地缩小查找范围，知道发现目标（成功）或缩小至空树（失败）。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200301150423.png" style="zoom: 80%;"></p><p>一般地，在上述查找过程中，一旦发现当前节点为<code>NULL</code>，即说明查找范围已经缩小至空，查找失败；否则，视关键码比较结果，向左（更小）或向右（更大）深入，或者报告成功。对照中序遍历序列可见，整个过程与<strong>有序向量的二分查找</strong>过程可视为等效。</p><p>BST的<code>search()</code>可以实现为下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) <span class="comment">//在BST中查找关键码e</span></span><br><span class="line">&#123; <span class="keyword">return</span> searchIn ( _root, e, _hot = <span class="literal">NULL</span> ); &#125; <span class="comment">//返回目标节点位置的引用，以便后续插入、删除操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">searchIn</span> <span class="params">( BinNodePosi(T) &amp; v, <span class="keyword">const</span> T&amp; e, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( !v || ( e == v-&gt;data ) ) <span class="keyword">return</span> v; <span class="comment">//递归基：在节点v（或假想的通配节点）处命中</span></span><br><span class="line">   hot = v; <span class="comment">//一般情况：先记下当前节点，然后再</span></span><br><span class="line">   <span class="keyword">return</span> searchIn ( ( ( e &lt; v-&gt;data ) ? v-&gt;lc : v-&gt;rc ), e, hot ); <span class="comment">//深入一层，递归查找</span></span><br><span class="line">&#125; <span class="comment">//返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）</span></span><br></pre></td></tr></table></figure><p>节点插入和删除操作，都需要首先调用查找算法，并根据查找结果确定后续的处理方式。因此这里以引用方式传递（子）树根节点，以为后续操作提供必要的信息。<code>searchIn()</code>采用典型的尾<strong>递归</strong>来实现。这种实现方式是为了统一并简化后续不同搜索树的各种操作接口的实现，其中的技巧体现于返回值和<code>hot</code>变量的<strong>语义约定</strong>。</p><p>若查找成功，则<code>searchIn()</code>和<code>search()</code>的返回值都指向一个关键码为<code>e</code>且真实存在的节点；若查找失败，则返回值的数值为<code>NULL</code>，但它作为引用将指向最后一次试图转向的空节点。对于后一种情况不妨将此空节点转换为一个数值为<code>e</code>的哨兵节点，这样无论成功与否，<strong>查找的返回值总是等效地指向“命中节点”</strong>。在整个查找的过程中，hot变量始终指向当前节点的父亲，因此在算法返回时，按照如上定义，<strong>_hot将统一指向“命中节点”的父亲</strong>。而<code>_hot</code>节点是否拥有另一个孩子与查找成功与否无关。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200301152343.png" style="zoom: 80%;"></p><p>接着分析查找算法的<strong>效率</strong>，在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故中体所需时间应线性正比与查找路径的长度，或最终返回节点的深度。在最好情况下，目标关键码出现在树根处，只需$O(1)$时间；而规模为n的二叉搜索树，深度在最坏情况下可达$O(n)$，如退化为一条单链，可见最坏情况下查找所需时间为$O(n)$。因此若要控制单词查找在最坏情况下的运行时间，须从控制二叉树的高度入手，后面介绍的平衡二叉树正是基于这一思路而做的改进。</p><h2 id="2-2-BST：插入"><a href="#2-2-BST：插入" class="headerlink" title="2.2. BST：插入"></a>2.2. BST：插入</h2><p>为了在二叉搜索树中插入一个节点，首先要利用<code>search(e)</code>确定插入位置及方向（左孩子还是右孩子），再将新节点作为叶子插入。若<code>e</code>尚不存在，则<code>_hot</code>为新节点的父亲，<code>v=search(e)</code>为 <code>_hot</code>对新孩子的引用。于是只需令 <code>_hot</code>通过<code>v</code>指向新节点。</p><p>如图(a)中的二叉搜索树为例，若欲插入关键码40，则在执行<code>search(40</code>)之后，如图(b)，<code>_ho</code>t将指向比较过的最后一个节点46，同时返回其左孩子（此时为空）的位置，于是接下来如图(c)，只需将其作为46的左孩子接入。为了保持二叉搜索树作为数据结构的完整性和一致性，还需从节点 <code>_hot(46</code>)出发，自底而上地逐个更新新插入的节点40的历代祖先的高度。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303122016.png" style="zoom:67%;"></p><p>BST的插入算法的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入BST树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); <span class="comment">//创建新节点x：以e为关键码，以_hot为父</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   updateHeightAbove ( x ); <span class="comment">//更新x及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> x; <span class="comment">//新插入的节点，必为叶子</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>按照以上的实现方式，无论插入操作成功与否，都会返回一个非空位置，且该处的节点与拟插入的节点相等，如此可以确保一致性，以简化后续的操作。节点插入操作所需的时间主要消耗于对算法<code>search()</code>和<code>updateHeightAbove()</code>的调用。后者与前者一样都是在每一层至多涉及一个节点，仅消耗$O(1)$时间，故时间复杂度取决于新节点的深度，在最坏情况下不会超过全树的高度$O(h)$。</p><h2 id="2-3-BST：删除"><a href="#2-3-BST：删除" class="headerlink" title="2.3. BST：删除"></a>2.3. BST：删除</h2><p>为从二叉搜索树中删除节点，首先也要调用<code>search()</code>，判断目标节点是否存在与树中，若存在，则需返回其位置。具体的删除操作要分两种情况来讨论：</p><p><strong>单分支情况</strong>：</p><p>如图(a)欲删除节点69，首先通过<code>search(69)</code>定外待删除节点69，该节点的右子树为空，故只需将69与替换为其左孩子64。为保持二叉搜索树作为数据结构的完整性和一致性，还需要更新全树的规模纪录，释放被摘除的节点69，并自下而上地逐个更新节点64历代祖先的高度。注意，首个需要更新高度的祖先58恰好由<code>_hot</code>指示。以上同时已涵盖左、右孩子均不存在（即目标节点为叶节点）的情况。如此操作之后，二叉搜索树的拓扑结构依然完整，顺序性依然满足。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303150946.png" style="zoom: 80%;"></p><p><strong>双分支情况</strong>：</p><p>以上图的二叉树为例，若欲删除节点36，则如图(c)首先调用<code>BinNode::succ()</code>算法找到该节点的直接后继(40)，即中序遍历下的下一个节点，然后交换二者的数据项，则可将后继节点等效地视作待删除的目标节点。而该后继节点必然无左孩子，从而问题转化为上面的单分支情况，于是如图(d)将新的目标节点(36)替换为其右孩子(46)，再释放被摘除的节点(36)，并更新一系列祖先节点的高度，此时首个需要更新高度的祖先，依然恰好由<code>_hot</code>指示，如图(e)。尽管全树的顺序性在中途会不满足，但完成整个删除操作后，全树的顺序性必然恢复。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303152200.png" style="zoom: 80%;"></p><p>BST的删除算法的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::<span class="built_in">remove</span> ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BST树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//实施删除</span></span><br><span class="line">   updateHeightAbove ( _hot ); <span class="comment">//更新_hot及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//删除成功与否，由返回值指示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************************</span></span><br><span class="line"><span class="comment"> * BST节点删除算法：删除位置x所指的节点（全局静态模板函数，适用于AVL、Splay、RedBlack等各种BST）</span></span><br><span class="line"><span class="comment"> * 目标x在此前经查找定位，并确认非NULL，故必删除成功；与searchIn不同，调用之前不必将hot置空</span></span><br><span class="line"><span class="comment"> * 返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲——二者均有可能是NULL</span></span><br><span class="line"><span class="comment"> *********************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">removeAt</span> <span class="params">( BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   BinNodePosi(T) w = x; <span class="comment">//实际被摘除的节点，初值同x</span></span><br><span class="line">   BinNodePosi(T) succ = <span class="literal">NULL</span>; <span class="comment">//实际被删除节点的接替者</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *x ) ) <span class="comment">//若*x的左子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;rc; <span class="comment">//直接将*x替换为其右子树</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *x ) ) <span class="comment">//若右子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;lc; <span class="comment">//对称地处理——注意：此时succ != NULL</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要</span></span><br><span class="line">      w = w-&gt;succ(); <span class="comment">//（在右子树中）找到*x的直接后继*w</span></span><br><span class="line">      swap ( x-&gt;data, w-&gt;data ); <span class="comment">//交换*x和*w的数据元素</span></span><br><span class="line">      BinNodePosi(T) u = w-&gt;parent;</span><br><span class="line">      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; <span class="comment">//隔离节点*w</span></span><br><span class="line">   &#125;</span><br><span class="line">   hot = w-&gt;parent; <span class="comment">//记录实际被删除节点的父亲</span></span><br><span class="line">   <span class="keyword">if</span> ( succ ) succ-&gt;parent = hot; <span class="comment">//并将被删除节点的接替者与hot相联</span></span><br><span class="line">   <span class="built_in">release</span> ( w-&gt;data ); <span class="built_in">release</span> ( w ); <span class="keyword">return</span> succ; <span class="comment">//释放被摘除节点，返回接替者</span></span><br><span class="line">&#125; <span class="comment">//release()负责释放复杂结构，与算法无直接关系</span></span><br></pre></td></tr></table></figure><p><strong>效率</strong>：BST的删除操作所需的时间，主要消耗于对<code>search()</code>、<code>succ()</code>和<code>updateHeightAbove()</code>的调用。在树中的任一层，它们各自都至多消耗$O(1)$时间，故总体的渐进时间复杂度，亦不超过全树的高度$O(h)$。</p><h1 id="3-平衡二叉搜索树"><a href="#3-平衡二叉搜索树" class="headerlink" title="3.平衡二叉搜索树"></a>3.平衡二叉搜索树</h1><h2 id="3-1-树高和性能"><a href="#3-1-树高和性能" class="headerlink" title="3.1.树高和性能"></a>3.1.树高和性能</h2><p>由以上的实现与分析，BST主要接口search()，insert()和remove()的运行时间在最坏情况下，均线性正比于其高度$O(h)$，因此若不能有效地控制树高，则就实际的性能而言，较之此前的向量和列表等数据结构，BST将无法体现出明显优势。比如在最坏情况下，二叉搜索树可能彻底地退化为列表，此时的查找效率甚至会降至$O(n)$，线性正比于树（列表）的规模。那么出现此类最坏或较坏情况的概率有多大，或者从平均复杂度的角度看，二叉搜索树的性能究竟如何呢？下面按两种常用的<strong>随机统计口径</strong>，就BST的平均性能做一分析和对比。</p><p><strong>随机生成</strong>：</p><p>考查n个互异词条$\{e_1,e_2,\dots,e_n\}$，对任一排列$\sigma=(e_{i_1},e_{i_2},\dots,e_{i_n})$，从空树开始，通过依次执行insert($e_{i_k}$)，即可得到这n个关键码的一棵二叉搜索树$T(\sigma)$。与随机排列$\sigma$相对应的$T(\sigma)$称为由$\sigma$<strong>随机生成</strong>（randomly generated）。下图以关键码为例$\{1,2,3\}$为例，列出了由其所有排列生成的二叉搜索树。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303214653.png" style="zoom:67%;"></p><p>显然任意的n个互异关键码都可以构成$n!$种全排列，若<strong>设各排列作为输入序列的概率均等</strong>，则在随机生成下二叉搜索树的平均高度为$\Theta(\log n)$。</p><p><strong>随机组成</strong>：</p><p>另一种随机策略是，假定n个互异节点同时给定，然后在遵守顺序性的前提下，随机确定它们之间的拓扑联接关系，如此所得的二叉搜索树，称为由这组节点随机组成（randomly composed）。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303215301.png" style="zoom:67%;"></p><p>由n个互异节点组成的二叉搜索树，总共有：</p><script type="math/tex; mode=display">T(n)=\sum_{k=1}^n SP(k-1)\cdot SP(n-k)=Catalan(n)=\frac{(2n)!}{(n+1)!\cdot n!}</script><p>若<strong>设所有BST等概率出现</strong>，则其平均高度为$\Theta(\sqrt{n})$。</p><p>随机生成口径的$\Theta(\log n)$和随机组成口径的$\Theta(\sqrt{n})$之间就渐进意义为言有实质的差别。原因在于随机生成下，同一组关键码的不同排列所生成的二叉搜索树，未必不同，会发现中位数越早插入，树的高度越低即越平衡，而实际上越是平衡的树，被统计的次数亦越多。从这个角度看，随机生成口径有些“乐观”，高估了二叉搜索树的平均性能，因而按照随机组成口径得到的$\Theta(\sqrt{n})$更可信。</p><p>实际上按照随机组成口径统计出的平均树高，仍不足以反映树高的随机分布情况，在实际应用中，理想的随机并不常见，一组关键码往往会按照（接近）单调次序出现，树高较大的情况依然可能频繁出现。另外若<code>removeAt()</code>操作总是固定地将待删除的二度节点与其直接后继交换，则随着操作次数的增加，二叉搜索树向左侧倾斜的趋势将愈发明显。</p><h2 id="3-2-理想平衡与适度平衡"><a href="#3-2-理想平衡与适度平衡" class="headerlink" title="3.2.理想平衡与适度平衡"></a>3.2.理想平衡与适度平衡</h2><p><strong>理想平衡</strong>：</p><p>在节点数目固定的前提下，应尽可能地降低高度，相应地应尽可能使兄弟子树的高度彼此接近，即全树尽可能平衡。由n个节点组成的二叉树，高度不低于$\log_2 n$，当高度恰为$\log_2 n$时称作理想平衡，即大致相当于完全二叉树或者满树，但是“叶节点只能出现于最底部的两层”—这一条件过于苛刻。此类二叉树所占的比例极低，而随着二叉树规模的增大，这一比例还将减小，且对二叉树的动态操作很容易就破坏了这种理想操作。</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303222749.png" style="zoom:67%;"></p><p><strong>适度平衡</strong>：</p><p>若将树高限制为“渐进地不超过$O(\log n)$，称作适度平衡。适度平衡的BST称为平衡二叉搜索树（balanced binary search tree，BBST），如之后要介绍的伸展树，红黑树，kd-树等都属于BBST。</p><h2 id="3-3-等价变换"><a href="#3-3-等价变换" class="headerlink" title="3.3.等价变换"></a>3.3.等价变换</h2><h3 id="3-3-1-等价二叉搜索树"><a href="#3-3-1-等价二叉搜索树" class="headerlink" title="3.3.1.等价二叉搜索树"></a>3.3.1.等价二叉搜索树</h3><p>若两棵二叉搜索树的<strong>中序遍历序列相同</strong>，则称它们彼此等价。如下图两个由11个节点组成的相互等价的二叉搜索树，它们在拓扑关系上有差异。</p><p>等价二叉搜索树的特点可概括为：</p><ul><li><strong>上下可变</strong>：联接关系不尽相同，承袭关系可能颠倒</li><li><strong>左右不乱</strong>：中序遍历序列完全一致，全局单调非降</li></ul><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303223737.png" style="zoom:67%;"></p><h3 id="3-3-2-局部性"><a href="#3-3-2-局部性" class="headerlink" title="3.3.2.局部性"></a>3.3.2.局部性</h3><p>平衡二叉搜索树的适度平衡性，都是通过对树中每一局部增加某种限制条件来保证的。除了适度平衡性外，还具有如下局部性：</p><ul><li><p>单次动态修改操作后，至多$O(1)$处局部不再满足限制条件</p></li><li><p>可在$O( \log n)$时间内，使这些局部（以至全树）重新满足</p></li></ul><p>这就意味着刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的BBST，等价二叉搜索树之间的上述转换过程，也称作<strong>等价变换</strong>。</p><h3 id="3-3-3-旋转调整"><a href="#3-3-3-旋转调整" class="headerlink" title="3.3.3.旋转调整"></a>3.3.3.旋转调整</h3><p>最基本的等价变换方法，即修复局部性失衡的方法，就是通过围绕特定节点的旋转，实现等价前提下的局部拓扑调整。</p><p><strong>zig和zag</strong>：</p><p><img src="/2020/03/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8813%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/QQ图片20200303224651.png" style="zoom: 80%;"></p><p><strong>zig</strong>和<strong>zag</strong>旋转均属于局部操作，仅涉及常数个节点及其之间的联接关系，故均可在常数时间内完成。每经过一次<strong>zig</strong>或<strong>zag</strong>旋转之后，节点v的深度加一，节点c的深度减一；这一局部子树（乃至全树）的高度可能发生变化，但上下幅度均不超过一层。</p>]]></content>
    
    <summary type="html">
    
      二叉搜索树在形式上继承了二叉树的特点，同时也借鉴了有序向量的特点，从而能高效地兼顾静态查找与动态修改。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（13）STL</title>
    <link href="http://nekomoon404.github.io/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/"/>
    <id>http://nekomoon404.github.io/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/</id>
    <published>2020-02-28T01:37:54.000Z</published>
    <updated>2020-02-28T04:05:25.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-标准库"><a href="#1-C-标准库" class="headerlink" title="1.C++标准库"></a>1.C++标准库</h1><ul><li><p>C++ 标准库（C++ Standard Library）是一个类库和函数的集合</p><ul><li>提供了若干泛型容器、函数对象、泛型字符串和流、常用函数等</li><li>声明在 std 名字空间中  <code>using namespace std;</code></li><li>吸收了 ISO C90 C 标准程序库<br>原有的 C 标准库中的所有头文件，都移去末尾的 .h 并在开头加上 c，如 <code>&lt;stdio.h&gt;</code> 变为 <code>&lt;cstdio&gt;</code></li></ul></li><li><p>C++ 标准模板库（C++ Standard Template Library，STL）</p><ul><li>是 C++ 标准库的一个子集</li><li>包括容器、算法、迭代器和函数对象</li></ul></li></ul><p>包含标准库声明的一些头文件关系：</p><p><img src="/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/QQ图片20200228094525.png" style="zoom:80%;"></p><h1 id="2-C-标准库模板"><a href="#2-C-标准库模板" class="headerlink" title="2.C++标准库模板"></a>2.C++标准库模板</h1><ul><li><p>C++ 中主要有两个方面体现了<strong>重用</strong></p><ul><li><strong>面向对象</strong>的设计思想，包括<strong>继承</strong>和<strong>多态</strong>，以及<strong>标准类库</strong></li><li><strong>泛型程序设计</strong>（generic programming）的思想，包括<strong>模板</strong>机制，以及<strong>标准模板库（STL）</strong></li></ul></li><li><p>泛型程序设计，简单来说就是使用模板的程序设计法</p><ul><li>将一些常用的<strong>数据结构</strong>（如链表、队列、二叉树）和<strong>算法</strong>（如排序、查找）写成模板，无论数据结构里放的是什么类型的对象</li></ul></li><li><p><strong>标准模板库</strong>（Standard Template Library，<strong>STL</strong>）就是一些常用数据结构和算法模板的集合</p><ul><li>STL大致可以视为由四部分组成：<strong>容器</strong>、<strong>迭代器</strong>、<strong>算法</strong>、<strong>函数对象</strong></li></ul></li></ul><h2 id="2-1-容器"><a href="#2-1-容器" class="headerlink" title="2.1.容器"></a>2.1.容器</h2><ul><li><strong>容器</strong>是可容纳各种数据类型的数据结构<ul><li>包括<strong>顺序容器</strong>和<strong>关联容器</strong></li><li>还有一类不提供真正的用于存储元素的数据结构实现，称作<strong>容器适配器</strong></li><li>容器适配器不支持迭代器，由使用者选择合适的底层数据结构</li></ul></li></ul><p><img src="/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/QQ图片20200228111525.png" style="zoom: 67%;"></p><p><strong>在顺序容器中，元素的插入位置与元素的值无关</strong>：</p><ul><li><p><code>vector</code> （声明于 &lt; vector&gt;）</p><p>顺序表：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以自动调整大小，在尾端增删元素时具有较佳的性能</p></li><li><p><code>array</code> （C++11 中新增，声明于 &lt; array&gt;）<br>顺序表：封装了一个静态数组，只能在初始化时指定大小</p></li><li><p>deque （声明于 &lt; deque&gt;）<br>双端队列：实现了一个动态数组，可以在常数时间内完成随机存取元素，可以快速地在数组的头尾两端增删元素</p></li><li><p><code>list</code> （声明于 &lt; list&gt;）<br>双向链表：不支持随机存取，但在任何位置增删元素都能在常数时间完成</p></li><li><p><code>forward_list</code> （ C++11 中新增，声明于 <forward_list>）<br>单向链表：<code>list</code> 类的单链表版，去掉了一些操作</forward_list></p></li></ul><p><strong>在关联容器中，元素的插入位置与元素的值有关</strong>，必须按相应的排序准则来确定，在查找元素时具有非常好的性能:</p><ul><li><p><code>set</code> / <code>multiset</code> （声明于 <code>#include&lt;set&gt;</code>）</p><p>集合：实现了一棵平衡二叉搜索树，使用元素本身作为键值（key）；<code>set</code> 容器中不允许存在相同元素，<code>multiset</code> 容器中允许存在相同的元素</p></li><li><p><code>map</code> / <code>multimap</code> （声明于 <code>#include&lt;map&gt;</code>）<br>映射表：实现了一棵平衡二叉搜索树，存放的是成对的键值和数据（key / value），并根据键值对元素进行排序，可快速地根据键值来检索元素；<code>map</code> 容器中不允许存在键值相同的元素，而 <code>multimap</code> 容器中则允许</p></li><li><p>C++11 中新增的 <code>unordered_set</code> / <code>unordered_multiset</code> （声明于 &lt; unordered_set&gt;）和 <code>unordered_map</code> / <code>unordered_multimap</code> （声明于 &lt; unordered_map&gt;）<br>映射表：通过哈希表实现，功能与 <code>set</code>/<code>multiset</code> 和 <code>map</code>/<code>multimap</code> 相似，但不对键值排序</p></li></ul><p>在<strong>容器适配器</strong>中，不提供真正的用于存储元素的数据结构实现，<strong>不支持迭代器</strong>，由使用者选择合适的底层数据结构：</p><ul><li><p><code>stack</code> （声明于 <code>#include&lt;stack&gt;</code>）<br><strong>栈</strong>：是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则</p></li><li><p>queue （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>队列</strong>：插入只可以在尾部进行，删除、检索和修改只允许从头部进行，即按照先进先出的原则</p></li><li><p><code>priority_queue</code> （声明于 <code>#include&lt;queue&gt;</code>）<br><strong>优先队列</strong>：最高优先级元素总是第一个出队，可视作堆</p></li></ul><p>所有 STL 容器的<strong>共有的成员函数</strong>：</p><ul><li><p>operator <code>=</code> / <code>&lt;</code> / <code>&lt;=</code> / <code>&gt;</code> / <code>&gt;=</code> / <code>==</code> / <code>!=</code> ： 比较元素大小</p></li><li><p><code>empty()</code> ：判断容器中是否有元素</p></li><li><p><code>max_size()</code> ：容器中最多能装多少元素</p></li><li><p><code>size()</code> ：容器中的元素个数</p></li><li><p><code>swap()</code>：交换两个容器对象中的内容</p></li></ul><p><strong>只在顺序容器和关联容器中的成员函数</strong>：</p><ul><li><p><code>begin()</code>：返回指向容器中第一个元素的迭代器</p></li><li><p><code>end()</code>：返回指向容器中最后一个元素后面的位置的迭代器</p></li><li><p><code>rbegin()</code>：返回指向容器中最后一个元素的迭代器</p></li><li><p><code>rend()</code>：返回指向容器中第一个元素前面的位置的迭代器</p></li><li><p><code>erase()</code>：从容器中删除一个或几个元素</p></li><li><p><code>clear()</code>：从容器中删除所有元素</p></li></ul><p><img src="/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/QQ图片20200228112753.png" style="zoom:67%;"></p><p>除前述共同操作外，<strong>顺序容器还有以下共同操作</strong>：</p><ul><li><p><code>front()</code>：返回容器中第一个元素的引用</p></li><li><p><code>back()</code>：返回容器中最后一个元素的引用</p></li><li><p><code>push_back()</code>：在容器末尾增加新元素</p></li><li><p><code>pop_back()</code>：删除容器末尾的元素</p></li></ul><p><img src="/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/QQ图片20200228112922.png" style="zoom:67%;"></p><h2 id="2-2-迭代器"><a href="#2-2-迭代器" class="headerlink" title="2.2.迭代器"></a>2.2.迭代器</h2><p><strong>迭代器用于指向顺序容器和关联容器中的元素</strong>，实际上就是泛化的指针，有 const 和非 const 两种：</p><ul><li><p>const_iterator 对于遍历 const 容器是必需的，允许以只读方式访问容器的底层元素；</p></li><li><p>通过迭代器可以读取它指向的元素，通过非 const 迭代器还能修改其指向的元素，用法和指针类似。</p></li></ul><p>使用“<code>容器类名::iterator</code> ”或“<code>容器类名::const_iterator</code> ”<strong>声明</strong>：</p><ul><li><p>例如 <code>vector&lt;int&gt;::iterator it;</code> 或 <code>set&lt;string&gt;::const_iterator it;</code></p></li><li><p>读取元素时就可以用 <code>*it</code> 来实现</p></li></ul><p>迭代器上<strong>可以执行自增（++）操作</strong>，以指向容器中的下一个元素：</p><ul><li>如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成 <code>past-the-end</code> 值，其与 <code>NULL</code> 的含义类似。</li></ul><p>不同容器上支持的迭代器功能强弱有所不同，<strong>按功能由弱到强</strong>，可以将迭代器分为 5 种：</p><ul><li><p>输入迭代器 <strong>Input iterators</strong> 和 输出迭代器 <strong>Output iterators</strong><br>提供对数据的只读或只写访问</p></li><li><p>正向迭代器 <strong>Forward iterators</strong><br>提供读写操作，并能一次一个地向前推进迭代器</p></li><li><p>双向迭代器 <strong>Bidirectional iterators</strong><br>提供读写操作，并能一次一个地向前和向后移动</p></li><li><p>随机访问迭代器 <strong>Random access iterators</strong><br>提供读写操作，并能在数据中随机移动</p></li></ul><p>注意：<strong>强迭代器拥有弱迭代器的所有功能，能当作弱迭代器使用</strong>。</p><p><strong>不同迭代器所能进行的操作</strong>如下所示：</p><ul><li><p>所有迭代器： <code>++p</code>、<code>p++</code></p></li><li><p>输入迭代器： <code>*p</code>、<code>p = q</code>、<code>p == q</code>、<code>p != q</code></p></li><li><p>输出迭代器： <code>*p</code>、<code>p = q</code></p></li><li><p>正向迭代器： 以上所有</p></li><li><p>双向迭代器： 以上所有，以及 <code>--p</code>、<code>p--</code></p></li><li><p>随机访问迭代器： 以上所有，以及移动 <code>i</code> 个单元（<code>p += i</code>、<code>p -= i</code>、<code>p + i</code>、<code>p – i</code>）、大小比较（<code>p &lt; q</code>、<code>p &lt;= q</code>、<code>p &gt; q</code>、<code>p &gt;= q</code>）、数组下标访问<code>p[i]</code>（p 后面的第 i 个元素的引用）</p></li></ul><p><strong>容器所支持的迭代器类别</strong>如下：</p><p><img src="/2020/02/28/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89STL/QQ图片20200228114108.png" style="zoom: 67%;"></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;   <span class="comment">// 一个存放 int 型元素的向量，一开始是空的</span></span><br><span class="line">    <span class="comment">// 依次放入 1 2 3 4</span></span><br><span class="line">    v.push_back(<span class="number">1</span>);  v.push_back(<span class="number">2</span>); </span><br><span class="line">    v.push_back(<span class="number">3</span>);  v.push_back(<span class="number">4</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 使用常量迭代器打印这个容器中的元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 输出 1 2 3 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非常量迭代器修改容器中的元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator j;</span><br><span class="line">    <span class="keyword">for</span> (j = v.<span class="built_in">begin</span>(); j != v.<span class="built_in">end</span>(); ++j) *j = <span class="number">100</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 再次使用常量迭代器打印这个容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); i++) <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 输出 100 100 100 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3.算法"></a>2.3.算法</h2><p><strong>算法</strong>就是一个个<strong>函数模板</strong>，STL 中提供了能在各种容器中通用的算法，如插入、删除、查找、排序等，约有70种标准算法。算法可以处理容器，也可以处理内置类型的数组。</p><p>算法<strong>通过迭代器来操纵容器中的元素</strong>，许多算法需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。有的算法<strong>返回一个迭代器</strong>，比如 <code>find()</code> 算法，其功能是在容器中查找一个元素，并返回一个指向该元素的迭代器。</p><p>头文件 <code>#inlcude&lt;algorithm&gt;</code> 中实现了一些常见的针对序列区间的算法：包括不修改值的序列操作、修改值的序列操作、分割与合并、查找与排序、堆操作、排列相关操作等。</p><p>头文件 <code>#include&lt;numeric&gt;</code> 中则实现了一些特别针对数值序列的算法</p><ul><li><p><code>accumulate()</code>：累加一个区间中的值</p></li><li><p><code>adjacent_difference()</code>：依次计算一个区间内每一对相邻元素的差</p></li><li><p><code>inner_product()</code>：计算两个向量的内积</p></li></ul><p>下面介绍一些&lt; algorithm&gt;中实现的<strong>常见算法</strong>：</p><ul><li><p>不修改值的序列操作<br><code>for_each()</code>：遍历一个区间内的元素<br><code>find()</code>：在一个区间中进行查找指定的元素<br><code>count()</code>：在一个区间中计数指定元素<br><code>search()</code>：在一个区间中查找指定的子序列</p></li><li><p>修改值的序列操作<br><code>copy()</code>：复制一个区间的内容<br><code>swap()</code>：交换两个对象的值<br><code>replace()</code>：替换一个区间中的某个值<br><code>unique()</code>：去重，删除相邻的相同元素<br><code>random_shuffle()</code>：随机洗牌，重排区间中的元素</p></li><li><p>分割与合并<br><code>partition()</code>：将一个区间根据指定规则分割为两个<br><code>merge()</code>：将有序区间合并<br><code>set_intersection()</code>：找出两个区间中相同的元素<br><code>set_difference()</code>：找出两个区间中不同的元素</p></li><li><p>查找<br><code>binary_search()</code>：二分查找<br><code>min_element()</code>：查找最小的元素<br><code>max_element()</code>：查找最大的元素</p></li><li><p>排序<br><code>sort()</code>：用快速排序算法给一个区间中的元素排序</p></li><li><p>堆（Heap）<br><code>make_heap()</code>：根据指定序列构建堆<br><code>push_heap()</code>：向堆中插入元素<br><code>pop_heap()</code>：弹出堆顶元素</p></li><li><p>排列<br><code>next_permutation()</code>：产生指定序列的下一个排列<br><code>prev_permutation()</code>：产生指定序列的上一个排列</p></li></ul><h2 id="2-4-函数对象"><a href="#2-4-函数对象" class="headerlink" title="2.4.函数对象"></a>2.4.函数对象</h2><p><strong>函数对象即重载了操作符 () 的对象</strong>，类的实例都可以称作为函数对象，本身是对象，但是用起来看上去象函数调用，实际上也执行了函数调用。</p><p>STL 中的头文件 &lt; functional&gt; 里实现了一些函数对象类模板，例如 equal_to&lt; T&gt;、greater&lt; T&gt;、less&lt; T&gt; 等这些模板都可以用来生成函数对象。</p><p>函数对象可以包含其他成员变量或成员函数，函数对象的<strong>优点</strong>是可以在对象内部修改而不用改动外部接口，可以存储先前调用结果的数据成员，编译器可通过内联函数对象来增强性能。</p><p>例如下面声明了一个函数对象 <code>average</code> 计算均值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Average</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  <span class="comment">// 重载 () 运算符时，参数可以是任意多个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Average average;  <span class="comment">// 函数对象</span></span><br><span class="line">    <span class="comment">// 调用 average.operator(2, 3, 5)</span></span><br><span class="line">    <span class="comment">// 但是使用时看上去象普通函数调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 3.33333</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">7</span>, <span class="number">11</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 输出 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntMod</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IntMod(<span class="keyword">int</span> _p) : p(_p) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 % p &gt;= v2 % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">float</span> v1, <span class="keyword">float</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(v1) * p % <span class="number">10</span> &gt;= </span><br><span class="line">               (<span class="keyword">int</span>)(v2) * p % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//IntMod 类重载了 ()对于 int 型，比较 %p 之后的大小</span></span><br><span class="line"><span class="comment">//对于 float 型，先转换成 int 型，然后比较 *p 后 %10 的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">myMax</span>(<span class="title">T</span> *<span class="title">pV</span>, <span class="title">int</span> <span class="title">n</span>, <span class="title">IntMod</span> <span class="title">fun</span>) &#123;</span></span><br><span class="line">  T result = *pV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!fun(result, *(pV + i))) &#123;</span><br><span class="line">          result = *(pV + i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板 myMax() 寻找最大值，可以处理不同类型的数组</span></span><br><span class="line"><span class="comment">//根据 IntMod 类中定义的大小关系，找到不同类型数组中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> b[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    IntMod obj1(8), obj2(3);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMax(a, <span class="number">5</span>, obj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第一行输出对应 int 型数组 a，数组长度为 5，对 8 模后取余</span></span><br><span class="line">    <span class="comment">//即找到 %8 之后最大的整数，因此最大值是 5，输出 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMax(b, <span class="number">5</span>, obj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第二行输出对应 float 型数组 b，数组长度为5,*8后对10模后取余</span></span><br><span class="line">    <span class="comment">//即找到 *8 %10 之后最大的数，因此最大值是 12，输出 12</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMax(a, <span class="number">5</span>, obj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//第三行输出对应 int 型数组 a，数组长度为 5，对 3模后取余</span></span><br><span class="line">    <span class="comment">//即找到 %3 之后最大的整数，若有相等的情况找靠前的那个，因此最大值是 5，输出 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myMax(b, <span class="number">5</span>, obj2) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      标准模板库（Standard Template Library，STL）就是一些常用数据结构和算法模板的集合，STL大致可以视为由四部分组成：容器、迭代器、算法、函数对象。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（12）广度/深度优先搜索</title>
    <link href="http://nekomoon404.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://nekomoon404.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2020-02-26T01:31:21.000Z</published>
    <updated>2020-02-27T13:21:14.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-广度优先搜索"><a href="#1-广度优先搜索" class="headerlink" title="1.广度优先搜索"></a>1.广度优先搜索</h1><h2 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1.算法"></a>1.1.算法</h2><ul><li>始自顶点s的<strong>广度优先搜索</strong>（Breadth-First-Search）<ul><li>访问顶点s</li><li>依次访问s所有尚未访问的邻接顶点</li><li>依次访问它们尚未访问的邻接顶点</li><li>…….如此反复，直至没有尚未访问的邻接顶点</li></ul></li></ul><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226100517.png" style="zoom:80%;"></p><p>这种搜索将首先访问s，在这个图中通过将s染黑表示它已经接受了访问。接下来需要访问S所有尚未访问的邻接顶点，由s通往它的那些刚被访问的邻居的边都被加粗，这暗示着这些边都已经被算法所采纳和保留，这些边都是非常重要的，它们携带了整个遍历过程中所发现的一些信息。反过来在原图中还会有一些边并不采纳（浅色线部分）在经过广度优先遍历之后，它们将不再保留而是被舍弃掉。</p><p>这个算法将不断地如此迭代反复，直到所有的顶点都接受了访问。所谓广度优先搜索的确是一种遍历，它会按照刚才所介绍的策略确定不同顶点接受访问的次序，并且按照这种次序对各顶点逐个地访问，而整个搜索过程的最终产物或成果不过是选自原图的一系列的加粗的边。</p><p>这里按照与起点s的距离将所有的顶点划分为若干个等价类，在同一等价类内部各顶点的边都不会被采纳，而只有连接于相邻等价类之间的某些边才会被采纳。所有被保留下来并且采纳的这些边将足以把所有的顶点连接起来构成一个连通图，且它是一个<strong>极大无环图</strong>。这就相当于一棵树，这棵树中涵盖了原图的所有的顶点，所以称之为<strong>支撑树</strong>（Spanning Tree）。对于树而言，以上策略及过程完全等同于<strong>层次遍历</strong>。</p><h2 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2.实现"></a>1.2.实现</h2><p>上述的策略可以实现而这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   Queue&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">   status ( v ) = DISCOVERED; Q.enqueue ( v ); <span class="comment">//初始化起点</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在Q变空之前，不断</span></span><br><span class="line">      <span class="keyword">int</span> v = Q.dequeue(); </span><br><span class="line">  dTime ( v ) = ++clock; <span class="comment">//取出队首顶点v</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( u ) ) &#123; <span class="comment">//若u尚未被发现，则</span></span><br><span class="line">            status ( u ) = DISCOVERED; Q.enqueue ( u ); <span class="comment">//发现该顶点</span></span><br><span class="line">            status ( v, u ) = TREE; parent ( u ) = v; <span class="comment">//引入树边拓展支撑树</span></span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="comment">//若u已被发现，或者甚至已访问完毕，则</span></span><br><span class="line">            status ( v, u ) = CROSS; <span class="comment">//将(v, u)归类于跨边</span></span><br><span class="line">         &#125;</span><br><span class="line">      status ( v ) = VISITED; <span class="comment">//至此，当前顶点访问完毕</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到遍历的起点总是某个预先指定的顶点v，既然图的广度优先遍历可以视作为树的层次遍历的一种推广，所以与后者相仿这里依然借助一个队列结构来实现。在v入队之前将它的状态由最初的undiscovered转化为discovered，接下来的<code>while</code>循环每次都通过<code>dequeue()</code>取出队首的顶点并且重新命名为<code>v</code>。</p><p>请注意 在每一个顶点刚刚出队并随即接受访问的同时，我们还需要给它打上一个时间标签<code>dTime</code>，在算法的入口处还有一个名为<code>clock</code>的引用型参数，它就像是一块钟表在整个算法的运行过程中都会给出时间的进度，任何时候如果你希望加注当前的时间标签，只需要将这块表取出来并读取上面的时刻。</p><p>按照算法的策略我们需要枚举出当前节点<code>v</code>的所有邻居，通过<code>for</code>循环语句来实现，<code>firstNbr</code>以及<code>nextNbr</code>接口在上文有介绍过。</p><p>经过整个的遍历搜索过程，每一个顶点的状态都会由最初的undiscovered转化为discovered，并最终转化为visited，这样的三个状态也就构成了每一个顶点在它的生命期内的三部曲。</p><p>下面以一个无向图为例来理解算法的过程：</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226105520.png" style="zoom: 75%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226105542.png" style="zoom:75%;"></p><h2 id="1-3-全图BFS"><a href="#1-3-全图BFS" class="headerlink" title="1.3.全图BFS"></a>1.3.全图BFS</h2><p>与起始顶点s相连通的每一个顶点都会被bfs搜索、发现并访问，即s顶点所属的那个连通域确实可以被悉数的遍历。然而问题是并非每幅图都只包含一个连通域，那么在含有多个连通域的时候从任何一个起点s出发未必能够抵达其它的连通域。那么这种情况如何处理，如何使得bfs搜索足以覆盖整幅图呢，可以采用下面的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         BFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次BFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226111027.png" style="zoom:80%;"></p><p>这里毕竟引入了一层新的循环而且至少从表面看来，这个循环的迭代次数将多达线性次。但这里并非对每一个顶点都启动一轮bfs搜索，而是只有在当前的顶点能够经过这个<code>if</code>判断（顶点尚未被发现）之后才启动这样一次搜索。这种处理方式可以保证对于每一个连通域只有一个顶点可能作为起点引起它所属的那个连通域被完全的遍历掉，每一个连通域启动而且只启动一次广度优先搜索，因此所有花费在搜索上的时间累计也不过是对全图的一次遍历，而不是多次。</p><h2 id="1-4-复杂度"><a href="#1-4-复杂度" class="headerlink" title="1.4.复杂度"></a>1.4.复杂度</h2><p>广度优先搜索算法的复杂度取决于不同实现方法，尤其是图结构自身的实现算法，这里不妨就以我们的实现版本为例，算法主体的复杂度部分是由while以及for所构成的两重循环。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226112909.png" style="zoom: 80%;"></p><h2 id="1-5-最短路径"><a href="#1-5-最短路径" class="headerlink" title="1.5.最短路径"></a>1.5.最短路径</h2><p>最好来讨论BFS算法的一个特性：最短距离性。</p><p>回顾此前所介绍的树结构，相对于树根节点任何一个节点v都对应于一条唯一的通路，这条路径的长度称作顶点v的深度depth(v)，于是我们可以对所有的顶点自上而下按照它们的深度进行等价类划分，在每一个等价类中的所有顶点所具有的深度指标都是彼此相等的。而树的层次遍历也可以认为是按照这一指标非降的次序，将所有的顶点逐一枚举出来。</p><p>那么这样一个遍历的过程是否也可以转化为图结构的遍历过程呢？表面看来似乎不太容易，因为此时与树结构极不相同的就是从起始顶点s出发可能有多条路径都最后通往同一个顶点，而且可能出现分叉。然而这样一个问题不难解决，实际上我们只需考察顶点之间的最短通路，并且将这两个顶点之间的距离取作这条最短通路的长度dist(v, s)。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226115437.png" style="zoom: 33%;"></p><p>巧合的是图的BFS搜索与树的层次遍历一样都具有这样一种单调性，即BFS所给出的顶点序列按照这样到起点的距离也是按照非降次单调排列的。在我们最终所生成的BFS树中，每个顶点与s之间的那条通路恰好就是在原图中这两个顶点之间的最短通路。</p><h1 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2.深度优先搜索"></a>2.深度优先搜索</h1><h2 id="2-1-算法"><a href="#2-1-算法" class="headerlink" title="2.1.算法"></a>2.1.算法</h2><p>这一节将介绍与上一节中的广度优先搜索完全对称的另一种搜索算法：深度优先搜索。相对于此前的广度优先搜索，深度优先搜索的算法策略更为简明，然而深度优先搜索的过程更为复杂，其功能也相对而言更为强大，因此也成为有效解决很多实际问题的。</p><p>深度优先搜索的基本算法框架如下：</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227184840.png" style="zoom:80%;"></p><p>首先确定一个搜索的起点s，找到它的任意的一个邻居，并且将控制权交给这个新的顶点。接下来新的顶点一旦接过控制权，它也会仿效这种策略在它的所有邻居中任选其一，并且将控制权交给这个尚未访问的邻居。当然如果有已经被访问过的，对应的这条边将不会被采用，而是以某种适当的形式加以标注（图中以浅色线表示）。假设这个顶点已经没有任何邻居尚未访问，那么按照算法的策略，我们将在这个位置返回（回溯），顺着此前的通路回到它的前驱顶点。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227184900.png" style="zoom:80%;"></p><p>可以看到遍历的效果与此前的BFS类似，我们依然会得到一棵DFS树，也就是图中这些粗边所构成的一棵支撑树，同样地未被这棵树所采纳的那些边会被分类，而且这种分类要更为细致。</p><p>这样一个遍历和递归的过程可以实现为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   dTime ( v ) = ++clock; status ( v ) = DISCOVERED; <span class="comment">//发现当前顶点v</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视其状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED: <span class="comment">//u尚未发现，意味着支撑树可在此拓展</span></span><br><span class="line">            status ( v, u ) = TREE; parent ( u ) = v; DFS ( u, clock ); <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED: <span class="comment">//u已被发现但尚未访问完毕，应属被后代指向的祖先</span></span><br><span class="line">            status ( v, u ) = BACKWARD; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//u已访问完毕（VISITED，有向图），则视承袭关系分为前向边或跨边</span></span><br><span class="line">            status ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; fTime ( v ) = ++clock; <span class="comment">//至此，当前顶点v方告访问完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         DFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次DFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-实例（无向图）"><a href="#2-2-实例（无向图）" class="headerlink" title="2.2.实例（无向图）"></a>2.2.实例（无向图）</h2><p>下面是一个<strong>无向图的实例</strong>，每一行的3格分别代表顶点及其<code>dTime</code>和<code>fTime</code>，为了方便理解将当前顶点在图中变为大写字母。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227203130.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227203136.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227203140.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227203144.png" style="zoom:80%;"></p><h2 id="2-3-实例（有向图）"><a href="#2-3-实例（有向图）" class="headerlink" title="2.3.实例（有向图）"></a>2.3.实例（有向图）</h2><p>有向图的深度优先搜索要更为复杂，所涉及的情况也会更多。不妨来看下面的一个实例，首先确认这是一幅有向图，在这个图中我们将每一个顶点都绘制成长方形，顶点的标识居中，在它的左右空白处将分别记录下它在遍历过程中所获得的<code>dTime</code>和<code>fTime</code>两个时间标签。当前顶点用深色加粗边框表示且字母大写，被访问过的顶点用双线边框表示，处于VISITED状态的顶点用黑色方框表示。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227205627.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227205631.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227205635.png" style="zoom:80%;"></p><p>综观整个过程，我们总共用了10秒遍历完了由这五个顶点所构成的一个子图，更确切地讲它们构成了在这个图中从顶点a出发可以达到的区域，也称作<strong>可达区域</strong>。那么图中的其余部分呢？比如说这里的顶点d以及e呢？</p><p>回顾对广度优先遍历算法bfs的处理手法，就不难发现我们完全可以效仿那种做法，在这样的dfs算法之外再包装一层循环来枚举图中的所有顶点。这样的话就可以无一遗漏地遍历图中的所有顶点，而且只要处理得当对所有可达域的遍历都不会彼此有所重叠，从而在时间效率上也依然可以得到保证。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227205639.png" style="zoom:80%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227205642.png" style="zoom:80%;"></p><p>最后不妨来盘点一下遍历所获得的成果，首先是这些粗边它们构成了两棵<strong>遍历树</strong>，整体地构成了一个遍历森林；此外我们还对所有未被采纳的边进行了分类：<strong>跨越边</strong>、<strong>前向边</strong>以及<strong>后向边</strong>，无一遗漏。在通过遍历所获得的所有这些信息中遍历树或者说遍历森林无疑是最为重要的，然而相对于原图，它们毕竟只是一个子集，这样一个子集所携带的难道是原图的所有信息吗？从某种意义上讲的确是这样的，而其中至关重要的一点就在于我们通过遍历不仅获得了这样一棵树，而且为每一个顶点都标记了<code>dTime</code>和<code>fTime</code>两类时间标签，而这两类时间标签的作用是非常巨大的。</p><h2 id="2-4-括号引理-嵌套引理"><a href="#2-4-括号引理-嵌套引理" class="headerlink" title="2.4.括号引理/嵌套引理"></a>2.4.括号引理/嵌套引理</h2><p>通过深度优先搜索DFS为图中所有顶点所标注的两个时间标签<code>dTime</code>和<code>fTime</code>，实际上蕴含了大量有用的信息这一点可以由<strong>括号引理</strong>或<strong>嵌套引理</strong>来加以印证。</p><p>为此首先要引入<strong>顶点的活动期</strong>的概念，也就是由它的<code>dTime</code>和<code>fTime</code>两个时间标签所界定的那样一段时间范围，即这个顶点在整个DFS搜索过程中处于活跃状态的时间范围。嵌套引理指出任何有向图经过了DFS搜索之后，在对应的DFS森林或者DFS树中任何一对顶点之间存在直系的血缘关系，当且仅当它们的活跃期存在包含与被包含的关系。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227211634.png" style="zoom:80%;"></p><p>为了获得对这个引理更为直观的认识，我们不妨以横向作为时间轴，依然以上节的有向图为例，将每个顶点都沿水平方向适当展开使得它们恰好覆盖各自所对应的活跃期。不难看出祖先的活跃期的确会覆盖它的后代，而反过来没有直接血缘关系的节点比如说F和B，或者B和G，它们的活跃期都的确彼此没有任何公共的部分。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227210912.png" style="zoom: 60%;"></p><p>这样一种特性是非常强大的一个工具，比如在算法中我们经常需要做的一个判断就是：任意的一对顶点 <code>v</code> 和 <code>u</code> 之间在遍历树中是否存在一个直系血缘的关系。如果没有这样一种简便的机制，我们将不得不从 <code>u</code> 出发顺着<code>parent</code>引用不断地溯流而上直到遇到顶点<code>v</code>，才能够确定它们的确存在祖先和后代的直系关系；或者不得不一直追溯到整个遍历的起点，从而断定u和v之间并没有直系血缘关系。而现在借助时间标签，我们可以快速准确地在$O(1)$的时间内就得出相应的结论。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200227211039.png" style="zoom: 33%;"></p>]]></content>
    
    <summary type="html">
    
      本文针对图结构介绍其广度优先搜索与深度优先搜索算法，总体策略都是将图这种非线性结构转化为半线性结构，进而转化为线性结构进行研究 。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（11）图</title>
    <link href="http://nekomoon404.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/"/>
    <id>http://nekomoon404.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/</id>
    <published>2020-02-25T01:23:52.000Z</published>
    <updated>2020-02-25T07:59:39.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1.基本术语"></a>1.1.基本术语</h2><ul><li><p>G = ( V;  E) = ( 顶点集;  边集)</p></li><li><p><strong>顶点</strong>（vertex）：n = |V|</p><p><strong>边</strong>（edge）|弧（arc）：e = |E|</p></li><li><p><strong>邻接关系</strong>（adjacency）：定义同一条边的两个顶点之间的关系</p><p>自环（self-loop）：同一顶点自我相邻</p><p>简单图（simple graph）：不含自环，这一章讨论的都是简单图</p></li><li><p><strong>关联关系</strong>（incidence）：顶点与其所属的边之间的关系</p><p>度（degree）：于同一顶点关联的边数</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225093718.png" style="zoom:80%;"></p><p>此前所学的几种数据结构都可以视作是图的特例，比如在向量和列表等线性结构中只有互为前驱与后继的元素之间才能够定义邻接关系，而树结构中只能在父节点与子节点之间才能够定义邻接关系。</p><p>图更为一般化，其中的任何两个节点之间都允许存在这样的一个邻接关系，我们这里讨论的图排除自环的存在。</p><h2 id="1-2-无向图-有向图"><a href="#1-2-无向图-有向图" class="headerlink" title="1.2.无向图/有向图"></a>1.2.无向图/有向图</h2><ul><li><p>若关联顶点u和v次序无所谓，则(u, v)为<strong>无向边</strong>（undirected edge）</p><p>所有边均为无方向的图，即为<strong>无向图</strong>（undigraph）</p></li><li><p>反之，<strong>有向图</strong>（digraph）中均为有向边（directed edge）</p><p>u，v分别称作边(u, v)的<strong>尾</strong>（tail）、<strong>头</strong>（head）</p></li><li><p>无向边、有向边并存的图，称作<strong>混合图</strong>（mixed graph）</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225095702.png" style="zoom:80%;"></p><p>在图这一章我们关注有向图，因为通过有向图完全可以表示并且实现无向图以及混合图，简单的做法是将任何一条无向边转化为彼此对称的一对有向边。</p><h2 id="1-3-路径-环路"><a href="#1-3-路径-环路" class="headerlink" title="1.3.路径/环路"></a>1.3.路径/环路</h2><ul><li><p>路径：$\pi$ = &lt;$V_0,V_1,\dots,V_k&gt;$</p><p>长度： | $\pi$ | = k</p></li><li><p>简单路劲：$V_i=V_j$  除非$i=j$，即路劲中不含重复顶点</p></li><li><p>环/环路：$V_0=V_k$</p></li><li><p>有向无环图（DAG）</p></li><li><p>欧拉环路：| $\pi$ | = | E |，即各边恰好出现一次</p></li><li><p>哈密尔顿环路：| $\pi$ | = | V |，即各顶点恰好出现一次</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225102106.png" style="zoom: 80%;"></p><h1 id="2-基于邻接矩阵实现图结构"><a href="#2-基于邻接矩阵实现图结构" class="headerlink" title="2.基于邻接矩阵实现图结构"></a>2.基于邻接矩阵实现图结构</h1><h2 id="2-1-Graph模板类"><a href="#2-1-Graph模板类" class="headerlink" title="2.1. Graph模板类"></a>2.1. Graph模板类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EType; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span> <span class="comment">//图Graph模板类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="comment">//所有顶点、边的辅助信息复位</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//所有顶点的</span></span><br><span class="line">         status ( i ) = UNDISCOVERED; dTime ( i ) = fTime ( i ) = <span class="number">-1</span>; <span class="comment">//状态，时间标签</span></span><br><span class="line">         parent ( i ) = <span class="number">-1</span>; priority ( i ) = INT_MAX; <span class="comment">//（在遍历树中的）父节点，优先级数</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有边的</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) type ( i, j ) = UNDETERMINED; <span class="comment">//类型</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">BFS</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp; )</span></span>; <span class="comment">//（连通域）广度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp; )</span></span>; <span class="comment">//（连通域）深度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">BCC</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp;, Stack&lt;<span class="keyword">int</span>&gt;&amp; )</span></span>; <span class="comment">//（连通域）基于DFS的双连通分量分解算法</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">TSort</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp;, Stack&lt;Tv&gt;* )</span></span>; <span class="comment">//（连通域）基于DFS的拓扑排序算法</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="function"><span class="keyword">void</span> <span class="title">PFS</span> <span class="params">( <span class="keyword">int</span>, PU )</span></span>; <span class="comment">//（连通域）优先级搜索框架</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 顶点</span></span><br><span class="line">   <span class="keyword">int</span> n; <span class="comment">//顶点总数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">insert</span> <span class="params">( Tv <span class="keyword">const</span>&amp; )</span> </span>= <span class="number">0</span>; <span class="comment">//插入顶点，返回编号</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//删除顶点及其关联边，返回该顶点信息</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv&amp; <span class="title">vertex</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的数据（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">inDegree</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的入度（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">outDegree</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的出度（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">firstNbr</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的首个邻接顶点</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">nextNbr</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的（相对于顶点j的）下一邻接顶点</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> VStatus&amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">dTime</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的时间标签dTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">fTime</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的时间标签fTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">parent</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v在遍历树中的父亲</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">priority</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v在遍历树中的优先级数</span></span><br><span class="line"><span class="comment">// 边：这里约定，无向边均统一转化为方向互逆的一对有向边，从而将无向图视作有向图的特例</span></span><br><span class="line">   <span class="keyword">int</span> e; <span class="comment">//边总数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)是否存在</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">( Te <span class="keyword">const</span>&amp;, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//在顶点v和u之间插入权重为w的边e</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te <span class="title">remove</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//删除顶点v和u之间的边e，返回该边信息</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> EType &amp; <span class="title">type</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的类型</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te&amp; <span class="title">edge</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的数据（该边的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">weight</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的权重</span></span><br><span class="line"><span class="comment">// 算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//广度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//深度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bcc</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//基于DFS的双连通分量分解算法</span></span><br><span class="line">   Stack&lt;Tv&gt;* tSort ( <span class="keyword">int</span> ); <span class="comment">//基于DFS的拓扑排序算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">prim</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//最小支撑树Prim算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//最短路径Dijkstra算法</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="function"><span class="keyword">void</span> <span class="title">pfs</span> <span class="params">( <span class="keyword">int</span>, PU )</span></span>; <span class="comment">//优先级搜索框架</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-邻接矩阵与关联矩阵"><a href="#2-2-邻接矩阵与关联矩阵" class="headerlink" title="2.2.邻接矩阵与关联矩阵"></a>2.2.邻接矩阵与关联矩阵</h2><ul><li><p><strong>邻接矩阵</strong>（adjacency matrix）：用二维矩阵记录顶点之间的邻接关系，矩阵元素与图中存在的边一一对应</p><p>$A(i,  j)=1$，若顶点$i$与$j$之间存在一条边；否则为0  （可以推广到带权图，即网络）</p><p>既然只考察简单图，则对角线元素统一设置为0</p><p>空间复杂度为$\Theta(n^2)$，与图中实际的边数无关</p></li><li><p><strong>关联矩阵</strong>（incidence matrix）：用二维矩阵记录顶点与边之间的关联关系</p><p>空间复制度为$\Theta(n*e)=O(n^3)$</p><p>空间利用率 &lt; 2/n</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225103611.png" style="zoom: 60%;"></p><p>下面是几个实例：</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225105024.png" style="zoom:67%;"></p><h2 id="2-3-Vertex"><a href="#2-3-Vertex" class="headerlink" title="2.3. Vertex"></a>2.3. Vertex</h2><p>下面是顶点（vertex）的一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span> <span class="comment">//顶点对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Tv data; <span class="keyword">int</span> inDegree, outDegree;<span class="comment">//数据、出入度数</span></span><br><span class="line">   VStatus status; <span class="comment">//（如上三种）状态</span></span><br><span class="line">   <span class="keyword">int</span> dTime, fTime; <span class="comment">//时间标签</span></span><br><span class="line">   <span class="keyword">int</span> parent;   <span class="comment">//在遍历树中的父节点</span></span><br><span class="line">   <span class="keyword">int</span> priority; <span class="comment">//在遍历树中的优先级数（最短通路、极短跨边等）</span></span><br><span class="line">   Vertex ( Tv <span class="keyword">const</span>&amp; d = ( Tv ) <span class="number">0</span> ) : <span class="comment">//构造新顶点</span></span><br><span class="line">      data ( d ), inDegree ( <span class="number">0</span> ), outDegree ( <span class="number">0</span> ), status ( UNDISCOVERED ),</span><br><span class="line">      dTime ( <span class="number">-1</span> ), fTime ( <span class="number">-1</span> ), parent ( <span class="number">-1</span> ), priority ( INT_MAX ) &#123;&#125; <span class="comment">//暂不考虑权重溢出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>边（Edge）的一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EStatus; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">//边对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Te data;        <span class="comment">//数据</span></span><br><span class="line">   <span class="keyword">int</span> weight;     <span class="comment">//权重</span></span><br><span class="line">   EStatus status; <span class="comment">//（如上五种）状态</span></span><br><span class="line">   Edge ( Te <span class="keyword">const</span>&amp; d, <span class="keyword">int</span> w ) : data ( d ), weight ( w ), status ( UNDETERMINED ) &#123;&#125; <span class="comment">//构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-GraphMatrix"><a href="#2-4-GraphMatrix" class="headerlink" title="2.4. GraphMatrix"></a>2.4. GraphMatrix</h2><p>现在就可以给出基于邻接矩阵实现图结构的一种可行方式，<code>GraphMatrix</code>类派生于此前所定义的<code>Graph</code>模板类，将顶点集实现为向量结构，其长度恰好等于顶点的规模即n；将边集实现为向量的向量，相当于一个n×n的矩阵，它恰好就是此前所构思的邻接矩阵。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225113730.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> :</span> <span class="keyword">public</span> Graph&lt;Tv, Te&gt; &#123; <span class="comment">//基于向量，以邻接矩阵形式实现的图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Vector&lt; Vertex&lt; Tv &gt; &gt; V; <span class="comment">//顶点集（向量）</span></span><br><span class="line">   Vector&lt; Vector&lt; Edge&lt; Te &gt; * &gt; &gt; E; <span class="comment">//边集（邻接矩阵）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   GraphMatrix() &#123; n = e = <span class="number">0</span>; &#125; <span class="comment">//构造</span></span><br><span class="line">   ~GraphMatrix() &#123; <span class="comment">//析构</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有动态创建的</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++ ) <span class="comment">//边记录</span></span><br><span class="line">            <span class="keyword">delete</span> E[j][k]; <span class="comment">//逐条清除</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 操作接口：顶点查询、顶点修改、边查询、边修改 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们此前对向量所重载的方括号操作符<code>[]</code>，这里只需用<code>E[i][j]</code>这样一种形式即可指代在顶点<code>i</code>与 <code>j</code> 之间的一条边，既可以读出这条边的信息，也可以反过来修改其中的某些信息。</p><h2 id="2-5-顶点操作"><a href="#2-5-顶点操作" class="headerlink" title="2.5.顶点操作"></a>2.5.顶点操作</h2><p>按照这种实现方式，我们可以简明实现顶点操作中的大部分基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点的基本操作：查询第i个顶点（0 &lt;= i &lt; n）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv&amp; <span class="title">vertex</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].data; &#125; <span class="comment">//数据</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">inDegree</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].inDegree; &#125; <span class="comment">//入度</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">outDegree</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].outDegree; &#125; <span class="comment">//出度</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> VStatus&amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].status; &#125; <span class="comment">//状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">dTime</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].dTime; &#125; <span class="comment">//时间标签dTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">fTime</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].fTime; &#125; <span class="comment">//时间标签fTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">parent</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].parent; &#125; <span class="comment">//在遍历树中的父亲</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">priority</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].priority; &#125; <span class="comment">//在遍历树中的优先级数</span></span><br></pre></td></tr></table></figure><p>对于任意顶点i，如何枚举其所有的邻接顶点neighbor？为此首先需要实现一个名为<code>nextNbr</code>的接口，它的功能语义是如果我们现在已经枚举到顶点<code>i</code>的编号为 <code>j</code> 的邻居，那么它将返回接下来的下一个邻居。与顶点 <code>i</code> 潜在的可以相邻的点，无非就是它在邻接矩阵中所对应的那一行中数值为1的单元，对应于与<code>i</code>邻接的一个顶点。而第一个有效的邻居是通过<code>firstNbr</code>接口实现，它调用了<code>nextNbr</code>，将顶点<code>n</code>（并不实际存在）作为上一个有效的邻居。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225113618.png" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">nextNbr</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123;<span class="comment">//相对于顶点j的下一邻接顶点</span></span><br><span class="line">   <span class="keyword">while</span> ( ( <span class="number">-1</span> &lt; j ) &amp;&amp; ( !<span class="built_in">exists</span> ( i, --j ) ) ); <span class="comment">//逆向线性试探，O(n)</span></span><br><span class="line">   <span class="keyword">return</span> j; </span><br><span class="line">&#125;  <span class="comment">//改用邻接表可提高至O(1 + outDegree(i))</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">firstNbr</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> nextNbr ( i, n ); </span><br><span class="line">&#125; <span class="comment">//首个邻接顶点</span></span><br></pre></td></tr></table></figure><h2 id="2-6-边操作"><a href="#2-6-边操作" class="headerlink" title="2.6.边操作"></a>2.6.边操作</h2><p>同样地，利用邻接矩阵我们也可以便捷地实现很多边的基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的确认操作</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> <span class="comment">//边(i, j)是否存在</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= i ) &amp;&amp; ( i &lt; n ) &amp;&amp; ( <span class="number">0</span> &lt;= j ) &amp;&amp; ( j &lt; n ) &amp;&amp; E[i][j] != <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="comment">// 边的基本操作：查询顶点i与j之间的联边（0 &lt;= i, j &lt; n且exists(i, j)）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> EStatus &amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;status; &#125; <span class="comment">//边(i, j)的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te&amp; <span class="title">edge</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;data; &#125; <span class="comment">//边(i, j)的数据</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">weight</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;weight; &#125; <span class="comment">//边(i, j)的权重</span></span><br></pre></td></tr></table></figure><p><strong>边插入</strong>：</p><p>假设我们需要在顶点<code>i</code>与顶点<code>j</code>之间连接一条有向边，假设这条边尚不存在，那么只需要将待插入的那条边的信息比如它的权重等等，封装为一个具体的边记录，然后将这个新的边记录地址存入于邻接矩阵中对应的那个单元，也可以说这个单元将指向这个新的边记录。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225115722.png" style="zoom:60%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">( Te <span class="keyword">const</span>&amp; edge, <span class="keyword">int</span> w, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="comment">//插入权重为w的边e = (i, j)</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) <span class="keyword">return</span>; <span class="comment">//确保该边尚不存在</span></span><br><span class="line">   E[i][j] = <span class="keyword">new</span> Edge&lt;Te&gt; ( edge, w ); <span class="comment">//创建新边</span></span><br><span class="line">   e++;   <span class="comment">//更新边计数</span></span><br><span class="line">   V[i].outDegree++;  <span class="comment">//更新关联顶点i的出度</span></span><br><span class="line">   V[j].inDegree++;   <span class="comment">//更新关联顶点i的入数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>边删除</strong>：</p><p>不妨假设从顶点 <code>i</code> 通往顶点 <code>j</code> 之间存在一条边，因此在邻接矩阵中对应的那一项就非空，而且这一项将指向一个对应的边记录。为了删除这条边，只需将这条边对应的记录释放并且归还给系统，然后令在邻接矩阵中对应于这一项的引用指向空。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225152142.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Te <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="comment">//删除顶点i和j之间的联边（exists(i, j)）</span></span><br><span class="line">   Te eBak = edge ( i, j ); </span><br><span class="line">   <span class="keyword">delete</span> E[i][j]; E[i][j] = <span class="literal">NULL</span>; <span class="comment">//备份后删除边记录</span></span><br><span class="line">   e--; </span><br><span class="line">   V[i].outDegree--; </span><br><span class="line">   V[j].inDegree--; <span class="comment">//更新边计数与关联顶点的度数</span></span><br><span class="line">   <span class="keyword">return</span> eBak; <span class="comment">//返回被删除边的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-顶点插入与删除"><a href="#2-7-顶点插入与删除" class="headerlink" title="2.7.顶点插入与删除"></a>2.7.顶点插入与删除</h2><p>顶点的插入与删除相对于边的操作要更为复杂，原因在于在此前的边操作中整个矩阵的规模并不会发生变化，而顶点的插入以及稍后的删除则会改变。为了在其中引入一个新的顶点，首先要将邻接矩阵中已有的各行分别向后扩展一个单元，即增加一列；接下来针对新引入的顶点还需在邻接矩阵中增加对应的一行；当然还需在第一级的边表中增加一个相应地单元用来指示或者说记录新引入的行向量；最后对应于这个新引入的顶点还需要在顶点向量中加入一个新的对应元素。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225153304.png" style="zoom:67%;"></p><p>这样的四个步骤可以实现为这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">insert</span> <span class="params">( Tv <span class="keyword">const</span>&amp; vertex )</span> </span>&#123; <span class="comment">//插入顶点，返回编号</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) E[j].insert ( <span class="literal">NULL</span> ); n++; <span class="comment">//各顶点预留一条潜在的关联边</span></span><br><span class="line">   E.insert ( Vector&lt;Edge&lt;Te&gt;*&gt; ( n, n, ( Edge&lt;Te&gt;* ) <span class="literal">NULL</span> ) ); <span class="comment">//创建新顶点对应的边向量</span></span><br><span class="line">   <span class="keyword">return</span> V.insert ( Vertex&lt;Tv&gt; ( vertex ) ); <span class="comment">//顶点向量增加一个顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点删除就是上述步骤的逆过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Tv <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="comment">//删除第i个顶点及其关联边（0 &lt;= i &lt; n）</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有出边</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) </span><br><span class="line">         &#123; <span class="keyword">delete</span> E[i][j]; V[j].inDegree--; e--; &#125; <span class="comment">//逐条删除</span></span><br><span class="line">   E.<span class="built_in">remove</span> ( i ); n--; <span class="comment">//删除第i行</span></span><br><span class="line">   Tv vBak = vertex ( i ); V.<span class="built_in">remove</span> ( i ); <span class="comment">//删除顶点i</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有入边</span></span><br><span class="line">      <span class="keyword">if</span> ( Edge&lt;Te&gt; * x = E[j].<span class="built_in">remove</span> ( i ) ) </span><br><span class="line">         &#123; <span class="keyword">delete</span> x; V[j].outDegree--; e--; &#125; <span class="comment">//逐条删除</span></span><br><span class="line">   <span class="keyword">return</span> vBak; <span class="comment">//返回被删除顶点的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-优缺点"><a href="#2-8-优缺点" class="headerlink" title="2.8.优缺点"></a>2.8.优缺点</h2><p>邻接矩阵的<strong>优点</strong>有：</p><ul><li><p>直观，易于理解和实现</p></li><li><p>适用范围广泛：digrah / network / cyclic / …</p><p>尤其适用于稠密图（dense graph）</p></li><li><p>判断两点之间是否存在联边：$O(1)$</p></li><li><p>获取顶点的（出/入）度数：$O(1)$</p><p>添加、删除边后更新度数：$O(1)$</p></li><li><p>扩展性（scalability）：</p><p>得益于Vector良好的空间控制策略，空间溢出等情况可“透明地”予以处理</p></li></ul><p>邻接矩阵的<strong>缺点</strong>则是：</p><ul><li>空间利用率，它始终是需要$\Theta(n^2)$空间，与边数无关</li></ul><p>在实际问题中的图通常不会有$n^2$级的边数，不妨考虑下平面图（planar graph），即可嵌入平面的图，其中不相邻的边不相交。根据欧拉推导的公式：对于所有的平面图有，$v-e+f-c=1$，各字母分别表示顶点数、边数、区域面片数、连通域数。因此平面图的边数有：$e\le 3\times n-6=O(n) \ll n^2$，此时空间利用率$\approx 1/n$。而对于一般的稀疏图（sparse graph），空间利用率同样很低，因此可以采用压缩存储技术予以改进。</p>]]></content>
    
    <summary type="html">
    
      本文主要介绍图结构，相对于此前的线性结构（向量，列表）以及半线性结构（二叉树），图结构对其中元素的限定更少，因此它描述应用问题的能力也就更强
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（12）文件操作和模板</title>
    <link href="http://nekomoon404.github.io/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/"/>
    <id>http://nekomoon404.github.io/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-22T08:51:42.000Z</published>
    <updated>2020-02-25T08:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1.文件操作"></a>1.文件操作</h1><p>本节介绍如何利用C++语言来处理文件的一些操作，我们知道所有的数据在计算机上保存的时候都是具有一定的层次化的结构的，一个数据在计算机实质上被保存的就是一个个0,1的<strong>比特位</strong>，它是每位这样存放的。但是去处理每个比特位的话那么可能在很多时候这个数据在构建时就会变得非常的繁琐，并且具有很强的不规律性，所以我们进一步把这8个比特位构成的称之为<strong>字节</strong>。那么每一个byte它对应描述了一定的内容，而这些各个字节组成的一些具体的内容又称之为<strong>域</strong>或者<strong>记录</strong>。</p><ul><li><p>数据的层次：</p><ul><li>位       bit</li><li>字节   byte</li><li>域/记录</li></ul></li><li><p>把所有记录顺序地写入一个文件 $\to$ 顺序文件</p></li></ul><h2 id="1-1-文件和流"><a href="#1-1-文件和流" class="headerlink" title="1.1.文件和流"></a>1.1.文件和流</h2><ul><li><p>顺序文件：一个有限字符构成的顺序字符流</p></li><li><p>C++标准库中：<code>ifstream</code>，<code>ofstream</code>和<code>fstream</code>共3个类 $\to$ 用于文件操作，统称为文件流类。</p><ul><li><code>ifstream</code>用于将文件读取，从文件中读取数据</li><li><code>ofstream</code>用于向文件中写入数据</li><li><code>fstream</code>即可以从文件中读取数据，又可以向文件中写入数据</li></ul></li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222172254.png" style="zoom:50%;"></p><p>（图中箭头表示派生）</p><h2 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2.文件操作"></a>1.2.文件操作</h2><ul><li><p>使用/创建文件的基本流程：</p><p>1）打开文件：通过指定文件名，建立文件和文件流对象的关联；指明文件的使用方式；</p><p>2）读/写文件：利用读/写指针进行相应的操作</p><p>3）关闭文件</p></li></ul><h2 id="1-3-建立顺序文件"><a href="#1-3-建立顺序文件" class="headerlink" title="1.3.建立顺序文件"></a>1.3.建立顺序文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;  //包含头文件</span></span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"clients.dat"</span>, ios::out | ios:: binary)</span></span>;  <span class="comment">//打开文件</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222172248.png" style="zoom: 55%;"></p><ul><li>也可以先创建ofstream对象，再用open函数打开；</li><li>一般要判断打开是否成功；</li><li>文件名可以给出绝对路径，也可以给相对路径；</li><li>没有交代路径信息，就是在当前文件夹下找文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"test.out"</span>, ios::out | ios::binary);</span><br><span class="line"><span class="keyword">if</span>(!fout) &#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"File open error!"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-文件的读写指针"><a href="#1-4-文件的读写指针" class="headerlink" title="1.4.文件的读写指针"></a>1.4.文件的读写指针</h2><ul><li><p>对于输入文件，有一个读指针；</p><p>对于输出文件，有一个写指针；</p><p>对于输入输出文件，有一个读写指针；</p></li><li><p>标识文件操作的当前位置，该指针在哪里 $\to$ 读写操作就在哪里进行</p></li></ul><p><strong>写指针</strong>：（location可以为负值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"a1.out"</span>, ios::app)</span></span>;</span><br><span class="line"><span class="keyword">long</span> location = fout.tellp();    <span class="comment">//取得写指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;</span><br><span class="line">fout.seekp(location);   <span class="comment">//将写指针移动到第10个字节处</span></span><br><span class="line">fout.seekp(location, ios::beg);  <span class="comment">//从头数location</span></span><br><span class="line">fout.seekp(location, ios::cur);  <span class="comment">//从当前位置数location</span></span><br><span class="line">fout.seekp(location, ios::<span class="built_in">end</span>);  <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><p><strong>读指针</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"a1.out"</span>, ios::in)</span></span>;</span><br><span class="line"><span class="keyword">long</span> location = fin.tellg();    <span class="comment">//取得写指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;</span><br><span class="line">fin.seekg(location);   <span class="comment">//将写指针移动到第10个字节处</span></span><br><span class="line">fin.seekg(location, ios::beg);  <span class="comment">//从头数location</span></span><br><span class="line">fin.seekg(location, ios::cur);  <span class="comment">//从当前位置数location</span></span><br><span class="line">fin.seekg(location, ios::<span class="built_in">end</span>);  <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><h2 id="1-5-二进制文件读写"><a href="#1-5-二进制文件读写" class="headerlink" title="1.5.二进制文件读写"></a>1.5.二进制文件读写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">fout.seekp(<span class="number">20</span>,ios::beg);</span><br><span class="line">fout.<span class="built_in">write</span>( (<span class="keyword">const</span> <span class="keyword">char</span>*)(&amp;x), <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">fin.seekg(<span class="number">0</span>,ios::beg);</span><br><span class="line">fin.<span class="built_in">read</span>( (<span class="keyword">char</span>*)(&amp;x), <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure><ul><li>二进制文件读写，直接读/写二进制数据，记事本看未必正确</li></ul><p>例子：从键盘输入几个学生的姓名和成绩，并以二进制文件形式存起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">ofstream <span class="title">OutFile</span><span class="params">(<span class="string">"D:\\tmp\\student.dat"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s.szName &gt;&gt; s.nScore) &#123;</span><br><span class="line"><span class="keyword">if</span> (stricmp(s.szName, <span class="string">"exit"</span>) == <span class="number">0</span>)   <span class="comment">//名字为exit则结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">OutFile.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">&#125;</span><br><span class="line">OutFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222181614.png" style="zoom: 55%;"></p><p>对二进制文件来进行读写的时候最好是能够保持一致，<strong>即以二进制的形式去写入就以二进制的形式来读出</strong>。例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"student.dat"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s))) &#123;</span><br><span class="line"><span class="keyword">int</span> nReadedBytes = inFile.gcount();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">" "</span> &lt;&lt; s.nScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚才的两个例子当中介绍了如何对一个文件进行二进制形式的一个写入，或者是对一个文件具体以二进制的形式来进行读出，而在很多时候我们通常会对一个文件同时要进行读和写的操作。</p><p>例子3：将<code>student.dat</code>文件的Jane的名字改成Mike</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"D:\\tmp\\student.dat"</span>, ios::in | ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!iofile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iofile.seekp(<span class="number">2</span> * <span class="keyword">sizeof</span>(s), ios::beg);    <span class="comment">//定位写指针到第三个记录</span></span><br><span class="line">iofile.<span class="built_in">write</span>(<span class="string">"Mike"</span>, <span class="built_in">strlen</span>(<span class="string">"Mike"</span>) + <span class="number">1</span>);</span><br><span class="line">iofile.seekg(<span class="number">0</span>, ios::beg);   <span class="comment">//定位读指针到开头</span></span><br><span class="line"><span class="keyword">while</span> (iofile.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s)))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">" "</span> &lt;&lt; s.nScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">iofile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显示关闭文件（写或读之后都要显示关闭文件）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"test.dat"</span>, ios::in)</span></span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"test.dat"</span>,ios::out)</span></span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>例子4：文件拷贝，用法示例：<code>mycopy src.dat dest.dat</code>，即将<code>src.dat</code>拷贝到<code>dest.at</code>，如果<code>dest.dat</code>原来就有，则原来的文件会被覆盖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数的两个参数分别记录命令行操作相应的参数的个数以及参数对应的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"File name missing!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(argv[<span class="number">1</span>], ios::binary | ios::in)</span></span>;  <span class="comment">//打开文件用于读</span></span><br><span class="line"><span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Source file open error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(argv[<span class="number">2</span>], ios::binary | ios::out)</span></span>; <span class="comment">//打开文件用于写</span></span><br><span class="line"><span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"New file open error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">inFile.<span class="built_in">close</span>();   <span class="comment">//打开的文件一定要关闭</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> c;   <span class="comment">//仅做示例，实际文件拷贝时不会是逐字节拷贝</span></span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">get</span>(c))    <span class="comment">//每次读取一个字符</span></span><br><span class="line">outFile.<span class="built_in">put</span>(c);      <span class="comment">//每次写入一个字符</span></span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h1><p>通过模板的使用就正式开始了泛型程序程序设计这样一个模块的学习。</p><p><strong>泛型程序设计</strong>（Generic Programming）</p><ul><li>算法实现时不指定具体要操作的数据的类型；</li><li>泛型—算法实现一遍 $\to$ 适用于多种数据结构</li><li>优势：减少重复代码的编写</li><li><p>大量编写模板，使用模板的程序设计：</p><ul><li>函数模板</li><li>类模板</li></ul></li><li><p><strong>函数模板的形式</strong>：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 类型参数1, <span class="title">class</span> 类型参数2,...&gt; 返回值类型 模板名(形参表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> &amp;<span class="title">y</span>)&#123;</span></span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    Swap(n, m);     <span class="comment">//编译器自动生成 void Swap(int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    Swap(f, g);     <span class="comment">//编译器自动生成 void Swap(double &amp;, double &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数模板中可以有不止一个类型参数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T2</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数模板可以重载</strong>，只要它们的形参表不同即可，例如下面两个模板可以同时存在：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">arg1</span>. <span class="title">T</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>C++编译器遵循以下优先顺序：</p><ul><li>Step1：先找参数完全匹配的普通函数（非由模板实例化而得的函数）；</li><li>Step2：再找参数完全匹配的模板函数；</li><li>Step3：再找实参经过自动类型转换后能够匹配的普通函数；</li><li>Step4：上面的都找不到，则报错。</li></ul></li><li><p>要注意赋值兼容原则引起函数模板中类型参数的二义性</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>, <span class="number">7</span>);      <span class="comment">//ok, replace T with int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5.8</span>, <span class="number">7.8</span>);  <span class="comment">//ok, replace T with double</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>, <span class="number">7.8</span>);    <span class="comment">//error, replace T with int or double? 二义性</span></span><br></pre></td></tr></table></figure><ul><li>函数模板的类型参数可以用于函数模板的局部变量声明，也可以用于声明函数模板的返回值。</li></ul><h1 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3.类模板"></a>3.类模板</h1><ul><li><strong>类模板</strong>：在定义类的时候给它一个/多个参数，这个/些参数表示不同的数据类型；在调用类模板时，指定参数，由编译系统根据参数提供的数据类型自动产生相应的<strong>模板类</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;类型参数表&gt; <span class="class"><span class="keyword">class</span> 类模板名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>类模板里的成员函数，如在类模板外面定义时：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;型参数表&gt;</span><br><span class="line">返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1类模板的定义"><a href="#3-1类模板的定义" class="headerlink" title="3.1类模板的定义"></a><strong>3.1类模板的定义</strong></h2><ul><li>用类模板定义对象的写法如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表);</span><br></pre></td></tr></table></figure><ul><li>如果类模板有无参构造函数，那么也可以只写：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 key;</span><br><span class="line">T2 value;</span><br><span class="line">Pair(T1 k, T2 v) :key(k), value(v) &#123; &#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Pair</span>&lt;T1,T2&gt;:</span>:<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;student(<span class="string">"Tom"</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">//实例化出一个类Pair&lt;string,int&gt;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; student.key &lt;&lt; <span class="string">" "</span> &lt;&lt; student.value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>Tom 19</code></p><h2 id="3-2-使用类模板声明对象"><a href="#3-2-使用类模板声明对象" class="headerlink" title="3.2.使用类模板声明对象"></a>3.2.使用类模板声明对象</h2><ul><li>编译器由类模板生成类的过程叫<strong>类模板的实例化</strong><ul><li>编译器自动用具体的数据类型 $\to$ 替换类模板中的类型参数，生成模板类的代码</li></ul></li><li><p><strong>由类模板实例化得到的类叫模板类</strong></p><ul><li>为类型参数指定的数据类型不同，得到的模板类不同</li></ul></li><li><p>同一个类模板的两个模板类是不兼容的</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; *p;</span><br><span class="line">Pair&lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; a;</span><br><span class="line">p = &amp; a;  <span class="comment">//Wrong</span></span><br></pre></td></tr></table></figure><h2 id="3-3-函数模板作为类模板成员"><a href="#3-3-函数模板作为类模板成员" class="headerlink" title="3.3.函数模板作为类模板成员"></a>3.3.函数模板作为类模板成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">Func</span>(<span class="title">T2</span> <span class="title">t</span>)&#123;</span> <span class="built_in">cout</span> &lt;&lt; t; &#125;</span><br><span class="line">    <span class="comment">//若改为template&lt;class T&gt;将报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.Func(<span class="string">'K'</span>);  <span class="comment">//成员函数模板Func被实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：<code>K</code></p><h2 id="3-4-类模板与非类型参数"><a href="#3-4-类模板与非类型参数" class="headerlink" title="3.4.类模板与非类型参数"></a>3.4.类模板与非类型参数</h2><ul><li>类模板的参数声明中可以包括<strong>非类型参数</strong>，如<code>template&lt;class T, int elementsNumber&gt;</code><ul><li>非类型参数：用来说明类模板中的属性，且非类型参数必须实例化，<strong>实参必须是编译时常量表达式</strong></li><li>类型参数：用来说明类模板中的属性类型，成员操作的参数类型和返回值类型</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：由不同的参数生成的模板类是不同的，<code>Array&lt;int,40&gt;</code>和<code>Array&lt;int,50&gt;</code>完全是两个类，这两个类的对象之间不能互相赋值，<code>Array&lt;int,40&gt;</code>实例化后得到的模板类是一个拥有一个固定长度为5的<code>int</code>型数组的成员变量的类。</p><h2 id="3-5-类模板与继承"><a href="#3-5-类模板与继承" class="headerlink" title="3.5.类模板与继承"></a>3.5.类模板与继承</h2><ul><li>类模板派生出类模板</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200224190624.png" style="zoom: 60%;"></p><ul><li>模板类（即类模板中类型/非类型参数实例化后的类）派生出类模板</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200224190812.png" style="zoom: 50%;"></p><ul><li>普通类派生出类模板</li><li>模板类派生出普通类</li></ul><h2 id="3-6-类模板与静态成员"><a href="#3-6-类模板与静态成员" class="headerlink" title="3.6.类模板与静态成员"></a>3.6.类模板与静态成员</h2><p>类模板中可以定义静态成员：</p><ul><li>从该类模板实例化得到的模板类的所有对象都包含同样的静态成员</li></ul><p>例如，声明一个类模板<code>A</code>，有一个静态成员变量<code>count</code>用于计数，有一个静态成员函数<code>printCount()</code>用于输出计数结果。由类模板 <code>A</code> 实例化的两个模板类 <code>A&lt;int&gt;</code> 和 <code>A&lt;double&gt;</code> 各自拥有一个名为 <code>count</code> 的静态成员变量，和一个名为 <code>printCount()</code> 的静态成员函数。<code>A&lt;int&gt;</code> 和 <code>A&lt;double&gt;</code> 是不同的模板类，不能共享静态成员变量 <code>count</code>，因而需要分别初始化。在声明了 1 个 <code>A&lt;int&gt;</code> 对象和 2 个 <code>A&lt;double&gt;</code> 对象之后，<code>A&lt;int&gt;::count</code> 的值变为 1，<code>A&lt;double&gt;::count</code> 的值变为 2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; ++count; &#125;</span><br><span class="line">    ~A() &#123; --count; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) &#123; ++count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">int</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> A&lt;<span class="keyword">double</span>&gt;::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; ia;</span><br><span class="line">    A&lt;<span class="keyword">double</span>&gt; da1, da2;</span><br><span class="line">    ia.printCount();         <span class="comment">// 输出 1</span></span><br><span class="line">    A&lt;<span class="keyword">double</span>&gt;::printCount(); <span class="comment">// 输出 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-类模板与友元"><a href="#3-7-类模板与友元" class="headerlink" title="3.7.类模板与友元"></a>3.7.类模板与友元</h2><p>类模板与友元大致分为四种情况：</p><ul><li><strong>函数、类、类的成员函数作为类模板的友元</strong></li></ul><p>例如，下面的代码中声明了一个类模板 <code>C</code>，可以将普通函数 <code>func1()</code> 声明为 <code>C</code> 的友元，使得 <code>func1()</code> 可以访问 <code>val</code>；还可以将普通类 <code>A</code> 声明为类模板 <code>C</code> 的友元；也可以将普通类 <code>B</code> 的成员函数 <code>func2()</code> 声明为类模板 C 的友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> B::func2();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(T _val) : val(_val) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">C&lt;<span class="keyword">int</span>&gt; c1(<span class="number">4</span>);</span><br><span class="line">C&lt;<span class="keyword">double</span>&gt; c2(<span class="number">2.8</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; c1.val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">void</span> B::func2() &#123; <span class="built_in">cout</span> &lt;&lt; c2.val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数模板作为类模板的友元</strong></li></ul><p>例如，下面声明了重载流运算符的两个函数模板为类模板 <code>Array</code> 的友元，两个函数模板的具体实现如下，作为友元可以访问 <code>size</code> 和  <code>ptrElement</code> ，分别用于依次读入和输出数组中的每个元素。声明 <code>Array&lt;int&gt;</code> 对象 <code>a</code> 时，自动生成了类模板 <code>Array&lt;int&gt;</code>，并根据两个函数模板自动重载了对应的流运算符：<br><code>istream &amp;operator &gt;&gt; (istream &amp;, Array&lt;int&gt; &amp;)</code><br><code>ostream &amp;operator &lt;&lt; (ostream &amp;, const Array&lt;int&gt; &amp;)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">    T1 *ptrElement;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> _size = <span class="number">0</span>) : <span class="built_in">size</span>(_size) &#123;</span><br><span class="line">ptrElement = <span class="keyword">new</span> T1[_size];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Array() &#123; <span class="keyword">delete</span>[] ptrElement; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">istream</span> &amp;<span class="title">operator</span> &gt;&gt; (<span class="title">istream</span> &amp;, <span class="title">Array</span>&lt;T2&gt; &amp;);</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">ostream</span> &amp;<span class="title">operator</span> &lt;&lt; (ostream &amp;, const Array&lt;T3&gt; &amp;);</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">template&lt;class T2&gt;</span></span><br><span class="line"><span class="class">istream &amp;operator &gt;&gt; (<span class="title">istream</span> &amp;<span class="title">s</span>, <span class="title">Array</span>&lt;T2&gt; &amp;<span class="title">a</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        s &gt;&gt; *(a.ptrElement + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span> &amp;<span class="title">operator</span> &lt;&lt; (ostream &amp;s, const Array&lt;T3&gt; &amp;a) &#123;</span></span><br><span class="line"><span class="class">    for (int i = 0; i &lt; a.size; ++i) &#123;</span></span><br><span class="line"><span class="class">        s &lt;&lt; *(a.ptrElement + i) &lt;&lt; " ";</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    return s;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">int main()&#123;</span></span><br><span class="line"><span class="class">    Array&lt;int&gt; a(5);</span></span><br><span class="line"><span class="class">    cin &gt;&gt; a;</span></span><br><span class="line"><span class="class">    // 若输入 1 2 3 4 5</span></span><br><span class="line"><span class="class">    cout &lt;&lt; a;</span></span><br><span class="line"><span class="class">    // 则输出 1 2 3 4 5</span></span><br><span class="line"><span class="class">    return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>函数模板作为类的友元</strong></li></ul><p>例如下面的普通类 <code>A</code> 和 <code>B</code> 都将 <code>print()</code> 函数模板声明为自己的友元，根据函数模板自动生成 <code>print(const A &amp;)</code> 和 <code>print(const B&amp;)</code> 来分别输出类 <code>A</code> 的 <code>int</code> 型私有成员变量 <code>v</code> 和类 <code>B</code> 的 <code>double</code> 型私有成员变量 <code>v</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> _v = <span class="number">3</span>) : v(_v) &#123; &#125;   </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">T</span> &amp;);</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">double</span> _v = <span class="number">2.1</span>) : v(_v) &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">T</span> &amp;);</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> v; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> <span class="keyword">double</span> v; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">const</span> <span class="title">T</span> &amp;<span class="title">p</span>) &#123;</span> <span class="built_in">cout</span> &lt;&lt; p.v &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;  <span class="built_in">print</span>(a);  <span class="comment">// 输出 3</span></span><br><span class="line">    B b;  <span class="built_in">print</span>(b);  <span class="comment">// 输出 2.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类模板作为类模板的友元</li></ul><p>例如下面的类模板 B 将类模板 A 声明为了自己的友元，在声明 b 对象时，自动生成模板类 <code>B&lt;int&gt;</code>；在声明 a 对象时，则自动生成模板类 <code>A&lt; B&lt;int&gt; &gt;</code>。由于 <code>B&lt;int&gt;</code> 声明了模板类 <code>A</code> 类为自己的友元，因此 <code>A&lt; B&lt;int&gt; &gt;</code> 对象 <code>a</code> 可以通过 <code>func()</code> 访问并输出 <code>B&lt;int&gt;</code> 对象 <code>b</code> 的私有成员变量 <code>v</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> T &amp;p)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; p.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    T v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(T _v) : v(_v) &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">class</span> <span class="title">A</span>;</span>  <span class="comment">// 把类模板 A 声明为友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>&gt; b(<span class="number">5</span>);</span><br><span class="line">    A&lt; B&lt;<span class="keyword">int</span>&gt; &gt; a; </span><br><span class="line">    <span class="comment">// 用 B&lt;int&gt; 替换 A 中的 T</span></span><br><span class="line">    a.func(b);  <span class="comment">// 输出 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板的一个综合示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(T* array_) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = array_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T s = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">            s += <span class="built_in">array</span>[i];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b1[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    A&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; a1 = b1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//输出：2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> b2[<span class="number">5</span>] = &#123;<span class="number">4.2</span>, <span class="number">0.0</span>, <span class="number">3.1</span>, <span class="number">2.7</span>, <span class="number">5.2</span>&#125;;</span><br><span class="line">    A&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; a2 = b2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2.sum() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：15.2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> b3[<span class="number">4</span>] = &#123;<span class="string">"Hello"</span>, <span class="string">", "</span>, <span class="string">"world"</span>, <span class="string">"!"</span>&#125;;</span><br><span class="line">    A&lt;<span class="built_in">string</span>, <span class="number">4</span>&gt; a3 = b3;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a3.sum() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：Hello, world!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-string类"><a href="#4-string类" class="headerlink" title="4. string类"></a>4. string类</h1><p><code>string</code>类本身是一个模板类，而它本身其实是由一个类模板实例化得到的，<code>string</code>类是一个非常好用的类库，在很多字符串处理的场合都会用到<code>string</code>类。</p><p>与<code>string</code>类有关的一些函数：</p><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200228094959.png" style="zoom:80%;"></p><h2 id="4-1-基础操作"><a href="#4-1-基础操作" class="headerlink" title="4.1.基础操作"></a>4.1.基础操作</h2><ul><li><code>string</code>类是一个模板类，它的定义为：<code>typedef basic_string&lt;char&gt;string</code>;</li><li>使用<code>string</code>类要包含头文件：<code>#include&lt;string&gt;</code></li><li><code>string</code>对象的初始化，<code>string</code> 类提供了多种构造函数：<ul><li>可以根据字符串常量（<code>const char *</code>）来构造 <code>string</code> 对象</li><li>也可以指定字符串长度和填充的字符来构造 <code>string</code> 对象</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;   <span class="comment">//一个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">S2</span><span class="params">(<span class="number">8</span>,<span class="string">'x'</span>)</span></span>;     <span class="comment">//两个参数的构造函数</span></span><br><span class="line"><span class="built_in">string</span> month = <span class="string">"March"</span>;</span><br></pre></td></tr></table></figure><ul><li>不提供以字符和整数为参数的构造函数，以下都是错误的初始化方法：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> error = <span class="string">'c'</span>;   <span class="comment">//错</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">error2</span><span class="params">(<span class="string">'u'</span>)</span></span>;   <span class="comment">//错</span></span><br><span class="line"><span class="built_in">string</span> error3 = <span class="number">22</span>;   <span class="comment">//错</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">error4</span><span class="params">(<span class="number">8</span>)</span></span>;     <span class="comment">//错</span></span><br></pre></td></tr></table></figure><ul><li>可以将字符赋值给string对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s = <span class="string">'n'</span>;</span><br></pre></td></tr></table></figure><ul><li>构造的string对象太长而无法表达 $\to$ 会抛出<code>length_error</code>异常</li><li><code>string</code>对象的长度用成员函数<code>length()</code>读取：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.length() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>string</code>支持流读取运算符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> stringObject;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; stringObject;</span><br></pre></td></tr></table></figure><ul><li><code>string</code>支持<code>getline</code>函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);</span><br></pre></td></tr></table></figure><h2 id="4-2-string的赋值和连接"><a href="#4-2-string的赋值和连接" class="headerlink" title="4.2. string的赋值和连接"></a>4.2. string的赋值和连接</h2><ul><li>用’<code>=</code>‘赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1("cat"), s2;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure><ul><li>用<code>assign</code>成员函数复制，也可以部分复制</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("catpig"), s2, s3;</span><br><span class="line">s2.assign(s1);</span><br><span class="line">s3.assign(s1,<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">//从s1中下标为1的字符开始复制3个字符给s3</span></span><br></pre></td></tr></table></figure><ul><li>单个字符复制：<code>s2[5] = s1[3] = &#39;a&#39;;</code></li><li>逐个访问string对象中的字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.at(i) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><p>成员函数<code>at</code>会做范围检查，如果超出范围，会抛出<code>out_of_range</code>异常，而下标运算符不做范围检查</p></li><li><p>用 <code>+</code> 运算符<strong>连接字符串</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("good"), s2("morning");</span><br><span class="line">s1 += s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;</span><br></pre></td></tr></table></figure><ul><li>用成员函数append连接字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1("good"), s2("morning");</span><br><span class="line">s1.append(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;  <span class="comment">//输出goodmorning</span></span><br><span class="line">s2.append(s1,<span class="number">3</span>,s1.<span class="built_in">size</span>());  <span class="comment">//s1.size()返回s1的字符数，</span></span><br><span class="line"><span class="comment">//取下标从3开始，s1.size()个字符，如果字符串内没有足够字符，则复制到字符串的最后一个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2;  <span class="comment">//输出morningd</span></span><br></pre></td></tr></table></figure><ul><li>子串：成员函数<code>substr()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span></span><br><span class="line"><span class="function">s2 </span>= s1.substr(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//从下标4开始5个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：o wor</span></span><br></pre></td></tr></table></figure><h2 id="4-3-比较string"><a href="#4-3-比较string" class="headerlink" title="4.3.比较string"></a>4.3.比较string</h2><ul><li>可以用关系运算符比较string对象的大小，==，&gt;，&gt;=，&lt;，&lt;=，!=，利用字符在字典中的顺序进行比较，且对字母的大小写敏感，返回值都是bool类型，成立返回true，否则返回false。</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200225184157.png" style="zoom: 67%;"></p><ul><li>也可以使用成员函数 <code>compare(string)</code> 比较字符串大小，返回值为 <code>int</code> 型<ul><li>若当前对象比被比较的对象（即括号中的对象）大，则返回 1；若相等则返回 0 ；若比被比较的对象小，则返回 -1。</li><li>比较原则为逐字符比较；若前面的字符全部相等，则较长的字符串大。</li></ul></li><li>也可以使用成员函数 <code>compare(int, int, string)</code> 或 <code>compare(int, int, string, int, int)</code> 比较两个子串的大小，返回值为 int 型。<ul><li>比较规则与 compare(string) 相同</li><li>使用时依次指定子串的起始位置和长度即可</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1("Alice"), s2("Bob");</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"Alice and Bob"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2.compare(s1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 'B' &gt; 'A'，"Bob" 比 "Alice" 大，输出 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.compare(s3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// s1 是 s3 的一个前缀，s3 比 s1 大，输出 -1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2.compare(<span class="number">0</span>, <span class="number">3</span>, s3, <span class="number">10</span>, <span class="number">3</span>); <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="comment">// (s2[0..2] = "Bob") == (s3[10..12] = "Bob")</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-寻找string中的字符"><a href="#4-4-寻找string中的字符" class="headerlink" title="4.4.寻找string中的字符"></a>4.4.寻找string中的字符</h2><ul><li>成员函数<code>find()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>lo</code>第一次出现的地方，如果找到，返回<code>lo</code>开始的位置，即<code>l</code>所在的位置下标；如果找不到，返回<code>string::nps</code>(<code>string</code>中定义的静态常量)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">"lo"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>rfind()</code>，如下例在<code>s1</code>中<strong>从后向前查找</strong><code>lo</code>第一次出现的地方，如果找到，返回<code>lo</code>开始的位置，即<code>l</code>所在的位置下标；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.rfind(<span class="string">"lo"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_first_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>abcd</code>中任何一个字符第一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_first_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_last_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>abcd</code>中任何一个字符最后一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_last_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_first_not_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找不在</strong><code>abcd</code>中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_first_not_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_last_not_of()</code>，如下例在<code>s1</code>中<strong>从后向前查找不在</strong><code>abcd</code>中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_last_not_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200225185829.png" style="zoom:67%;"></p><h2 id="4-5-替换string的字符"><a href="#4-5-替换string的字符" class="headerlink" title="4.5.替换string的字符"></a>4.5.替换string的字符</h2><ul><li>成员函数<code>erase()</code>，删除字符串中指定位置及以后的内容；缺省值为 0 ，即清除字符串的所有内容（变成一个空串 “” ）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">s1.erase(<span class="number">5</span>);  <span class="comment">//去掉下标5及之后的字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.length();  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">size</span>();    <span class="comment">//输出：hello55</span></span><br></pre></td></tr></table></figure><ul><li>成员函数find()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello worlld"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//分别从下标1,2,3开始查找ll，输出：2;2;9</span></span><br></pre></td></tr></table></figure><ul><li>成员函数<code>replace(int, int, string)</code>将字符串中的某一段替换为指定子串，前两个参数指定需要替换的起始位置和长度，第三个参数是进行替换的子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">s1.replace(<span class="number">2</span>,<span class="number">3</span>,<span class="string">"haha"</span>);   <span class="comment">//将s1中从下标2开始的3个字符换成"haha"</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;   <span class="comment">//输出hehaha world</span></span><br><span class="line"></span><br><span class="line">s1.replace(<span class="number">2</span>,<span class="number">3</span>,<span class="string">"haha"</span>,<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//将s1中从下标2开始的3个字符换成"haha"中下标1开始的2个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;   <span class="comment">//输出heha world</span></span><br></pre></td></tr></table></figure><h2 id="4-6-在string中插入字符"><a href="#4-6-在string中插入字符" class="headerlink" title="4.6.在string中插入字符"></a>4.6.在string中插入字符</h2><ul><li>成员函数<code>insert()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"show insert"</span>)</span></span>;</span><br><span class="line">s1.insert(<span class="number">5</span>,s2);     <span class="comment">//将s2插入s1下标5的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：helloshow insert world</span></span><br><span class="line">s1.insert(<span class="number">2</span>,s2,<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//将s2中下标5开始的3个字符插入s1下标2的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：heinslloshow insert world</span></span><br></pre></td></tr></table></figure><ul><li>可以使用成员函数 <code>push_back(char)</code> 在字符串末尾增加一个字符；C++11 标准中还增加了成员函数 <code>pop_back()</code> ，可以用来删除字符串中的最后一个字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">    s.push_back(<span class="string">'A'</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 输出 ABCDEFG</span></span><br></pre></td></tr></table></figure><h2 id="4-7-将string转换成C语言式"><a href="#4-7-将string转换成C语言式" class="headerlink" title="4.7.将string转换成C语言式"></a>4.7.将string转换成C语言式</h2><ul><li>成员函数<code>c_str()</code>，返回传统的<code>const char*</code>类型字符串，且该字符串以’<code>\0</code>‘结尾；<code>data()</code>也可以，但不会在字符串末尾增加结束符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s1.c_str());  <span class="comment">//输出：hello world</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = s1.data();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);   <span class="comment">// 输出 Hello world</span></span><br></pre></td></tr></table></figure><ul><li>C++11 中提供了 <code>std::to_string()</code> 函数，可以将 <code>int</code> / <code>unsigned int</code> / <code>float</code> / <code>double</code> 等数值转换为 <code>string</code> 对象，效果与 C 语言中的 <code>%i</code> / <code>%u</code> / <code>%f</code> / <code>%lf</code> 等相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">string</span> s = to_string(x);</span><br><span class="line">    s += <span class="string">" "</span> + to_string(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 42 3.140000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文的内容包括：文件操作，函数模板，类模板，string类
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（10）二叉树的遍历</title>
    <link href="http://nekomoon404.github.io/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://nekomoon404.github.io/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-21T03:42:13.000Z</published>
    <updated>2020-02-22T04:27:41.943Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次。</p><p>$T=V\cup L \cup R=\{root\} \cup L_ subtree(T) \cup R _ subtree(T)$</p></li><li><p>遍历结果  ~  遍历过程  ~  遍历次序  ~ 遍历策略</p><ul><li>先序遍历：<strong>V</strong>  |  L  |  R</li><li>中序遍历：L  |  <strong>V</strong>  |  R</li><li>后序遍历：L  |  R  |  <strong>V</strong></li><li>层次遍历：自上为下，先左后右</li></ul></li></ul><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221115804.png" style="zoom: 80%;"></p><h1 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h1><h2 id="1-1递归"><a href="#1-1递归" class="headerlink" title="1.1递归"></a>1.1递归</h2><p>以上三种典型的遍历策略都不难实现，因为它们的定义本身就是<strong>递归式的</strong>，以先序遍历为例，只需四句就可以实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_R</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（递归版）</span></span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">visit(x-&gt;data);</span><br><span class="line">travPre_R(x-&gt;lc, visit);</span><br><span class="line">travPre_R(x-&gt;rc, visit);</span><br><span class="line">&#125;  <span class="comment">//T(n) = O(1) + T(a) + T(n-a-1) = O(n)</span></span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是线性的，即$O(n)$，然而这只具有渐近的意义。在实际的运行过程中，因为递归程序的实现机制，并不可能做到针对具体的问题来量体裁衣，而只能采用通用的方法。在运行栈中尽管每一个递归实例都的确只对应于一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。而针对于具体的问题，只要我们能够进行精巧的设计，完全是可以使得每一帧做到足够小的，尽管从big O的意义上讲，这两种策略所对应的每一帧都可以认为是常数，但是这种常数的差异实际上是非常巨大的。</p><p>因此作为树算法的一个重要基石，遍历算法非常有必要<strong>从递归形式改写为迭代形式</strong>，同时经过这样的改写之后，我们也可以对整个遍历算法的过程以及原理获得更加深刻的认识。稍加观察不难发现此处的两句递归调用都非常类似于<strong>尾递归</strong>，其特征是递归调用出现在整个递归实例体的尾部，这种递归是非常容易化解为迭代形式的，为此我们只需<strong>引入一个栈</strong>。</p><h2 id="1-2-迭代（版本1）"><a href="#1-2-迭代（版本1）" class="headerlink" title="1.2.迭代（版本1）"></a>1.2.迭代（版本1）</h2><p>改写之后的第一个跌打版本，如这段代码所示，作为初始化取一个栈s用以存放树节点的位置，即它们的引用。首先将当前的树根<code>x</code>推入栈中，以下进入一个主体的循环，每一次弹出当前的节点并且随即对它进行访问，此后如果当前这个节点拥有右孩子就将右孩子推入栈中，如果有左孩子 那么左孩子也会随后入栈，此后整个循环又进入下一步迭代直到整个栈变空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#1）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">if</span> (x) S.push(x); <span class="comment">//根节点入栈</span></span><br><span class="line"><span class="keyword">while</span> (!S.empty()) &#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">x = S.pop(); visit(x-&gt;data); <span class="comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span></span><br><span class="line"><span class="keyword">if</span> (HasRChild(*x)) S.push(x-&gt;rc); <span class="keyword">if</span> (HasLChild(*x)) S.push(x-&gt;lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>左右孩子的入栈次序是先右后左</strong>，这是因为包括先序遍历在内的所有遍历，都先遍历左子树再去遍历右子树，在这个算法模式中既然<strong>每个节点都是在被弹出栈的时刻才接受访问</strong>，所以根据<strong>栈后进先出</strong>的特性，自然应该将希望后出栈的右子树先入栈了。</p><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221164625.png" style="zoom: 50%;"></p><ul><li><p>正确性：</p><ul><li><p>无遗落：每个节点都会被访问到</p><p>归纳假设：若深度为d的节点都能被正确访问到，则深度为d+1的也是</p></li><li><p>根先：对于任一子树，根被访问后才会访问其他节点</p><p>只需注意到：若u是v的真祖先，则u必先于v被访问到</p></li><li><p>左先右后：同一节点的左子树，限于右子树被访问</p></li></ul></li><li><p>效率：$O(n)$</p><ul><li>每步迭代，都有一个节点出栈并被访问；</li><li>每个节点入/出栈一次仅且一次；</li><li>每步迭代只需$O(1)$时间。</li></ul></li></ul><p>可以看到算法所输出的节点序列恰好就是我们所希望得到的先序遍历序列，第一个迭代版算法非常简明，然而遗憾的是这种算法策略并不容易直接推广到此后要研究的中序遍历和后序遍历算法，因此我们或许应该另辟蹊径寻找其它等效的策略。</p><h2 id="1-3-迭代（版本2）"><a href="#1-3-迭代（版本2）" class="headerlink" title="1.3.迭代（版本2）"></a>1.3.迭代（版本2）</h2><p>不妨从一个规模略大同时更具一般性的例子入手：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221165937.png" style="zoom:50%;"></p><p>可以发现这样一个规律：一旦树根节点接过控制权并接受访问，接下来被访问的就是它的左孩子以及左孩子的左孩子，以及同样地，当不能下去的时候才会进行一次新的转移，而每转移到一个具体的局部，做的事情都是尝试着沿着这样的一个左孩子的分支不断地下行。</p><p>对于任何一棵子树，都将起始于树根的接下来总是沿着左侧孩子分支不断下行的这样一条链称作是当前这棵子树的<strong>左侧链</strong>，而这个算法就是沿着这个左侧链逐渐展开。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221170918.png" style="zoom:50%;"></p><ul><li>沿着左侧分支：各节点与其右孩子（可能为空）一一对应；</li><li>从宏观上，整个遍历过程可划分为：<strong>自上而下对左侧分支的访问</strong>，及随后<strong>自下而上对一系列右子树的遍历</strong>；</li><li>不同右子树的遍历相互独立，自成一个子任务。</li></ul><p>新版本的迭代算符首先需要实现一个标准的例程<code>visitAlongLeftBranch</code>，它的任务就是来实现从根节点开始沿着left branch 不断下行，依次访问沿途所有节点的这样一个过程。</p><p>这个主算法则是反复地在每一个局部调用<code>visitAlongLeftBranch</code>这个例程来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongVine</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">visit(x-&gt;data); <span class="comment">//访问当前节点</span></span><br><span class="line">S.push(x-&gt;rc); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line">x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">visitAlongVine(x, visit, S); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line"><span class="keyword">if</span> (S.empty()) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line">x = S.pop(); <span class="comment">//弹出下一子树的树根</span></span><br><span class="line">&#125;  <span class="meta">#pop = #push = #visit = O(n) = 分摊O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之所以使用一个栈而不是队列的用意，依然是因为栈的后进先出的特性，对于左侧链的访问的是自上而下的，存入栈中的右子树也就是自上而下的，而接着对右子树的遍历是自下而上的，对栈来说就是自顶向底的，对栈的一系列依次的<code>pop</code>操作则恰好可以实现栈中右子树的自顶向底的访问。</p><p>下面看一个实例：（^代表空）</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221172902.png" style="zoom:50%;"></p><h1 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1.递归"></a>2.1.递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_R</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（递归版）</span></span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">travIn_R(x-&gt;lc, visit);</span><br><span class="line">visit(x-&gt;data);</span><br><span class="line">travIn_R(x-&gt;rc, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222093308.png" style="zoom:50%;"></p><p>将递归转换为迭代的难点在于尽管右子树的递归遍历是尾递归，但左子树却严格地不是。解决方法可是是：找到第一个被访问的节点，将其祖先用栈保存，这样原问题就分解为依次对若干棵子树的遍历问题。</p><h2 id="2-2迭代"><a href="#2-2迭代" class="headerlink" title="2.2迭代"></a>2.2迭代</h2><p>同样从一个规模略大同时更具一般性的例子入手：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222093741.png" style="zoom: 33%;"></p><p>与先序遍历非常类似，整个中序遍历过程是从根节点开始，一直沿着左侧分支逐层向下，直到末端不能再向下的那个节点，因此可以将整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理。我们可以将任何一棵二叉树抽象地规范为如下图所示的形式，整棵树可以分解为一条起自根节点的左侧链以及左侧链上各节点所对应的右孩子。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222094715.png" style="zoom:33%;"></p><p>在一个局部，当前节点$L_{d-1}$将控制权交给并访问它的左孩子$L_d$后，再遍历$L_d$的右子树$T_d$，然后回到并访问节点$L_{d-1}$，再遍历其右子树$T_{d-1}$，如此反复直到遍历全树。在这样的一个过程中存在着某种逆序性，我们最初的起点是在根节点处可是首先接受访问的却是它所对应的左侧链的末端节点，如果说这个的过程是自顶而下的话，那么各节点实际被访问的次序大体而言是呈一种自下而上的过程，因此仍然要使用栈结构来实现这一过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123; S.push(x); x = x-&gt;lChild; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">goAlongLeftBranch(x, S); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line"><span class="keyword">if</span> (S.empty()) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">x = S.pop();     <span class="comment">//x的左子树或为空，或已遍历（等效于空），故可以</span></span><br><span class="line">visit(x-&gt;data);  <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line">x = x-&gt;rChild;   <span class="comment">//转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222100937.png" style="zoom: 40%;"></p><p>我们知道递归的版本可以简明地实现$O(n)$的复杂度，尽管它的常系数非常之大，那么迭代版本的时间复杂度仍是$O(n)$，但常系数要小的多（分摊分析）。尽管单次调用<code>goAlongLeftBranch</code>就可能需要做$\Omega(n)$次入栈操作需要$\Omega(n)$时间，但这些左侧链的长度加起来也不过是n，因此迭代算法的复杂度仍是线性的，即$O(n)$。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222101806.png" style="zoom: 50%;"></p><p>此外还要其他版本的中序遍历的迭代实现，如版本2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( x ) &#123;</span><br><span class="line">         S.push ( x ); <span class="comment">//根节点进栈</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !S.empty() ) &#123;</span><br><span class="line">         x = S.pop(); <span class="comment">//尚未访问的最低祖先节点退栈</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该祖先节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//遍历祖先的右子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//遍历完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从左子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本4：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I4</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历（迭代版#4，无需栈或标志位）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) <span class="comment">//若有左子树，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问当前节点，并</span></span><br><span class="line">         <span class="keyword">while</span> ( !HasRChild ( *x ) ) <span class="comment">//不断地在无右分支处</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">return</span>; <span class="comment">//回溯至直接后继（在没有后继的末节点处，直接退出）</span></span><br><span class="line">            <span class="keyword">else</span> visit ( x-&gt;data ); <span class="comment">//访问新的当前节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//（直至有右分支处）转向非空的右子树</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-层次遍历"><a href="#3-层次遍历" class="headerlink" title="3.层次遍历"></a>3.层次遍历</h1><p>我们此前讨论的有根有序树，任何一棵二叉树都被指定了一个特殊的节点：根节点，由此就可以在垂直方向按照深度将所有节点划分为若干个等价类，因此可以认为所谓的<strong>有根性对应的就是垂直方向的次序。</strong></p><p>进一步地位于同一深度也属于同一等价类内部的所有节点，即所有的同辈节点也可以分出次序，比如对于二叉树可以通过左右的明确定义给出同辈节点之间的相对次序，因此可以认为<strong>有序给出沿水平方向的一个次序</strong>。</p><p>因此按照垂直方向和水平方向的次序可以在所有的节点之间定义一个整体的次序，并进而对它进行遍历。自高向低而在每一层自左向右逐一地访问树中的每一个节点的遍历策略及过程就是<strong>层次遍历</strong>。</p><p>此前的三种遍历策略：先序、中序和后序都无法保证所有节点严格地按照深度次序访问，都有后代限于祖先被访问的情况，即逆序，为此需要借助栈结构。反过来，在层次遍历中，所有节点的访问都满足顺序性，因此这里就需要借助与栈结构对称的<strong>队列结构</strong>。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222102518.png" style="zoom:50%;"></p><p>具体实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line">   Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line">   Q.enqueue ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">      BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lChild ); <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rChild ); <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222110506.png" style="zoom:50%;"></p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222110653.png" style="zoom:45%;"></p><h1 id="4-重构"><a href="#4-重构" class="headerlink" title="4.重构"></a>4.重构</h1><p>由任何一棵二叉树我们都可以导出三个序列：先序(preorder)、中序(inorder)和后序(postorder)遍历序列，这三个序列的长度相同，它们都是由树中的所有节点依照对应的遍历策略所确定的次序依次排列而成。那么如果我们已知某棵树的遍历序列，是否可以还原出这棵树的拓扑结构？什么情况下可以？什么情况下不可以？如果可以具体又应该使用什么样的方法？</p><p>关于二叉树重构的第一个结论是：<strong>只需中序遍历序列再加上先序与后序遍历序列之一</strong>，即可还原二叉树的完整拓扑结构。</p><p>用<strong>数学归纳</strong>来证明：假设对于规模小于大N的所有二叉树这个规律都是成立的，接下来考察规模恰好为N的二叉树。在先序遍历序列中可以地将左子树和右子树所对应的遍历子序列切分开。这样就将原来全树的重构问题化解为两棵子树的重构问题，这两棵子树在规模上都符合归纳假设，即它们都严格地小于大N，因此根据归纳假设无论是左子树还是右子树都可以重构出来。</p><p>当然你应该不难写出一个递归式的重构算法，需要特别注意的是无论是左子树还是右子树，都有可能是空树，在这种情况下树的规模应该是零。而<strong>不借助中序遍历序列</strong>而只凭借先序和后序遍历序列，是不能保证完成对左右子树的正确切分的。因为无论是L还是R都有可能是空树，在先序遍历或者后序遍历的表达中<strong>会出现歧义</strong>，我们无法根据先序遍历序列以及后序遍历序列来区分在这种情况下除去根节点之后的部分究竟是左子树还是右子树。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222115137.png" style="zoom: 60%;"></p><p><strong>在某些特定情况下</strong>由先序和后序遍历序列也可以还原树的整体结构。比如对于<strong>真二叉树</strong>，每个节点的度数都必须是偶数，即0度或2度，此时的左子树和右子树要么同时为空要么同时非空。</p><p>在任何给定的先序遍历序列中都可以找到其左子树L，进而在后序遍历序列中对它进行定位，而这个节点在它所属的这棵子树的后序遍历子序列中必然垫后，这就意味着我们可以明确地界定左右子树的范围，即左子树由哪些节点构成以及右子树由哪些节点构成都是可以确定的。</p><p>当然对称地在后序遍历序列中，右子树的树根位置也是确定的，因此通过右子树的树根节点依然可以反过来在先序遍历序列中进行定位，而且同样地可以确定左右子树的切分位置。也就是说我们在这里<br>确实可以进行分而治之从而通过递归的形式，完整地重构出一棵真二叉树原本的结构。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222122643.png" style="zoom: 60%;"></p>]]></content>
    
    <summary type="html">
    
      二叉树的相关算法也往往需要对其中的元素按照某种次序来逐一访问，本文要介绍的遍历就是按照某种原则在二叉树的所有节点之间定义某种明确的线性次序，从而将半线性结构转换为我们已熟悉的线性结构的问题。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（11）虚函数和多态</title>
    <link href="http://nekomoon404.github.io/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://nekomoon404.github.io/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</id>
    <published>2020-02-20T10:03:49.000Z</published>
    <updated>2020-02-22T10:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><h2 id="1-1-虚函数"><a href="#1-1-虚函数" class="headerlink" title="1.1.虚函数"></a>1.1.虚函数</h2><ul><li>在类的定义中，前面有virtual 关键字的成员函数就是虚函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> base::<span class="built_in">get</span>() &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>virtual 关键字只用在类定义里的函数声明中，写函数体时不用。</li><li>构造函数和静态成员函数不能是虚函数。</li><li>虚函数和普通函数的本质区别在于虚函数可以参与多态，而普通成员函数不能。</li><li>派生类中和基类中虚函数同名同参数表的函数，不加<code>virtual</code>也自动成为虚函数。</li></ul><h2 id="1-2-多态的表现形式一"><a href="#1-2-多态的表现形式一" class="headerlink" title="1.2.多态的表现形式一"></a>1.2.多态的表现形式一</h2><ul><li>派生类的指针可以赋给基类<strong>指针</strong>。</li><li>通过基类指针调用基类和派生类中的同名虚函数时：<ul><li>若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul></li><li>这种机制就叫作<strong>多态</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hi"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Woof!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *pa)</span> </span>&#123; pa-&gt;sayHi(); &#125;  <span class="comment">// 使用基类指针调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Animal a; Dog d;</span><br><span class="line">func(&amp;a);  <span class="comment">// 指向基类对象，则输出 Hi</span></span><br><span class="line">func(&amp;d);  <span class="comment">// 指向派生类对象，则输出 Woof!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-多态的表现形式二"><a href="#1-3-多态的表现形式二" class="headerlink" title="1.3.多态的表现形式二"></a>1.3.多态的表现形式二</h2><ul><li>派生类的指针可以赋给基类<strong>引用</strong>。</li><li>通过基类引用调用基类和派生类中的同名虚函数时：<ul><li>若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数；</li><li>若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul></li></ul><p>不加<code>virtual</code>，就根据指针，引用的类型来决定调用基类还是派生类的函数；加<code>virtual</code>，就是虚函数，就根据指针所指，引用所引的类型来决定调用基类还是派生类的函数。派生类的函数与基类的虚函数同名且参数列表完全相同时才能体现多态性，因此<strong>一般应该禁止重新定义继承而来的非虚函数</strong>。</p><p>在多层继承的情况下，从定义<code>virtual</code>开始的派生类中同名函数均为虚函数，无论在这些派生类的同名函数中是否显示加<code>virtual</code>。如果派生类将基类中的某个非虚函数声明为虚函数，使用基类指针调用该函数时，不能体现多态。</p><p>当基类指针指向派生类对象时，会优先选择符合多态的派生类成员函数。</p><h1 id="2-多态程序实例"><a href="#2-多态程序实例" class="headerlink" title="2.多态程序实例"></a>2.多态程序实例</h1><h2 id="2-1-例1几何形体处理程序"><a href="#2-1-例1几何形体处理程序" class="headerlink" title="2.1.例1几何形体处理程序"></a>2.1.例1几何形体处理程序</h2><p>几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出。输出时要指明形状。</p><p><strong>输入Input</strong>：第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母c开头</p><p>若 c 是 ‘R’，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高；</p><p>若 c 是 ‘C’，则代表一个圆，本行后面跟着一个整数代表其半径；</p><p>若 c 是 ‘T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。</p><p><strong>输出Output</strong>：按面积从小到大依次输出每个几何形体的种类及面积，每行一个几何形体，输出格式为：形体名称：面积</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221210752.png" style="zoom:67%;"></p><p>类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各成员函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Rectangle::Area() &#123;</span><br><span class="line"><span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Rectangle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Circle::Area() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Triangle::Area() &#123;</span><br><span class="line"><span class="keyword">double</span> p = (a + b + c) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(p*(p - a)*(p - b)*(p - c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个指向<code>Shape</code>基类的指针数组<code>pShapes</code>来存放各个几何形体，数组中的每一个元素都是基类指针，因此它可以指向不同派生类的对象。<code>MyCompare</code>函数比较两个几何形体面积的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shape * pShapes[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * s1, <span class="keyword">const</span> <span class="keyword">void</span> * s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> a1, a2;</span><br><span class="line">Shape **p1;         <span class="comment">//s1,s2是void*，不可写 *s1 来取得s1指向的内容</span></span><br><span class="line">Shape **p2;</span><br><span class="line">p1 = (Shape**)s1;   <span class="comment">//s1,s2指向Shapes数组中的元素，数组元素的类型是Shape*</span></span><br><span class="line">p2 = (Shape**)s2;   <span class="comment">//故p1,p2都是指向指针的指针，类型为Shae**</span></span><br><span class="line">a1 = (*p1)-&gt;Area(); <span class="comment">//*p1的类型是Shape*，是基类指针，故此句为多态</span></span><br><span class="line">a2 = (*p2)-&gt;Area();</span><br><span class="line"><span class="keyword">if</span> (a1 &lt; a2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a2 &lt; a1)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">int</span> n;</span><br><span class="line">Rectangle *pr;  Circle *pc;  Triangle *pt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>R<span class="number">'</span>:</span><br><span class="line">pr = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h;</span><br><span class="line">pShapes[i] = pr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>C<span class="number">'</span>:</span><br><span class="line">pc = <span class="keyword">new</span> Circle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pc-&gt;r ;</span><br><span class="line">pShapes[i] = pc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>T<span class="number">'</span>:</span><br><span class="line">pt = <span class="keyword">new</span> Triangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c;</span><br><span class="line">pShapes[i] = pt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(pShapes, n, <span class="keyword">sizeof</span>(Shape*), MyCompare); <span class="comment">//按指针指向的几何形体的面积从小到大排序</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">pShapes[i]-&gt;PrintInfo();  <span class="comment">//多态，根据pShapes[i]指向的对象调用其对应的成员函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用多态来实现这个问题所带来的好处就是<strong>提高了程序的可扩充性</strong>，如果要添加新的几何形体如五边形，则只需要从Shape里派生出<code>Pentagon</code>，以及在<code>main</code>函数中的<code>swtich</code>语句中增加一个<code>case</code>，其余部分不变。</p><ul><li>用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常见的做法。</li></ul><h2 id="2-2-例2"><a href="#2-2-例2" class="headerlink" title="2.2.例2"></a>2.2.例2</h2><p>再看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; fun2(); &#125; <span class="comment">//等价于 this-&gt;fun2，fun2是虚函数，所以这句是多态</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base * pBase = &amp;d;</span><br><span class="line">pBase-&gt;fun1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序运行的结果是<code>Derived::fun2()</code>，而不是<code>Base::fun2()</code>。这是因为<code>pBase-&gt;fun1</code>指至<code>pbase</code>是指向一个派生类的对象<code>d</code>的，那进到<code>fun1</code>里面，<code>this</code>指针指向的东西自然也就是这个<code>d</code>，所以此时<code>this</code>指针指向的是一个派生类的对象，那么根据多态的原则这条语句就会调用派生类的<code>fun2</code>，也就是<code>Derieved</code>类的<code>fun2</code>，所以会输出<code>Derieved</code>的<code>fun2</code>，即<code>Derived::fun2()</code>。</p><p>成员函数中调用虚函数有这样的规则：</p><ul><li><p><strong>在非构造函数，非析构函数的成员函数中调用虚函数，是多态</strong>。</p></li><li><p><strong>在构造函数和析构函数中调用虚函数，不是多态</strong>。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from myclass"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from myclass"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span><span class="keyword">public</span> myclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类中和基类中虚函数同名同参数表的函数，不加`virtual`也自动成为虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">son() &#123; hello(); &#125;;</span><br><span class="line">~son() &#123; bye(); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">grandson gson;</span><br><span class="line">son *pson;</span><br><span class="line">pson = &amp;gson;</span><br><span class="line">pson-&gt;hello();  <span class="comment">//多态</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221223531.png" style="zoom:80%;"></p><h1 id="3-多态实现原理"><a href="#3-多态实现原理" class="headerlink" title="3.多态实现原理"></a>3.多态实现原理</h1><p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫“<strong>动态联编</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:Print"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived:Print"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Base) &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="keyword">sizeof</span>(Derived);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出结果为：8,12。那么为什么这个对象的大小都多出了4个字节呢？</p><p><strong>多态实现的关键——虚函数表</strong>：</p><p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的4个字节就是用来放虚函数表的地址的。</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221230451.png" style="zoom:67%;"></p><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221230814.png" style="zoom:60%;"></p><p>多态在提高程序可扩充性时也会有一定的代价：多态程序在运行期间会有额外的时间和空间上的开销，即时间上编译时会查询虚函数表，空间上每个有虚函数的类的对象里都会多出4个字节来存放虚函数表的地址。</p><p>需要注意的是，在构造函数和析构函数中调用虚函数时，调用的是自己的类或基类中定义的函数，不会等到运行时才决定，因此不是动态联编。在普通成员函数中调用虚函数，才是动态联编，是多态。</p><h1 id="4-虚析构函数"><a href="#4-虚析构函数" class="headerlink" title="4.虚析构函数"></a>4.虚析构函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~son() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">son *pson;</span><br><span class="line">pson = <span class="keyword">new</span> grandson;</span><br><span class="line"><span class="keyword">delete</span> pson;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序运行会输出<code>bye from son</code>，<code>pson</code>这个基类的指针指向了派生类的对象，当<code>delete pson</code>后会引起一些问题，直观上看因为<code>delete</code>掉的是一个基类的指针，所以会去调用基类的析构函数。但是逻辑上讲这个指针本身又指向的是一个派生类的对象，那么分配的也是一个派生类对应的这样的一个内存空间，那么这时它应该调用的还有派生类的析构函数，但是目前的程序设计角度上来看编译器是不会知道它需要调用派生类的机构函数的，这样可能导致一些问题。</p><p>我们希望做的是：</p><ul><li>通过基类的指针删除一个派生类的对象时，先调用派生类的析构函数，再调用基类的析构函数。</li></ul><p>解决方法是：</p><ul><li>把基类的析构函数声明为<code>virtual</code>，派生类的析构函数virtual可以不进行声明。</li><li>类如果定义了虚函数，则最好将析构函数也定义成虚函数。</li><li>注意：<strong>不允许以虚函数作为构造函数</strong></li></ul><p>一般来说，如果一个类中定义了虚函数，则应该将析构函数也定义成虚函数；同理，若一个类没有定义虚函数，但需要通过基类的指针销毁派生类对象，也应该将析构函数声明为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~son() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">son *pson;</span><br><span class="line">pson = <span class="keyword">new</span> grandson;</span><br><span class="line"><span class="keyword">delete</span> pson;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200222161223.png" style="zoom:80%;"></p><h1 id="5-纯虚函数和抽象类"><a href="#5-纯虚函数和抽象类" class="headerlink" title="5.纯虚函数和抽象类"></a>5.纯虚函数和抽象类</h1><ul><li>纯虚函数：没有函数体的虚函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;   <span class="comment">//错误，A是抽象类，不能创建对象</span></span><br><span class="line">    A *pa; <span class="comment">//正确，可以定义抽象类的指针和引用</span></span><br><span class="line">    pa = <span class="keyword">new</span> A; <span class="comment">//错误，A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象类：包含纯虚函数的类</p><ul><li>抽象类只能作为基类来派生新类使用；</li><li><strong>不能创建抽象类的对象</strong>；</li><li>抽象类的指针和引用 $\to$ 由抽象类派生出来的类的对象。</li></ul></li><li><p>在抽象类中：</p><ul><li>在成员函数内可以调用纯需函数；</li><li>在构造函数/析构函数内部不能调用纯虚函数</li></ul></li><li>如果一个类从抽象类派生而来 $\to$ 它实现了基类中的所有纯需函数，才能成为非抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123; <span class="keyword">this</span>-&gt;f(); &#125;   <span class="comment">//ok</span></span><br><span class="line">    A() &#123; f();&#125;  <span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B:f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;  <span class="comment">//将虚函数“实例化”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.g();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>B:f()</code></p>]]></content>
    
    <summary type="html">
    
      多态提供了一种根据指针/引用指向的对象类型来决定调用的函数的机制，通过虚函数来实现。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（9）二叉树</title>
    <link href="http://nekomoon404.github.io/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-20T01:11:42.000Z</published>
    <updated>2020-02-21T03:31:16.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h1><p>回顾之前所学的向量结构（Vector）和列表结构（List），对于以查找为代表的静态操作和以插入为代表的动态操作，两者都无法兼顾静态和动态的高效性。而本章要介绍的树结构恰好能将二者的优势结合起来，即可快速查找，又可以快速插入和删除。树可以理解为列表的列表，或二维的列表。树并不是严格意义上的线性结构，但又带有一定的线性特征，因此树可以被称为半线性结构。</p><p>树是用来按照<strong>层次关系</strong>组织一系列数据项的一种方式，如：表达式、文件系统、函数调用和递归过程、Internet URL等等。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220093704.png" style="zoom:50%;"></p><h2 id="1-1-有根树"><a href="#1-1-有根树" class="headerlink" title="1.1.有根树"></a>1.1.有根树</h2><ul><li><p>树是特殊的图<strong>T = ( V, E)</strong>，可以认为树是定义在一组元素之间的二元关系，节点（<strong>Vertex</strong>）数 <strong>|V| = n</strong>，边（<strong>edge</strong>）数 <strong>|E| = e</strong>。</p></li><li><p>为树指定任一节点 r $\in$ V作为根后，树T 即称作<strong>有根树（rooted tree）</strong>。</p></li></ul><p>对于任何一组有根树都可以通过引入一个新的顶点，并且在新的这个顶点与此前各棵有根树的树根之间引入对应的一条连边，从而构成一棵规模更大的有根树，这棵新的有根树的树根就是所引入的这个新的节点，通常记作r，暗示着它就是root树根。而对于这棵更大的树，参与组成它的每一棵有根树都相对地称作是它的<strong>子树subtree</strong>。</p><ul><li>若：$T_1,T_2,\dots ,T_d$是有根树，则：$T=\left( (\cup V_i)\cup\{r\},\,(\cup E_i)\cup\{<r,r_i>|1\le i\le d\}  \right)$也是有根树。</r,r_i></li><li>相对于$T$，$T_i$称作以$r_i$为根的子树（subtree rooted at $r_i$），记作$T_i$ = subtree( $r_i$ )。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220095521.png" style="zoom: 40%;"></p><h2 id="1-2-有序树"><a href="#1-2-有序树" class="headerlink" title="1.2.有序树"></a>1.2.有序树</h2><ul><li><p>$r_i$称作$r$的<strong>孩子（child）</strong>，$r_i$之间互称<strong>兄弟（sibling）</strong>；</p><p>$r$为其<strong>父亲（parent）</strong>，d = degree( r )为$r$的（出）<strong>度</strong>（degree）。</p></li><li><p>可归纳证明： e（节点数总和）= $\sum_{r\in V}degree(r)$ = n - 1 = $\Theta(n)$，即任何<strong>一棵树中的边数与其中顶点的数目是同阶的</strong>，一棵树的总体规模也可度量为( n + e )，故在衡量相关复杂度时，可以n作为参照。</p></li><li>若指定$T_i$为$T$的第$i$棵子树，$r_i$作为$r$的第$i$个孩子（即在兄弟间定义了次序），则$T$称作<strong>有序树（ordered tree）</strong>。</li></ul><h2 id="1-3-连通与无环"><a href="#1-3-连通与无环" class="headerlink" title="1.3.连通与无环"></a>1.3.连通与无环</h2><p>上面从递归嵌套的角度定义了树，但我们并没有看到树结构相对于一般的图结构而言在拓扑上到底有什么不同。那么接下来将从<strong>连通性</strong>和<strong>无环性</strong>两个角度来揭示树结构的特性。</p><ul><li><p>V中的k+1个节点，通过E中的k条边依次相连，构成一条<strong>路径（path）</strong>：</p><p>$\pi=\{ \, (V_0,V_1),\, (V_1,V_2),\,\dots,\,(V_{k-1},V_k)\,    \}$</p></li><li><p><strong>路径长度</strong>：$|\pi|=$边数$=k$</p></li><li><p>任意节点之间均有路径的图，称作<strong>连通图（connected graph）</strong></p><p>若$V_k=V_0$，则该路径是<strong>环路（cycle/loop）</strong>，不含环路的图，称作<strong>无环图（acyclic graph）</strong>。</p></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220101809.png" style="zoom:40%;"></p><ul><li>树结构是<strong>无环连通图</strong>，即是极小连通图，也是极大无环图。</li><li>故在树中，<strong>任一节点V与根之间存在唯一路径</strong>，故可记 path(v, r) = path(v)</li><li>因此可以|path(v)|为指标，对所有节点做等价类划分。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220102245.png" style="zoom:50%;"></p><h2 id="1-4-深度与层次"><a href="#1-4-深度与层次" class="headerlink" title="1.4.深度与层次"></a>1.4.深度与层次</h2><ul><li>在不致歧义的情况下，路径、节点和子树可相互指代： path(v) ~ v ~ subtree(v)</li><li>v的<strong>深度</strong>：depth(v) = |path(v)|</li><li>path(v)上的节点均为v的<strong>祖先（ancestor）</strong>，v是它们的<strong>后代（descendent）</strong>；除v自身以外的祖先，是<strong>真</strong>（proper）祖先。</li><li><strong>在任一深度：v的祖先若存在则必然唯一；v的后代未必唯一</strong>。从这个意义上讲也应该将数称为半线性结构。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220103816.png" style="zoom:40%;"></p><ul><li>根节点是所有节点的（公共）祖先，深度为0；没有后代的节点称作叶子（leaf）。</li><li>所有叶子深度中的最大者称为子树的高度：height(v) = height( subtree( v ) )；注意与树根的高度（height(T))区分开。</li><li>特别低，只有一个节点的树的高度为1，空树的高度为-1。</li><li>depth( v )  +  height( v )  $\le$  height( T )</li></ul><h1 id="2-树的表示"><a href="#2-树的表示" class="headerlink" title="2.树的表示"></a>2.树的表示</h1><p>上一节介绍了树的基本概念，这一节将来讨论在计算机中如何从逻辑上来表示一棵树，从抽象数据类型的角度来看树结构应该提供大致如下这些接口：</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220105128.png" style="zoom:40%;"></p><h2 id="2-1-父节点"><a href="#2-1-父节点" class="headerlink" title="2.1.父节点"></a>2.1.父节点</h2><ul><li>除根外，任一节点有且仅有一个父节点。</li></ul><p>不妨将所有的节点组织为一个序列：其中的每一个元素都分别包括三项，data是节点本身的信息，rank或者position指明的是这个节点的记录在这个序列中所对应的秩或者是位置，而parent恰好就是节点唯一的父节点所对应的秩或者是位置。树根也有一个“虚构的”父节点-1或NULL。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220110308.png" style="zoom:40%;"></p><ul><li>空间性能：$O(n)$</li><li>时间性能：<ul><li>​          <code>parent()</code>：$O(1)$</li><li>​              <code>root()</code>：$O(n)$或$O(1)$</li><li><code>firstChild()</code>：$O(n)$</li><li><code>nextSibling()</code>：$O(n)$</li></ul></li></ul><p>这样做有一定的好处，不幸的是如果要向下索取某个节点的后代比如长子，依然需要去遍历所有的元素并且逐一地确认它的父节点是否就是当前查询的元素，这个基本操作在最坏情况下需要线性时间$O(n)$；而查找兄弟节点也是类似的在最坏情况下需要遍历整棵树。因此我们下一步改进自然就集中在这两种向下方向的查询上。</p><h2 id="2-2-孩子节点"><a href="#2-2-孩子节点" class="headerlink" title="2.2.孩子节点"></a>2.2.孩子节点</h2><p>不妨对于任何一个节点都将它的孩子汇聚起来构成一个更小的数据集，为<strong>每一个节点准备一个名为children的引用，所指向的是由它的所有的孩子构成的一个序列</strong>，如使用<strong>列表</strong>来实现这个序列，列表的长度分别等于对应节点当前的度数。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220111335.png" style="zoom: 50%;"></p><p>这个方法解决了向下的查找问题，而向上的查找优势却丧失殆尽，不难发现为了查找某一个节点的父亲不得不去遍历整个线性序列，并且逐一地翻看它所对应的孩子记录，在最坏的情况下仍需要线性时间$O(n)$。</p><h2 id="2-3-父节点-孩子节点"><a href="#2-3-父节点-孩子节点" class="headerlink" title="2.3.父节点+孩子节点"></a>2.3.父节点+孩子节点</h2><p>如果将刚才的两个线性的序列组合起来，即对于同一个节点不仅保留它的parent域，同时还要保留它的children这样的一个引用，那么刚才两个方向的优势是可以兼而有之的。如果要去查找父亲就在parent这一列中进行查找，需要$O(1)$的时间；如果要是去查找孩子，就在children所指向的序列中再去查找，若是长子就可在$O(1)$的时间内直接返回，若是其它的孩子最多是去遍历序列。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220112749.png" style="zoom:50%;"></p><p>但这种方法仍有一些不足：每一个节点的children引用所指向的序列在规模上有可能相差极其悬殊，每一个序列的长度恰好是节点对应的出度，而出度的总和为$\sum_{r\in V}degree(r)$ = n - 1 = $\Theta(n)$，与n同阶。而这种组织方式有时需要长达$O(n)$的一个数据集，为此需要找到一些新的办法，更加规范并相应也更简洁和高效。</p><h2 id="2-4-长子-兄弟"><a href="#2-4-长子-兄弟" class="headerlink" title="2.4.长子+兄弟"></a>2.4.长子+兄弟</h2><p>反观上小节方法存在根源在于每一个节点的出度是不尽相同的，为进行改进我们必须发现每个节点所具有的某种不变性。就向下的引用而言每一个节点只需记两个信息就够了，第一个就是它的长子，第二个是每一个节点的下一个兄弟。</p><ul><li>每个节点均设两个引用：<ul><li>纵向：<code>firstChild()</code></li><li>横向：<code>nextSibling()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220113446.png" style="zoom:50%;"></p><ul><li>如此，对于度数为d的节点，可在$O(n+1)$时间内遍历其所有孩子</li><li>若再设置parent引用，则<code>parent()</code>接口也仅需$O(1)$时间</li></ul><p>相对于此前的表示方法，这种表示方法的规整性非常的突出，由于每个节点只需记录两个引用，因此其点所需要占用的空间依然是常数，，而且都彼此接近，这是此前的常规方法所无法比拟的。</p><p>这种长子兄弟法不仅是树的一种很好的表示方法，而且也是对树的本质的一种更深刻的理解，在此后介绍二叉树<br>并且用二叉树来代表所有的树的时候，我们将再次用到这样一种表示方法。对于树这样的一个全集来说尽管二叉树只是它的一个特殊的子集，但是很有趣的是在施加了某些条件之后，二叉树却足以来表示和实现所有的树，而这样一种方法背后的原理在很大程度上就是基于长子兄弟法。</p><h1 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3.二叉树"></a>3.二叉树</h1><p>这一节介绍树的一种特殊但又不失代表性的特例：二叉树（binary tree）</p><ul><li><p><strong>节点数不超过2</strong>的树，称作二叉树</p></li><li><p>同一节点的孩子和子树，均以左、右区分（隐含着有序性）</p><ul><li><code>lChild()</code>  ~  <code>lSubtree()</code></li><li><code>rChild()</code>  ~  <code>rSubtree()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115144.png" style="zoom:40%;"></p><h2 id="3-1-基数"><a href="#3-1-基数" class="headerlink" title="3.1.基数"></a>3.1.基数</h2><ul><li>二叉树中深度为k的节点至多$2^k$个</li><li>含n个节点、高度为h的二叉树中有：$h&lt;n&lt;2^{h+1}$<ul><li>当 $n=h+1$时，退化为一条单链</li><li>当$n=2^{h+1}-1$时，称作满二叉树（full binary tree）</li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115551.png" style="zoom:40%;"></p><p>由此也可见一棵二叉树在横向上的宽度与它在纵向上的高度是呈一个指数的关系的，宽度是高度的指数，而指数意味着爆炸（剧烈的增长），所以如果节点的总数固定，宽度大致与它相当，但是高度却会增长的非常的缓慢呈一个对数的形式。也就是说对于一棵二叉树而言，它非常倾向于“涨宽”，它“涨宽”的速度更快，而它的高度呢如果控制得当的话会增长的异常的缓慢，这个特点也是之后介绍的二叉搜索树的重要理论基础。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115646.png" style="zoom:40%;"></p><h2 id="3-2-真二叉树"><a href="#3-2-真二叉树" class="headerlink" title="3.2.真二叉树"></a>3.2.真二叉树</h2><p>上面介绍的二叉树只对每个节点的出度做了个上限的约定，即不得超过2。这样一般性的一棵二叉树在很多操作，包括算法的实现以及对算法的理解上都会引来一些不必要的麻烦。而反过来一个比较有效的改进方法就是将任何的这样一棵一般性的二叉树转化为一棵<strong>真二叉树（proper binary tree）</strong>。</p><ul><li>通过引入$n_0+n_2$个外部节点，可是原有节点度数同一为2，如此即可将任一二叉树转化为真二叉树。</li><li>经过转换之后，从渐进意义上，全树自身的<strong>复杂度并未实质增加</strong>。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220120456.png" style="zoom:40%;"></p><p>在之后实现相应的算法的时候就会看到这种添加实际上完全是假想的，即并不需要真正去引入节点，只需要假想着它们存在，你的算法就可以更加简洁的实现而且更加简洁的被理解。</p><h2 id="3-3-描述多叉树"><a href="#3-3-描述多叉树" class="headerlink" title="3.3.描述多叉树"></a>3.3.描述多叉树</h2><p>接下来来介绍这一节最重要的一点：<strong>如何通过二叉树来描述多叉树</strong>。其实上需要的条件只有两条：<strong>有根</strong>和<strong>有序</strong>。</p><ul><li>二叉树是多叉树的特例，但在<strong>有根</strong>且<strong>有序</strong>时其描述能力却足以覆盖后者；</li><li>即任意有根有序的多叉树均可转换为二叉树——回顾“长子-兄弟”表示法；</li><li>为此只需将节点处旋转45度，将长子，兄弟与左、右孩子等效地相互对应：<ul><li><code>firstChild()</code>       ~    <code>lChild()</code></li><li><code>nextSibling()</code>    ~   <code>rChild()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220121855.png" style="zoom: 80%;"></p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220121900.png" style="zoom:67%;"></p><p>如果说这一章的任务是描述并且实现以及利用树结构的话，不如说我们只需研究并且实现二叉树。接下来几节将介绍二叉树结构的实现和相关的算法。</p><h1 id="4-二叉树实现"><a href="#4-二叉树实现" class="headerlink" title="4.二叉树实现"></a>4.二叉树实现</h1><p>在此前的几节先后介绍了树的概念，了解了树的特点，并且懂得了如何来表示一棵树。最重要的方法就是借助二叉树来表示任何一棵有根有序树，所以接着就来介绍如何在C++语言中实现一棵二叉树。</p><h2 id="4-1-BinNode模板类"><a href="#4-1-BinNode模板类" class="headerlink" title="4.1.BinNode模板类"></a>4.1.BinNode模板类</h2><p>二叉树的基本组成单位是<strong>二叉树节点（Binary Node， 或简称BinNode）</strong>，每一个BinNode的逻辑组成可以用下图来表示。每一个BinNode节点首先应该有一个data域，记录它携带的信息，这是BinNode节点的核心的要素；它也应该配备相应的引用域，分别指向左右孩子以及父亲；此外作为在树中的一个特定元素它也需要记录一些重要的指标，比如height 高度，对于红黑树而言就会有颜色的区别，对于左式堆而言有npl指标，所以也需要为它们留有余地。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221100854.png" style="zoom: 67%;"></p><p>下面定义名为<code>BinNode</code>的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BinNodePosi(T) BinNode<span class="meta-string">&lt;T&gt;* //节点位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span> &#123;</span> <span class="comment">//二叉树节点模板类</span></span><br><span class="line">    </span><br><span class="line">BinNodePosi(T) parent, lChild, rChild; <span class="comment">//父节点及左、右孩子</span></span><br><span class="line">T data; <span class="keyword">int</span> <span class="built_in">height</span>; <span class="comment">//数据，/高度（通用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">   BinNode() :</span><br><span class="line">      parent ( <span class="literal">NULL</span> ), lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ), <span class="built_in">height</span> ( <span class="number">0</span> ), npl ( <span class="number">1</span> ), color ( RB_RED ) &#123; &#125;</span><br><span class="line">   BinNode ( T e, BinNodePosi(T) p = <span class="literal">NULL</span>, BinNodePosi(T) lc = <span class="literal">NULL</span>, BinNodePosi(T) rc = <span class="literal">NULL</span>,</span><br><span class="line">             <span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">1</span>, RBColor c = RB_RED ) :</span><br><span class="line">      data ( e ), parent ( p ), lc ( lc ), rc ( rc ), <span class="built_in">height</span> ( h ), npl ( l ), color ( c ) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//统计当前节点后代总数，亦即以其为根的子树的规模</span></span><br><span class="line">BinNodePosi(T) insertAsLC(T <span class="keyword">const</span>&amp;); <span class="comment">//作为当前节点的左孩子插入新节点</span></span><br><span class="line">BinNodePosi(T) insertAsRC(T <span class="keyword">const</span>&amp;); <span class="comment">//作为当前节点的右孩子插入新节点</span></span><br><span class="line">BinNodePosi(T) succ(); <span class="comment">//取当前节点的直接后继</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树层次遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树先序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树后序遍历</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-BinNode接口实现"><a href="#4-2-BinNode接口实现" class="headerlink" title="4.2.BinNode接口实现"></a>4.2.BinNode接口实现</h2><p>这一小节介绍<code>BinNode</code>类的几个常用接口，首先是<code>insertAsLC</code>接口，我们要对传入的参数e进行封装<br>使之成为一个新的节点，并且将它作为当前节点的左孩子接入所属的这棵树中。当然作为入口条件可以假设当前节点的左孩子现在是空的。</p><p>这个功能的实现方法是：通过<code>BinNode</code>构造函数创建一个新的<code>BinNode</code>节点，而它的父节点就是<code>this</code>即当前这个节点。从下面的图来看，这一步就相当于将新的<code>BinNode</code>节点的<code>parent</code>引用指向当前的这个节点。这只是自下而上一个方向的连接，为了保证整体的一致性我们还需要相应地完成自上而下的连接，也就是令当前这个节点<code>this</code>的左孩子引用<code>lChild</code>能够指向新创建的节点，这一步可以通过直接用这个新生成的节点赋予当前节点的<code>lChild</code>引用来实现。</p><p><code>insertAsRC</code>接口实现的方式完全对称，只需相应地将左孩子引用替换为右孩子引用。两个插入操作的复杂度均为$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> lc = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="comment">//将e作为当前节点的左孩子插入二叉树,  O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> rc = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="comment">//将e作为当前节点的右孩子插入二叉树,  O(1)</span></span><br></pre></td></tr></table></figure><p><code>BinNode</code>的<code>size()</code>接口，返回包括当前节点在内所有后代的总数，可以通过递归来实现，复杂度为$O(n=|size|)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> BinNode&lt;T&gt;::<span class="built_in">size</span>() &#123; <span class="comment">//统计当前节点后代总数，即以其为根的子树规模</span></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>; <span class="comment">//计入本身</span></span><br><span class="line"><span class="keyword">if</span> (lChild) s += lChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入左子树规模</span></span><br><span class="line"><span class="keyword">if</span> (rChild) s += rChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入右子树规模</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;  <span class="comment">//O(n = |size|)</span></span><br></pre></td></tr></table></figure><h2 id="4-3-BinTree模板类"><a href="#4-3-BinTree模板类" class="headerlink" title="4.3.BinTree模板类"></a>4.3.BinTree模板类</h2><p>在完成了对二叉树节点类<code>BinNode</code>的定义之后，我们就可以基于它来实现整体的binary tree简称<code>BinTree</code>这样一种模板类，代码的主体结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"BinNode.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BinTree</span> &#123;</span> <span class="comment">//二叉树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _size; BinNodePosi(T) _root; <span class="comment">//规模、根节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x的高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeightAbove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x及其祖先的高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinTree() : _size(<span class="number">0</span>), _root(<span class="literal">NULL</span>) &#123; &#125; <span class="comment">//构造函数</span></span><br><span class="line">~BinTree() &#123; <span class="keyword">if</span> (<span class="number">0</span> &lt; _size) <span class="built_in">remove</span>(_root); &#125; <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line">BinNodePosi(T) root() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//操作接口</span></span><br><span class="line">BinNodePosi(T) insertAsRoot(T <span class="keyword">const</span>&amp; e); <span class="comment">//插入根节点</span></span><br><span class="line">BinNodePosi(T) insertAsLC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e); <span class="comment">//e作为x的左孩子（原无）插入</span></span><br><span class="line">BinNodePosi(T) insertAsRC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e); <span class="comment">//e作为x的右孩子（原无）插入</span></span><br><span class="line">BinNodePosi(T) attachAsLC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); <span class="comment">//T作为x左子树接入</span></span><br><span class="line">BinNodePosi(T) attachAsRC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); <span class="comment">//T作为x右子树接入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//删除以位置x处节点为根的子树，返回该子树原先的规模</span></span><br><span class="line">BinTree&lt;T&gt;* secede(BinNodePosi(T) x); <span class="comment">//将子树x从当前树中摘除，并将其转换为一棵独立子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travLevel(visit); &#125; <span class="comment">//层次遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travPre(visit); &#125; <span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travIn(visit); &#125; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travPost(visit); &#125; <span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (BinTree&lt;T&gt; <span class="keyword">const</span>&amp; t) <span class="comment">//比较器（其余自行补充）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _root &amp;&amp; t._root &amp;&amp; lt(_root, t._root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>== (BinTree&lt;T&gt; <span class="keyword">const</span>&amp; t) <span class="comment">//判等器</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _root &amp;&amp; t._root &amp;&amp; (_root == t._root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;; <span class="comment">//BinTree</span></span><br></pre></td></tr></table></figure><p>需要注意的是：其中<code>updateHeight</code>这个接口是以<code>virtual</code>来修饰的，即虚函数。后面我们会看到二叉树，尤其是二叉搜索树是一个庞大的家族，其中的每一个成员对于高度的定义包括更新的方法都不尽相同，因此通过将它定义为虚方法可以便于各种派生类对这个方法进行适当的重写。</p><h2 id="4-4-高度更新"><a href="#4-4-高度更新" class="headerlink" title="4.4.高度更新"></a>4.4.高度更新</h2><p>对于任何一个节点<code>x</code>，它的高度是在以它为根的子树中，从它通往那个最深的叶节点的路径长度。有两种特殊情况：单节点的树高度取0，空树高度取-1，这里采用<strong>宏定义</strong>的封装的方式，通过重新命名一个新的等价意义上的高度，将常规情况下的高度与退化情况下的高度统一起来，使得此后对算法的描述和理解可以更为简便，同时也不致于影响到算法的正确性。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221110507.png" style="zoom: 40%;"></p><p>一个节点的高度恰好等于它的左孩子与右孩子高度中的更大者再加1，因此可以相应地得到对任意节点<code>x</code>进行高度更新的算法。 而如果<code>x</code>的祖先节点存在，那么祖先节点的高度可能因为<code>x</code>的高度变化而变化，整个这样的过程需要从x开始遍历它的所有历代祖先，算法的复杂度正比于x节点的深度，即$O(n=depth(x))$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stature(p) ( (p) ? (p)-&gt;height : -1 ) <span class="comment">//节点高度—约定空树高度为-1</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x) <span class="comment">//更新节点x高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x-&gt;<span class="built_in">height</span> = <span class="number">1</span> + __max(stature(x-&gt;lc), stature(x-&gt;rc));</span><br><span class="line">&#125; <span class="comment">//具体规则，因树而异</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> BinTree&lt;T&gt;::updateHeightAbove(BinNodePosi(T) x) <span class="comment">//更新节点x及其历代祖先的高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123; updateHeight(x); x = x-&gt;parent; &#125;</span><br><span class="line">&#125; <span class="comment">//可优化：一旦高度未变，即可终止。 O(n = depth(x))</span></span><br></pre></td></tr></table></figure><h2 id="4-5-节点插入"><a href="#4-5-节点插入" class="headerlink" title="4.5.节点插入"></a>4.5.节点插入</h2><p><code>insertAsRC</code>接口为原树中一个没有右孩子的节点插入一个右孩子节点，插入后原树的规模会增加1，<code>x</code>节点的高度有可能因为它新加入了一个孩子而发生变化，因此还要调用<code>updateHeightAbove</code>来对<code>x</code>这个节点以及它的历代祖先更新高度。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221112247.png" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinTree&lt;T&gt;::insertAsRC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">_size++; x-&gt;insertAsRC(e); </span><br><span class="line">updateHeightAbove(x);   <span class="comment">//x及其祖先的高度可能增加，其余节点必然不变</span></span><br><span class="line"><span class="keyword">return</span> x-&gt;rc;</span><br><span class="line">&#125; <span class="comment">//e插入为x的右孩子，insertAsLC()完全对称</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      向量结构（Vector）和列表结构（List）两者都无法兼顾静态和动态的高效性，而本章要介绍的树结构恰好能将二者的优势结合起来。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
