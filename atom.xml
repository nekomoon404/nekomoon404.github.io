<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-02-14T15:07:25.537Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法（5）列表</title>
    <link href="http://nekomoon404.github.io/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-14T12:33:23.000Z</published>
    <updated>2020-02-14T15:07:25.537Z</updated>
    
    <content type="html"><![CDATA[<p>本章的主题是列表，与向量一样列表也是典型的最基本的一类线性结构，但是列表结构与向量结构在几乎所有的方面都是对称的、互补的，因此它的特点也十分的鲜明。本文主要介绍列表的接口与实现，无序列表和有序列表。</p><h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><h2 id="从静态到动态"><a href="#从静态到动态" class="headerlink" title="从静态到动态"></a>从静态到动态</h2><ul><li><p>根据是否修改数据结构，所有操作大致分为两类方式：</p><ul><li>静态：仅读取，数据的内容及组成一般不变：get、search</li><li>动态：需写入，数据结构的局部或整体将改变：insert、remove</li></ul></li><li><p>与操作方式相对应地，数据元素的存储于组织方式也分为两种</p><ul><li><p>静态：数据空间整体创建或销毁</p><p>​            数据元素的物理存储次序与其逻辑次序严格一致</p><p>​            可支持高效的静态操作</p><p>比如向量，元素的物理地址与其逻辑次序线性对应</p></li><li><p>动态：为各数据元素动态地分配和回收的物理空间</p><p>​            逻辑上相邻的元素记录彼此的物理地址</p><p>​            形成一个整体可支持高效的动态操作</p><p>这里的代表就是我们这一章的主题：列表</p></li></ul></li></ul><h2 id="从向量到列表"><a href="#从向量到列表" class="headerlink" title="从向量到列表"></a>从向量到列表</h2><ul><li><p>列表（list）是采用动态存储策略的典型结构</p><ul><li>其中的元素称作<strong>节点</strong>（node）</li><li>各节点通过指针或引用彼此联接，构成一个逻辑上的线性序列：$L={a<em>0,a_1,\dots,a</em>{n-1}}$</li></ul></li><li><p>相邻节点彼此互称<strong>前驱</strong>（predecessor）或<strong>后继</strong>（successor）</p><ul><li>前驱或后继若存在，则必然唯一</li></ul></li><li>一个序列中的第一个元素称为<strong>首节点</strong>（没有前驱），最后一个元素称为<strong>末节点</strong>（没有后继）</li></ul><p>以下图为例，对于任何一个列表而言，首先都有一个入口的位置，所有的元素确实可以从入口开始沿着它们之间的引用，依次地从相对的前驱转向后继以及后继的后继，直到最终的末节点。虽然在逻辑上它们是这样的一个排列的次序，但是在物理上却远远不是。但是这样不妨碍它们定义并且实现这样的一个次序，比如说从某一个位置出发，我们可以找到它的物理位置并且访问它，接下来可以顺着它的后继的引用找到它的后继，以及再顺着后继的引用找到后继的后继，诸如此类直到最终抵达末节点，从而退出这个列表。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214210536.png" style="zoom:67%;"></p><h2 id="从秩到位置"><a href="#从秩到位置" class="headerlink" title="从秩到位置"></a>从秩到位置</h2><ul><li><p>向量支持循秩访问（call-by-rank）的方式，根据数据元素的秩，可在$O(1)$时间内直接确定其物理地址，</p><p>V[i] 的物理地址 = V + i × s，s为单个单元占用的空间量</p></li><li><p>既然同属线性序列，列表固然也可通过秩找到对应的元素</p><p>为找到秩为<code>i</code>的元素，须从头（尾）端出发，沿引用前进（后退）<code>i</code>步</p></li><li><p>然而因为成本过高，此时的循秩访问已不合时宜</p><p>以平均分布为例，单次访问的期望复杂度为$(n+1)/2=O(n)$</p></li><li><p>因此，应改用循位置访问（call-by-position）的方式访问列表元素，也就是说，应转而利用结点之间的相互引用，找到特定的节点</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="列表节点：ADT接口"><a href="#列表节点：ADT接口" class="headerlink" title="列表节点：ADT接口"></a>列表节点：ADT接口</h3><ul><li>作为列表的基本元素，列表节点首先需要独立地“封装”实现。为此，可设置并约定若干基本的操作接口</li></ul><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214123.png" style="zoom: 67%;"></p><h3 id="列表节点：ListNode模板类"><a href="#列表节点：ListNode模板类" class="headerlink" title="列表节点：ListNode模板类"></a>列表节点：ListNode模板类</h3><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214127.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Posi(T) ListNode<span class="meta-string">&lt;T&gt;* //列表节点位置（ISO C++.0x，template alias）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//简洁起见，完全开放而不再过度封装</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span> <span class="comment">//列表节点模板类（以双向链表形式实现）</span></span><br><span class="line">T data;  <span class="comment">//数值</span></span><br><span class="line">Posi(T) pred; <span class="comment">//前驱</span></span><br><span class="line">Posi(T) succ; <span class="comment">//后继</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ListNode() &#123;&#125;   <span class="comment">//针对header和trailer的构造</span></span><br><span class="line">ListNode(T e, Posi(T) p = <span class="literal">NULL</span>, Posi(T) s = <span class="literal">NULL</span>)</span><br><span class="line">: data(e), pred(p), succ(s) &#123;&#125; <span class="comment">//默认构造器</span></span><br><span class="line"> <span class="comment">// 操作接口</span></span><br><span class="line">Posi(T) insertAsPred(T <span class="keyword">const</span>&amp; e); <span class="comment">//紧靠当前节点之前插入新节点</span></span><br><span class="line">Posi(T) insertAsSucc(T <span class="keyword">const</span>&amp; e); <span class="comment">//紧随当前节点之后插入新节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="列表：ADT接口"><a href="#列表：ADT接口" class="headerlink" title="列表：ADT接口"></a>列表：ADT接口</h3><p>在给出列表结构的具体实现之前，首先定义一组它所应该提供的操作接口，仔细看会发现它的接口的形式以及对应的功能与第二章中所学过的向量Vector结构颇为类似，这里逐一再展开了，在后边相应的各节将对它们的功能和实现再做详细的介绍。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214131.png" style="zoom: 67%;"></p><h3 id="列表：List模板类"><a href="#列表：List模板类" class="headerlink" title="列表：List模板类"></a>列表：List模板类</h3><p>接下来介绍列表也就是List这种模板类的具体定义，首先要引入刚才所实现的列表节点类，可以看到<code>List</code>这种模板类也是分为三个层次，其中private 私有的层次与向量类似，记录的都是那些对外不可见的部分，具体包括规模、引入两个哨兵节点。另外也包括一些内部的功能函数，以及刚才我们所定义的那些对外开放的标准ADT接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"listNode.h"</span> <span class="comment">//引入列表节点类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span> <span class="comment">//列表模板类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _size; Posi(T) header; Posi(T) trailer; <span class="comment">//规模、头哨兵、尾哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">//列表创建时的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清除所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyNodes</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//复制列表中自位置p起的n项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Posi(T)&amp;, <span class="keyword">int</span>, List&lt;T&gt;&amp;, Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Posi(T)&amp;, <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    List() &#123; init(); &#125; <span class="comment">//默认</span></span><br><span class="line">List(List&lt;T&gt; <span class="keyword">const</span>&amp; L); <span class="comment">//整体复制列表L</span></span><br><span class="line">List(List&lt;T&gt; <span class="keyword">const</span>&amp; L, Rank r, <span class="keyword">int</span> n); <span class="comment">//复制列表L中自第r项起的n项</span></span><br><span class="line">List(Posi(T) p, <span class="keyword">int</span> n); <span class="comment">//复制列表中自位置p起的n项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">    ~List(); <span class="comment">//释放（包含头、尾哨兵在内的）所有节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读访问接口</span></span><br><span class="line"><span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size &lt;= <span class="number">0</span>; &#125; <span class="comment">//判空</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>[] (Rank r) <span class="keyword">const</span>; <span class="comment">//重载，支持循秩访问（效率低）</span></span><br><span class="line">Posi(T) first() <span class="keyword">const</span> &#123; <span class="keyword">return</span> header-&gt;succ; &#125; <span class="comment">//首节点位置</span></span><br><span class="line">Posi(T) last() <span class="keyword">const</span> &#123; <span class="keyword">return</span> trailer-&gt;pred; &#125; <span class="comment">//末节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(Posi(T) p)</span> <span class="comment">//判断位置p是否对外合法</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> p &amp;&amp; (trailer != p) &amp;&amp; (header != p); &#125; <span class="comment">//将头、尾节点等同于NULL</span></span><br><span class="line">Posi(T) <span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e) <span class="keyword">const</span> <span class="comment">//无序列表查找</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">find</span>(e, _size, trailer); &#125;</span><br><span class="line">Posi(T) <span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span>; <span class="comment">//无序区间查找</span></span><br><span class="line">Posi(T) search(T <span class="keyword">const</span>&amp; e) <span class="keyword">const</span> <span class="comment">//有序列表查找</span></span><br><span class="line">  &#123; <span class="keyword">return</span> search(e, _size, trailer); &#125;</span><br><span class="line">Posi(T) search(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span>; <span class="comment">//有序区间查找</span></span><br><span class="line">Posi(T) selectMax(Posi(T) p, <span class="keyword">int</span> n); <span class="comment">//在p及其n-1个后继中选出最大者</span></span><br><span class="line">Posi(T) selectMax() &#123; <span class="keyword">return</span> selectMax(header-&gt;succ, _size); &#125; <span class="comment">//整体最大者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写访问接口</span></span><br><span class="line">Posi(T) insertAsFirst(T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作首节点插入</span></span><br><span class="line">Posi(T) insertAsLast(T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作末节点插入</span></span><br><span class="line">Posi(T) insertA(Posi(T) p, T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作p的后继插入（After）</span></span><br><span class="line">Posi(T) insertB(Posi(T) p, T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作p的前驱插入（Before）</span></span><br><span class="line"><span class="function">T <span class="title">remove</span><span class="params">(Posi(T) p)</span></span>; <span class="comment">//删除合法位置p处的节点,返回被删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(List&lt;T&gt;&amp; L)</span> </span>&#123;merge(first(), <span class="built_in">size</span>, L, L.first(), L._size);&#125;<span class="comment">//全列表归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Posi(T) p, <span class="keyword">int</span> n)</span></span>; <span class="comment">//列表区间排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort(first(), _size); &#125; <span class="comment">//列表整体排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>; <span class="comment">//无序去重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>; <span class="comment">//有序去重</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>; <span class="comment">//前后倒置（习题）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">void</span>(*) (T&amp;))</span></span>; <span class="comment">//遍历，依次实施visit操作（函数指针，只读或局部性修改）</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//遍历，依次实施visit操作（函数对象，可全局性修改）</span></span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">//List</span></span><br></pre></td></tr></table></figure><p>这样的一个宏观结构可以用下面的图来表示，任何一个<code>List</code>结构都会拥有一个叫作<code>header</code>，以及另一个叫作<code>trailer</code>的哨兵节点，<code>header</code>和<code>trailer</code>对外是不可见的，当然我们后面会看到它们的作用非常巨大。而对外可见的部分主要是介乎<code>header</code>和<code>trailer</code>之间的这样的一系列的元素，其中如果存在的话，第一个元素也就是<code>firstNode</code>，我们称作<strong>首元素</strong>，而最后一个<code>last</code>我们称作<strong>末元素</strong>。那么相应的也把名字规范一下，称<code>header</code>叫作<strong>头元素</strong>，称<code>trailer</code>是<strong>尾元素</strong>。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214135.png" style="zoom:67%;"></p><ul><li>等效地，头、首、末和尾这四个节点的“ 秩 ”可以分别理解为是等于-1、0、n-1以及n。</li></ul><p>那么它们之间的联系是：头节点和尾节点是与生俱来的，而且二者并不相同，<code>first</code>和<code>last</code>并不见得不相同，甚至不能保证它们存在，但是对外而言<code>first</code>、<code>last</code>是可见的，而<code>trailer</code>和<code>header</code>这两个哨兵都是invisible不可见的。当然从秩的角度来看一个长度为n的列表中，头、首、末和尾这四个节点的秩可以分别理解为是等于-1、0、n-1以及n。</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>如此定义的一个列表结构可以按照这样的过程来创建：首先要为header和trailer分别地分配一个节点使它们真实的存在，接下来要将它们的后继以及前驱引用分别指向对方，从而实现这样一个互联的效果。当然逻辑上看<br>这个时候对外可见的那个列表实际上是没有任何元素的，对应的就是一个空列表。而在接下来的几节里会介绍如何实现在其中插入一些元素，以及再插入一些元素，也可能时不常地从中删除或者是修改某一个元素。总而言之这个列表将有可能会包含一些实在的、对外可见的节点，我们在后面几节再来看这些操作是如何具体实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> List&lt;T&gt;::init() &#123; <span class="comment">//列表初始化，在创建列表对象时统一调用</span></span><br><span class="line">header = <span class="keyword">new</span> ListNode&lt;T&gt;; <span class="comment">//创建头哨兵节点</span></span><br><span class="line">    trailer = <span class="keyword">new</span> ListNode&lt;T&gt;; <span class="comment">//创建尾哨兵节点</span></span><br><span class="line">    header-&gt;succ = trailer; header-&gt;pred = <span class="literal">NULL</span>;   <span class="comment">//互联</span></span><br><span class="line">trailer-&gt;pred = header; trailer-&gt;succ = <span class="literal">NULL</span>;  <span class="comment">//互联</span></span><br><span class="line">_size = <span class="number">0</span>; <span class="comment">//记录规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214139.png" style="zoom:67%;"></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><h2 id="秩到位置"><a href="#秩到位置" class="headerlink" title="秩到位置"></a>秩到位置</h2><p>这一节讨论无序列表的相关算法，首先关心的一个问题是既然列表和向量同属于线性的序列结构那么是否可以继续沿用向量那种，十分便捷也是我们十分习惯的循序秩访问的方式呢？具体说来，对于任何一个名字叫L的列表，每当我们指定其中一个合法的秩r，都可以以这样的一个形式来直接引用并且访问到对应的这个节点。</p><p>答案是可以的，因为我们可以<strong>仿照向量的做法对下标操作符进行适当的重载</strong>，具体的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//重载下标操作符，以通过秩直接访问列表节点（虽方便，效率低，需慎用）</span></span><br><span class="line">T List&lt;T&gt;::<span class="keyword">operator</span>[] (Rank r) <span class="keyword">const</span> &#123; <span class="comment">//assert: 0 &lt;= r &lt; size</span></span><br><span class="line"> Posi(T) p = first(); <span class="comment">//从首节点出发</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt; r--) p = p-&gt;succ; <span class="comment">//顺数第r个节点即是</span></span><br><span class="line"> <span class="keyword">return</span> p-&gt;data; <span class="comment">//目标节点，返回其中所存元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此也可以看出这个算法的复杂度是取决于所指定的那个秩r的，即$O(r)$，这个是十分低下的。实际上这种用法虽然很方便，但是我们只能偶尔为之而不能常用。估算它的平均性能为$O(n)$，需要线性的时间，这样一个性能，无论如何我们都是无法接受的。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214222433.png" style="zoom:50%;"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>接下来考虑无序列表的查找算法，这里将这个算法的接口语义定义为在当前的列表L中以位置为<code>p</code>的某一个特定节点为基准，在它的<code>n</code>个<strong>真前驱</strong>中（不包括它自己在内的n个前驱中）找到某个可能存在的数值为特定值<code>e</code>的节点。</p><p>仿照向量的查找算法我们从p这个位置出发，从后向前将每个节点逐一取出并与目标元素进行比对，一旦发现相等也就是命中，即可停止。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214224316.png" style="zoom: 67%;"></p><p>这样一个过程可以准确地描述为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//在无序列表内节点p（可能是trailer）的n个真前驱中，找到等于e的最后者</span></span><br><span class="line"> Posi(T) List&lt;T&gt;::<span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) <span class="comment">//（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左</span></span><br><span class="line">   <span class="keyword">if</span> (e == (p = p-&gt;pred)-&gt;data) <span class="keyword">return</span> p; <span class="comment">//逐个比对，直至命中或范围越界</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//p越出左边界意味着区间内不含e，查找失败</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回NULL</span></span><br></pre></td></tr></table></figure><p>注意无论是成功的情况所返回的<code>p</code>，还是失败时返回的<code>NULL</code>，都是我们此前所定义的一个节点位置Position。还要注意一种特殊的情况，即目标节点e不仅存在而且可能有多个，那么在这时根据这个算法，它会首先停止于相对而言最靠后的那个节点，因为这正是我们的语义所要求的一个细节。</p><p>那么在最坏的情况下，当然这个算法必须一直迭代到最末尾这个位置，累计的宽度是n，所以相应的复杂度也就是最坏情况下$O(n)$。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214224536.png" style="zoom:67%;"></p><p>还需要留意的是，我们这里的三个参数的次序<code>find(T const&amp; e, int n, Posi(T) p)</code>，为什么这里将<code>n</code>放在<code>p</code>的前端呢？实际上这是为了让我们更方便地了解这个算法的功能语义，当使用<code>find(e, n ,p)</code>这样一个方式来调用这个接口的时候，你就很容易理解它是在<code>p</code>的<code>n</code>个前驱中去进行查找。换而言之我们完全可以重载另一个接口<code>find(e, p, n)</code>，它的不同之处就在于<code>p</code>和<code>n</code>的位置恰好交换，这就意味着是在p的n个后继中去查找特定的某一个元素。</p>]]></content>
    
    <summary type="html">
    
      与向量一样列表也是典型的最基本的一类线性结构，但是列表结构与向量结构在几乎所有的方面都是对称的、互补的，因此它的特点也十分的鲜明。本文主要介绍列表的接口与实现，无序列表和有序列表。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（8）数据的共享与保护</title>
    <link href="http://nekomoon404.github.io/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
    <id>http://nekomoon404.github.io/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</id>
    <published>2020-02-13T12:58:24.000Z</published>
    <updated>2020-02-14T12:15:09.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h1><p>作用域是一个标识符在程序正文中的有效区域。作用域可以分为以下几类：</p><ul><li>函数原型作用域：函数原型中的参数，其作用域始于”(“，结束语”)”，如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="keyword">double</span> radius)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>局部作用域：</p><ul><li>函数的形参、在块中声明的标识符</li><li>其作用域自声明处起，限于块中</li></ul></li><li><p>类作用域：</p><ul><li>类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。</li><li>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）</li></ul></li><li>文件作用域：<ul><li>不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束语文件尾。</li></ul></li><li>可见性：<ul><li>可见性是从对标识符的引用的角度来谈的概念</li><li>可见性表示从内层作用域向外层作用域“看”时能看见什么</li><li>如果标识在某处可见，就可以在该处引用此标识符</li><li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见</li><li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i;  <span class="comment">//全局变量，文件作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i = <span class="number">5</span>;  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i; <span class="comment">//局部变量，局部作用域</span></span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h1><p><strong>静态生存期</strong>：</p><ul><li>静态生存期与程序的运行期间相同;</li><li>在文件作用于中声明的对象具有这种生存期</li><li>在函数内部声明静态生存期对象，要冠以关键字<code>static</code></li></ul><p><strong>动态生存期</strong>：</p><ul><li>开始于程序执行到声明点时，结束语命名该标识符的作用域结束处</li><li>块作用域中声明的，没有用static修饰的对象时动态生存期的对象（习惯称局部生存期对象）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;   <span class="comment">//i为全局变量，具有静态生存期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//a, b为静态局部变量，具有全局寿命，局部可见</span></span><br><span class="line"><span class="comment">//只第一次进入函数时被初始化</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;  <span class="comment">//C为局部变量，具有动态生存期，</span></span><br><span class="line">             <span class="comment">//每次进入函数时都初始化</span></span><br><span class="line">a += <span class="number">2</span>; i += <span class="number">32</span>; c += <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---OTHER---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">//静态局部变量，有全局寿命，局部可见（实际中尽量不使用重名的变量）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-10</span>;   <span class="comment">//b,c为局部变量，具有动态生存期</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">c += <span class="number">8</span>;   other();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i += <span class="number">10</span>;  other();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/QQ图片20200214145239.png" style="zoom:80%;"></p><h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><p><strong>静态成员</strong>：在定义前面加了<code>static</code>关键字的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> w,h;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> nTotalNUmber;  <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CRectangle(<span class="keyword">int</span> _w,<span class="keyword">int</span> _h);</span><br><span class="line">       ~CRectangle();</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;   <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享</li></ul><p>​       注意：<code>sizeof</code>运算符不会计算静态成员变量，如下例中<code>sizeof(Myclass)</code>等于4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。</li><li>因此静态成员不需要通过对象就能访问</li></ul><p>如何<strong>访问静态成员</strong>：</p><ol><li>类名::成员名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>对象名.成员名（并不意味着静态成员或静态成员函数只作用于该对象,，它们是被所有的CRentangle对象所共享的）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r;  r.PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>指针-&gt;成员名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle *p = &amp;r;  p-&gt;PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>引用.成员名</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle &amp;<span class="built_in">ref</span> = r;  <span class="built_in">int</span> n = <span class="built_in">ref</span>.nTotalNumber;</span><br></pre></td></tr></table></figure><ul><li><strong>静态成员变量本质上是全局变量</strong>，哪怕一个对象都不存在，类的静态成员变量也存在。</li><li>静态成员函数本质上是全局函数</li><li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</li></ul><p><strong>示例</strong>：考虑一个需要随时知道矩阵总数和总面积的图像处理程序，可以用全局变量来记录总数和总面积，同静态成员将这两个变量封装进类中，就更容易理解和维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nTotalNUmber;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CRectangle(<span class="keyword">int</span> _w, <span class="keyword">int</span> _h);</span><br><span class="line">~CRectangle();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;   <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> _w, <span class="keyword">int</span> _h)</span><br><span class="line">&#123;</span><br><span class="line">w = _w;</span><br><span class="line">h = _h;</span><br><span class="line">nTotalNUmber++;</span><br><span class="line">nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()</span><br><span class="line">&#123;</span><br><span class="line">nTotalNUmber--;</span><br><span class="line">nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nTotalNUmber &lt;&lt; <span class="string">", "</span>&lt;&lt;nTotalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalNUmber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalArea = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//必须在定义类的文件中对静态成员变量进行一次说明或初始化。</span></span><br><span class="line"><span class="comment">//否则编译能通过，链接不能通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line"><span class="comment">//cout&lt;&lt;CRectangle::nTotalNUmber;   //Wrong,私有成员不能在类外访问</span></span><br><span class="line">CRectangle::PrintTotal();</span><br><span class="line">r1.PrintTotal();  <span class="comment">//与上一句等价</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数（因为其可能访问非静态成员变量），例如下面的定义就是错误的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; w &lt;&lt;<span class="string">", "</span>&lt;&lt; nTotalNUmber &lt;&lt; <span class="string">", "</span>&lt;&lt;nTotalArea &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  <span class="comment">//Wrong，因为PrintTotal是静态成员函数，而w属于非静态成员变量</span></span><br></pre></td></tr></table></figure><p>我们回过头来再看之前的<code>CRectangle</code>类的写法，其实它是有严重<strong>缺陷</strong>的，那么这个缺陷是如何产生的呢？</p><p>问题就出在我们忽略了复制构造函数，在程序需要它时，会调用自动生成的复制构造函数，自然就不会对<code>nTotalNUmber</code>和<code>nTotalArea</code>作相应的增加。</p><ul><li><p>在使用<code>CRectangle</code>类时，有时会调用复制构造函数生成临时的隐藏的<code>CRectangle</code>对象</p><ul><li>调用一个以<code>CRectangle</code>类对象作为参数的函数时</li><li>调用一个以<code>CRectangle</code>类对象作为返回值的函数时    </li></ul></li><li><p>临时对象在消亡时会调用析构函数，减少<code>nTotalNUmber</code>和<code>nTotalArea</code>的值，可是这些临时对象在生成时却没有增加<code>nTotalNUmber</code>和<code>nTotalArea</code>的值。</p></li></ul><p><strong>解决办法</strong>：为<code>CRectangle</code>类写一个复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::CRectangle(CRectangle &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    w=r.w; h=r.h;</span><br><span class="line">    nTotalNUmber++;</span><br><span class="line">nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h1><ul><li>友元是C++提供的一种破坏数据封装和数据隐藏的机制</li><li>通过将一个模块声明为另一个模块的友元，一个模块能引用到另一个模块中很是被隐藏的信息</li><li>可以使用<strong>友元函数</strong>和<strong>友元类</strong></li><li>为了确保数据的完整性，及数据封装与隐藏的原则，<strong>建议尽量不使用或少使用友元</strong></li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul><li>友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体重能够通过对象名访问<code>private</code>和<code>protected</code>成员。</li><li>作用：增加灵活性，时程序员可以在封装和快速性方面做合理的选择。</li><li>访问对象中的成员必须通过对象名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostram&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>  <span class="comment">//提前声明CCar类，因为后面CDriver类要前向引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar *pCar)</span></span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>; <span class="comment">//类外函数声明为友元函数</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar);  <span class="comment">//其他类的成员函数声明为友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)  <span class="comment">//求最贵汽车的价格</span></span><br><span class="line">&#123;</span><br><span class="line">pCar-&gt;price += <span class="number">1000</span>;   <span class="comment">//汽车改装后价格增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line"><span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">tmpMax = cars[i].price;</span><br><span class="line"><span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><ul><li>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员</li><li>声明语法：将友元类名在另一个类中使用<code>friend</code>修饰说明</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span>  <span class="comment">//声明CDriver为CCar的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span></span>&#123;    <span class="comment">//改装汽车</span></span><br><span class="line">        myCar.price += <span class="number">1000</span>;  <span class="comment">//CDriver是CCar的友元类-&gt;可以访问其私有成price</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要注意的是：<strong>类的友元关系是单向的</strong>：</p><ul><li>如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数不能访问B类的私有、保护数据，即友元类的关系不能传递，不能继承。</li></ul>]]></content>
    
    <summary type="html">
    
      本章主要学习了标识符的作用域与可见性，对象的生存期，类的静态成员，类的友元
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ML:Week2</title>
    <link href="http://nekomoon404.github.io/2020/02/13/ML-Week2/"/>
    <id>http://nekomoon404.github.io/2020/02/13/ML-Week2/</id>
    <published>2020-02-13T09:43:58.000Z</published>
    <updated>2020-02-13T12:40:49.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multivariate-Linear-Regression"><a href="#Multivariate-Linear-Regression" class="headerlink" title="Multivariate Linear Regression"></a>Multivariate Linear Regression</h1><h2 id="Multiple-Features"><a href="#Multiple-Features" class="headerlink" title="Multiple Features"></a>Multiple Features</h2><p>Linear regression with <strong>multiple variables</strong> is also known as “multivariate linear regression”. We now introduce notation for equations where we can have any number of input variables.</p><script type="math/tex; mode=display">\begin{align*}x_j^{(i)} &= \text{value of feature } j \text{ in the }i^{th}\text{ training example} \newline x^{(i)}& = \text{the input (features) of the }i^{th}\text{ training example} \newline m &= \text{the number of training examples} \newline n &= \text{the number of features} \end{align*}</script><p>The multivariable form of the hypothesis function accommodating these multiple features is as follows:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x_1+θ_2x_2+θ_3x_3+⋯+θ_nx_n</script><p>In order to develop intuition about this function, we can think about $\theta_0$ as the basic price of a house, $\theta_1$ as the price per square meter, $\theta_2$ as the price per floor, etc. $x_1$ will be the number of square meters in the house, $x_2$ the number of floors, etc.</p><p>Using the definition of matrix multiplication, our <strong>multivariable hypothesis function</strong> can be concisely represented as:</p><script type="math/tex; mode=display">\begin{align*}h_\theta(x) =\begin{bmatrix}\theta_0 \hspace{2em} \theta_1 \hspace{2em} ... \hspace{2em} \theta_n\end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x\end{align*}</script><p>This is a vectorization of our hypothesis function for one training example; see the lessons on vectorization to learn more.</p><p>Remark: Note that for convenience reasons in this course we assume $x^{(i)}_0=1 $ for $(i\in 1,\dots,m)$. This allows us to do matrix operations with theta and x. Hence making the two vectors $’\thetaθ’$ and $x^{(i)}$match each other element-wise (that is, have the same number of elements: n+1).]</p><h2 id="Gradient-Descent-for-Multiple-Variables"><a href="#Gradient-Descent-for-Multiple-Variables" class="headerlink" title="Gradient Descent for Multiple Variables"></a>Gradient Descent for Multiple Variables</h2><p>The gradient descent equation itself is generally the same form; we just have to repeat it for our ‘n’ features:</p><script type="math/tex; mode=display">\begin{align*} & \text{repeat until convergence:} \; \lbrace \newline \; & \theta_0 := \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_0^{(i)}\newline \; & \theta_1 := \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_1^{(i)} \newline \; & \theta_2 := \theta_2 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_2^{(i)} \newline & \cdots \newline \rbrace \end{align*}</script><p>In other words:</p><script type="math/tex; mode=display">\begin{align*}& \text{repeat until convergence:} \; \lbrace \newline \; & \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; & \text{for j := 0...n}\newline \rbrace\end{align*}</script><p>The following image compares gradient descent with one variable to gradient descent with multiple variables:</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213200014.png" style="zoom: 50%;"></p><h2 id="Gradient-Descent-in-Practice-I-Feature-Scaling"><a href="#Gradient-Descent-in-Practice-I-Feature-Scaling" class="headerlink" title="Gradient Descent in Practice I -Feature Scaling"></a>Gradient Descent in Practice I -Feature Scaling</h2><p>We can <strong>speed up gradient descent</strong> by having each of our input values in roughly the same range. This is because <strong>θ will descend quickly on small ranges</strong> and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213201445.png" style="zoom: 50%;"></p><p>The way to prevent this is to modify the ranges of our input variables so that they are all roughly the same. Ideally:</p><p>−1 ≤ $x<em>{(i)}$≤ 1     or      −0.5 ≤ $x</em>{(i)}$ ≤ 0.5</p><p>Two techniques to help with this are <strong>feature scaling</strong>(特征缩放) and <strong>mean normalization</strong>(均值归一化). </p><p>Feature scaling involves dividing the input values by the range (maximum value  - minimum value) of the input variable, resulting in a new range of just 1. </p><p>Mean normalization involves subtracting the average value for an input variable from the values for that input variable resulting in a new average value for the input variable of just zero. To implement both of these techniques, adjust your input values as shown in this formula:</p><script type="math/tex; mode=display">x_i:=\frac{x_i-\mu_i}{s_i}</script><p>Where $\mu_i$ is the <strong>average</strong> of all the values for feature (i) and $s_i$ is the range of values (max - min), or $s_i$ is the <strong>standard deviation</strong>(标准差). （量化后的特征将分布在[-1, 1]，服从标准正态分布）</p><h2 id="Gradient-Descent-in-Practice-II-Learning-Rate"><a href="#Gradient-Descent-in-Practice-II-Learning-Rate" class="headerlink" title="Gradient Descent in Practice II - Learning Rate"></a>Gradient Descent in Practice II - Learning Rate</h2><p><strong>Debugging gradient descent</strong>(调试梯度下降):  Make a plot with <em>number of iterations</em> on the x-axis. Now plot the cost function, J(θ) over the number of iterations of gradient descent. If J(θ) ever increases, then you probably need to decrease α.</p><p><strong>Automatic convergence test</strong>(自动收敛测试):  Declare convergence if J(θ) decreases by less than E in one iteration, where E is some small value such as 10−3. However in practice it’s difficult to choose this threshold value</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213202754.png" style="zoom:50%;"></p><p>It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213202813.png" style="zoom:50%;"></p><p>To summarize:</p><ul><li><p>If $\alpha$ is too small: slow convergence. </p></li><li><p>If $\alpha$ is too large: ￼may not decrease on every iteration and thus may not converge.</p></li></ul><h2 id="Features-and-Polynomial-Regression"><a href="#Features-and-Polynomial-Regression" class="headerlink" title="Features and Polynomial Regression"></a>Features and Polynomial Regression</h2><p>We can improve our features and the form of our hypothesis function in a couple different ways.</p><p>We can <strong>combine</strong> multiple features into one. For example, we can combine $x_1$ and $x_2$ into a new feature $x_3$ by taking $x_1⋅x_2$.</p><p>Our hypothesis function need not be linear (a straight line) if that does not fit the data well.</p><p>We can <strong>change the behavior or curve</strong> of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).</p><p>For example, if our hypothesis function is $h<em>\theta (x) = \theta_0 + \theta_1 x_1$ then we can create additional features based on $x_1$, to get the quadratic function $h</em>\theta(x) = \theta<em>0 + \theta_1 x_1 + \theta_2 x_1^2$ or the cubic function $h</em>\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_1^2 + \theta_3 x_1^3$</p><p>In the cubic version, we have created new features $x_2$ and $x_3$ where $x_2 = x_1^2$ and $x_3 = x_1^3$.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213204000.png" style="zoom:50%;"></p><p>To make it a square root function, we could do: $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 \sqrt{x_1}$.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213203859.png" style="zoom:50%;"></p><p>One important thing to keep in mind is, if you choose your features this way then <strong>feature scaling becomes very important.</strong></p><p>eg. if $x_1$ has range 1 - 1000 then range of $x_1^2$ becomes 1 - 1000000 and that of $x_1^3$ becomes 1 - 1000000000</p>]]></content>
    
    <summary type="html">
    
      Week2的主要内容包括：Multivariate Linear Regression多变量线性回归...
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（4）气泡排序与归并排序</title>
    <link href="http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-12T12:45:52.000Z</published>
    <updated>2020-02-13T02:39:03.196Z</updated>
    
    <content type="html"><![CDATA[<p>通过之前的两篇文章我们可以知道有序向量相对于无序向量有着更多的优势，比如它的去重操作以及查找操作都可以更快速地完成，然而我们遗留下一个问题，就是如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法，即起泡算法与归并算法。</p><h1 id="排序器：统一接口"><a href="#排序器：统一接口" class="headerlink" title="排序器：统一接口"></a>排序器：统一接口</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::sort ( Rank lo, Rank hi ) &#123; <span class="comment">//向量区间[lo, hi)排序</span></span><br><span class="line">  <span class="keyword">switch</span> ( rand() % <span class="number">6</span> ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  bubbleSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//起泡排序</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:  selectionSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//选择排序（习题）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:  mergeSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:  heapSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//堆排序（第12章）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:  quickSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//快速排序（第14章）</span></span><br><span class="line">    <span class="keyword">default</span>: shellSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//希尔排序（第14章）</span></span><br><span class="line">  &#125; <span class="comment">//随机选择算法以充分测试。实用时可视具体问题的特点灵活确定或扩充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量的起泡排序（基本版）</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort( Rank lo, Rank hi ) &#123; <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">  <span class="keyword">while</span>( lo &lt; --hi ) <span class="comment">//反复起泡扫描</span></span><br><span class="line">    <span class="keyword">for</span>( Rank i = lo; i &lt; hi; i++ ) <span class="comment">//逐个检查相邻元素</span></span><br><span class="line">      <span class="keyword">if</span>( _elem[i] &gt; _elem[i + <span class="number">1</span>] ) <span class="comment">//若逆序，则</span></span><br><span class="line">        swap( _elem[i], _elem[i + <span class="number">1</span>] ); <span class="comment">//经交换使局部有序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一章曾以这个算法为例介绍过如何证明算法的正确性，这里按照刚才统一定义的形式将它整理为一个名为<code>bubbleSort</code>的算法接口。这个算法实际上可以认为是通过调用一个名为bubble的过程迭代地来进行，在每一迭代过程中都会考察当前介于<code>lo</code>和<code>hi</code>之间的所有相邻元素，只要有一对相邻元素是逆序的，就将它们交换，所以整个这样的一个过程也称作<strong>扫描交换</strong>。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200206133211.png" style="zoom: 50%;"></p><p>这个算法的不变法具体来说，如果最初的这个向量是一个无序向量的话，那么每经过这样一趟对bubble的调用都会有一个新的元素就位，比如对于第一次而言就是全局最大的那个元素，这里用红色来表示就位的元素，那么当然互补地其它的部分也就是接下来要考察的问题的范围，就会相应地缩小一个单元，这也是减而治之。再接下来有序的部分会继续地拓展，而无序的部分会继续地缩减，整个呈现为一个不断此消绿色的这部分，和彼涨红色的这部分<br>这样一个过程，直到无序的部分只剩下一个元素。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212210120.png" style="zoom:80%;"></p><p>不难看出每一趟对bubble的调用所需要的时间都线性正比于绿色无序部分的宽度，整体地呈现为一个算术级数的形式，所以它的总体量与它的末项成平方关系，即$O(n^2)$。然而我们并不满足于这样的结果，至少在很多情况下都是有可能改进的。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>可以看到这里的红色部分确实必然是有序的，但是绿色的部分未必都是无序的，事实上比如这个时候有可能其中会有一部分元素，甚至所有的元素都是有序的。那么如何尽早地判定出这种情况，从而提前结束这个算法呢？这里依赖的准则与算法最初的判定准则是一样的，也就是一个向量包括一个区间如果是完全有序的，当且仅当其中任何一对相邻的元素都是彼此顺序的，而实际上在刚刚进行完的前一次迭代中我们在某种意义上已经做过这种类似的检查了。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212211729.png" style="zoom: 67%;"></p><p>由此可以得出一个改进的策略：在每一次扫描交换的过程中不妨记录一下是否曾经真的存在逆序元素，如果存在的话它的充要条件是在此前做过一次交换，所以我们只要来记录一下在当下这趟扫描交换过程中是否曾经做过至少一次扫描交换，如果没有做过那么后续的各趟其实都可以省略掉，从而在实际的运行时间上有可能会有所减少，甚至大大减少。这是一个很好的策略，我们不妨把这个策略整理为下面的一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123;</span><br><span class="line"><span class="keyword">while</span> (!bubble(lo, hi--));</span><br><span class="line">&#125;  <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123;</span><br><span class="line"><span class="keyword">bool</span> sorted = ture;  <span class="comment">//整体有序标志</span></span><br><span class="line"><span class="keyword">while</span>(++lo &lt; hi)&#123;    <span class="comment">//自左向右，逐一检查各相邻元素</span></span><br><span class="line"><span class="keyword">if</span> (_elem[lo - <span class="number">1</span>] &gt; _elem[lo]) &#123;    <span class="comment">//若逆序，则</span></span><br><span class="line">sorted = <span class="literal">false</span>;                 <span class="comment">//意味着尚未整体有序，并需要</span></span><br><span class="line">swap(_elem[lo - <span class="number">1</span>], _elem[lo]); <span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sorted;  <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原算法整体运行时间确实可以度量为一个三角形的面积，那么对于新的改进的这个算法，它固然要做第一趟扫描交换也许还需进行若干次扫描交换，但是在某些情况下它有可能会发现不光此后的部分已经有序了，而且这个前缀也已经完全有序了，所以这时它就会及时地跳转到最后，聪明地绕过这些完全可以绕过的计算量。因此与刚才那样对比新的这个算法所执行的计算量可以度量为这样一个梯形，而不是原来的三角形，也就是说很多情况下都可以节省一定的甚至是相当多的时间。不过我们对这个算法的改进并不满足于此因为我们发现在一些其它或者说在更多的情况下，这个算法依然存在继续改进的空间。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212212729.png" style="zoom:50%;"></p><h2 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h2><p>考察这样一个向量，假设它可以分为长度相差悬殊的一个前缀以及后缀，而且后缀中的元素都已按顺序排列并严格地就位，当然相应地所有的乱序元素都集中分布于这样一个相对更短的前缀中。对于这样的一个实例，上节中已经做过优化的起泡排序算法会如何表现呢？</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212214445.png" style="zoom: 67%;"></p><p>首先它需要做第一趟完整地扫描交换，并且确认在最后这个位置有一个元素就位，虽然它原本就是就位的。请注意虽然这个时候在这个后缀中，存在着大量的就位元素，但因为在前缀中刚才存在交换，<code>bubble</code>算法会返回false，那么算法接下来还会继续下去。尽管能够判定的就位元素数目会继续增加，但是与刚才同理，我们依然不能确认可以提前退出，接下来还需要进行若干次的扫描交换。那么对于这样的一个例子，总体而言需要的扫描交换的趟数不会超过这个前缀的长度<code>r</code>。</p><p>因为此前所做的各趟扫描交换，与其说是在对绿色的范围做处理，不如说实际影响的是这个前缀中的倒数第一个<br>倒数第二个 以及倒数第三个，即是在这个前缀中后面的那些元素。每一趟扫描交换所起的实质作用无非是在这样一个前缀中，令其中的一个一个的后缀元素依次就位，直到整个这个前缀中的元素完全就位。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212215502.png" style="zoom:67%;"></p><p>因此这个算法总体消耗的时间应该是n乘以r，如果r取作根号n，相应地也就是n的1.5次方，即$O(n^{1.5})$。但如果能及时地检测出这样一种情况，也就是实质需要排序的元素集中在一个宽度仅为$\sqrt{n}$的区间中，而不是整个向量。那么即使套用最原始的起泡排序算法，所需要的时间也无非是$O((\sqrt{n})^2)=O(n)$。问题是如何才能够完成从1.5次方到一次方的优化转换呢？</p><p>重新审视上面的例子，所多余出来的时间消耗无非是在后缀中，对这些已就位元素的反复扫描交换，不难理解这些元素都是不必扫描交换的，可惜此前的算法版本未能及时地将它们分解出来，但它们实际上是可以分解出来的。</p><p>比如说如果我们通过某一种方法记录在上一趟扫描交换过程中所进行的最后一次交换，就很容易确定在上一趟扫描的区间中有一个多长的后缀实际上没有做过任何交换，也就是说它们中的元素都是已经就位了的。如果能这样只需要将原先的右侧标志<code>hi</code>直接地指向这个新的位置，而不是像刚才那样亦步亦趋地、逐个地收缩。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212215732.png" style="zoom:50%;"></p><p>基于以上的分析不难得到下面的新的改进的方法，从结构上看跟刚才大体类似，依然是逐个地检查所有的相邻对，如果是逆序的就做交换，不同之处在于这里我们所记录的不再只是一个逻辑性变量，而是一个名为<code>last</code>的整型或者说是秩，它的初值是取作lo，而每当需要交换就将这个<code>last</code>更新为新的位置。在整个算法的过程中<code>lo</code>这个变量是持续递增的，所以当它在返回的时候，<code>last</code>确实名副其实地记录了最右侧也就是最后一对逆序对的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123;</span><br><span class="line"><span class="keyword">while</span> (!bubble(lo, hi--));</span><br><span class="line">&#125;  <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123;</span><br><span class="line">Rank last = lo;  <span class="comment">//最右侧的逆序对初始化为[lo-1, lo]</span></span><br><span class="line"><span class="keyword">while</span>(++lo &lt; hi)&#123;    <span class="comment">//自左向右，逐一检查各相邻元素</span></span><br><span class="line"><span class="keyword">if</span> (_elem[lo - <span class="number">1</span>] &gt; _elem[lo]) &#123;    <span class="comment">//若逆序，则</span></span><br><span class="line">last = lo;                 <span class="comment">//更新最右侧逆序对位置记录，并</span></span><br><span class="line">swap(_elem[lo - <span class="number">1</span>], _elem[lo]); <span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;  <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;  <span class="comment">//前一版本中的逻辑型标志sorted，改为秩last</span></span><br></pre></td></tr></table></figure><p>这样我们就可以有效地来处理刚才那种情况，回到刚才那个实例，我们构造了一个足够短的乱序前缀再加一个非常长但是已经就绪了的后缀。新的算法首先也会做一趟扫描交换，当然为此花费的时间是$O(n)$。但是与刚才那个版本的不同，在这个时候它会检测出发生的最后一次扫描交换绝对不会超过绿色末尾的位置，将扫描交换的右侧界桩<code>hi</code>一次性地挪到那里，这等效于判断出了此后的这些元素包括最后那个元素都是已经就位的。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212222027.png" style="zoom: 50%;"></p><p>从算法的流程来说我们的下一趟扫描交换的区间，就不再是原先整个那个绿色的区间，而是相对要短很多的一个区间。接下来等效于只是对这样一段区间做扫描交换，因此需要花费的时间除了刚才的$O(n)$以外，主要是对应于这样的一个更小的三角形，如果边长是$\sqrt{n}$，累计也不过是再加上一个$O(n)$，与刚才的$O(n)$合并，总体不过是$O(n)$，更有意思的是这种情况在整个排序过程中有可能会多次出现。</p><p>我们也可以通过图形的方式，形象地将新的这个算法版本与之前的原始版本在时间效率上做一个对比。这个三角形 代表的是原始的起泡排序算法所需要的时间。新版本的算法所需要执行的扫描交换将会呈现为连续的一段。然后再间或地跳跃到下面一段以及再间或地有可能会跳跃到下面一段（深色部分）。换而言之这个算法的时间成本将取决于这样一个一个若干个梯形的面积总和，相对于此前那个梯形来说这种梯形的划分更加的精细，所以它节省下来的时间也会在通常的情况下相对更多。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212220355.png" style="zoom:50%;"></p><p>当然在最坏的情况下这个算法依然是于事无补的，起泡排序依然注定需要$O(n^2)$的时间。</p><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><ul><li><p>三种起泡排序在最好和最坏情况下的效率相同：最好$O(n)$，最坏$O(n^2)$</p></li><li><p>输入含重复元素时，算法的稳定性（stability）是更为细致的要求</p><p>重复元素在输入，输出序列中的相对次序，是否保持不变？（在某些问题中很敏感）</p><p>​        输入：$6,7_a,3,2,7_b,1,5,8,7_c,4$</p><p>​        输出：$1,2,3,4,5,6,7_a,7_b,7_c,8$      //stable</p><p>​                    $1,2,3,4,5,6,7_a,7_c,7_b,8$     //unstable</p></li><li><p>三种起<strong>泡排序算法都是稳定</strong>的，因为在起泡排序中，元素$7_a$和$7_b$的相对位置发生变化，只有一种可能：</p><p>​        经分别与其他元素的交换，二者相互接近直至相邻</p><p>​        在接下来一轮扫描交换中，二者因逆序而交换位置</p><p>而起泡排序中交换，即if的判断条件是<code>_elem[lo - 1] &gt; _elem[lo])</code>，严格大于，因此不会出现上面的情况</p></li></ul><p>虽然起泡排序可以做大量的改进，但从最坏情况而言它依然是注定也需要$O(n^2)$的时间，所以我们非常希望能够得到一个即便在最坏情况下也能够效率更高的排序算法，这也就是下一节所要介绍的内容。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>采用包括Bubble sort在内的常规的基于比较式的算法（Comparison Based Algorithm），求解排序问题都存在一个下界$nlogn$。那么在$n^2$的上界到$nlogn$的下界之间是否存在一些其它的，相对于$n^2$而言更好的算法,甚至于是否有一个算法即使在最坏的情况下也只需要$nlogn$的时间就能完成排序呢？答案就蕴含在这一节的主题里<br>也就是归并排序（Merge Sort）。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212224219.png" style="zoom: 50%;"></p><p>归并排序算法是<strong>分治策略</strong>在算法设计中应用的又一个典型，这个算法最初是由冯·诺依曼编码实现的，所谓的分治策略在这里就是说将待排序的那个序列（向量或者列表）一分为二，这种分法很快捷只需要$O(1)$的时间，接下来 对于划分出的两个子序列分别去做递归地求解，也就是递归地排序。而当两个子序列已经分别有序之后，我们接下来要解决的一个问题就是将它们合并准确地讲是归并merge，从而构成一个完整的有序序列。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212225508.png" style="zoom: 80%;"></p><p>对于上面这样一个由8个元素组成的向量，首先是分沿左右划分为左和右两个子序列，这两个子序列递归地求解的过程中依然还是相对比较大，所以它们会继续递归地、各自地进行划分继续分为左左、左右以及右左和右右四个子序列。同样 它们还是不够平凡所以我们最后还要对这四个子序列继续地一分为二，最终八个元素各自成为一个独立的序列，这个时候从递归地角度讲就抵达了递归基，所有这些元素都已经不需要再继续划分下去了，因为它们各自有序了。</p><p>所以如果说前面半层是做无序向量的递归分解，接下来就要通过逐层的合并使之逐渐地变成一个大一点的，更大一点的，直到最后那个有序的序列。我们可以看到每一次都是将两个已经是有序的子序列合并为一个有序的子序列，然后再继续相邻的子序列逐对地合并构成再更大的序列，最后左右这两个各自有序的子序列再逐对地合并最终得到整体的序列。</p><p>那么如果果真能像这里所说的那样，我们就应该能够得到一个总体是$nlogn$的算法，可由下面的递推式证明，其中$O(n)$是分与并累计的时间。</p><script type="math/tex; mode=display">T(n)=2\cdot T(n/2)+O(n)</script><p>可以得到：$T(n)=O(nlogn)$。</p><p>接下来的技术细节就是如何来兑现这一点呢？可以看到从这里的划分的过程是非常简单，递归也可以交给递归的机制去做，所以这里核心的任务是在怎么进行合并，或者准确地讲是怎么将两个已经有序的序列归并成一个更大的序列，这也是这个算法最关键的细节和技巧。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212224639.png" style="zoom: 50%;"></p><h2 id="主算法"><a href="#主算法" class="headerlink" title="主算法"></a>主算法</h2><p>把刚才的思路实现为这样一段具体的代码，和所有的递归程序一样首先要处理递归基，接下来开始实质的分也就是除二取到中点，这样的话我们可以将整体的一个序列分成左和右两部分，分别由<code>lo</code>和<code>mi</code>，以及<code>mi</code>和<code>hi</code>来界定。对于这两个序列，分别是递归调用自己，<code>mergeSort</code>前一个序列，<code>mergeSort</code>后一个序列。接下来最重要的实质的工作是在<code>merge</code>，下面不妨来通过一个实例来理解merge算法的原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">  <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">  <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">  mergeSort ( lo, mi ); </span><br><span class="line">  mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">  merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>2-way merge：将两个有序序列合并为一个有序序列 S[lo, hi) = S[lo, mi) + S[mi, hi)</li></ul><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212233054.png" style="zoom:80%;"></p><p>首先（a）图给出了两个各自有序的子序列，二路归并算法的要诀就是我们只需要把注意力关注在这两个序列的首元素上，这样一个虚线的方框是我们的关注焦点，其余的元素可以暂时不用顾及。那么我们取出这两个序列各自的首元素的时候，都要从中挑选出更小的那个元素，如果是两者相等的话，可以任意取一个。<br>比如 就这个例子而言</p><p>就这个例子而言首先取出的是这个2，我们将它择出来，相应地在摘除了首元素以后，后续的元素将逐次递补，也就是关注到新顶替上来的这个首元素上。同样在接下来的一轮比对中，我们考察这两个首元素的大小，并且同样地取出其中的更小的那个，4依然比5小所以4被取出，同样它的后继们会顶替上来对这个例子而言就是10。就这样逐步进行到图（h），直到最终一旦有一个向量已经变成空的，那么另一个向量所剩余的元素无论多少都直接串接在后边（因为剩余那部分必然是有序的）。</p><p>按照这样的原理，我们确实可以得到一个更大的单调序列，这种二路归并的算法实际上是非常通用的一个版本，但在这里针对于归并排序而言的，我们实际上用到的是其中的一种特例，在这个时候参与归并的两个序列实际上是来自于同一个更大的向量，只不过是由其中的三个界桩也就是<code>lo</code>、<code>mi</code>和<code>hi</code>来联合定义的。如果左侧的这个向量称作B，右侧的称作C的话，那么合并起来的整体的这个向量就是A。那下一小节介绍针对这样一种特殊情况，二路归并算法应该如何实现。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212234305.png" style="zoom:50%;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序向量（区间）的归并</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge ( Rank lo, Rank mi, Rank hi )&#123;<span class="comment">//各自有序的子向量[lo, mi)和[mi, hi)</span></span><br><span class="line">  T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br><span class="line">  <span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line">  <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="comment">//复制前子向量</span></span><br><span class="line">  <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br><span class="line">  <span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb) || (k &lt; lc); ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt;  B[j]))) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;  <span class="comment">//该循环实现紧凑；但就效率而言，不如拆分处理</span></span><br><span class="line">  <span class="keyword">delete</span> [] B; <span class="comment">//释放临时空间B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读一下上面的代码：首先需要将定义两个向量的三个界桩也就是<code>lo</code>、<code>mi</code>和<code>hi</code>作为参数传入，接下来要定义清楚ABC三个向量：首先A向量在这里将继续地保存在它输入的位置，准确地讲就是在<code>_elem</code>整个数据区中起自于最左侧的界桩<code>lo</code>的一段区间，可以直接令A指向这个区间的起点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br></pre></td></tr></table></figure><p>接下来是左侧的子向量B，我们需要为这个子向量申请一段空间，它的宽度应该是<code>mi</code>到<code>lo</code>之间的距离，当然还需要将A中对应的那些元素，也就是左半部分的那些元素，逐一地取出来并且复制到新开辟的这段空间中去，从而完成整体的这个子向量B的一个缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line"><span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="comment">//复制前子向量</span></span><br></pre></td></tr></table></figure><p>最后是C，C非常的简单，实际上定义的就是在<code>_elem</code>数据区中，起始于<code>mi</code>的这段数据，那么不同的在于右侧的子向量C并不需要另辟空间进行缓存，尽管在这里为了说明的方便，还是将它画在了上边作为一个单独的子向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213000033.png" style="zoom:80%;"></p><p>接下来就是最主要的这个循环，这也就是上节实例子所给的过程，具体来讲就是每一次我们都比较两个子向量当前的首元素取出其中更小的那个，比如说在for循环体中上面一句的情况下B更小，而在下面一句的情况下C更小，无论谁更小都把它转入到A中去。B和C首元素是由j和k这两个秩来标定的，在最初始的情况下它们都是0，分别指向B和C的第一个元素，在随后 每当有一个元素转移到A中，它们各自都会自加，从而指向下一个替补的新的首元素。而A每次纳入新元素由<code>i</code>指示，其初值也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb) || (k &lt; lc); ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt;  B[j]))) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当B更小的情况：严格来讲是由一系列的逻辑判断构成的，首先是一个and，我们要确定<code>j &lt; lb</code>，即B中的首元素的秩应该至少没有越过它的右侧的边界，它还是合法的，也就是<code>B[j]</code>指向的还是一个实在的而不是虚拟的元素，接下来地有两种情况，要么C中的<code>k</code>已经越界，要么就是<code>k</code>没有越界，但是<code>B[j]</code>更小<code>B[j] &lt;= C[k]</code>，这里我们运用了C++语言里头的“<strong>短路求值”</strong>的语法特性，否则在不满足的情况下还去进行比较求值，实际上这个<code>k</code>因为已经越界就会造成程序运行过程中的错误。当C更小的情况也是同理。</p><p>当然整个这个循环的退出条件也值得揣摩的，这里的条件<code>(j &lt; lb) || (k &lt; lc)</code>可以理解为是这两个位置<code>j</code>和<code>k</code>同时越界之后算法才会退出，而在这个时候无论是B还是C中的元素都已经完整地归入到了A中，成为了一个整体的序列。</p><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>为了更好地理解算法的过程，我们不妨分几种情况来给出具体的图示作进一步解释。</p><p>首先来考虑第一种情况（a)，<code>i</code>还是介于<code>lo</code>和<code>mi</code>之间没有越过<code>mi</code>这个界线，还没有进入到C这个子向量的范围，这种情况显然<code>i</code>不可能居于<code>j</code>的左侧，顶多是平齐，所以每次迭代中如果需要发生数据转移的话，无论是<code>B[j]</code>转移到<code>A[i]</code>，还是<code>C[k]</code>转移到<code>A[i]</code>，整个数据从内容来讲都不会发生覆盖，是安全的，功能上讲也是正确的。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093008.png" style="zoom:67%;"></p><p>再来看相对复杂一点的情况(b)，也就是当<code>i</code>在持续增加之后，终会越过<code>mi</code>，进入C的区域。表面看这样会侵犯到C的区域，但实际上不要紧，因为在这个时候<code>k</code>绝对不会位于<code>i</code>的左侧，所以介于<code>mi</code>和<code>i</code>之间的这些元素，其实作为C中原来的元素必然已经归入到A中，当然是它的左侧在<code>i</code>之前的这部分中的某一个适当的位置。所以这种情况依然是安全的，无论是<code>C[k]</code>、还是<code>B[j]</code>转移到<code>A[i]</code>中去，都不会导致C中已有的元素被无意中覆盖掉，从而导致错误。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093113.png" style="zoom:67%;"></p><p>再来看最后两种更为复杂的情况，如图（c），B这个子向量已经提前耗尽，它其中的元素已经完全地归入到A中<br>当然也是就位了，而在C中还残存有部分的元素没有转移和就位。这种情况下我们的逻辑其实相当于等效地是在B的最右侧，就是<code>lb</code>这个位置上增加了一个哨兵节点，而且它的数值就是正无穷。因此即便C的右侧还残存有若干个元素它们也会在接下来的各次迭代中，因为是与这样一个正无穷相比而被认为是更小，从而顺利地转移到A中适当的位置，直到两个子向量都同时耗尽。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093158.png" style="zoom:67%;"></p><p>反过来另一种对称的情况（d）就是C也可能会提前耗尽，也相当于等效地 在C的最右侧增加了一个数值为正无穷的哨兵，它的秩是<code>lc</code>，所以即便在B的尾部 还残存有部分的元素也不要紧，它们也等效于和这样一个数值为正无穷的哨兵相比，总是会被认为是更小，所以按照算法的逻辑会等效地转移到A中剩余的对应区域中去，整个这个过程也是会顺利地进行，不会出现我们所说的数据遗漏或者数据被无意中覆盖。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093242.png" style="zoom:67%;"></p><p>需要注意的是（c）和（d）这两种情况其实并不对等，因为按照这里的设计，其实向量C和B地位本来就是不等的。B是完全复制出来的一个缓冲部分，而C虽然是独立的绘制出来但实际上它就在A中，占据右端，换而言之如果是C提前耗尽，我们确实需要把B尾部的这些元素悉数转移到A的尾部，但如果是B提前耗尽那么对C尾部这些元素的转移其实都是多余的，因为它们原来就在那，完全没有必要。注意到这样一个现象的话，我们就不难对刚才表面上很规范的逻辑进一步的精简：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; lb; ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( lc &lt;= k || (B[j] &lt;= C[k]) ) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (C[k] &lt;  B[j]) ) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213095412.png" style="zoom:67%;"></p><p>这里最重要的改进就是并不需要考虑C提前耗尽的那种情况，我们只需要考虑B提前耗尽的情况，一旦B提前耗尽<br>我们就可以直接终止这个循环包括这个算法，这样可以使这个算法效率进一步的提高，尽管不是从渐进角度而言的一种实质的提高。</p><p>那么这个算法在原来以及包括这样精简之后，从渐进意义上讲 复杂度是多少呢？是否能像我们最初所预期的那样能够有大幅度的提高呢？</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>算法的运行时间主要消耗于for循环，共有两个控制变量 </p><p>​    初始：j = 0, k = 0</p><p>​    最终：j = lb, k = lc</p><p>​    亦即：j + k = lb + lc =hi - lo = n</p></li><li><p>观察：每经过一次迭代，j和k中至少有一个会加一（j + k 也至少加一）</p></li><li><p>故知：merge()总体迭代不过$O(n)$次，累计只需线性时间</p><p>这一结论与排序算法的$\Omega(nlogn)$下界并不矛盾——毕竟这里的B和C均已各自有序</p></li><li><p>归并算法在最坏情况下的复杂度：$T(n)=2\cdot T(n/2)+O(n)$ ——&gt;$T(n)=O(nlogn)$</p></li><li><p>注意：待归并子序列不必等长</p><p>亦即：允许lb $\ne$ lc，mi $\ne$ (lo + hi) / 2</p></li><li><p>实际上，这一算法及结论也适用于另一类序列——列表</p></li></ul>]]></content>
    
    <summary type="html">
    
      如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法：起泡算法与归并算法。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ML:Week1</title>
    <link href="http://nekomoon404.github.io/2020/02/11/ML-Week1/"/>
    <id>http://nekomoon404.github.io/2020/02/11/ML-Week1/</id>
    <published>2020-02-11T02:15:57.000Z</published>
    <updated>2020-02-13T09:43:15.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="What-is-Machine-Learning"><a href="#What-is-Machine-Learning" class="headerlink" title="What is Machine Learning"></a>What is Machine Learning</h2><p>Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition.</p><p>Tom Mitchell provides a more <strong>modern definition</strong>: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”</p><p>Example: playing checkers.</p><p>E = the experience of playing many games of checkers</p><p>T = the task of playing checkers.</p><p>P = the probability that the program will win the next game.</p><p>In general, any machine learning problem can be assigned to one of two broad classifications:</p><p>Supervised learning and Unsupervised learning.</p><h2 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h2><p>In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.</p><p>Supervised learning problems are categorized into “<strong>regression</strong>“ and “<strong>classification</strong>“ problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103343.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103351.png" style="zoom:50%;"></p><p><strong>Example 1:</strong></p><p>Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.</p><p>We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories.</p><p><strong>Example 2</strong>:</p><p>(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture</p><p>(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.</p><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>Unsupervised learning allows us to <strong>approach problems with little or no idea what our results should look like</strong>. We can derive structure from data where we don’t necessarily know the effect of the variables.</p><p>We can derive this structure by clustering the data based on relationships among the variables in the data.</p><p>With unsupervised learning there is no feedback based on the prediction results.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103654.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103533.png" style="zoom:50%;"></p><p><strong>Example:</strong></p><p><strong>Clustering</strong>: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.</p><p><strong>Non-clustering</strong>: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party).</p><h1 id="Model-and-Cost-Function"><a href="#Model-and-Cost-Function" class="headerlink" title="Model and Cost Function"></a>Model and Cost Function</h1><h2 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h2><p>To establish notation for future use, we’ll use $x^{(i)}$to denote the “input” variables (living area in this example), also called input features, and $y^{(i)}$ to denote the “output” or target variable that we are trying to predict (price). A pair $(x^{(i)} , y^{(i)} )$ is called a training example, and the dataset that we’ll be using to learn—a list of m training examples $(x^{(i)},y^{(i)});i=1,…, m$—is called a <strong>training set</strong>. </p><p>Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ.</p><p>To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a <strong>hypothesis</strong>. Seen pictorially, the process is therefore like this:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211104346.png" style="zoom: 80%;"></p><p>When <strong>the target variable that we’re trying to predict is continuous</strong>, such as in our housing example, we call the learning problem a <strong>regression problem</strong>. When <strong>y can take on only a small number of discrete values</strong> (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a <strong>classification problem</strong>.</p><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>We can measure the accuracy of our hypothesis function by using a <strong>cost function</strong>. This takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s.</p><script type="math/tex; mode=display">J(\theta_0, \theta_1) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>To break it apart, it is $\frac{1}{2} <script type="math/tex">\bar{x}$， where</script>\bar{x}$$ is the mean of the squares of $h<em>\theta (x</em>{i}) - y_{i}$, or the difference between the predicted value and the actual value.</p><p>This function is otherwise called the “<strong>Squared error function</strong>“, or “<strong>Mean squared error</strong>“. The mean is halved $\left(\frac{1}{2}\right) $as a convenience for the computation of the gradient descent, as the derivative term of the square function will cancel out the$ \frac{1}{2}$ term. The following image summarizes what the cost function does:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211110416.png" style="zoom: 50%;"></p><h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition 1"></a>Intuition 1</h3><p>If we try to think of it in visual terms, our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by $h_\theta(x)$) which passes through these scattered data points.</p><p>Our objective is to get the best possible line. The best possible line will be such so that the average squared vertical distances of the scattered points from the line will be the least. Ideally, the line should pass through all the points of our training data set. In such a case, the value of $J(\theta_0, \theta_1)$will be 0. The following example shows the ideal situation where we have a cost function of 0.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111045.png" style="zoom:50%;"></p><p>When $\theta_1 = 1$, we get a slope of 1 which goes through every single data point in our model. Conversely, when $\theta_1 = 0.5$, we see the vertical distance from our fit to the data points increase.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111208.png" style="zoom:50%;"></p><p>This increases our cost function to 0.58. Plotting several other points yields to the following graph:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111212.png" style="zoom:50%;"></p><p>Thus as a goal, we should try to minimize the cost function. In this case, $\theta_1 = 1$=1 is our <strong>global minimum</strong>.</p><h3 id="Intuition-2"><a href="#Intuition-2" class="headerlink" title="Intuition 2"></a>Intuition 2</h3><p>A <strong>contour plot</strong>（等高线，轮廓线） is a graph that contains many contour lines. A contour line of a two variable function has a constant value at all points of the same line. An example of such a graph is the one to the right below.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111928.png" style="zoom:50%;"></p><p>Taking any color and going along the ‘circle’, one would expect to get the same value of the cost function. For example, the three green points found on the green line above have the same value for $J(\theta_0,\theta_1)$ and as a result, they are found along the same line. The circled x displays the value of the cost function for the graph on the left when $\theta_0$ = 800 and $\theta_1$= -0.15. Taking another h(x) and plotting its contour plot, one gets the following graphs:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111932.png" style="zoom:50%;"></p><p>When $\theta_0$ = 360 and $\theta_1$ = 0, the value of $J(\theta_0,\theta_1)$ in the contour plot gets closer to the center thus reducing the cost function error. Now giving our hypothesis function a slightly positive slope results in a better fit of the data.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111935.png" style="zoom:50%;"></p><p>The graph above minimizes the cost function as much as possible and consequently, the result of $\theta_1$ and $\theta_0$ tend to be around 0.12 and 250 respectively. Plotting those values on our graph to the right seems to put our point in the center of the inner most ‘circle’.</p><h1 id="Parameter-Learning"><a href="#Parameter-Learning" class="headerlink" title="Parameter Learning"></a>Parameter Learning</h1><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>So we have our hypothesis function and we have a way of measuring how well it fits into the data. Now we need to estimate the parameters in the hypothesis function. That’s where <strong>gradient descent</strong> comes in.</p><p>Imagine that we graph our hypothesis function based on its fields $\theta_0$ and $\theta_1$ (actually we are graphing the cost function as a function of the parameter estimates). We are not graphing x and y itself, but the parameter range of our hypothesis function and the cost resulting from selecting a particular set of parameters.</p><p>We put $\theta_0$ on the x axis and $\theta_1$ on the y axis, with the cost function on the vertical z axis. The points on our graph will be the result of the cost function using our hypothesis with those specific theta parameters. The graph below depicts such a setup.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211112658.png" style="zoom:50%;"></p><p>We will know that we have succeeded when our cost function is at the very bottom of the pits in our graph, i.e. <strong>when its value is the minimum</strong>. The red arrows show the minimum points in the graph.</p><p>The way we do this is by taking the <strong>derivative</strong> (the tangential line to a function) of our cost function. The slope of the tangent is the derivative at that point and it will give us a direction to move towards. We make <strong>steps down the cost function in the direction with the steepest descent</strong>. The size of each step is determined by the parameter α, which is called the learning rate.</p><p>For example, the distance between each ‘star’ in the graph above represents a step determined by our parameter α. A smaller α would result in a smaller step and a larger α results in a larger step. The direction in which the step is taken is determined by the partial derivative of J(\theta_0,\theta_1)<em>J</em>(<em>θ</em>0,<em>θ</em>1). Depending on where one starts on the graph, one could end up at different points. The image above shows us two different starting points that end up in two different places.</p><p>The gradient descent algorithm is:</p><p>repeat until convergence:</p><script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} J(\theta_0, \theta_1)</script><p>where $j=0,1$ represents the feature index number.</p><p>At each iteration j, one should simultaneously update the parameters $\theta_1, \theta_2,…,\theta_n$. Updating a specific parameter prior to calculating another one on the $j^{(th)}$ iteration would yield to a wrong implementation.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211112718.png" style="zoom:50%;"></p><h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>In this part we explored the scenario where we used one parameter $\theta_1$ and plotted its cost function to implement a gradient descent. Our formula for a single parameter was :</p><p>Repeat until convergence:</p><script type="math/tex; mode=display">\theta_1 := \theta_1 - \alpha \frac{\partial}{\partial \theta_1} J(\theta_1)</script><p>Regardless of the slope’s sign for $\frac{d}{d\theta_1} J(\theta_1)$, $\theta_1$ eventually converges to its minimum value. The following graph shows that when the slope is negative, the value of $\theta_1$ increases and when it is positive, the value of $\theta_1$ decreases.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113613.png" style="zoom:50%;"></p><p>On a side note, we should <strong>adjust our parameter $\alpha$ to ensure that the gradient descent algorithm converges in a reasonable time</strong>. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113618.png" style="zoom:50%;"></p><p>How does gradient descent converge with a fixed step size $\alpha$?</p><p>The intuition behind the convergence is that $\frac{d}{d\theta_1} J(\theta_1)$ approaches 0 as we approach the bottom of our convex function. At the minimum, the derivative will always be 0 and thus we get:</p><script type="math/tex; mode=display">\theta_1 := \theta_1 - \alpha*0</script><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113622.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113625.png" style="zoom:50%;"></p><h2 id="Gradient-Descent-For-Linear-Regression"><a href="#Gradient-Descent-For-Linear-Regression" class="headerlink" title="Gradient Descent For Linear Regression"></a>Gradient Descent For Linear Regression</h2><p>When specifically applied to the case of linear regression, a new form of the gradient descent equation can be derived. We can substitute our actual cost function and our actual hypothesis function and modify the equation to :</p><p>Repeat until convergence:</p><script type="math/tex; mode=display">\begin{align*}   & \newline \theta_0 := & \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}(h_\theta(x_{i}) - y_{i}) \newline \theta_1 := & \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}\left((h_\theta(x_{i}) - y_{i}) x_{i}\right) \newline & \end{align*}</script><p>where m is the size of the training set, $\theta_0$ a constant that will be changing simultaneously with $\theta_1$ and $x_i$, $y_i$ are values of the given training set (data).</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114831.png" style="zoom:50%;"></p><p>The point of all this is that if we start with a guess for our hypothesis and then repeatedly apply these gradient descent equations, our hypothesis will become more and more accurate.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114835.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114839.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114850.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114854.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114859.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114902.png" style="zoom:50%;"></p><p>So, this is simply gradient descent on the original cost function J. This method looks at every example in the entire training set on every step, and is called <strong>batch gradient descent</strong>. Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have posed here for linear regression has only one global, and no other local, optima; thus gradient descent always converges (assuming the learning rate α is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114941.png" style="zoom: 67%;"></p><p>The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (48,30). The x’s in the figure (joined by straight lines) mark the successive values of θ that gradient descent went through as it converged to its minimum.</p>]]></content>
    
    <summary type="html">
    
      这几天开始看coursera网站上Andrew Ng教授的Machine Learning课程，看评论说这门课讲的比较浅显，适合入门学习，课程是按周排的，那我也按周记录下学习的内容_φ_(．．)。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（3）有序向量</title>
    <link href="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/</id>
    <published>2020-02-10T02:58:38.000Z</published>
    <updated>2020-02-12T12:44:19.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h1><p>有序向量是相对于无序向量而言，无序向量要求元素之间至少应该能比较是否相等，我们称作比对操作；而有序向量更为复杂，它需要能够判定任何一对元素孰大孰小，这叫作比较操作。元素之间可以相互比较只是有序向量的一个必要条件，如果要成为一个真正的有序向量，还必须要求其中的元素确实是按照顺序排列的，因此就存在一个如何甄别一个向量是否有序的问题。</p><h2 id="有序性及其甄别"><a href="#有序性及其甄别" class="headerlink" title="有序性及其甄别"></a>有序性及其甄别</h2><ul><li>与起泡排序算法的理解相同：</li></ul><p>​        有序序列中，任意一对相邻元素顺序；无序序列中，总有一对相邻元素逆序。</p><ul><li>因此，逆序相邻元素的数目，可用以度量向量的逆序程度。</li><li>无序向量经预处理转换为有序向量之后，相关算法多可优化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//返回逆序相邻元素对的总数</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;    <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _sizei++)        <span class="comment">//逐一检查各对相邻元素</span></span><br><span class="line">n += (_elem[i - <span class="number">1</span>] &gt; _elem[i]);  <span class="comment">//逆序则计数</span></span><br><span class="line"><span class="keyword">return</span> n;   <span class="comment">//向量有序当且仅当 n = 0</span></span><br><span class="line">&#125;  <span class="comment">//若只需判断是否有序，则首次遇到逆序对之后，即可立即终止</span></span><br></pre></td></tr></table></figure><p>根据上面的分析可以知道，一个向量是有序的，当且仅当经过disordered()判断以后返回的值是零。实际上只要向量中的元素本身是支持大小比较的，就有一定的办法将它转化为有序向量。其中的原因在于经过这样的一个转换以后虽然我们花费了一定的成本，但此后涉及到的很多操作也就是相关算法，大多都可以优化，相应地所得要远远比转换时所花费的成本大的多。</p><h2 id="低效算法"><a href="#低效算法" class="headerlink" title="低效算法"></a>低效算法</h2><p>上一篇文章介绍了无序向量的去重操作，现在我们希望把这种去重操作推广到有序向量，即将一个有序向量中的重复元素（如果存在）全部剔除掉，同样地每一组重复元素只保留一个副本。有序向量其实相对于无序向量而言，具有更好的规范性。这种规范性是指在有序向量中，彼此重复的元素必然会依次相互紧邻地构成一个一个的区间，比如就下图中的例子而言，这些元素相互重复，它们彼此紧邻，会紧密地排列成一个区间，其它元素也有这种规律。所以既然我们需要从每一组元素中保留一个副本，等价于从其中找出一个代表并且保留下来。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210132545.png" style="zoom: 67%;"></p><p>具体到一个算法，可以大致用一个线性扫描过程来描述：每次都观察并比对一对相邻的元素，如果二者相等就将后者删除掉，并且继续比较，如果后者还相等就把它继续删除掉，直到遇到一个不相重复的元素，这个时候我们才把注意力后移，再去考虑下一对紧邻的元素，如果依然出现这种情况再删除，直到又转到下一对。这样确实可以顺利地把所有重复的元素都剔除掉，但是不倾向与使用，因为其效率低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line"><span class="keyword">int</span> oldSize = _size;  <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//从首元素开始</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; _size - <span class="number">1</span>)  <span class="comment">//从前向后，逐一比对各相邻元素</span></span><br><span class="line"><span class="comment">//若雷同，则删除后者；否则，转至后一个元素</span></span><br><span class="line">(_elem[i] == _elem[i + <span class="number">1</span>]) ? <span class="built_in">remove</span>(i + <span class="number">1</span>) : i++;</span><br><span class="line"><span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：其中_size的减小，由remove()内隐式地完成</span></span><br></pre></td></tr></table></figure><h3 id="低效算法的复杂度"><a href="#低效算法的复杂度" class="headerlink" title="低效算法的复杂度"></a>低效算法的复杂度</h3><ul><li>算法的运行时间主要取决去<code>while</code>循环，次数共计: _size - 1 = n -1</li><li>最坏情况下：每次都需调用<code>remove()</code>，耗时$O(n-1)\sim O(1)$，累计$O(n^2)$</li></ul><p>​       尽管省去<code>fine()</code>，总体竟与无序向量的<code>deduplicate()</code>相同。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113255.png" style="zoom: 80%;"></p><h2 id="高效算法"><a href="#高效算法" class="headerlink" title="高效算法"></a>高效算法</h2><p>需要首先对原有的算法进行反思，我们发现造成低效率的根源在于：其中的同一个元素有可能会作为被删除元素的后继，而多次地参与前移操作，对于这样的一个元素来说虽然它每次都是向前移动，但是很可惜它的每一次移动只会移动一个单元，而不是一次性地一步到达它最终的位置。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113558.png" style="zoom:50%;"></p><p>反过来这就启示我们，如果能够将每一个<strong>重复的区间作为一个整体</strong>来考虑，成批地删除雷同的元素而不是像刚才那样逐个地去删除，并且逐个地移动，就有可能实现这种一步到位式的移动，从而使得整体的性能大大地改进。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113800.png" style="zoom: 80%;"></p><p>这个新算法的思路可以由上面的图来表示，在任何时刻我们关注的都是<code>i</code>和<code>j</code>两个元素，而且这里有一个不变性，也就是在<code>i</code>之后 <code>j</code>之前的所有这些元素都与<code>i</code>重复，这个算法一直扫描直到发现第一个与i不同的元素。如果它确实是不同的话我们就只需将<code>j</code>向前移到与<code>i</code>紧邻于右侧的这个位置，这是一个很高明的删除算法，因为在这样的一个过程中虽然没有显式地去做这些重复元素的删除，但是实际上已经无形中将它们忽略掉了，等效于做删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">Rank i = <span class="number">0</span>, j = <span class="number">0</span>;     <span class="comment">//各对互异“相邻”元素的秩</span></span><br><span class="line"><span class="keyword">while</span> (++j &lt; _size)    <span class="comment">//逐一扫描，直至末元素</span></span><br><span class="line"><span class="comment">//跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧</span></span><br><span class="line"><span class="keyword">if</span> (_elem[i] != _elem[j])  </span><br><span class="line">_elem[++i] = _elem[j];</span><br><span class="line">_size = ++i;  </span><br><span class="line">shrink();      <span class="comment">//直接截除尾部多余元素</span></span><br><span class="line"><span class="keyword">return</span> j - i;  <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：通过remove(lo,hi)批量删除，依然不能达到高效率</span></span><br></pre></td></tr></table></figure><h3 id="高效算法的复杂度"><a href="#高效算法的复杂度" class="headerlink" title="高效算法的复杂度"></a>高效算法的复杂度</h3><p>下面通过一个例子来分析新算法的复杂度：</p><ul><li>共计n-1次迭代，每次常数时间，累计$O(n)$时间。</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210114155.png" style="zoom:80%;"></p><p>算法首先考虑的<code>i</code>和<code>j</code>元素，其实就是0和1号元素，对这个例子而言它们是彼此重复的元素，所以在那个循环中将会通过那个隐藏着看不见的<code>else</code>直接将它忽略掉，并且使得<code>j</code>进而转向下一个单元，以及在接下来的一个循环中再下一个单元，以及再下一个单元。执行到3和5出现了第一次的不同，按照刚才算法的逻辑会把<code>i++</code>到1号位置，然后把第<code>j</code>号元素取出来复制到对应的1号位置上，这就是为什么变成了3和5相邻。注意，在这个过程中我们并<strong>没有做显式的删除操作</strong>。</p><p>接下来的操作与之类似，直到<code>j</code>第一次越过右侧的边界的时候循环退出，算法也就终止。这个时候我们已经无形中将后边的这些元素统一地给删除掉了，这种删除非常的高明，因为我们没有做任何的一次显式的删除操作，而只是通过合理的计算得知了最终的向量规模之后，对<code>_size</code>这个量重新进行了一次设置。</p><p>通过这个例子可以得出，算法过程中只是经过了<code>i+1</code>次的迭代，每次移动j必然总是会往后移动一位。而且在每一次过程中，所做的操作无非就是一次比对，只有在比对不同的情况下才会做一次复制，即便是最坏的情况下既比对而且也复制的话，累计起来也不过是常数的时间。所以换而言之，整个这个新的算法只需要$O(n)$线性的时间。</p><h1 id="二分查找（版本A）"><a href="#二分查找（版本A）" class="headerlink" title="二分查找（版本A）"></a>二分查找（版本A）</h1><p>在上一篇文章中介绍了无序向量的查找算法，它的格式为<code>Vector::find(e, lo, hi)</code>，第一个参数指明查找的对象，第二和第三个参数<code>lo</code>和<code>hi</code>指示查找的区间范围。这种算法从思路上来说大体是从一端出发不断地逐个比对，直到发现某一个特定的元素就是<code>e</code>，或者一直到<code>lo-1</code>这个位置在左侧越界，即是查找失败。所以最好情况它只需$O(1)$的时间，但是从最坏的情况以及从一般<code>e</code>的概率分布的平均情况而言，都不得不需要线性的时间。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210141315.png" style="zoom:67%;"></p><p>那么在进入有序向量之后，我们应该可以得到更快的一种解决方案，不妨重新起一个名字叫<code>search()</code>，以示与无序向量的那个<code>find()</code>的区别。当然从操作的参数以及接口的语义来说都是类似的，即我们同样要在<code>lo</code>到<code>hi</code>这样一个左闭右开的区间里找到一个特定的元素。</p><h2 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//查找算法统一接口，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::search(T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi) <span class="keyword">const</span>&#123;   </span><br><span class="line"><span class="keyword">return</span>(rand() % <span class="number">2</span>) ?   <span class="comment">//按各50%的概率随机选用</span></span><br><span class="line">binSearch(_elem, e, lo, hi)   <span class="comment">//二分查找算法，或者</span></span><br><span class="line">  : fibSearch(_elem, e, lo, hi);  <span class="comment">//Fibonacci查找算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所提供的<code>search()</code>接口从形式上看是统一的，即ADT。从内部讲，它的具体实现算法却不见得完全一样，后面的的各节将会分别介绍二分查找算法以及Fibonacci查找算法，而且对每一种算法都有不同的版本。</p><p>为了做测试这里采用了一个随机的方法，也就是在0和1之间随机地取一个数，从而随机地调用这两个算法。在实际应用中可以针对不同的情况在这几种算法中选择其一。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210142201.png" style="zoom: 67%;"></p><p><code>seach()</code>的简要的操作语义就是在<code>lo</code>和<code>hi</code>所确定的这个区间找出目标元素<code>e</code>（如果它确实存在的话）。这里需要处理很多特殊的情况，比如，目标元素并不存在与规定的区间中，这就叫失败。在此前学习的无序向量的<code>find</code>的接口中我们只是简单地返回了一个标志-1，但严格地说这样做是不够的。反过来有可能目标元素存在多个，既然作为有序向量，一旦有多个e的话，那么它肯定会连续地分布构成一个区间。在这种情况下，到底是返回最前边的一个，最后的一个？还是中间的某一个？这些都是我们需要进一步地从语义上予以约定的。</p><h2 id="语义约定"><a href="#语义约定" class="headerlink" title="语义约定"></a>语义约定</h2><p>在语义上的细致约定是非常有必要的，否则<code>search()</code>接口将只能作为一个孤立的功能，而不能有效地、便捷地为其它的算法，作为一个基本的部件而利用。<code>search()</code>接口至少应该<strong>使得有序向量自身的动态维护变得非常便利</strong>，比如在有序向量不断插入元素过程中，我们希望往往能够采用这样一种形式：当插入某一个元素时，首先要通过<code>search()</code>来确定一个适当的位置，例如查找返回的那个值再加1，然后再将<code>e</code>插入于这个秩所对应位置，并且同时使得这个有序向量继续是一个有序向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.insert(<span class="number">1</span> + V.search(e), e);</span><br></pre></td></tr></table></figure><p>幸运的是前人已经帮我们设计出了这样的<strong>语义约定</strong>，比如下面就是其中的一种约定：</p><ul><li>在有序向量区间V[lo, hi)中，确定不大于e的最后一个元素</li><li>-∞ &lt; e &lt; V[lo] 时，返回 lo-1 （左侧哨兵）</li><li>V[hi-1] &lt; e &lt; +∞ 时，返回hi-1（右侧哨兵的前一个）</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210171952.png" style="zoom:67%;"></p><p>按照这个约定，对于要查找的元素有重复元素的情况，即有多个元素是与目标的元素是重复的，应该返回的所谓的不大于<code>e</code>的最后一个元素，也就是这个区段的右端点。如果我们要做一个插入，把新的元素插入这个位置同加1后的位置，即重复元素区间右端点的后面，正是再合适不过的。</p><p>这里的合适是指：第一，它继续保持了整体的有序性；第二，它以及与它雷同的那些元素会保持它们插入到这个向量中的先后的次序。所以这种语义约定是非常好的，它涵盖了我们几乎所有的情况包括特殊情况。所以接下来我们在实现这些具体的算法的时候，必须最终落实到能够符合这种语义的要求。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个版本只是为了说明原理，从严格的意义上讲，它还不能完全地符合刚才的语义要求，在后面的小节就会对它进行改进。</p><ul><li><p>减而治之：以任一元素x = S[mi] 为界，都可将待查找的区间分为三部分</p><p>S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)                 // S[mi] 称作轴点</p></li><li><p>只需将目标元素e与x做比较，即可分三种情况进一步处理：</p><ul><li>e &lt; x：则e若存在，必属于左侧子区间S[lo, mi)，故可递归深入</li><li>x &gt; e：则e若存在，必属于右侧子区间S(mi, hi)，亦可递归深入</li><li>x = e：已在此处命中，可随即返回       //若有多个，返回哪个？后面会介绍</li></ul></li><li><p>二分（折半）策略：轴点mi总是取作中点（至少能保证不是最坏情况）</p><p>于是每经过至多两次比较，或者能够命中，或者将问题规模减一半</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210174237.png" style="zoom: 67%;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//在有序向量区间[lo, hi)内查找元素e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;  </span><br><span class="line">Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;     <span class="comment">//每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line"><span class="keyword">if</span>      (e &lt; A[mi])  hi = mi;      <span class="comment">//深入前半段[lo, hi)继续查找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[mi] &lt; e)  lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)</span></span><br><span class="line"><span class="keyword">else</span>                 <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong>：这里有编写程序的一个小的习惯，可以帮助我们更好地思考问题并且写出算法，更重要的是可以让代码更加好理解，同时也减少一些不必要的失误。我们这里<strong>统一地都用了小于号</strong>，因为小于号的左右的次序和我们通常所画的这样从小到大的次序是吻合的，所以这里<code>e &lt; A[mi]</code>的解读既可以认为是<code>e</code>小于<code>mi</code>，也可以认为是<code>e</code>存在于当前这个分界点<code>mi</code>的左侧。当这样顺着读下来时，当然我们就应该深入到前半段也就是左半段去，相应地呢，我们应该修改右侧的界桩<code>hi = mi</code>。同样接下来<code>A[mi] &lt; e</code>解读也是这样与其说是<code>mi</code>小于<code>e</code>，不如更直观地说是我们的目标<code>e</code>是处于<code>mi</code>这个分界点的右侧，所以我们应该深入到右半段也就是后半段去继续搜索，相应的操作也就是去修改左侧的界桩<code>lo = mi +1</code>。</p><h2 id="实例与复杂度"><a href="#实例与复杂度" class="headerlink" title="实例与复杂度"></a>实例与复杂度</h2><ul><li><code>S.search(8, 0, 7)</code>：共经$2+1+2=5$次比较，在<code>S[4]</code>处命中</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182501.png" style="zoom:67%;"></p><ul><li><code>S.search(3, 0, 7)</code>：共经$1+1+2=4$次比较，在<code>S[1]</code>处失败</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182505.png" style="zoom:67%;"></p><ul><li><p>线性递归：$T(n)=T(n/2)+O(1)=O(logn)$，大大优于顺序查找</p><p>递归跟踪：轴点总取重点，递归深度$O(logn)$；各递归实例均耗时$O(1)$。</p></li></ul><h2 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h2><p>有序向量的查找是一种非常基本的算法，而且它存在多个版本，因此除了上面利用渐近的复杂度能够从总体上把握它的大体性能以外，我们还需要对不同版本算法的性能做更加细微的评定。具体来说就是考察渐近复杂度$logn$前面的那个常系数，而具体地在统计和分析的时候，更多的是考量关键码的比较操作次数，也就是在其中所执行的if语句的次数，我们将此称作是不同的算法在不同的情况下所对应的查找长度。</p><ul><li><p>如何更为精确地评估查找算法的性能？</p><p>考查关键码的比价次数，即查找长度（search length）</p></li><li><p>通常，需分别针对成功与失败查找，从最好，最坏，平均等角度评估</p></li><li><p>例如，成功、失败时的平均查找长度均大致为$O(1.50\cdot logn)$。</p></li></ul><p>下面是一个一个具体的实例，这是一个由七个元素构成的有序向量，其实它的数值是具体是多少我们并不在意，只要它是非降排列的就可以。如果把算法改写成递归的形式，那么整个的不同情况的递归跟踪将构成下面的递归跟踪图，每条虚线旁边的数字代表由上一步执行到下一步所增加的比较操作的次数，具体位置的方框中的数字代表查找到它所需要总的比较操作次数，即查找长度。需要注意的是，每次递归到左子区间，比较操作次数增加1，而递归到右区间，比较操作次数增加2。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210193029.png" style="zoom:80%;"></p><ul><li>n = 7时，各元素对应的成功查找长度为${4,3,5,2,5,4,6}$</li></ul><p>​       在等概率情况下，平均成功查找长度$=29/7=4.14$；</p><ul><li><p>共有8中失败情况，查找长度分别为${3,4,4,5,4,5,5,6}$</p><p>在等概率情况下，平均失败查找长度$=36/8=4.50$；</p></li><li><p>可见，成功和失败的平均查找长度大致是$1.50\cdot log_28$</p></li></ul><h1 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h1><h2 id="改进思路及原理"><a href="#改进思路及原理" class="headerlink" title="改进思路及原理"></a>改进思路及原理</h2><p>在上一节引入了二分查找（Binary search）这样的一个概念，并且给出了一个基本的算法的版本，这个版本的复杂度从渐近意义而言应该是logn量级的，但如果进一步地细微地来考察前面的系数大致是1.5，我们也指出这个1.5是可以改进的。我们现在就来看看，如何通过一种新的算法：fibonacci查找（fibonaccian search）来对此进行改进。</p><p>上一节的末尾以一个长度为7的有序向量为例，具体地给出了在成功和失败情况下平均查找长度的估算的过程。实际上通过那个实例的推而广之，如果考虑更一般的情况，不难发现此前所介绍的版本A，确实还有很大地改进余地。这样一个判断是来自于这样一个观察事实，也就是说版本A这个算法实际上从用意上讲，它是试图通过使各种情况的搜索<strong>在迭代次数上的平衡</strong>来尽可能地回避掉最坏的情况。</p><p>具体讲比如所有的失败情况大部分都会失败在同样深度的，也就是最深的这个位置，所以它表面上看是平衡的，但这其中却蕴涵着很大的不平衡。因为在整个这个查找的过程中我们在任何一个位置上，如果要决定是向左或者是向右深入的话，所花费的成本，也就是比较的次数是不等的。准确地说按照版本A，向左侧只需要一次比较，而向右侧却需要两次比较，所以这样一个表面上看是非常公平的一个平衡，实际上在内部却蕴涵着极大的不平衡，所以我们确实有理由怀疑算法的效率是否已经达到最优。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201438.png" style="zoom: 50%;"></p><p>反过来我们也可以得到改进的一个思路，具体讲就是既然我们已经看到目前的机制中，向左侧确实会成本更低，而向右侧更高。那么为什么不把这个搜索的各种情况画成类似下面的这样一个树状图，做成左侧是更深的，而右侧是相对更浅的。这样一个表面上看的不平衡，却因为它恰好和这种成本互相之间能做一个合适的补偿，反过来有可能从整体上会得到更优，也就是说使得整体的查找平均长度反而会缩短。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201558.png" style="zoom:50%;"></p><p>具体来讲，越是成本低的转向我们就越希望更多地做，越是成本更高的越是希望它能更少地来做，所以这样的话我们就得到了新的算法的改进的思路。那么具体这个思路怎么来兑现呢？非常有意思的是需要用到<strong>fibonacci数</strong>。不失一般性，假设有序向量的长度N，就是某个fibonacci数减1的形式。</p><p>如下图所示有序向量的长度<code>n = fib(k) - 1</code>，那我们就在其中选择这么样一个特定的切分点<code>mi</code>，<code>mi = fib(k-1) - 1</code>，如果以这个点为切分，那么左边子向量的长度就恰好是<code>fib(k-1) - 1</code>，而右边子向量的长度恰巧是<br><code>fib(k-2) - 1</code>。可见这样一种切分的好处就是，在任何时候只要按照这样来切分，无论是向左还是向右它都会从长度上保持某个fibonacci数再减1的形式，而这种形式实际上恰好是最优的。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210203236.png" style="zoom:67%;"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>首先定义一个<code>Fib</code>类，让其提供一些接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span> &#123;</span> <span class="comment">//Fibonacci数列类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> f, g; <span class="comment">//f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Fib ( <span class="keyword">int</span> n ) <span class="comment">//初始化为不小于n的最小Fibonacci项</span></span><br><span class="line">  &#123; f = <span class="number">1</span>; g = <span class="number">0</span>; <span class="keyword">while</span> ( g &lt; n ) next(); &#125; <span class="comment">//fib(-1), fib(0)，O(log_phi(n))时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> g; &#125; <span class="comment">//获取当前Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; g += f; f = g - f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至下一Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123; f = g - f; g -= f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至上一Fibonacci项，O(1)时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Fibonacci查找可以实现为下面的一段代码，可以注意到它的接口还是完全一样的，而且在其中的这个循环，大致来说也是与版本A类似的，即每次都要来判断以保证当前的<code>lo</code>和<code>hi</code>构成一个合法的区间，如果这个区间能够收缩到非法(lo == hi)，那也就意味着查找是失败的，这跟此前的版本A是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fibonacci/Fib.h"</span> <span class="comment">//引入Fib数列类</span></span></span><br><span class="line"><span class="comment">// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Fib <span class="title">fib</span><span class="params">(hi - lo)</span></span>;   <span class="comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">   <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( hi - lo &lt; fib.<span class="built_in">get</span>() ) fib.prev();   <span class="comment">//自后向前顺序查找（分摊O(1)）</span></span><br><span class="line">      Rank mi = lo + fib.<span class="built_in">get</span>() - <span class="number">1</span>;       <span class="comment">//确定形如Fib(k) - 1的轴点</span></span><br><span class="line">      <span class="keyword">if</span>      ( e &lt; S[mi] ) hi = mi;      <span class="comment">//深入前半段[lo, mi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( S[mi] &lt; e ) lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span>                  <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">   &#125; <span class="comment">//成功查找可以提前终止</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure><h2 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h2><ul><li>fibonacci查找算法的平均查找长度为$O(1.44 \cdot logn)$，略优于二分查找</li><li>仍以n = fib(6) -1 = 7 为例，在等概率情况下：<ul><li>平均成功查找长度$=(2+3+4+4+5+5+5)/7=28/7=4.00&lt;4.14$</li><li>平均失败查找长度$=(4+5+4+4+5+4+5+4)/7=35/7=4.38&lt;4.50$</li></ul></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210205204.png" style="zoom: 80%;"></p><h2 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h2><ul><li><p>通用策略：对于任何的A[0, n)，总是选取A[λn]作为轴点，$0\le \lambda &lt;1$:</p><p>比如二分查找对应于$\lambda=0.5$，Fibonacci查找对应于$\lambda=\phi=(\sqrt{5}-1)/2=0.6180339\dots$（黄金分割比）</p></li><li><p>在[0, 1)内，$\lambda$如何取值才能达到最优？设平均查找长度为$\alpha(\lambda)\cdot log_2n$，何时$\alpha(\lambda)$最小？</p></li><li><p>递推式：$\alpha(\lambda)\cdot log_2 n=\lambda\cdot [1+\alpha(\lambda)\cdot log_2 (\lambda n)]+(1-\lambda)\cdot [2+\alpha(\lambda)\cdot log_2 \left((1-\lambda) n \right)]$</p></li><li><p>整理后：$\frac{-ln2}{\alpha(\lambda)}=\frac{\lambda\cdot ln\lambda+(1-\lambda)\cdot ln(1-\lambda)}{2-\lambda}$，当$\lambda=\phi$时，$\alpha(\lambda)=1.440420\dots$达到最小。</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210212554.png" style="zoom: 80%;"></p><p>相对于我们上一节的二分查找$\alpha(\lambda)=1.50$，Fabonacci查找又有了一定的改进，而且从本节的分析可以看出这种改进已经达到了极限，如果我们不再改变这个算法的总体模式和框架的话。</p><h1 id="二分查找（改进）"><a href="#二分查找（改进）" class="headerlink" title="二分查找（改进）"></a>二分查找（改进）</h1><p>这一节将介绍另一种思路的改进，这是一种直截了当的改进思路，既然我们已经注意到了此前的版本A中造成效率略低的原因是因为左右分支的转向代价不平衡，那么可以考虑是否能将二者做成是平衡的。</p><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><ul><li><p>二分查找中左、右分支转向代价不平衡的问题，也可直接解决</p></li><li><p>比如，每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个</p></li><li><p>同样地，轴点mi取作中点，则查找每深入一层，问题规模也缩减一半</p><p>1）e &lt; x：  则e若存在，必属于左侧子空间S[lo, mi)，故可递归深入</p><p>2）x &lt;= e：则e若存在，必属于右侧子空间S[mi, hi)，亦可递归深入</p></li><li><p>只有当元素数目hi - lo = 1时，才判断该元素是否命中，这是该算法做出的牺牲</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210215936.png" style="zoom:67%;"></p><h2 id="版本B：实现"><a href="#版本B：实现" class="headerlink" title="版本B：实现"></a>版本B：实现</h2><p>主要注意代码中与版本A不同的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找算法（改进）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo ) &#123;         <span class="comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;   <span class="comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi;     <span class="comment">//经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">  &#125;    <span class="comment">//出口时hi = lo + 1，查找区间仅含一个元素A[lo]</span></span><br><span class="line">  <span class="keyword">return</span> (e == A[lo]) ? lo : <span class="number">-1</span>; <span class="comment">//返回命中元素的秩或者-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法是封闭的，可以运转，而且可以完全实现此前一样的功能。与此前的版本A对比，它在最好情况下反而有所倒退，原因是在与即使是成功的情况它也一直要推迟到最终，只有在经过最终的这次比对之后才会确定是否成功。此前的版本A它的最好情况是非常好的，最最好的情况莫过于在第一次试图做减而治之的时候，所采用的那个切分点就成功命中，只需要$O(1)$的时间。</p><p>本节改进的二分查找无论如何都一直要切分到最后，所以最好的情况的时间复杂度是$O(logn)$。但是反过来最坏的情况又会更好，因为我们这里最坏的情况不会出现每一次都是向右，即每次都要花费两次比较的情况，所以最坏的情况会得到抑制。所以从总体而言此前的那个版本A如果说它在性能上好坏情况相差非常大的话，那么本节中改进的版本在整体性能上，它就会趋于更加的稳定，即差异化不是那么大，当然这还不是它的最大的优势所在。</p><h2 id="语义约定-1"><a href="#语义约定-1" class="headerlink" title="语义约定"></a>语义约定</h2><ul><li><p>以上的二分查找及Fibonacci查找算法，均未严格地兑现<code>search()</code>接口的语义约定：</p><p><strong>返回不大于e的最后一个元素</strong></p></li><li><p>只有兑现这一约定，才可以有效支持相关算法，比如：<code>V.insert(1 + V.search(e), e)</code></p><p>1）当有多个命中元素时，必须返回最靠右（秩最大）者</p><p>2）失败时，应返回小于e的最大者（含哨兵<code>lo-1</code>）</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210222959.png" style="zoom:67%;"></p><h2 id="版本C：实现"><a href="#版本C：实现" class="headerlink" title="版本C：实现"></a>版本C：实现</h2><p>在刚才代码的基础上，我们做进一步的调整，得到一个最终的版本，它可以严格地实现上面定义的语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) </span><br><span class="line">  &#123;   <span class="comment">//不变性：A[0,lo) &lt;= e &lt; A[hi,n)</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;    <span class="comment">//以中点为轴点</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>;    <span class="comment">//经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">  &#125; <span class="comment">//出口时，A[lo = hi]为大于e的最小元素</span></span><br><span class="line">  <span class="keyword">return</span> --lo;   <span class="comment">//故循环结束时lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125;   <span class="comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span></span><br></pre></td></tr></table></figure><p>就算法的结构而言，这个新的算法版本C和此前的版本A，尤其是版本B，似乎没有什么太大的区别。解读一下：当这个区间还是合法之前我们就不断地迭代，每一次也照样是取出它的中点作为轴点，并且经过一次比较从而决定到底是向左侧还是向右侧深入，那么直到区间宽度缩小到足够小的时候，才返回最终的值。</p><p>需要注意的是版本C和版本B，虽然在功能上是等效的，但是在很多细节上却有着本质的<strong>区别</strong>：</p><ul><li>待<strong>查找区间宽度缩短至0</strong>而非1时，算法才结束</li><li>转入右侧子向量时，<strong>左边界取作mi+1</strong>，而非mi                 //A[mi]会被遗漏？下一小节证明</li><li>无论成功与否，返回的秩严格<strong>符合接口的语义约定</strong></li></ul><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>首先通过下面的图例来具体地了解一下版本C的工作过程，其实最主要的是它的每次迭代的过程都是类似的。如图(a)，在整个向量的区间内，我们关注的是某一个特定的从<code>lo</code>到<code>hi</code>的一个查找区间，每次在这个区间里都要考虑middle point，即图中的x。</p><p>我们以它为界，经过一次比较以后有可能会发现目标元素更小所以就深入到如图b所示的左侧的这个子区间；或者对称地，因为目标元素更大而深入到右侧的这个区间，如图(c)。版本C的算法中左侧子区间和右侧的子区间都没有覆盖这个middle point，而且对middle point也没有做显式地判断，所以这也是为什么有理由怀疑它有可能是这个算法的一个疏忽。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210230255.png" style="zoom:67%;"></p><p>接下来我们来证明这样一个模式实际上是安全的，为此同样用我们的两种技巧：第一就是给出这个算法的不变性<br>其次要给出它的一个单调性，而单调性是一目了然，就不再说明了，主要是证明它的不变性：</p><ul><li>不变性：A[0, lo) &lt;= e &lt; A[hi, n)            //A[hi] 总是大于e的最小者</li><li>初始时，lo = 0且 hi = n，A[0, lo) = A[hi, n) = $\varnothing$，自然成立</li><li>数学归纳法：假设不变性一直保持至图(a)的状态，下一步无非两种情况：</li></ul><p>第一种情况，也就是深入左侧这个分支的情况，即图(b)。那么此前的判断<code>e &lt; A[mi]</code>返回的是True，之后执行   <code>hi = mi</code>，从而使得右侧的这段区间向左拓展是安全的，因为确实可以断定这个整个区间内的这些元素都是严格地大于e的，因为它们其中最小的那个元素也就是<code>A[mi]</code>都大于<code>e</code>。而A[0, lo)保持不变,所以这种情况是没有问题的。</p><p>第二种情况，也就是深入右侧这个分支的情况，即图(c)。那么此前的判断<code>e &lt; A[mi]</code>返回的是False，之后执行 <code>lo = mi</code>，此时<code>e</code>是不小于<code>A[mi]</code>的，而<code>A[mi]</code>元素是左段区间中最大的，所以左段区间都是都是不大于e的。这样一个左侧区间向右拓展的动作在刚才不变性的意义上讲，依然是安全的，它使得不变性得到了延续。所以经过一次迭代以后无论是向左还是向右的深入，不变性都是成立的。</p><ul><li>单调性：显而易见，直到最后会出现一个情况，就是整个区间的宽度变成零，可以表示为下图。</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210234026.png" style="zoom:67%;"></p><p>从整个的原始的搜索空间开始，经过不断地压缩、压缩、压缩之后，将搜索的范围缩小到一个宽度为零的一个区间，其实它就只是一个分界。它严格地将整个区间分为了左右两部分，由不变性左侧这部分依然是不大于e，而右侧这部分是严格地&gt;e。如果查找的结果是命中的，我们只需要返回左侧这个区间的最右端的那个元素就可以了，而这个元素正是A[lo-1]。这也就是为什么我们在算法的最终返回之前要做一次<code>--lo</code>的操作。</p><p>这样的话我们就得到了一个从<strong>功能</strong>上、从<strong>语义</strong>上、从<strong>性能</strong>上都近乎完美的算法！</p><h1 id="插值插值"><a href="#插值插值" class="headerlink" title="插值插值"></a>插值插值</h1><p>插值查找（Interpolation Search）有序向量查找算法的一个另类的变种，此前所介绍的Fibonacci search或binary search包括它们的各种版本对向量只做了一个假定，即其中的元素是单调有序的，对于其中元素的分布情况并没有做任何的假设，也就是可以是完全理想任意随机的。但是在某些情况下也许不是这样，比如我们可能不仅知道向量是有序的，而且<strong>其中的元素是按照某种先验规律随机分布的</strong>。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194037.png" style="zoom: 50%;"></p><p>在这里我们考虑一种最常见的随机分布：<strong>均匀独立的随机分布</strong>，比如在从<code>lo</code>一直到<code>hi</code>的秩的范围之内，所有的元素都是互相不影响，各自独立的，然后从取值来看是均匀的取自于某一个区间范围。如果我们确实知道诸如此类的规律的话，就有可能实现优于此前那些算法$O(logn)$的更高的查找效率，以$o(logn)$的效率来完成一次查找。</p><h2 id="原理与算法"><a href="#原理与算法" class="headerlink" title="原理与算法"></a>原理与算法</h2><p>在均匀且独立的随机分布下，所有的元素在排序之后，即组织成一个有序向量之后，必然大体上是按线性增长的趋势分布的，从最小值<code>lo</code>开始大致是<strong>线性增长</strong>到最高值<code>hi</code>。这就意味着对于其中的任何一个潜在元素<code>mi</code>，都可以写出这样一个近似的线性等式，它们的秩的比与它们的数值比，二者是近似接近的。</p><script type="math/tex; mode=display">\frac{mi-lo}{hi-lo}\approx \frac{e-A[lo]}{A[hi]-A[lo]}</script><p>实际上这给了我们一个启示，即在每次确定mi的时候，既不需要固定的用1/2，也不需要固定的用小写的φ（黄金分割比），甚至不需要用某一个一般的λ，而是可以动态的来猜测这样一个轴点，就是根据上面的等式。将这个等式稍微整理一下把<code>mi</code>提到左侧，我们就可以知道根据<code>lo</code>、<code>hi</code>以及它们对应的这两个元素的数值，以及每次动态要查找的那个元素的数值<code>e</code>，就可以大致的估算出<code>mi</code>，这样的话如果整个的减而治之的搜索过程可以认为是一个不断收缩包围圈逐步收敛的一个过程，那么它将会使得收敛的速度极大的加快，从而更快速的完成我们整个的查找。</p><script type="math/tex; mode=display">mi\approx lo+(hi-lo)\cdot \frac{e-A[lo]}{A[hi]-A[lo]}</script><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212190744.png" style="zoom: 80%;"></p><p>正如这个图所画的是一本英文词典中abcd一直到z开头的单词各自起始的页码,它大致是1300多页，换而言之如果它确实是一个大致平均分布的话，每一个字母大概占50页，所以我们可以大致估算出来从1到50页大概是a，50页到100页大概是b，100页到150页大概是c，诸如此类。比如说去查binary (b)，那么因为它是第二个字母所以它大概会在整书从2/26这个位置开始，而search,s是第19个元素 所以大概它会位于19/26的位置。正因为这种算法在确定切分点也就是轴点的时候，采用的是近似的插值估算的方法，所以我们也称之为Interpolation Search插值查找，下面是一个实例。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194041.png" style="zoom: 67%;"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>从刚才的例子我们可以看出，对于这样一个长度为19的有序向量，只用了3次比较就给出了答案，而在通常的二分查找中这是做不到的，所以我们已经看到它在某些情况下确实很快，但是它总是能很快吗？包括这种很快到底定性是多大呢？</p><p>我们需要做一个严格的界定，首先一个不好的消息是插值查找<strong>在某些情况下效率会很低</strong>，比如说 可能退化为与平凡的顺序查找没有什么区别，我们此前所做的那种假设也就是均匀独立的分布不满足，或者至少在某些部分不满足以致在全局或某些局部出现一些所谓的病态分布。</p><ul><li>最坏情况：$O(hi- lo)=O(n)$</li></ul><p>当然 插值查找的最好情况也是不言而喻的，和其他的查找差不多，也就是说有可能我们在某次，甚至在第一次猜测的时候就直接命中，那么这种我们也不再考虑。我们转而再考虑一般的情况，也就是平均而言会怎么样。</p><p>这里我们需要用到一个非常基础类似引理的结论这个结论：在插值查找算法中每经过一次迭代，或者说每经过一次比较，都可以将查找的范围也就是减而治之之后剩余的部分由原先的规模n缩减为$\sqrt{n}$。</p><ul><li>平均情况：每经过一次比较，$n$缩减至$\sqrt{n}$。</li><li>于是，待查找区间宽度将按一下趋势缩减：</li></ul><p>​       $n,\quad\sqrt{n},\quad \sqrt{\sqrt{n}},\quad \sqrt{\sqrt{\sqrt{n}}},\dots,\quad2$</p><p>​       $n,\quad n^{(1/2)},\quad n^{(1/2)^2},\dots,\quad n^{(1/2)^k},\dots,\quad2$</p><ul><li><p>经多少次比较之后，有$n^{(1/2)^k}&lt;2$？</p><p>$k&gt;loglogn$</p></li><li><p>插值查找的时间复杂度为：$O(loglogn)$</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212201351.png" style="zoom: 67%;"></p><p>我们同样可以来估算：如果向量的长度或者这个区间的宽度是n的话，考虑这个n按照二进制打印出来以后的位宽就是以的2为底 logn，那么每一次将它变为根号n从二进制的打印宽度来看其实就是变成了1/2的原来那么多宽度，换而言之每一次开方其实同步的是使宽度变成了原来的1/2，这样的过程 从n的数位宽度来说是一个不断折半的过程。</p><p>回顾此前的二分查找，如果是对的n的数值每次折半的话，那么这里的<strong>插值查找实际上就是对n的二进制位宽度来做二分查找</strong>。二分查找所需要的迭代次数是与它的初始值呈一个对数关系的，即$O(logn)$，而插值查找的位宽的初值相当于是logn，所以其需要的迭代次数就是$O(loglogn)$。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212204350.png" style="zoom: 50%;"></p><p>从今以后也许我们应该学会忘掉这些复杂的，虽然是精确的数学，而改用这种宏观的大趋势的把握本质的习惯。</p><h2 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h2><p>现在将插值查找和其他的算法综合起来进行比对和考量，刚才插值查找所实现的这种改进也就是从logn到loglogn<br>虽然从数学上是一个比较大的改进，但从实际效率来看却值得商榷。</p><ul><li><p>从$O(logn)$到$O(loglogn)$，是否值得？</p></li><li><p>通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高。</p><p>比如，n = 2^(2 ^ 5) = 2 ^ 32 = 4G时，$log_2(n)=32,\quad log_2(log_2(n))=5$</p></li><li><p>易受小扰动的干扰和“蒙骗”，可能在局部花费非常多的时间</p></li><li>须引入乘法、除法运算，相对而言成本更高（二分查找只需加法，Fibonacci查找只需加法和减法）</li></ul><p>所以可行的查找算法也许应该将插值查找以及此前的那些查找算法各自的优势综合结合起来，比如说插值查找更善于在比较大的一个宏观的范围内，将问题的关注点尽可能快的缩小到一定的范围，即它比较擅长于处理那种极大的情况，然后一旦到了比较小的情况，这种容易受到干扰包括蒙骗尤其是乘法除法这样的一些overhead额外计算占得比重就会更大成为不可忽略的因素，而在这个时候二分查找的优势就体现出来了。</p><ul><li><p>实际可行的方法：</p><p>首先通过插值查找，将插值范围缩小到一定的范围，然后再进行二分查找，或者顺序查找，即：</p><ul><li>大规模：插值查找</li><li>中规模：折半查找</li><li>小规模：顺序查找</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      向量这一章的内容比较多，决定分开写，本文主要介绍有序向量。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（2）向量</title>
    <link href="http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/</id>
    <published>2020-02-08T02:04:27.000Z</published>
    <updated>2020-02-08T17:07:27.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><p>我们首先需要辨析一组非常相关但是又非常容易弄混的概念，也就是<strong>抽象数据类型</strong>以及<strong>数据结构</strong>。那么什么是<strong>Abstract Data Type</strong>呢？以及什么是<strong>Data Structure</strong>呢？可以从字面上给出定义，所谓的抽象数据类型，其实就是在一组数据的模型上定义的一组操作。那么什么叫作数据结构呢？是基于某种特定的语言真正实现的一套完整的算法。</p><p>我们此前比较熟悉的程序语言，先不要考虑什么抽象数据类型，先来看看什么叫作Data Type数据类型。比如在高级程序设计语言中<code>int</code>也就是整型，这就是一个数据类型，而<code>floa</code>t也是，还有<code>char</code>，诸如此类地。这种数据类型能够让我们能定义其中的一个成员，比如<code>n</code>是一个整数，从此以后我们就可以使用它了，我们也可以定义<code>x</code>是一个浮点数，<code>c</code>是一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">char</span> c;</span><br></pre></td></tr></table></figure><p>凡是这样指定了某一个元素是来自于某一个数据类型，或者说属于某一个数据类型，那么它就自然地具有了这种数据类型的特点，包括支持相应地处理方法，比如说运算。那么这里那些操作的运算具体是如何实现的，我们并不知道，我们也并不需要知道，这是最重要的。</p><p>把这样的一个概念抽象出来施加到我们所将要实现的数据结构上，比如这一章要介绍的<code>vector</code>。我们希望在使用的时候能够参照数据类型的这种形式，把它等同地当作是一个数据类型，比如可以用类似的方法来定义一个<code>vector</code>结构，包括下一章将要介绍的<code>List</code>。</p><p>这种使用方法使得我们可以将数据结构与数据类型等同起来，我们只需要知道它所提供的那些操作，比如说向量的查找、排序，而不需要去关心它其中的细节，比如说这些操作是如何实现的。那么从这个意义上讲，它就是一个经过了抽象以后的数据类型，所以称之为<strong>Abstract Data Type</strong>。</p><p>举个例子：我们可以将数据结构比喻成某种产品，比如说汽车，相关的有两类人，首先是用户，我们笼统地称之为应用Application，另一类人是汽车这种产品的设计和制造者，称之为实现Implementation。这两类人所关心的以及他们的职责是不同的，作为用户而言，他只关心这种产品的外在特性，能够提供的功能；而实现者则需要对这些功能以及特性具体如何落实负责。在这二者之间实际上是有某种形式的一个协议，也就是使用说明书，产品手册。而这种手册或者说明在数据结构的使用者与数据结构内部算法的设计者之间，达成了这么样一个协议，两类人可能互不见面，互不相识，但是他们通过这样一个规范，可以很好地彼此沟通，并且有效地合作。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208102916.png" style="zoom:67%;"></p><h2 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h2><h3 id="从数组到向量"><a href="#从数组到向量" class="headerlink" title="从数组到向量"></a>从数组到向量</h3><p><strong>向量实际上是C++等高级编程语言中数组这种数据组织形式的一个推广和泛化</strong>。实际上在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都与0到n之间的某一个整数编号相互彼此对应，我们称之为第0号单元或者元素，或者第1号元素、第2号元素以及到最后的实质第n-1个元素。这里我们也同样延用此前已经约定的习惯，虽然最后这个第n个元素，实际上未必存在，我们还是把它虚拟地放在这儿作为哨兵，以帮助我们对很多问题的思考，并且使得我们很多算法的实现能够得以简化。</p><ul><li>C/C++语言中，<strong>数组A[ ]中的元素与[0,n)内的编号一一对应</strong>。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208105846.png" style="zoom:67%;"></p><p>既然每一个这样的元素都与这些编号是一一对应的，所以反过来我们通过合法区间内的编号都可以唯一地来指代并且访问对应的那个元素。一旦知道这个元素的下标<code>i</code>，就可以从<code>A</code>也就是这段存储区域的首地址出发，再向后以s作为间隔去数出<code>i</code>步，就可以得到某一个特定的单元。正因为所有这些元素的物理地址可以按照这样一个线性的方程来确定。所以我们也称之为<strong>线性数组</strong>（linear array）。</p><ul><li><p>反之每个元素均由（非负）编号唯一指代，并可直接访问。<strong>A[i]</strong>的物理地址 = A + i×s，s为单个元素占用的空间量。</p></li><li><p>向量是数组的抽象与泛化，由一组元素按线性次序封装而成：</p><ul><li>各元素与[0, n)内的秩（rank）一一对应</li><li>元素的类型不限于基本类型</li><li>操作、管理维护更加简化、统一于安全</li><li>可更为便捷地参与复杂数据结构的定制与实现</li></ul></li></ul><h3 id="向量ADT接口"><a href="#向量ADT接口" class="headerlink" title="向量ADT接口"></a>向量ADT接口</h3><p>按照抽象数据类型的规范，向量结构必须提供一系列的操作接口，可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作，这里的接口功能非常的丰富。</p><p>比如说 与其它的数据结构一样向量也可以看作是一组元素的集合，所以<code>size( )</code>实际上返回的是其中元素的总数，称之为这个数据结构的规模。也可以从中取特定的元素<code>get(r)</code>，也可以修改其中特定的元素<code>put(r, e)</code>，甚至插入<code>insert(r, e)</code>或者是删除某个元素<code>remove(r)</code>。我们也可以判定一下其中的元素是否已经有序排列<code>disordered( )</code>，如果没有有序排列，可以调用相应的接口使之有序排列<code>sort( )</code>。</p><p>我们也可以在它尚未有序排列的时候，按某种算法找到其中特定的元素<code>find(e)</code>，也可以在已经有序的前提下按照某种方式，来找到其中的元素<code>search(e)</code>。当然为了展示一些算法的实现我们也附加了一些其它的功能，比如说能够在无序和有序的情况下分别剔除这个数据集中的重复元素：<code>deduplicate( )</code>和<code>uniquify( )</code> 。最后也是非常重要的一个接口就是如何对这个数据集中的元素逐一地进行枚举，并且访问一遍<code>traverse( )</code>，称之为遍历。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208110149.png" style="zoom:80%;"></p><h3 id="ADT接口操作实例"><a href="#ADT接口操作实例" class="headerlink" title="ADT接口操作实例"></a>ADT接口操作实例</h3><p>下面举例说明ADT接口的实现。</p><p>最开始向量与任何一个数据结构一样，初始化的时候都是不包含任何实质的内容的，我们称它是一个空的向量。接下来调用插入操作<code>insert</code>，它在rank为0的这个位置上插入一个元素9，所以向量的组成将由空变成包含一个元素9。接下来继续调用<code>insert</code>接口，在0号这个位置上rank为0的这个位置上插入一个元素4，原来的元素9将会后移一位。同样地，我们也可以调用插入接口在rank为1的位置上插入5，在这个位置上出现了5，而它的后继统一地向后后移了一位。我们也可以调用<code>put</code>接口，这个接口的意思是修改，它会把当前rank为1的那个位置上的元素数值，由原来的5修改为2。我们也可以通过<code>get</code>这个接口获取秩为某一特定值的元素，比如说秩为2的那个元素，实际上就是2这个位置上的9，因此会返回<code>9</code>。</p><p><code>remove</code>接口的参数是2，这说明它希望在原来这个向量中将rank为2的这个元素，把它剔除掉，剔除之后，会把这个被剔除的元素的值作为输出返回，即返回<code>2</code>，同时它的所有的后继与插入时候的操作的现象相反，会向前平移一个单元。当这个时候我们调用<code>size</code>的时候，因为这里所包含的元素总共是6个，所以它会返回<code>6</code>。</p><p>我们可以看到在整个这个操作的过程中向量都确实具有这么样一个特点，就是它在逻辑上，甚至在物理上必然是彼此紧邻的排列的，所有的元素之间没有任何的缝隙。需要注意的是无论是此前所介绍的这些接口，还是后面所要介绍的接口，就目前而言，我们并不关心它的具体实现方法，我们关心的只是它的操作语义。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208125724.png" style="zoom:80%;"></p><p>接下来我们可以通过<code>disordered()</code>这个接口来检测向量的有序性，或者更准确地讲它的<strong>无序性</strong>。在此前介绍bubble sort算法的原理的时候，曾经指出包括向量在内的序列是否有序，当且仅当其中是否存在紧邻的逆序对。那么这里总共有6个元素，共定义了5组紧邻对，其中有3组，也就是4和3、7和4、和9和6是逆序的，<code>disordered</code>会<strong>返回逆序对的个数</strong>，即是<code>3</code>，只要这个数值不是0，就说明它尚未构成有序的序列。</p><p>对于这样的一个<strong>无序向量</strong>我们已经可以通过<code>find</code>接口，来查找其中特定的某个元素，比如说9。可以看到9号元素是位于rank为4的位置，因此find会返回<code>4</code>。同样地，也可以查找比如说5，我们发现5并不存在，这个时候我们统一地约定返回一个数值是<code>-1</code>，这个-1肯定不是一个合法的rank，表示查找失败。接着我们可以通过sort这个接口对整个向量排序，接下来再调用<code>disordered()</code>这个接口，它已经没有任何逆序的紧邻对了，所以返回<code>0</code>。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208130026.png" style="zoom:80%;"></p><p>对于<strong>有序向量</strong>，我们可以通过另一套接口，也就是<code>search</code>来进行查找。比如说可以首先通过<code>search</code>，然后引用9来查找数值为9的元素，这个元素的rank为5，因此返回的是<code>5</code>。那么如果查找8会怎么样呢？向量中并没有8，这里我们采用了另一种约定：如果<strong>没有找到</strong>这个元素，我们要找的是<strong>不超过这个元素的最大的那个元素的值</strong>。对这个例子而言不超过8的最大的元素实际上就是7，而7的秩是4，所以<code>search(8)</code>会返回<code>4</code>。同样 我们如果要去查找10的话会返回不超过10的最大的那个元素也就是9的秩5，因此<code>search(10)</code>会返回<code>5</code>。</p><p>另一种特殊情况：查找一个全局都没有而且小于全局的最小的那个元素的数比如说1，我们会假设在-1的rank这个位置上有一个假想的哨兵，它的数值是负无穷，所以<code>search(1)</code>返回的是<code>-1</code>。这样一套约定可以使得我们在语义上更加的明确，使得我们在后续的操作过程中可以便利地来搭建不同的算法。还有一点要注意的是：在有些时候，我们要查找的元素尽管有，但是它却有<strong>多次出现</strong>，比如说这个4 出现了两次，那这个时候会返回什么呢？同样跟这里的语义所定义吻合的是，我们要<strong>返回其中不超过4这个目标元素的最后边那个元素</strong>，所以如果有两个甚至多个4的话，我们会取其中rank最大的那个元素把它的rank返回，对这个例子而言也就是2号元素，因此<code>search(4)</code>会返回<code>2</code>。</p><p>最后，<code>uniquify()</code>对于一个有序的向量把所有的重复的元素，比如说4都剔出掉，只保留一个拷贝。</p><h2 id="vector模板类"><a href="#vector模板类" class="headerlink" title="vector模板类"></a>vector模板类</h2><p>有上述接口规范之后，我们就可以遵照这种规范来学习如任何具体地在C++语言平台上实现这样一种向量模板类<code>vector</code>结构。首先约定用int来定义这里所说的秩这种概念，接下来会首先采用一种基本的扩容方式，它的初始容量需要设定，这里不妨取它的DEFAULT_CAPACITY取作3，在实际应用中完全可以取更大的一个数。</p><p>下面通过<code>template</code>这种方式给一个模板参数T，它的意思可以认为是定义了一个<code>vector</code>这样的模板类。其中的元素类型是什么可以是将来指定的任何名字现在叫作T的类型。所以与其说它写的是一个类，不如说这个模板类给的是一系列的类，我们可以根据实际需要直接地生成相应的<code>vector</code>类。在模板类里面有一些私有的，也就是封装和隐藏起来的变量，比如说其内部会记忆它到底有多少个元素有一个<code>_size</code> ，以及它目前的容量<code>_capacity</code>，还有<br>包括真正存放元素的一个空间<code>_elem</code>。其它的内部函数以及公开的接口函数会在后边陆续学到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank; <span class="comment">//秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_CAPACITY  3 <span class="comment">//默认的初始容量（实际应用中可设置为更大）</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span> <span class="comment">//向量模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity;  T* _elem; <span class="comment">//规模、容量、数据区</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="keyword">const</span>* A, Rank lo, Rank hi )</span></span>; <span class="comment">//复制数组区间A[lo, hi)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">bubble</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//扫描交换</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//起泡排序算法</span></span><br><span class="line">  <span class="function">Rank <span class="title">max</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选取最大元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选择排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">( Rank lo, Rank mi, Rank hi )</span></span>; <span class="comment">//归并算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//归并排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//堆排序（稍后结合完全堆讲解）</span></span><br><span class="line">  <span class="function">Rank <span class="title">partition</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//轴点构造算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//快速排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//希尔排序算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  Vector ( <span class="keyword">int</span> c = DEFAULT_CAPACITY, <span class="keyword">int</span> s = <span class="number">0</span>, T v = <span class="number">0</span> ) <span class="comment">//容量为c、规模为s、所有元素初始为v</span></span><br><span class="line">  &#123; _elem = <span class="keyword">new</span> T[_capacity = c]; <span class="keyword">for</span> ( _size = <span class="number">0</span>; _size &lt; s; _elem[_size++] = v ); &#125; <span class="comment">//s&lt;=c</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank n ) &#123; copyFrom ( A, <span class="number">0</span>, n ); &#125; <span class="comment">//数组整体复制</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V ) &#123; copyFrom ( V._elem, <span class="number">0</span>, V._size ); &#125; <span class="comment">//向量整体复制</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">  ~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125; <span class="comment">//释放内部空间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只读访问接口</span></span><br><span class="line">  <span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_size; &#125; <span class="comment">//判空</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span> ( e, <span class="number">0</span>, _size ); &#125; <span class="comment">//无序向量整体查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//无序向量区间查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> <span class="comment">//有序向量整体查找</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &gt;= _size ) ? <span class="number">-1</span> : search ( e, <span class="number">0</span>, _size ); &#125;</span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//有序向量区间查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写访问接口</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] ( Rank r ); <span class="comment">//重载下标操作符，可以类似于数组形式引用各元素</span></span><br><span class="line">  <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] ( Rank r ) <span class="keyword">const</span>; <span class="comment">//仅限于做右值的重载版本</span></span><br><span class="line">  Vector&lt;T&gt; &amp; <span class="keyword">operator</span>= ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; ); <span class="comment">//重载赋值操作符，以便直接克隆向量</span></span><br><span class="line">  <span class="function">T <span class="title">remove</span> <span class="params">( Rank r )</span></span>; <span class="comment">//删除秩为r的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//删除秩在区间[lo, hi)之内的元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( Rank r, T <span class="keyword">const</span>&amp; e )</span></span>; <span class="comment">//插入元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> </span>&#123; <span class="keyword">return</span> insert ( _size, e ); &#125; <span class="comment">//默认作为末元素插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">()</span> </span>&#123; unsort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>; <span class="comment">//无序去重</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>; <span class="comment">//有序去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( <span class="keyword">void</span> (* ) ( T&amp; ) )</span></span>; <span class="comment">//遍历（使用函数指针，只读或局部性修改）</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( VST&amp; )</span></span>; <span class="comment">//遍历（使用函数对象，可全局性修改）</span></span><br><span class="line">&#125;; <span class="comment">//Vector</span></span><br></pre></td></tr></table></figure><p>vector模板类的原理：整个vector结构是被封装起来，能供来自各种应用的用户使用的操作接口就是interface框中vector，~vector，insert，remove等等，它们就相当于vector结构的使用说明书，它告诉我们这里提供了哪些操作渠道、途径，通过这种接口规范直接使用。经过了这样地一个剥离之后，使得我们的应用和实现相互之间可以很好的分工，又同时很好的协作。<br>那么具体内部怎么实现的呢？可以看出其实是开辟了一个名字叫作<code>_elem</code>的数据区，它的容量至少要足以容纳所存放的有效数据，对外而言的每一个元素都通过某种形式转译为内部这段数据区中的，实际上是这个有效的数据区（<code>_size</code>）中的某一个元素，由此实现了对内部数据项的封装。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208143153.png" style="zoom: 50%;"></p><h3 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h3><p>作为一种数据结构与所有的类一样，<code>vector</code>也首先需要解决<strong>构造和析构</strong>的问题。向量的默认的构造实际上只需指始初始的容量就可以了，如果没有指定会按照默认的容量，指定一个数值。在内部的操作其实就是通过<code>new</code>申请一个长度为<code>c</code>，基本类型就是模板参数<code>T</code>的一段连续的数据空间。在创建了这样一个空间之后，我们把这个空间的首地址交给内部的<code>_elem</code>记下来。这个时候虽然它有一定的空间，但是其中有效的数据是没有的，所以这就是为什么<code>_size</code>初始化是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector(<span class="keyword">int</span> c = DEFAULT_CAPACITY)</span><br><span class="line">&#123;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = c]; </span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">//默认</span></span><br></pre></td></tr></table></figure><p>当然还有其它的一些构造的方法，比如如果已经有一组以数组的形式存放的数据，我们也可以将其中从<code>lo</code>到<code>hi</code>的这段区间中的元素取出来作为初始向量，可以看到它是通过调用一个叫作<code>copyFrom()</code>的内部接口实现的。同样地 它还<strong>重载</strong>了其它的一些形式，比如被复制的元素可能是来自于一个数组，而是来自于一个本身已经被封装了的向量，我们可以从这个向量的<code>_elem</code>区域中去读取出来，并且同样调用<code>copyFrom()</code>来做这件事。所以这里有区间的复制，也可以有对整个向量的一个克隆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector(T <span class="keyword">const</span> *A, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(A, lo, hi);&#125;           <span class="comment">//数组区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(V._elem, lo, hi);&#125;     <span class="comment">//向量区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V)</span><br><span class="line">  &#123; copyForm(V._elem, <span class="number">0</span>, V._size);&#125; <span class="comment">//向量整体复制</span></span><br></pre></td></tr></table></figure><p>内部操作接口<code>copyForm( )</code>的工作原理以及过程可以通过下图示意，工作原理以及过程，可以通过这个图来示意。一般地我们需要从一个数组<code>A</code>中将介于<code>lo</code>到<code>hi</code>之间的元素整体复制到当前仍然为空的一个向量中，具体的操作大概分为两步，首先在向量内部开辟出足够的空间，接下来再将区间内的元素逐一地复制过来。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208145159.png" style="zoom:50%;"></p><p>这个过程可以描述并且实现为下面的C++代码：首先申请足够多的空间，这里需要再强调一下这个区间的宽度可以直接通过<code>lo</code>和<code>hi</code>之间的一个减法得到，这是因为当我们在描述一个区间的时候往往是用<strong>左闭右开</strong>的形式，所以换而言之这个<code>lo</code>是在这个区间中最靠左的那个元素，而hi是在右侧第一个不属于这个区间的那个元素，尽管<code>hi</code>这个元素有可能压根就不存在。但是我们不妨把它统一地理解成是一个哨兵，这样的话我们就可以通过，<code>hi</code>减<code>lo</code>直接得到区间的宽度。</p><p>这里给计算出的宽度再乘个2，也就是说我们实际开辟的空间是我们需要复制的空间的两倍，而不是恰好那么多。这样做的主要的目的在于预留了一些空间之后，就可以使得我们在接下来足够长的时间之内，不会因为有必要扩容而打断我们的计算过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//元素类型</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom (T <span class="keyword">const</span>* A, Rank lo, Rank hi)<span class="comment">//以数组区间A[lo, hi)为蓝本复制向量</span></span><br><span class="line">&#123; </span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span> * ( hi - lo ) ]; _size = <span class="number">0</span>; <span class="comment">//分配空间，规模清零</span></span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) <span class="comment">//A[lo, hi)内的元素逐一</span></span><br><span class="line">  _elem[_size++] = A[lo++]; <span class="comment">//复制至_elem[0, hi - lo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还需要对这个向量的有效规模进行初始化 把它清为0。</p><p>再接下来 就是复制过程也就是说我们对于<code>lo</code>和<code>hi</code>中间的每一个<code>Rank</code>，都要从<code>A</code>这个数组中取出对应的元素，并将它们顺次的存入到<code>_elem</code>，对应的区间里面去。整体循环构成了这个操作的最重要的部分，所以我们也可以看出算法的复杂度主要是来自于这样一个循环。这样一个主体的复杂度是取决于被复制元素的个数，或者说这个复制区间的宽度，也可以认为是这个向量通过复制被创建之后的初始规模。</p><p><strong>析构函数</strong>只需要把这个曾经动态分配获得的数据区域释放掉，归还给操作系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125;     <span class="comment">//释放内部空间</span></span><br></pre></td></tr></table></figure><p>这样的话我们就完成了向量这种最基本的结构作为一种模板类它的最基本的一些接口，接下来会学习功能更为复杂的其它的接口。</p><h1 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h1><p>与所有的数据结构一样，向量也可以认为是一组数据项的集合，换而言之，它首先必须能够自适应地在规模上适应其中所包含的元素个数的变化，这一节集中讨论它的可扩充性能。向量本身并不具有这种性能，我们需要采取一些策略。就目前的设计方案而言，我们的向量并不具备可扩充的性能，究其原因在于它采用的 实际上是所谓的静态空间管理的策略。</p><h2 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h2><p>具体来说，它实际上在内部只不过是设置了一个私有的数组，这个数组所占有的那段连续的地址空间会被用来存放若干个对外界而言可见的，或者是有效的元素。这些元素的总数，或者说它们所占用的逻辑空间的数，用<code>_size</code>来表示，而整个物理空间的大小是由<code>_capacity</code>来确定的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208163714.png" style="zoom: 80%;"></p><p>这里的问题是<code>_capacity</code>一旦确定,按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：第一 是有可能会出现所谓的<strong>上溢overflow</strong>，也就是说随着有效元素（个数）的增加，总会出现这样的可能，使得整个<code>_elem</code>所占用的物理空间已经不足以存放需要存放的元素组。尽管这个时候在系统的其它的部分仍然有足够多的空间可以用于存放这些元素，但是限于<code>_capacity</code>是固定的，我们不能直接做到这一点。</p><p>另一种情况虽然不是很严重，但是也是会造成一定的空间的效率低下，我们称之为<strong>下溢underflow</strong>。具体来说就是有可能我们开辟了一个比较大的空间，但是在整个这个数据结构的生命期内真正存放于其中的数据却寥寥无几，从而使得<strong>装填因子</strong>指标会非常非常的小，这个装填因子其实就是有效元素个数，也就是<code>_size</code> ，去除以可用于存放元素的空间总数<code>_capacity</code>，也可以理解成是空间的利用率有可能不到一半，甚至远远地低于一半，那么在这种时候空间效率非常低下。</p><p>很遗憾如果我们坚持采用这样一种固定容量的策略，我们在实际的一般应用环境中，很难在事先就预测到我们需要用多少空间，也就是说这种空间不足以及空间浪费的情况，都有可能发生甚至经常发生。</p><p>那么如何使得向量可以自适应地根据实际需要来动态地调整自己的容量呢？而且这种调整的过程既能保证足够同时又不致使得因为开辟的空间过多而导致空间效率的低下。</p><h2 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h2><p>为了解决上述的问题，我们需要把刚才所采用的静态空间管理策略改变为所谓的<strong>动态空间管理策略</strong>，就是如果在某个时刻，某一个向量即将发生上溢，那么我们就适当地扩大内部数组的容量，使之足以容纳新的元素。按照这样一种策略向量的生命期可以大致由下面一组图来表示。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208164212.png" style="zoom:80%;"></p><p>最开始的时候向量所存放的有效元素还不是很多，还不致于出现上溢的情况，这时候可以从容应对。但是剩余的空间有可能会逐步地被占用，直到某一个关键时刻，内部数组有可能已经饱和，这时就存在一个风险也就是说再插入一个元素的话，就会导致上溢。为此我们可以动态的申请另一段存放空间，当然它的大小应该比原来的有所增长。接下来我们要把原先已经存放好的那些有效元素，逐一地按次序地复制过来，从而使得它们对外界而言依然保持原貌。新多出来的这些空间就足够用以存放新需要插入的元素，而原来所占用的空间将在此之后被释放并且归还给系统。上述这样一个完整的调整过程可以描述并且实现为下面的c++的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123;    <span class="comment">//向量空间不足时扩容</span></span><br><span class="line"><span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;   <span class="comment">//尚未满员时，不必扩容</span></span><br><span class="line">_capacity = <span class="built_in">max</span>(_capacity, DEFAULT_CAPACITY);   <span class="comment">//不低于最小容量</span></span><br><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];  <span class="comment">//容量加倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)  <span class="comment">//复制原向量内容</span></span><br><span class="line">_elem[i] = oldElem[i];       <span class="comment">//T为基本类型，或已重载复制操作符'='</span></span><br><span class="line"><span class="keyword">delete</span>[] oldElem;   <span class="comment">//释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要判断现在是否处于即将发生上溢的临界状态，它的标志就是<code>_size</code>是否还继续严格地小于<code>_capacity</code>。如果是还不存在上溢的风险，可以直接返回，所以这里隐含着有一个else，即接下来<code>_size</code>虽然不一定大于<code>_capacity</code>，但是至少会出现等于<code>_capacity</code>的情况。</p><p>这时我们要做的是将原来的那个数据域做一个备份，接下来以原先的容量（注意这里是左移一位，相当于加倍）加倍的一个新的容量来申请一段动态空间，并且将这段空间交由原来的<code>_elem</code>来指示。接下来是复制，对从原先的那个数据域中逐一地取出各项，并且将其转移至新的这个数据域中对应的位置。在整体赋值完之后，原先的这个空间已经没有任何存在的意义了，所以通过<code>delete</code>操作将它释放。</p><p>其实对于尚未封装的数组同样可以采用上述的这样的一个策略，而对于向量而言，这里调整的优势体现在向量整体的封装性上。因为对于一般的数组，如果它经过了动态的重新分配地址，那么原先指向它内部的某些元素的一些指针就有可能会出现无效，即虽然它能指向一个地址但其中并没有存放所需要的数值。但是对于向量而言经过了这样的封装以后就安全了，因为无论是此前此后我们在访问某一个具体的元素的时候，在内部都是通过<code>_elem</code>这个统一的指示器来标识空间的起点。从这一点也可以看出进行封装以后的一个好处。</p><p>那么为什么要采用一个容量加倍的策略呢？采用其他策略，比如适当增加背部数组的容量，是否也可行呢？</p><h3 id="容量递增策略"><a href="#容量递增策略" class="headerlink" title="容量递增策略"></a>容量递增策略</h3><p>实际上情况并不那么简单，我们不妨以其中的一种典型的策略，即容量递增策略，来做一个对比。就是每当发现<br>当前的内部数组即将发生上溢我们并不是对它进行容量的加倍，而只是在原来的容量的基础上追加一个固定的数额，这样看起来并没有什么问题。在代码上只需将原来的<code>_capacity*2</code>变成<code>_capacity</code>追加一个固定的数额，记为<code>INCREMENT</code>，简记作$I$。下面来考虑这个策略的效率。</p><ul><li>在即将上溢之前，追加固定大小的容量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity += INCREMENT];</span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量0的空向量中，连续插入$n = m * I$个元素（远大于2）</li><li>于是，在第$1, I+1, 2I+1, 3I+1,……$次插入时都需要扩容</li><li>即便不计申请空间操作，各次过程中复制原向量的时间成本依次为：$0,I,2I,\dots,(m-1)I$（算术级数）</li><li>总体耗时 = $I\times(m-1)\times m/2=O(n^2)$，每次扩容的<strong>分摊成本为</strong>$O(n)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208172649.png" style="zoom: 50%;"></p><h3 id="容量加倍策略"><a href="#容量加倍策略" class="headerlink" title="容量加倍策略"></a>容量加倍策略</h3><ul><li>在即将上溢之前，使容量加倍</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];   <span class="comment">//容量加倍</span></span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量1的的满向量中，连续插入$n=2^m$个元素</li><li>于是，在第$1，2,4,8,16,32，\dots$次插入时都需要扩容</li><li>各次扩容过程中复制原向量的时间成本依次为：$1,2,4,8,\dots,2^m$  （几何级数）</li><li>总耗时 = $O(n)$，每次扩容的分摊成本为$O(1)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208174131.png" style="zoom:50%;"></p><p>造成两种方法每次扩容分摊成本的时间复杂度出现很大差别的原因，可以用下图说明。实际上在向量规模不断递增<br>达到某一固定的数值之前，如果采用的是递增式的增容策略，那么所需增容的操作必然是按当时的规模呈算数级数的形式分布。反过来如果是以倍增式的策略来进行的扩容，那么只需要进行其中的少数几次扩容就够了，具体来说就是这些以紫色标明的，可以看到要远远小于原先的数目，而且随着数组规模的增加，这种差异会更加的明显。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208171602.png" style="zoom:80%;"></p><p>我们不妨将这两种策略所对应的性能列成如上面的一张表。在时间方面，在达到一个固定的规模n之前，累计所用的扩容时间：递增策略要多达$O(n^2)$，而倍增策略只需要$O(n)$，如果从分摊的意义上讲分摊到每一次扩容所需要的时间：前者是$O(n)$， 而后者是$O(1)$。可以看到就时间而言，容量加倍策略具有巨大的优势。而在空间方面，前一种策略似乎要非常好，因为它总是每次增加一个固定的数额，所以随着向量规模的增加，整个空间的利用率会越来越接近于百分之百。而加倍策略未必能做到百分之百，但是它至少有个底线，至少是50%，只有在它即将发生上溢，而因此刚刚通过加倍扩容的那个瞬间时才会是50%。所以相对而言，可以理解为倍增策略是通过在空间的效率上做了一个适当的牺牲，来换取在时间方面的巨大的收益，显然收益要远远大于损失。</p><h2 id="平均分析-vs-分摊分析"><a href="#平均分析-vs-分摊分析" class="headerlink" title="平均分析 vs. 分摊分析"></a>平均分析 vs. 分摊分析</h2><p><strong>平均复杂度或期望复杂度（average/expected complexity）</strong></p><p>根据数据结构各种操作出现概率的分布，将对应的成本加权平均。</p><ul><li>各种可能得操作，作为独立事件分别考查；</li><li>割裂了操作之间的相关性和连贯性；</li><li>往往不能准确地评判数据结构和算法的真实性能。</li></ul><p><strong>分摊复杂度（amortized complexity）</strong></p><p>对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作。</p><ul><li>从实际可行的角度，对一系列操作做整体的考量；</li><li>更加忠实地刻画了可能出现的操作序列；</li><li>可以更为精确地评判数据结构和算法的真实性能</li></ul><h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><p>回顾前两节，我们以向量为例给出了数据结构定义的一种通用方法，即模板，大致格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Vector &#123; ...... &#125;;</span><br></pre></td></tr></table></figure><p>这种方法实际上定义了 一系列的<code>Vector</code>，在使用的时候可以灵活指定它的类型。如果尖括号里是<code>int</code>的，那这个<code>Vector</code>实际上是a Vector of integers，即由一系列的整数组成的向量。更重要的是 在以后我们将利用这种方式来构造更为复杂的数据结构，比如可以把某些数据结构作为基本的组成元素来构成向量，举个例子在后面的学习中会定义二叉树Binary Tree这样一种数据结构，如果把<code>BinTree</code>作为基本的元素来构成<code>Vector</code>，那我们就可以构成一个由一系列的二叉树构成的一个线性序列，也就是A Vector of Binary Trees，取个形象的名字可以叫它<code>forest</code> 森林。在后面介绍霍夫曼编码的时候也会用到这种技巧，通过采用统一的模板式的方法，可以使得数据结构的定义非常的规范，而且更重要的是它们可以互相的融合组合，便捷地搭建更为复杂的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="keyword">int</span>&gt; myVector1;</span><br><span class="line">Vector&lt;<span class="keyword">float</span>&gt; myVector2;</span><br><span class="line">Vector&lt;<span class="keyword">char</span>&gt; myVector3;</span><br><span class="line"></span><br><span class="line">Vector&lt;BinTree&gt; forest;</span><br></pre></td></tr></table></figure><p>这一节我们将围绕向量的最基本的形式，即无序向量来展开。无序向量不一定是说其中的元素没有顺序，甚至有时候其中的元素是根本就不可能排成顺序。在这样的一个前提下我们将研究如何来定义并且实现相应的操作接口。</p><h2 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h2><p>通过<code>V.get(r)</code>和<code>V.put(r, e)</code>接口，固然可以读，写向量元素，但便捷性远不如数组元素的下标式访问方式A[r]。通过<strong>重载下标操作符</strong>“ [ ] “，便可沿用数组的下标方式访问向量元素。对于任何一个指定的Rank r，只需在内部数据区中取出对应的第r号元素，此后凡是需要引用向量中的某个特定的比如说Rank为r的这个元素，就可以直接以这样一种类似于数组下标的形式进行引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span>  <span class="comment">//0 &lt;= r &lt; _size</span></span><br><span class="line">   &#123; <span class="keyword">return</span> _elem[r]; &#125;</span><br></pre></td></tr></table></figure><p>此后，对外的V[r]即对应于与内部的V._elem[r]。这种引用可以作为右值，以这种类似数组形式进行运算并且将运算的结果，向左侧赋值给某一变量；而反过来计算的结果也可以赋值给向量中某一个元素，也就是作为左值，因为这个接口返回值是一个引用。</p><ul><li><p>右值：<code>T x = V[r] + U[s] * W[t]</code></p></li><li><p>左值：<code>V[r] = （T) (2*x + 3)</code></p></li></ul><p>需要注意的是这里我们对入口参数r并没有做过多的检查，而是简易地在入口处增设了一个断言，用以提醒使用者保证入口参数r能够在合理的范围之内，但在真正的实际应用中，要做更为严格的处理。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p> 向量的插入算法具体来说就是如何将某一个特定的元素插入到向量的特定位置，在原来向量中因为所有的元素都必须是紧邻排列的，所以为了能够插入新的元素我们需要做一个调整，也就是将对应这个位置之后的所有的那些元素，称作它的后继，整体的构成一个后缀，进行一个整体的右移操作。这个right shift操作效果就是所有的后缀元素都向右移动一个单元，从而空出一个单，此时才可以将指定的那个元素纳入其中，从而完成插入。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208211730.png" style="zoom: 50%;"></p><p>整个算法可以描述并且实现如下的C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//e作为秩为r的元素插入，0 &lt;= r &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert(Rank r, T <span class="keyword">const</span>&amp; e) &#123;</span><br><span class="line">expand();  <span class="comment">//若有必要，扩容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">//自后向前</span></span><br><span class="line">_elem[i] = _elem[i - <span class="number">1</span>];     <span class="comment">//后继元素顺次后移一个单元</span></span><br><span class="line">_elem[r] = e;  <span class="comment">//置入新元素</span></span><br><span class="line">_size++;       <span class="comment">//更新容量</span></span><br><span class="line"><span class="keyword">return</span> r;      <span class="comment">//返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移操作可以通过for循环完成，每个元素确实都是后移一位，当所有的后移完成之后，再将新的那个元素纳入到rank所指的位置上，当然同时还要更新整个向量的规模。</p><p>有两个需要注意的地方：第一，在for循环的方向是从最后一直向前不断地递减，也就是说整个的移动的方向虽然是向右，但是<strong>所有元素移动的先后次序却是后优先的</strong>，用图来表示也就是最后这个元素先移动，接下来是次后这个元素，再往前一直直到最前面的那个元素。这是必要的，如果把这个次序颠倒过来会有危险，会出现数据在无意中被覆盖的问题。</p><p>第二个主要注意的是<code>expand()</code>，即扩容操作，这是有必要的。因为确实在某些时候这个向量可能已经是满载的，所以为了插入新元素，在后移的过程中必然会出现上溢的情况，在这种时候就需要对向量进行扩容处理，比如上节的容量加倍策略，这样一件事情完全由<code>expand()</code>完成。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h3><p>我们先考虑一个通用的一个版本，即区间删除，具体来说就是在某个向量中，我们要将介于<code>lo</code>和<code>hi</code>之间的一系列的元素成批地从中剔除掉。因为向量要求所有的元素始终都是彼此紧邻排列的，所以不应该在删除之后留下这个缝隙，换而言之，我们需要将它后继的那些元素（如果有的话）统一地向前或者说向左移动来填补这段空白。其实可以反过来看到如果能够完成这样的一个左移的话，那么实际上也就相当于把这些元素给剔除或者叫覆盖掉了，所以关键的任务在于如何实现这个左移。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208212314.png" style="zoom:50%;"></p><p>这样的一个过程可以实现为下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除区间[lo, hi)，0&lt;=lo&lt;=hi&lt;=_size</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank lo, Rank hi) &#123;  <span class="comment">//O(n-hi)</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//处于效率考虑，单独处理退化情况</span></span><br><span class="line"><span class="keyword">while</span> (hi &lt; _size)</span><br><span class="line">_elem[lo++] = _elem[hi++];  <span class="comment">//[hi, _size)顺次前移hi-lo个单元</span></span><br><span class="line">_size = lo; shrink();   <span class="comment">//更新闺蜜，若有必要则缩容</span></span><br><span class="line"><span class="keyword">return</span> hi - lo;   <span class="comment">//返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中最关键的是<code>while</code>循环，它会遍历整个后缀，并且将其中的每一个元素逐一地取出，向前转移到合适的位置。比如第一个转移的是<code>hi</code>这个位置上的这个元素，它将被转移到<code>lo</code>这个位置，紧接着是<code>hi+1</code>转移到<code>lo+1</code>，<code>hi+2</code>转移到<code>lo+2</code>，直到最后。</p><p>同样有两个问题需要强调说明：第一个问题，在整个移动的过程中，所有这些元素参与移动的先后次序，同样也是很敏感的，或者说不能更改的，与插入算法完全颠倒，插入算法是自后向前，而区间删除算法是越往前的元素越优先参与移动，所以我们也可以认为它是一个<strong>自前向后的前移操作</strong>。如果把这个次序颠倒过来是有风险的，比如两者，即前缀的原来的那个位置和后来的那个位置中间有相互重叠的部分，如果优先移动后面的那个元素，那么就有可能会造成重叠区间的元素在无意中被覆盖掉。</p><p>第二点是<code>shrink()</code>这个历程的调用，它是某种意义上讲的缩容，这种操作在实际应用中并不是必须的，我们往往可以忽略它。</p><h3 id="单元素删除"><a href="#单元素删除" class="headerlink" title="单元素删除"></a>单元素删除</h3><p>上一小节中实现了区间的批量删除的接口，所以我们不妨把单元素的删除视作是整个区间操作的特例。具体来说<br>，就是要将任何一个由单个元素构成的区间视作是由 <code>r</code> 到 <code>r+1</code>所定义的左闭右开的那段区间。这样就可以很简明地调用用此前重载的那个<code>remove</code>接口，只不过这里的参数改变为 <code>r</code> 和 <code>r+1</code>，与我们刚才的那种转换相对应。同理算法所进行的操作就是所有的后缀向前移动一个单位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除向量中秩为r的元素，0 &lt;=r &lt; _size</span></span><br><span class="line">T Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank r) &#123;  <span class="comment">//O(n - r)</span></span><br><span class="line">T e = _elem[r];     <span class="comment">//备份被删除的元素</span></span><br><span class="line"><span class="built_in">remove</span>(r, r + <span class="number">1</span>);   <span class="comment">//调用区间删除算法</span></span><br><span class="line"><span class="keyword">return</span> e;           <span class="comment">//返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反过来，基于remove(r)接口，通过反复的调用，实现remove(lo, hi)是否可行呢。理论上是可行的，对于一个特定的一段从 lo 到 hi的区间，我们可以对其中的每一个元素分别去调用一次单元素删除接口，从而完成整体的删除操作。但是正如我们一直强调的，数据结构更多关注的是效率，而从效率上看这样做是非常差的。</p><p>首先考虑单元素删除本身的效率，最重要的实际上是这段区间也就是被删除元素的那些后继们，统一地要向前移动一次，这也是它的复杂度的来源。因此它的时间复杂度是取决于它的后继的个数，即为n-hi，最坏情况下是$O(n)$。如果按这种方式反复调用，有可能会导致$O(n^2)$的复杂度，在效率上是不能接受的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208225132.png" style="zoom: 67%;"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找即是按照某种特定的条件，从向量中找出特定的元素。首先我们要明确两个概念：<strong>判等</strong>与<strong>比较</strong>，对于任何的两个元素，我们来判断它们是否是相等，或者是比较它们之间谁大谁小，这两个操作并不是所有的类型都天然支持的。所以这里我们做一个<strong>假设</strong>：向量中元素的类型是基本类型，或者向量元素这个类已经重载了对应的判等的操作符或者是比较的操作符。无序向量可以一般性地认为它只支持判等操作，而对于有序向量，要求要更高一点，它还需要支持其中的元素能够相互比较大小。</p><ul><li>无序向量：<code>T</code>为可判等的基本类型，或已重载操作符<code>=</code>或<code>!=</code></li><li>有序向量：<code>T</code>为可比较的基本类型，或已重载操作符<code>&lt;</code>或<code>&gt;</code></li></ul><p>无序向量的查找过程可以描述为下图，如果查找的区间范围是 <code>lo</code> 到 <code>hi</code> 的话，就<strong>从 <code>hi</code> 出发</strong>逆向地、逐一地取出<br>向量中的各个元素与目标元素进行比对，如果不相等就忽略它，进而考察它的前驱，所以整个的工作会亦步亦趋地逐个地遍历向量中的所有的元素。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208222707.png" style="zoom:50%;"></p><p>经过这样一个逆向地扫描的过程，我们很有可能在中间的某一步找到所需要的那个目标，即查找成功；如果一直持续到最后，在试图越过<code>lo</code>也就是合法的最左侧的边界的时候，就可以断定整个查找是失败的。这个算法可以通过下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">find</span>(T <span class="keyword">const</span> &amp;e, Rank lo, Rank hi) cosnt</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//O(hi - lo) = O(n)，在命中多个元素时可返回秩最大者</span></span><br><span class="line"><span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (e != _elem[hi]));  <span class="comment">//逆向查找</span></span><br><span class="line"><span class="keyword">return</span> hi;   <span class="comment">// hi &lt; lo 意味着失败，否则hi即命中元素的秩</span></span><br><span class="line">&#125;   <span class="comment">// Excel::match(e, range, type)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>find</code>函数<strong>返回的都是最终停止的那个位置</strong>，有可能是合法的一个位置。也可能是刚刚越过左边界的那个非法的位置。而具体判别是否成功可以交给上层的调用者，因为他通过这个秩是否是合法就可以判断查找是否成功，如果是成功的话这样一个秩将可以被高层的算法进一步地利用。</p><p>我们也可以看出这个算法的复杂度有很大的变化空间，在最好的情况下，可能在第一个元素位置上就顺利地命中<br>所以这时复杂度是常数$O(1)$；但是在最坏的情况下，比如一直持续到比较后才发现这个元素，甚至一直持续到最终也没有发现我们的目标元素，为此在这个过程中我们需要扫描的元素可能会与向量的规模相当，复杂度就会是$O(n)$。</p><p>这样一种在最好和最坏情况下相差极其悬殊的算法，叫作<strong>输入敏感</strong>算法（input-sensitive），即它的复杂度具体是多少与输入时候数据的配置紧密相关。</p><ul><li>输入敏感（input-sensitive）：最好$O(1)$，最差$O(n)$。（对本例而言）</li></ul><h2 id="唯一化问题"><a href="#唯一化问题" class="headerlink" title="唯一化问题"></a>唯一化问题</h2><p>无序向量的唯一化问题，即是<strong>把其中重复的元素都剔除掉</strong>，使得每一组重复的元素只保留一个拷贝。在很多实际的应用中都能够找到唯一化的影子，比如在网络搜索的环境中有很多个不同的结点所分工完成的局部的搜索结果，可能会含有大量的重复的元素，我们需要将其中重复的元素剔除掉，从而得到一份记忆完整同时又不冗余的搜索报告。这样一个算法大致可以通过这样的一个图示来表示它的原理：</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208232314.png" style="zoom:80%;"></p><p>对于一个向量，我们总是把它<strong>分为三个部分</strong>，以当前的这个元素为界，当前这个元素自己是一部分，它的前驱所构成的前缀是一部分，以及对称地，所有的后继是一部分。每一次我们遇到一个新的元素，都在它的前缀中去进行查找，这可以通过find操作来完成的，如果能够找到雷同的元素，比如在某个位置上出现了一个x，就可以把这个元素剔除掉。反之，经过查找以后，如果这个元素没有出现，那么我们就可以把它保留下来，同时再去考察它的下一个元素。这个算法可以由下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//删除重复元素，返回被删除元素数目</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class="line"><span class="keyword">int</span> oldSize = _size;  <span class="comment">//记录原规模</span></span><br><span class="line">Rank i = <span class="number">1</span>;      <span class="comment">//从_elem[1]开始</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; _size)   <span class="comment">//自前向后逐一考查各元素_elem[i]</span></span><br><span class="line">(<span class="built_in">find</span>(_elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>) ?   <span class="comment">//在前缀中寻找雷同者</span></span><br><span class="line">i++   <span class="comment">//若无雷同者则继续考查其后继</span></span><br><span class="line">: <span class="built_in">remove</span>(i);    <span class="comment">//否则删除雷同者（可以是多个）</span></span><br><span class="line"><span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>那么我们如何给出这个算法正确性的严格证明呢？同样根据第一章学到的知识，我们通过挖掘算法所具有的<strong>不变性</strong>和<strong>单调性</strong>，来证明一个算法最终的正确性。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208234943.png" style="zoom:50%;"></p><p>首先来证明不变性，我们发现在这个算法运行的任何一个时刻，如果当前所对应的是第<code>i</code>个元素<code>V[i]</code>的话，那么在它所对应的那个前缀中所有的元素必然是彼此互异，即不包含重复元素。当算法开始时<code>i=1</code>，它的前缀只有<code>V[0]</code>。</p><p>其余的一般情况下可以用数学归纳法来予以证明：假设当时的状态是第<code>i</code>个元素<code>e</code>，它的前缀是从<code>0</code>到<code>i</code>的区间。按照数学归纳法我们假设在此前不变性是成立的话，那么接下来，无非两种情况，即当前的这次对应的查找成功或者失败。</p><p>如果是失败，即在它的前缀中不含元素e，算法给出的处理方法是直接令<code>i++</code>，也就是我们已经指向了它的下一个元素，而将刚才那个元素<code>e</code>归入了新的这个前缀中。既然<code>e</code>和此前的那些前缀是互不重复的，所以将<code>e</code>归入这样的一个区间以后，这个区间必然是不含重复元素的。</p><p>反之如果如果查找成功，<code>e</code>出现在它的前缀中，按照算法流程会将它剔除掉，也就是通过删除操作使得后继的元素整体地向前移动，从而使得原先它的直接后继变为当前的这个元素，并且算法继续地运转下去。经过了这样一次迭代之后当前的这个元素虽然换了，但是它的前缀并没有换，这个前缀所具有的元素互异的性质也依然会保持下来。</p><p>算法运行到最终是覆盖整个向量，到那时我们所说的当前的元素其实就是最末尾的那个哨兵元素，而它的前缀其实就是整个向量，那么它的前缀中不包含重复的元素其实也就相当于整体的向量中不包含重复的元素，这正是我们这个算法的功能唯一化所要求的，所以在最终这个不变性必然会转化为我们所需要的正确性</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209000113.png" style="zoom:50%;"></p><p>接着我们证明单调性，这个算法的主体是由一个<code>while</code>循环构成的，随着反复的while迭代:</p><ul><li>当前元素前缀的长度单调非降，且迟早增至_size</li><li>当前元素后缀的长度严格单调下降，且迟早减至0</li></ul><p>所以算法待处理元素的个数会严格单调减少，算法必然终止，且至多迭代$O(n)$轮。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>这个算法的主体是while循环，而在while循环中真正能够造成有效复杂度的是<code>find</code>操作和<code>remove</code>操作，其中<code>find</code>操作是对于当前的元素的整个前缀而言的，而<code>remove</code>操作恰好对称是相对于当前这个元素的后继而言的。所以每一次<code>while</code>循环所需要的成本也就是<code>find</code>和<code>remove</code>两类操作的成本，累计起来也不会超过整个向量的长度，即$O(n)$线性步。而<code>while</code>循环最多会迭代$O(n)$轮，所以这个算法累计起来最多不超过$O(n^2)$的时间复杂度，这也是最坏情况。</p><p>这个算法也可以进一步的优化。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209001549.png" style="zoom:50%;"></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历就是按照某种事先约定的操作（称之为<code>visit</code>），对向量中的每一个元素逐一地、统一地执行一次。所以这里涉及到两个问题：第一，如何来指定或者来描述这样一个visit操作；第二，如何将它传递到向量内部的每一个具体的元素。</p><p>通常有两种方法：第一种是使用函数指针，也就是说可以对于<code>vector</code>这样一个类定义一个<code>traverse</code>接口，作为它的参数<code>visit</code>本身就是一个函数的指针。所以为了兑现这样的一个遍历操作我们只需要逐一地取出向量中由这个<code>i</code>确定的每一个元素通过这个函数指针找到这个函数，并且对这个元素实施这个函数所指定的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span>(*visit)(T&amp;))&#123;   <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是使用函数对象，也就是说我们指定的这个参数visit，本身就是一个对象，它的作用就是用来模拟一个操作一个函数的一个行为方式。所以同样地，我们也可以对这个向量中的每一个元素都逐一地取出，并且转交给这样一个函数对象，通过它来实施具体地、统一地操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST&amp; visit) &#123;       <span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法其实是非常接近，但是也有一些重要的区别，相对而言，后一种方式的通用性更强。</p><p>下面通过一个实例来了解如何通过函数对象，实现刚才所说的具体地遍历。比如说，我们可以考虑将向量中的所有的元素统一地各自+1。为此我们只需要实现一个对应功能的函数对象，它本身也是以一个类的形式给出来的。这里为了简化起见使用了<code>struct</code>，而没有进行过多的封装。这个对象最重要的一个作用或者说唯一的作用就是重载了它的圆括号操作符<code>()</code>，从而使得它在行为上与一个函数非常的类似，而具体的功能就是把每一个参数<code>e</code>做一个+1操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//假设T可直接递增或已重载操作符“++”</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inciease</span> &#123;</span>       <span class="comment">//函数对象：通过重载操作符"()"实现</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp; e)</span> </span>&#123; e++; &#125;   <span class="comment">//加一</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现了这样一个对应的类之后，就可以通过调用vector统一遍历接口traverse，将我们刚刚编写的这个函数对象以参数的形式传入就可以实现相应的功能，也就是把向量中的每一个元素统一地加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class="line">V.traverse(Increase&lt;T&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      向量属于最基本的数据结构，这一章围绕向量讨论两个方面的问题：如何根据统一的接口规范来定制并且实现一个数据结构，如何通过更加有效的算法使得我们对外的接口更加高效率地工作。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（1）</title>
    <link href="http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-05T02:32:06.000Z</published>
    <updated>2020-02-06T16:31:08.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>对象：规律，技巧</p><p>目标：高效，低耗</p><p>Computer science should be called called computing science, for the same reason why surgery is not called knife science.</p><p>-E.Dijkstra</p><ul><li>计算 = 信息处理</li></ul><p>​       借助某种工具，遵照一定规则，以明确而机械的形式进行</p><ul><li>计算模型 = 计算机 = 信息处理工具</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>所谓算法，即特定计算模型下，旨在解决特定问题的指令序列</p><p>​        输入：待处理的信息（问题）</p><p>​        输出：待处理的信息（答案）</p><p>​    正确性：的确可以解决指定的问题</p><p>​    确定性：任一算法都可以描述为一个由基本操作组成的序列</p><p>​    可行性：每一基本操作都可以实现，且在常数时间内完成</p><p>​    有穷性：任一算法在执行有限次基本操作之后终止并给出输出</p><ul><li>列子：Hailstone序列</li></ul><script type="math/tex; mode=display">\begin{align*}& 序列Hailstone(n)=\begin{cases}\{1\}     &n\le1\\\{n\}\cup Hailstone(n/2) &n为偶数\\\{n\}\cup Hailstone(3n+1) &n为奇数\end{cases}\\\\&Hailstone(42)=\{ 42,21,64,32,\dots,1\}\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hailstone</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//计算序列Hailstone(n)的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>; <span class="comment">//从1开始递推</span></span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">1</span>) &#123; (n % <span class="number">2</span>) ? n = <span class="number">3</span> * n + <span class="number">1</span> : n / = <span class="number">2</span>; lenth++; &#125;</span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回hailstone(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：对于任意的n，总有|Hailstone(n)| &lt;  ∞ ？</p><p>目前还不能证明</p><ul><li>程序不一定是算法</li></ul><h2 id="好算法"><a href="#好算法" class="headerlink" title="好算法"></a>好算法</h2><p>正确：符合语法，能够编译，链接</p><p>​           能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入</p><p>健壮：能辨别不合法的输入并做适当处理，而不致非正常退出</p><p>可读性：结构化  + 准确命名 + 注释 + …</p><p><strong>效率</strong>：<strong>速度尽可能快 ；存储空间尽可能少</strong>   （最重要的）</p><p>​           Algorithms + Data Structures = Programs         -N. Wirth, 1976</p><p>​          (Algorithms + Data Structures) × Efficiency = Computation</p><h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>好的数据结构和算法才能有高效的计算，从而有好的应用。         </p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>两个主要方面：</p><p>​        正确性：算法功能与问题要求一致？</p><p>​                        数学证明？并不简单</p><p>​        <strong>成本</strong>：    <strong>运行时间</strong>+所需存储空间</p><p>​                        如何度量？如何比较？</p><p>考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。</p><p>​           意义不大，因为可能出现的问题实例太多。那么如何归纳概括？</p><p>观察：问题实例的<strong>规模</strong>，往往是决定计算成本的主要因素。</p><p><strong>特定算法 + 不同实例</strong></p><ul><li>令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。</li></ul><p>​         讨论特定算法A（及其对应的问题）时，简记作$T(n)$。</p><ul><li><p>然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。</p></li><li><p>稳妥起见，取$T(n) = max{ T(P)| |P| = n }$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。</p></li></ul><p><strong>特定问题 + 不同算法</strong></p><ul><li>同一问题通常有多种算法，如何评判其优劣？</li><li>实验统计是最直接的方法，但足以准确反映算法的真正效率？</li><li>但实验统计还是不足够的，还要考虑：<ul><li>不同的算法，可能更适应于不同规模的输入</li><li>不同的算法，可能更适应 与不同类型的输入</li><li>同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现</li><li>同一算法，可能实现并运行与不同的体系结构、操作系统</li></ul></li><li>为给出客观的评判，需要抽象出一个理想的平台或模型<ul><li>不再依赖于上述种种具体的因素</li><li>从而直接而准确地描述，测量并评价算法</li></ul></li></ul><h2 id="图灵机-Turing-Machine"><a href="#图灵机-Turing-Machine" class="headerlink" title="图灵机 Turing Machine"></a>图灵机 Turing Machine</h2><ul><li>Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’</li><li>Alphabet：字符的种类有限</li><li>Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格</li><li>State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态</li><li>Transition Function ：（q,  c;  d,  L/R,  P)</li></ul><p>​        若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；</p><p>​        转入p状态，一旦转入特定的状   态’h’，则停机。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205112701.png" alt="QQ图片20200205112701" style="zoom:67%;"></p><h2 id="RAM-Random-Access-Machine"><a href="#RAM-Random-Access-Machine" class="headerlink" title="RAM:  Random Access Machine"></a>RAM:  Random Access Machine</h2><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114006.png" alt="QQ图片20200205114006" style="zoom:67%;"></p><p>与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。</p><p>在这些模型中：</p><ul><li>算法的运行时间   转化为   算法需要执行的基本操作次数</li><li>$T(n)$  =  算法为求解规模为n的问题，所需执行的基本操作次数</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114827.png" style="zoom:67%;"></p><h1 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h1><h2 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h2><ul><li>回到原先的问题：随着问题规模的增长，计算成本如何增长？</li></ul><p>​        注意：这里更关心足够大的问题，注重考察成本的增长趋势</p><ul><li>渐进分析：在问题规模足够大后，计算成本如何增长？</li></ul><p>​       Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法</p><p>​               需执行的基本操作次数：T(n) = ?</p><p>​               需占用的存储单元数：S(n) = ?         //通常可不考虑</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205124613.png" style="zoom:50%;"></p><h2 id="大-O-记号（big-O-notation）"><a href="#大-O-记号（big-O-notation）" class="headerlink" title="大$O$记号（big-$O$ notation）"></a>大$O$记号（big-$O$ notation）</h2><script type="math/tex; mode=display">\begin{align*}&T(n)=O(\,f(n)\,)\quad if \quad \exists c>0, 当n>>2后，有T(n)<c\cdot f(n)\\\\&例如：\sqrt{5n\cdot[3n\cdot(n+2)+4]+6}<\sqrt{5n\cdot[6n^2+4]+6}<\sqrt{35n^3+6}<6\cdot n^{1.5}=O(n^{1.5})\end{align*}</script><p>与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势</p><ul><li>常系数可忽略：$O(\,f(n)\,)=O(c\times \,f(n)\,)$</li><li>低次数可忽略：$O(n^a+n^b)=O(n^2),\,a&gt;b&gt;0$</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205130742.png" alt="QQ图片20200205130742" style="zoom: 50%;"></p><p><strong>其它记号</strong>：</p><ul><li>$T(n)=\Omega(\,f(n)\,)$：</li></ul><p>​       $ \exists c&gt;0, 当n&gt;&gt;2后，有T(n)&lt;c\cdot f(n)$</p><ul><li>$T(n)=\Theta(\,f(n)\,)$：</li></ul><p>​       $ \exists c_1&gt;c_2&gt;0, 当n&gt;&gt;2后，有c_1\cdot f(n)&gt;T(n)&gt;c_2\cdot f(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205131613.png" style="zoom:50%;"></p><h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>下面讨论大$O$记号的几种”刻度“：</p><p><strong>$O(1)$</strong></p><ul><li><p>常数（constant function）</p><p>$2=2013=2013\times 2013=O(1)$，甚至$2013^2013=O(1)$</p></li><li><p>这类算法的效率最高</p></li><li><p>什么样的代码对应于常数执行时间？</p><p>一般地，不含循环；不含分支转向；不能有（递归）调用，应具体问题具体分析</p></li></ul><p><strong>$O(log^c n)$</strong></p><ul><li>对数$O(log^c n)$</li><li>常底数无所谓</li></ul><p>​       $\forall a,b&gt;0,\,log_an=log_ab\cdot log_bn=\Theta(logn)$</p><ul><li>常数次幂无所谓</li></ul><p>​       $\forall c&gt;0,\,logn^c=c\cdot logn=\Theta(logn)$</p><ul><li><p>对数多项式（ploy-log function）</p><p>$123\cdot log^{321}n+log^{105}(n^2-n+1)=\Theta(log^{321}n)$</p></li><li><p>这类算法非常有效，复杂度无限接近于常数</p><p>$\forall c&gt;0,\,logn=\Theta(n^c)$</p></li></ul><p><strong>$O(n^c)$</strong></p><ul><li><p>多项式（polynomial function）</p><p>$(100n-500)(20n^2-300n+2013)=O(n\times n^2)=O(n^3)$</p><p>一般地，$a<em>kh^k+a</em>{k-1}n^{k-1}+\dots+a_1n+a_0=O(n^k),\,a_k&gt;0$</p></li><li><p>线性（linear function）：所有$O(n)$函数</p></li><li><p>这门课主要覆盖的范围：从$O(n)$到$O(n^2)$</p></li><li><p>这类算法的效率通常认为已可令人满意</p></li></ul><p><strong>$O(2^n)$</strong></p><ul><li>指数（exponential function）：$T(n)=a^n$</li><li>$\forall c&gt;1,\,n^c=O(2^n);\,n^{1000}=O(1.00001^n)=O(2^n);\,1.00001^n=\Omega(n^{1000})$</li><li>这类算法的计算成本增长极快，通常被认为不可忍受</li><li>从$O(n^c)$到$O(2^n)$，是从有效算法到无效算法的分水岭</li><li>很多问题的$O(2^n)$算法往往显而易见，然而设计出$O(n^c)$算法却极为不易，甚至有时注定只能是徒劳无功。</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100203.png" style="zoom:50%;"></p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100207.png" style="zoom:50%;"></p><p><strong>例子</strong>：2-Subset</p><p>S包含n个正整数，$\sum S=2m$，S是否有子集T，满足$\sum T=m$？</p><ul><li>直觉算法：逐一枚举S的每一个子集，并统计其元素的总和</li><li>定理：$|2^s|=2^{|s|}=2^n$，亦即直觉算法需要迭代$2^n$轮，并（在最坏情况下）至少需要花费这么多时的间</li><li>但实际上上述的直觉算法已属最优解，就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法。</li><li>2-Subset is NP-complete</li></ul><h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>两个主要任务 = 正确性（不变形 × 单调性） + 复杂度</p><p>那么为了确定复杂度，真地需要将算法描述为RAM的基本指令，再统计累计的执行次数嘛？答案是不必的。</p><p>C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当：</p><ul><li>分支转向：goto   //算法的灵魂，出于结构化考虑，被隐藏了</li><li>迭代循环：for( )、while( )……  //本质上就是 if + goto</li><li>调用 + 递归（自我调用）  //本质上也是goto</li></ul><p>复杂度分析的主要方法：</p><ul><li>迭代：级数求和</li><li>递归：递归跟踪 + 递推方程</li><li>猜测 + 验证</li></ul><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><ul><li>算数级数：与末项平方同阶</li></ul><p>​       $T(n)=1+2+\dots +n=n(n+1)/2=O(n^2)$</p><ul><li>幂方级数：比幂次高出一阶</li></ul><p>​       $\sum_{k=0}^nk^d\approx \int_0^n x^{d+1}dx=\frac{1}{d+1}x^{d+1}\mid_0^n=\frac{1}{d+1}n^{d+1}=O(n^{d+1})$</p><p>​       $T_2(n)=1^2+2^2+3^2+\dots+n^2=n(n+1)(2n+1)/6=O(n^3)$</p><p>​       $T_3(n)=1^3+2^3+3^3+\dots+n^3=n^2(n+1)^2/4=O(n^4)$</p><ul><li>几何级数（a&gt;1）：与末项同阶</li></ul><p>​       $T_a(n)=a^0+a^1+\dots+a^n=(a^{n+1}-1)/(a-1)=O(a^n)$</p><p>​       $1+2+4+\dots+2^n=2^{n+1}-1=O(2^{n+1})=O(2^n)$</p><ul><li>收敛级数</li></ul><p>​       $1/2/2+1/2/3+1/3/4+\dots+1/(n-1)/n=1-1/n=O(1)$</p><p>​       $1+1/2^2+\dots+1/n^2&lt;1+1/2^2+\dots=\pi^2/6=O(1)$</p><p>​       $1/3+1/7+1/8+1/15+/24+1/26+1/31+1/35+\dots=1=O(1)$</p><p>​       实际上讨论这类分数级数是有必要的，因为在某种意义上，基本操作次数，存储单元数可以看作是分数，例如将某个循环条件执行的概率设为$\lambda$，则其数学期望为：</p><p>​        $(1-\lambda)\cdot[1+2\lambda+3\lambda^2+4\lambda^3+\dots]=1/(1-\lambda)=O(1)，0&lt;\lambda&lt;1$</p><ul><li>某些不收敛但长度有限的级数</li></ul><p>​       $h(n)=1+1/2+1/3+\dots+1/n=\Theta(logn)$                     调和级数</p><p>​       $log1+log2+log3+\dots+logn=log(n!)=\Theta(nlogn)$      对数级数</p><h2 id="循环与级数"><a href="#循环与级数" class="headerlink" title="循环与级数"></a>循环与级数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=n+n+\dots+n=n\cdot n=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131334.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=0+1+\dots+(n-1)=\frac{n(n-1)}{2}=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131338.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j+=<span class="number">2013</span>)</span><br></pre></td></tr></table></figure><p>算术级数：$O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131342.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i&lt;&lt;=<span class="number">1</span>)  <span class="comment">// i&lt;&lt;=1 左移一位，相当于乘2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>几何级数：$1+2+4+\dots+2^{[log<em>2(n-1)]}={\sum}</em>{k=0}^{[log_2(n-1)]}2^k=2^{[log_2(n-1)]}-1=n-1=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131345.png" style="zoom:67%;"></p><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>问题：给定整数子集S，|S| = n &gt;=3，找出元素$a\in S,a\ne max(S)，且 a\ne min(S)  $</p><p>算法：从S中任取三个元素{x, y, z}  //若S以数组形式给出，不妨取前三个；由于S是集合，这三个元素必互异</p><p>​            确定并排除其中的最小者，最大者  //不妨设 x = max{x, y, z},  y = min{x, y, z}</p><p>​            输出剩下的元素z</p><p>无论输入规模n多大，上述算法需要的执行时间不变</p><p>​            $T(n)=常数=O(1)=\Omega(1)=\Theta(1)$</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p><strong>问题</strong>：给定n个整数，将它们按非降序排列</p><p><strong>观察</strong>：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</p><p><strong>扫描交换</strong>：依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；否则，再做一趟交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           <span class="keyword">if</span>(A[i<span class="number">-1</span>] &gt; A[i])&#123;</span><br><span class="line">               swap(A[i<span class="number">-1</span>],A[i]);</span><br><span class="line">               sorted = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑算法的正确性</p><p>问题：该算法必然会结束？至多需迭代多少趟？</p><p><strong>不变性</strong>：经k轮扫描交换后，最大的k个元素必然就位</p><p><strong>单调性</strong>：经k轮扫描交换后，问题规模缩减至n-k</p><p><strong>正确性</strong>：经至多n趟扫描后，算法必然终止，且能给出正确答案</p><p><strong>通过挖掘并且综合算法的不变性和单调性，进而证明算法正确性</strong>的方法是算法分析中的一个基本且重要的方法。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206133211.png" style="zoom: 67%;"></p><h2 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h2><p>除了大$O$记号这种定性的方法，我们在很多时候也需要定量的估算，一种常用的方法是封底估算（Back-of-the-Envelope Calculation）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206134004.png" style="zoom:67%;"></p><h1 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h1><p>To iterate is human, to recurse, divine.</p><p><strong>例子</strong>：<strong>数组求和（迭代）</strong></p><p>问题：计算任意n个整数之和</p><p>实现：逐一取出每个元素，累加之</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumI</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论A[ ]内容如何，都有时间复杂度为：</p><p>​        $T(n)=1+n*1+1=n+2=O(n)=\Omega(n)+\Theta(n)$</p><p>如果把输入参数中的n看作是这个问题的规模，其中最重要的循环部分，每经过一次迭代，有一个数已经统计完毕，而相应的尚未参与统计的元素，即尚未解决的问题的规模就会递减一个元素，这种通过不断削减问题的有效规模的方法就是减而治之。</p><h2 id="减而治之（Decrease-and-conquer）"><a href="#减而治之（Decrease-and-conquer）" class="headerlink" title="减而治之（Decrease-and-conquer）"></a>减而治之（Decrease-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡易解，另一规模缩减；分别求解子问题；由子问题的解，得到原问题的解。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206174923.png" style="zoom:67%;"></p><h3 id="数组求和：线性递归"><a href="#数组求和：线性递归" class="headerlink" title="数组求和：线性递归"></a>数组求和：线性递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>) ? <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归跟踪</strong>（recursion trace）分析：</li></ul><p>​       检查每个递归实例；累计所需时间（调用语句本身，计入对应的子实例）；其总和即算法执行时间</p><ul><li>本例中，单个递归实例自身只需$O(1)$时间</li></ul><p>​        $T(n)=O(1)*(n+1)=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206181824.png" style="zoom:67%;"></p><ul><li>从<strong>递推</strong>的角度看，为求解<code>sum(A, n)</code>，需要</li></ul><p>​                递归求解规模为n-1的问题<code>sum(A,n-1)</code>           //T(n-1)</p><p>​                再累加上A[n-1]                                                   //$O(1)$</p><p>​                递归基：<code>sum(A, 0)</code>                                          //$O(1)$</p><ul><li>递推方程：$T(n)=T(n-1)+O(1)$                     //recurrence</li></ul><p>​                          $T(0)=O(1)$                                            //base</p><ul><li>求解：       $T(n)-n=T(n-1)-(n-1)=\dots=T(2)-2=T(1)-1=T(0)$</li></ul><p>​                          $T(n)=O(1)+n=O(n)$</p><h3 id="数组倒置"><a href="#数组倒置" class="headerlink" title="数组倒置"></a>数组倒置</h3><p>任给数组A[n]，将其前后颠倒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">&#123;</span><br><span class="line">swap(A[lo], A[hi]);</span><br><span class="line">reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由递推方程：$T(n)=T(n-2)+O(1)$可得其时间复杂度为：$O(n)$。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206184350.png" style="zoom:67%;"></p><h2 id="分而治之（Divide-and-conquer）"><a href="#分而治之（Divide-and-conquer）" class="headerlink" title="分而治之（Divide-and-conquer）"></a>分而治之（Divide-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为若干个（通常两个）子问题，规模大体相当；分别求解子问题；由子问题的解，得到原问题的解</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201250.png" style="zoom:67%;"></p><h3 id="数组求和：二分递归"><a href="#数组求和：二分递归" class="headerlink" title="数组求和：二分递归"></a>数组求和：二分递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(A,lo,mi) + sum(A,mi+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201640.png" style="zoom:67%;"></p><p>该算法的正确性毋庸置疑，接下来分析其时间复杂度：</p><ul><li>从<strong>递归跟踪</strong>的角度：</li></ul><p>​       $T(n)=各层递归实例所需时间之和=O(1)\times(2^0+2^1+2^2+\dots+2^{logn})=O(n)$</p><p>​     （几何级数的时间复杂度与末项同阶）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206202116.png" style="zoom: 67%;"></p><ul><li><p>从<strong>递推</strong>的角度：为求解<code>sum(A, lo, hi)</code>，需要</p><p>​        递归求解<code>sum(A, lo, mi)</code>和<code>sum(A, mi+1, hi)</code> ；进而将子问题的解累加</p></li></ul><p>​               递归基：<code>sum(A, lo, lo)</code></p><p>​        递推关系：$T(n)=2*T(n/2)+O(1)$</p><p>​                           $T(1)=O(1)$</p><p>​        求解：        $T(n)=O(n)$</p><h2 id="Max2"><a href="#Max2" class="headerlink" title="Max2"></a>Max2</h2><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]，元素比较的次数，要求尽可能地少.</p><h3 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206204203.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x1 = lo; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[i]) x1 = i;                  <span class="comment">//hi-lo-1 = n-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x2 = lo; i &lt; x1; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//x1-lo-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x1 + <span class="number">1</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//hi-x1-1次比较      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何，该算法的比较次数总是$\Theta(2n-3)$</p><h3 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206205752.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])  swap(x1, x2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = i])</span><br><span class="line">swap(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：$1+(n-2)\times1=n-1$</p><p>最坏情况：$1+(n-2)\times2=2n-3$；就最坏的情况而言，这种算法并没有改进</p><h3 id="递归-分治"><a href="#递归-分治" class="headerlink" title="递归+分治"></a>递归+分治</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206210400.png" style="zoom:67%;"></p><p>将数组二分为左侧和右侧两部分，分别找出最大值和次大值，再进行比较；每一侧又可以继续二分，实现递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">2</span> == hi)&#123;                          <span class="comment">//T(2) = 1</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">3</span> == hi)&#123;                          <span class="comment">//T(3) &lt;= 3</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[lo + <span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = lo + <span class="number">2</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;                                </span><br><span class="line"><span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;    <span class="comment">//divide</span></span><br><span class="line"><span class="keyword">int</span> x1L, x2L;  max2(A, lo, mi, x1L, x2L);</span><br><span class="line"><span class="keyword">int</span> x1R, x2R;  max2(A, mi, hi, x1R, x2R);</span><br><span class="line"><span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">x1 = x1L;</span><br><span class="line">x2 = (A[x2L] &gt; A[x1R]) ? x2L : x1R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = x1R;</span><br><span class="line">x2 = (A[x1L] &gt; A[x2R]) ? x1L : x2R;</span><br><span class="line">&#125;     <span class="comment">//1 + 1 = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度：$T(n)=2*T(n/2)+2\le5n/3-2$</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work, make it right, make it fast.</p><p>前两步work和right可以通过递归解决，而最后一步fast可以通过迭代解决。</p><h2 id="斐波那契数列fib"><a href="#斐波那契数列fib" class="headerlink" title="斐波那契数列fib( )"></a>斐波那契数列fib( )</h2><p>$fib(n)  = fib(n-1) + fib(n-2) : {0, 1, 1, 2, 3, 5, 8, ……}$</p><h3 id="fib-：递归"><a href="#fib-：递归" class="headerlink" title="fib( )：递归"></a>fib( )：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>&gt;n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当n较大时，这个递归算法的计算是很慢的，其<strong>时间复杂度</strong>为：</p><p>$T(0)=T(1)=1;\,T(n)=T(n-1)+T(n-2)+1,\,n&gt;1$</p><p>令：$S(n)=[T(n)+1]/2$</p><p>则：$S(0)=1=fib(1),\,S(1)=1=fib(2)$</p><p>故：$S(n)=S(n-1)+S(n-2)=fib(n+1)$</p><p>​        $T(n)=2*S(n)-1=2\times fib(n+1)-1=O(fib(n+1))=O(\Phi^n)=O(2^n)$  ，</p><p>其中：$\Phi=\frac{1+\sqrt{5}}{2}=1.61803…$，即黄金分割数</p><p>可见该算法的时间复杂度和fib数列的n+1项的值是一个量级的。</p><p>接着对这个$O(\Phi^n)$进行较准确的估算，用<strong>封底估算</strong>的方法有：</p><p>$\Phi^{36}=2^{25},\,\Phi^{43}=2^{30}=10^9flo=1sec$</p><p>$\Phi^{5}=10,\,\Phi^{67}=10^14flo=10^5sec$</p><p>$\Phi^{92}=10^{19}flo=10^{10}sec=10^5day=3century$</p><p>可见这并不是一个好方法。</p><p>从<strong>递归跟踪</strong>的角度来分析：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206221339.png" style="zoom:67%;"></p><p>递归版<code>fib( )</code>低效的根源在于，各地鬼实例均被大量重复地调用</p><p>那么可以使每个实例只能调用一次嘛？答案是可以的。先后出现的递归实例，供给$O(\Phi^n)$个，而去除重复之后，总共不过$O(n)$种。</p><h3 id="fib-：迭代"><a href="#fib-：迭代" class="headerlink" title="fib( )：迭代"></a>fib( )：迭代</h3><p>解决方法A（<strong>记忆</strong>：memoization）：</p><p>​        将已计算过实例的结果指标备查。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206222400.png" style="zoom: 50%;"></p><p>解决方法B（动态规划：dynamic programming）：</p><p>​        颠倒计算方向，由自顶而下递归，改为自底而上迭代。不妨用两个变量f和g，分别来记忆当前我所处的相邻的两个数。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206223053.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;   <span class="comment">//fib(0), fib(1)</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了一个循环，没有其他增加时间复杂度的操作，而且只需要f和g两个存储单元。</p><p>$T(n)=O(n)$，而且仅需要$O(1)$空间！</p><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p><strong>子序列（Subsequence）</strong>：由序列中若干字符，按原相对次序构成（线不能有交叉）。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224303.png" style="zoom:67%;"></p><p><strong>最长公共子序列（Longest Common Subsequence）</strong>：两个序列公共子序列中的最长者。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224308.png" style="zoom:67%;"></p><p>现在考虑一个较简单的问题：如何计算出任意给出的两个序列的最长公共子序列的长度？</p><h3 id="LCS：递归"><a href="#LCS：递归" class="headerlink" title="LCS：递归"></a>LCS：递归</h3><p>对于序列A[0, n]和B[0, m]，LCS(A, B)无非三种情况</p><p>0）若n = -1 或 m = -1，则取空序列（“ ”）                                      //递归基</p><p>1）若A[n] = ‘X’ = B[m]，则取作LCS( A[0, n),  B[0, m) ) + ‘X’          // 减而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230441.png" style="zoom: 67%;"></p><p>2）若A[n] $\ne$ B[m]，则分别计算LCS( A[0, n],  B[0, m) )，与LCS( A[0, n),  B[0, m] )，取更长者。 //分而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230523.png" style="zoom:67%;"></p><p>我们把上述算法中生成的所有递归实例绘制成一个表，每一个横纵坐标所确定的3×3的小方格所组成的一个大方格分别对应于一个子任务或者说是递归实例，可以看到如果是减而治之的情况，对应大方格中的一条对角线；如果是分而治之的情况，则会考虑左侧和上方的子问题，然后取更长者，保留其对应的一条边。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206231904.png" style="zoom:67%;"></p><p>这样的形式可以帮助我们理解整个计算的过程，在这样一张表中我们最终求解的问题必然是右下角的方格对应的子问题，它分别会递归地引发一些更小的子问题，最终收缩到平凡的长度为0的子问题；我们也可以认为，每一个LCS问题的解都是从左上角(0,0)的单元开始一直沿着可行的深色的线通往右下角单元的路径，每一条路径就对应着一个解，这样就能很好地理解多解的情况。</p><p>接下来分析该算法的正确性和时间复杂度：</p><ul><li><p><strong>单调性</strong>：无论如何，每经过一次比对，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位。</p></li><li><p><strong>最好情况</strong>（不出现情况2））下，只需$O(n+m)$时间（线性规模）</p></li><li>但问题在于，在情况2）下原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能<strong>雷同</strong>，与<code>fib( )</code>的递归出现的问题类似，这种重复度往往是超出我们直观想象的。</li></ul><p>​       我们将上面的图表进行局部放大：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206233230.png" style="zoom:67%;"></p><p>为了进行更好的估算，我们不妨从更宏观的角度来重新审视上面的表格，不妨把其中所有的递归实例分别按坐标的形式表示为(n, m)，那么为了计算出最终的递归实例即(n, m)对应的解，我们需要唤醒某一个特定的递归实例(a. b)多少次呢？</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206234248.png" style="zoom:67%;"></p><p>根据图表中路线行进的方向，在最坏的情况下所唤醒的次数应该等于介于这两点之间的通路的条数，每一条通路对应于(a, b)被唤醒一次，即为两点之间所有合法的通路的总长n+m-a-b中挑选出n-a条水平路径的方案数，或挑选出m-b条垂直路径的方案数。</p><p>那么在最坏情况下，LCS( A[0, a],  B[0, b] )出现的次数为：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m-a-b\\n-a\end{pmatrix}=\begin{pmatrix}n+m-a-b\\m-b\end{pmatrix}</script><p>特别地，LCS( A[0],  B[0] )出现的次数多达：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m\\n\end{pmatrix}=\begin{pmatrix}n+m\\m\end{pmatrix}</script><p>当$n=m$时，该算法的时间复杂度为：$O(2^n)$。</p><h3 id="LCS：迭代"><a href="#LCS：迭代" class="headerlink" title="LCS：迭代"></a>LCS：迭代</h3><ul><li><p>与<code>fib( )</code>类似，这里也有大量重复的递归实例（子问题），（最坏情况下）先后共计出现$O(2^n)$个</p></li><li><p>各子问题，分别对应于A和B的某个前缀组合，因此总共不过$O(n*m)$种</p></li><li><p>采用动态规划的策略，只需$O(n*m)$时间即可计算出所有子问题</p></li><li><p>为此，我们只需将所有子问题列成一张表，颠倒计算方向，<strong>从LCS( A[0],  B[0] )出发</strong>，依次计算出所有项。</p><p>填表的规则是：首先初始化，行列都设为0，若遇到减而治之，即字母相同，则对应位置元素为其左上对角线元素+1；若遇到分而治之，即字母不相同，则对应位置元素取其上方和左侧元素中的最大值。</p></li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206235750.png" style="zoom:67%;"></p><p>这样对于每一个子问题，只会出现一次，因此算法的时间复杂度为$O(n*m)$。</p>]]></content>
    
    <summary type="html">
    
      开个新坑
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（7）类和对象</title>
    <link href="http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-04T08:09:38.000Z</published>
    <updated>2020-02-14T11:35:17.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计的基本特点"><a href="#面向对象程序设计的基本特点" class="headerlink" title="面向对象程序设计的基本特点"></a>面向对象程序设计的基本特点</h1><p><strong>抽象</strong>：对同一类对象的共同属性和行为进行概括，形成类。</p><ul><li>首先注意问题的本质及描述，其次是实现过程或细节。</li><li>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</li><li>代码抽象：描述某类对象的共有的行为特征或具有的功能。</li><li>抽象的实现：类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装</strong>：将抽象出的数据，代码封装在一起，形成类。</p><ul><li>目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</li><li>实现封装：类声明中的{ }</li></ul><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174646.png" alt="QQ图片20200204174646" style="zoom: 50%;"></p><p><strong>继承</strong>：在已有类的基础上，进行扩展形成新的类。</p><p><strong>多态</strong>：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。</p><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。</p><p>设计类就是设计类型，需要<strong>关注哪些问题</strong>：</p><ul><li>此类型的“合法值”是什么？</li><li>此类型应该有什么样的函数和操作符？</li><li>新类型的对象该如何被创建和销毁？</li><li>如何进行对象的初始化和赋值？</li><li>对象作为函数的参数如何以值传递？</li><li>谁将使用此类型的对象成员？</li></ul><h3 id="类定义的语法形式"><a href="#类定义的语法形式" class="headerlink" title="类定义的语法形式"></a>类定义的语法形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">           公有成员（外部接口）</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">           私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">           保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour = <span class="number">0</span>, minute = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p><strong>公有类型成员</strong>：在关键字<code>public</code>后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</p><p><strong>私有类型成员</strong>：在关键字<code>private</code>后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字<code>private</code>可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p><p><strong>保护类型成员</strong>：与private类似，其差别表现在继承与派生时对派生类的影响不同。</p><p>类中成员之间直接使用成员名互相访问。</p><p>从类外访问成员使用“ <code>对象名.成员</code>”，来访问公有成员。</p><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类中声明函数原型：</p><ul><li>可以直接在类中给出函数体，形成内联成员函数；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以在类外给出函数体实现，并在函数名前用类名加以限定；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::getArea() &#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line"><span class="keyword">int</span> Rectangle::getPerimeter() &#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br></pre></td></tr></table></figure><ul><li>允许声明重载函数和带默认参数值的函数。</li></ul><p><strong>例子</strong>：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setM</span><span class="params">(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y)</span> </span>&#123; x = _x; y = _y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> _r)</span> </span>&#123; r = _r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * r * r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> *r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Circle myCircle;</span><br><span class="line">myCircle.setM(<span class="number">1.7</span>, <span class="number">3.2</span>);</span><br><span class="line">myCircle.setR(<span class="number">4.2</span>);</span><br><span class="line"><span class="keyword">double</span> myArea = myCircle.getArea();</span><br><span class="line"><span class="keyword">double</span> myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">myCircle.setR(<span class="number">8.4</span>);</span><br><span class="line">myArea = myCircle.getArea();</span><br><span class="line">myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174231.png" alt="QQ图片20200204174231" style="zoom:80%;"></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>当我们定义对象时，如何对对象进行初始化？在定义基本类型的变量时，是可以直接给定初始值的，但是在定义对象时却不是这么简单，因为一个类是我们自己定义的，对类的对象按照什么规则进行初始化，编译器是不会自动知道的，必须由程序员写程序来规定。为此C++中提供了一种特殊的机制：<strong>构造函数</strong>，在构造函数中我们可以描述如何对类的对象进行初始化。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><ul><li>在对象被创建时使用特点的值构造对象，将对象初始化为一个特定的初始状态</li></ul><p>例如：希望在构造一个Clock类对象时，将初始时间设为0:0:0，就可以通过构造函数来设置</p><h3 id="构造函数的形式"><a href="#构造函数的形式" class="headerlink" title="构造函数的形式"></a>构造函数的形式</h3><ul><li>函数名与类名相同；</li><li>不能定义返回值类型，也不能在函数体有return语句；</li><li>可以有形式参数，也可以没有形式参数；</li><li>可以是内联函数；</li><li>可以是重载；</li><li>可以带默认参数值。</li></ul><h3 id="构造函数的调用时机"><a href="#构造函数的调用时机" class="headerlink" title="构造函数的调用时机"></a>构造函数的调用时机</h3><ul><li>在对象创建时被自动调用，但如果没有定义构造函数就进行初始化，那么编译器就会报错。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Clockk <span class="title">myClock</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>调用时可以不需要实参的构造函数：</p><ul><li>参数表为空的构造函数</li><li>全部参数都有默认值的构造函数</li></ul><p>下面两个都是默认构造函数，如在类中同时出现，将产生编译错误，不是合法的函数重载形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock();</span><br><span class="line">Clock(<span class="keyword">int</span> newH=<span class="number">0</span>, <span class="keyword">int</span> newM=<span class="number">0</span>, <span class="keyword">int</span> newS=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="隐含生成的构造函数"><a href="#隐含生成的构造函数" class="headerlink" title="隐含生成的构造函数"></a>隐含生成的构造函数</h3><p>如果在程序中未定义构造函数，编译器将在需要时自动生成一个<strong>默认的构造函数</strong>：</p><ul><li>参数列表为空，不为数据成员设置初始值；</li><li>如果类内定义了成员的初始值，则使用内类定义的初始值；</li><li>如果没有定义类内的初始值，则以默认方式初始化；</li><li>基本类型的数据默认初始化的值是不确定的。</li></ul><p>如果定义的类的成员不是基本类型的成员，而是其他类的对象，这个就是类组合的情况，其默认的初始化方式由它所属的类决定。</p><h4 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h4><p>如果程序中已定义构造函数，默认情况下编译器就不会再隐含生成默认构造函数。如果此时依然希望编译器隐含生成的默认构造函数，可以使用<code>=default</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Clock() = <span class="keyword">default</span>;</span><br><span class="line">       Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">c.showTime();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);   <span class="comment">//构造函数</span></span><br><span class="line">    Clock();  <span class="comment">//默认构造函数，如果类要重复使用，一般要提供一个默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;  <span class="comment">//调用有参数的构造函数</span></span><br><span class="line">    Clock c2;          <span class="comment">//调用无参数的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>当我们在一个类中重载多个构造函数的时候，往往发现这些构造函数它们只是形参表不同，初始化列表不同，而其他都是一样的，初始化算法都是相同的，函数体都是相同的。那么在这种情况下，如果我们写多个函数体来重载，往往就显得重复了，为了避免这种重复，C++11新标准提供了一种新的机制：<strong>委托构造函数</strong>，也就是让一个构造函数可以去委托另一个构造函数去帮它完成初始化功能。</p><p>回顾<code>Clock</code>类的两个构造函数，第一个构造函数是有三个参数的，第二个构造函数是默认构造函数，没有参数。实际上，这两个构造函数进行初始化的方式是完全一样的，只不过第一个构造函数是用参数表里的参数进行初始化，第二个构造函数用默认状态全部用0进行初始化。那么我们其实没有必要写两个类似的重复的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br></pre></td></tr></table></figure><p>委托构造函数使用类的其他构造函数执行初始化过程，我们用委托构造函数的方法重写上面的代码，这里第二个构造函数调用了另外一个有参数的构造函数，将默认的三个初始化参数传给有参数表的Clock构造函数，这样就不用把同样的初始化方法再写一遍了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125;</span><br><span class="line">Clock::Clock():Clock(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>用委托构造函数不仅可以减少重复的工作，其最大的好处是可以<strong>保持代码实现的一致性</strong>，如果想要修改构造函数的初始化算法时，就只需在一处修改，其他的委托这个构造函数来进行初始化的构造函数的算法也就同步修改了。</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>当我们在定义一个基本类型的变量时，经常会用一个已经存在的已经有值的变量去初始化这个变量；我们在定义对象时可会有这样的需求，即用一个存在的对象去初始化一个新的对象，这时要如何实现这种初始化呢？C++中提供了一种特殊的构造函数，叫<strong>复制构造函数</strong>。</p><p>在复制构造函数中我们可以规定如何用一个已经存在的对象去初始化一个新对象，可以用这个已经存在的对象的引用作为构造函数的参数。如果在定义类的时候没有定义复制构造函数，编译器也生成一个默认的复制构造函数，它会实现类的两个对象的数据成员之间一一对应复制，这些功能在很多时候已经能满足需求，那么我们就不需要再写复制构造函数了。</p><h3 id="复制构造函数定义"><a href="#复制构造函数定义" class="headerlink" title="复制构造函数定义"></a>复制构造函数定义</h3><ul><li>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</li></ul><p>由于复制构造函数的目的不会是将原有的那个形参对象给修改了，所以最好是在形参引用前加上<code>const</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       类名(形参)； <span class="comment">//构造函数</span></span><br><span class="line">       类名(<span class="keyword">const</span> 类名 &amp;对象名);   <span class="comment">//复制构造函数</span></span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类(<span class="keyword">const</span> 类名 &amp;对象名)      <span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><h3 id="复制构造函数的调用"><a href="#复制构造函数的调用" class="headerlink" title="复制构造函数的调用"></a>复制构造函数的调用</h3><p>除了在定义新对象时，用已有的对象作为参数去初始化它这种情况以外，共有三种情况是典型的要调用复制构造函数的情况：</p><ul><li>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</li><li>如果<strong>函数的**</strong>形参是类的对象**，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</li><li>如果<strong>函数的返回值是类的对象</strong>，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。</li></ul><h3 id="隐含的复制构造函数"><a href="#隐含的复制构造函数" class="headerlink" title="隐含的复制构造函数"></a>隐含的复制构造函数</h3><ul><li>如果程序员没有为类拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数；</li><li>这个构造函数的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</li></ul><p>如果类的成员中有指针的时候，很多情况下，默认的复制构造函数其浅层的复制功能就不够用了，这是我们就需定义深层的复制构造。</p><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>如果我们不希望对象被复制构造，那么可以采用下面的方法:</p><ul><li>C++98做法：将复制构造函数声明为<code>private</code>，并且不提供函数的实现。</li><li>C++11做法：用<code>=delete</code>指示编译器不生成默认复制构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx=<span class="number">0</span>, <span class="keyword">int</span> yy=<span class="number">0</span>) &#123;x=xx; y=yy&#125;  <span class="comment">//构造函数，内联</span></span><br><span class="line">       Point(<span class="keyword">const</span> Point &amp;p) = <span class="keyword">delete</span>;         <span class="comment">//指示编译器不生成默认复制构造函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当一个对象在存续期间会占用系统资源，当这个对象的生存期结束时，需要进行善后工作将其删除清理掉，C++中提供了这样一种机制：析构函数。当对象被构造时，构造函数会自动调用；当对象要消亡时，其析构函数也会自动调用。</p><ul><li>完成对象被删除前的一些清理工作；</li><li>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间；</li><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空；</li><li>析构函数的原型：<code>~类名( );</code></li><li>析构函数没有参数，没有返回类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)   <span class="comment">//构造函数</span></span><br><span class="line">       ~Point();               <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line">Point::Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    x=xx; y=yy;</span><br><span class="line">&#125;</span><br><span class="line">Point::~Point()&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h1><p>在制造业多年来都一直使用部件组装的生产方式，与一切手工从头做起相比，部件组装的生产效率肯定是要高，产品的标准化  它的可靠性也都更好。在程序中我们也可以借用这种部件组装的思想，用已经存在的这些类去组装新的类，C++语言支持类的组合。我们在定义一个新类的时候，可以让它的类成员是已有类的对象，也就是说一些类的对象可以作为另外一个类的部件，这就是类的组合。</p><p><strong>类组合的基本概念</strong>：</p><ul><li>类中的成员是另外其他类的对象；</li><li>可以在已有抽象的基础上实现更复杂的抽象。</li></ul><p><strong>成员对象</strong>：一个类的成员变量是另一个类的对象</p><p>包含成员对象的类叫<strong>封闭类</strong>（Enclosing）</p><h2 id="类组合的构造函数设计"><a href="#类组合的构造函数设计" class="headerlink" title="类组合的构造函数设计"></a>类组合的构造函数设计</h2><p>那么组合类的构造函数如何设计呢？每个类的构造函数都是负责自己本类成员初始化的，如果用另外类的对象作为新定义类的成员，那么这个组合类是没有权利去访问部件对象内部的私有成员。因为一个类的私有成员只有这个类内部的函数可以访问，类外任何地方是不可以访问的，而且部件类的设计者、开发者，跟组合类的设计者  开发者可能不是一个人，甚至不是一个团队。因此在写组合类的构造函数时要考虑，由组合类的构造函数负责将部件对象初始化所需要的初始化参数传递给它，然后编译器会自动去调用部件类的构造函数，来初始化这些部件对象。其语法形式如下：</p><ul><li>原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。</li><li>声明形式：<strong>初始化列表</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(对象成员所需的形参，本类成员形参):</span><br><span class="line">    对象<span class="number">1</span>(参数), 对象<span class="number">2</span>(参数),......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//函数体其他语句</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造组合类对象时的初始化次序"><a href="#构造组合类对象时的初始化次序" class="headerlink" title="构造组合类对象时的初始化次序"></a>构造组合类对象时的初始化次序</h3><ul><li>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。<ul><li>成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造</li><li>初始化列表中未出现的成员对象，调用默认构造函数（即无形餐的）初始化</li></ul></li><li>处理完初始化化列表之后，再执行构造函数的函数体</li></ul><p>也可以这样理解，<strong>构造函数和析构函数的调用顺序</strong>：</p><ul><li>当封闭类对象生成时：<ul><li>S1：执行所有成员对象的构造函数</li><li>S2：执行封闭类的构造函数</li></ul></li><li>成员对象的构造函数调用顺序<ul><li>和成员对象在类中的说明顺序一致</li><li>与在成员初始化列表中出现的顺序无关</li></ul></li><li>当封闭类的对象消亡时<ul><li>S1：先执行封闭类的析构函数</li><li>S2：再执行成员对象的析构函数</li></ul></li><li>析构函数顺序和构造函数的调用顺序相反（先构造的后析构，后构造的先析构）</li></ul><p>需要注意的是，我们在写类的构造函数时，<strong>最好再写一个无参数的默认构造函数</strong>。当这个类的对象被用作其他类的部件成员时，可能组合类中没有写构造函数只使用默认构造函数，这个时候我们上面的操作就显得很必要了。</p><p><strong>例子</strong>：构造一个<code>Point</code>类，再用<code>Point</code>类构造组合类<code>Line</code>类，通过构造函数和复制构造函数中的“调试信息”（<code>cout&lt;&lt;</code>……）可以更好地理解构造函数和复制构造函数的调用过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span>    <span class="comment">//Point类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">x = xx;</span><br><span class="line">y = yy;</span><br><span class="line">&#125;</span><br><span class="line">Point(Point &amp;p);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point(Point &amp;p) &#123;   <span class="comment">//复制构造函数的实现</span></span><br><span class="line">x = p.x;</span><br><span class="line">y = p.y;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling the copy constructor of Point"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span>   <span class="comment">//Line类的定义</span></span><br><span class="line"><span class="keyword">public</span>:        <span class="comment">//外部接口</span></span><br><span class="line">Line(Point xp1, Point xp2);</span><br><span class="line">Line(Line &amp;l);</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> len; &#125;</span><br><span class="line"><span class="keyword">private</span>:      <span class="comment">//私有数据成员</span></span><br><span class="line">Point p1, p2;   <span class="comment">//Point类的对象p1,p2</span></span><br><span class="line"><span class="keyword">double</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合类的构造函数</span></span><br><span class="line">Line::Line(Point xp1, Point xp2) :p1(xp1), p2(xp2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling constructor of Line"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p1.getX() - p2.getX());</span><br><span class="line"><span class="keyword">double</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p1.getY() - p2.getY());</span><br><span class="line">len = <span class="built_in">sqrt</span>(x*x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合类的复制构造函数</span></span><br><span class="line">Line::Line(Line &amp;l) :p1(l.p1), p2(l.p2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling the copy constructor of Line"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">len = l.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Point myp1(1, 1), myp2(4, 5);</span><br><span class="line"><span class="function">Line <span class="title">line</span><span class="params">(myp1, myp2)</span></span>;</span><br><span class="line"><span class="function">Line <span class="title">line2</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the line is: "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span>.getLen() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the line2 is: "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line2.getLen() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200209205450.png" style="zoom:80%;"></p><h1 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h1><p>类应该先声明，后使用，如果<strong>需要在某个类的声明之前引用该类</strong>，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其他地方。前向引用声明某个类之后，可在之后的其他类的成员函数中将该类作为参数类型使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。</li><li>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。</li><li>当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>;</span>  <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barney</span>&#123;</span></span><br><span class="line">    Fred x;  <span class="comment">//错误：类Fred的声明尚不完整，不能声明该类的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>&#123;</span></span><br><span class="line">    Barney y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol><li>声明一个<code>CPU</code>类，包含等级（rank）、频率（frequency）、电压（voltage）等属性，有两个公有成员函数run、stop。其中，rank为枚举类型CPU_Rank，声明为<code>enum CPU_Rank {P1=1,P2,P3,P4,P5,P6,P7}</code>，frequency为单位是MHz的整型数，voltage为浮点型的电压值。类似地声明一个<code>RAM</code>类。</li><li>声明一个简单的Computer类，有数据成员芯片（cpu）、内存（ram），有两个公有成员函数run、stop。cpu为CPU类的一个对象，ram为RAM类的一个对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> CPU_Rank &#123; P1 = <span class="number">1</span>, P2, P3, P4, P5, P6, P7 &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU_Rank rank;</span><br><span class="line"><span class="keyword">int</span> frequency;</span><br><span class="line"><span class="keyword">float</span> voltage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CPU(CPU_Rank r, <span class="keyword">int</span> f, <span class="keyword">float</span> v)  <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">rank = r;</span><br><span class="line">frequency = f;</span><br><span class="line">voltage = v;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个CPU!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CPU(CPU &amp;c)  <span class="comment">//复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">rank = c.rank;</span><br><span class="line">frequency = c.frequency;</span><br><span class="line">voltage = c.voltage;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造了一个CPU！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~CPU() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个CPU!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">CPU_Rank <span class="title">GetRank</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rank; &#125;       <span class="comment">//外部接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFrequency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> frequency; &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetVoltage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> voltage; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRank</span><span class="params">(CPU_Rank r)</span> </span>&#123; rank = r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFrequency</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123; frequency = f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVoltage</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123; voltage = v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CPU开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CPU停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RAM_TYPE &#123; DDR2 = <span class="number">2</span>, DDR3, DDR4 &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> RAM_TYPE type;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> frequency;  <span class="comment">//MHz</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>;       <span class="comment">//GB</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RAM(RAM_TYPE t, <span class="keyword">unsigned</span> <span class="keyword">int</span> f, <span class="keyword">unsigned</span> <span class="keyword">int</span> s)  <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">type = t;</span><br><span class="line">frequency = f;</span><br><span class="line"><span class="built_in">size</span> = s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RAM(RAM &amp;c)    <span class="comment">//复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">type = c.type;</span><br><span class="line">frequency = c.frequency;</span><br><span class="line"><span class="built_in">size</span> = c.<span class="built_in">size</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~RAM() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;   <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">RAM_TYPE <span class="title">GetType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetFrequency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> frequency; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetType</span><span class="params">(RAM_TYPE t)</span> </span>&#123; type = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFrequency</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> f)</span> </span>&#123; frequency = f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> s)</span> </span>&#123; <span class="built_in">size</span> = s; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RAM开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RAM停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//COMPUTER类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COMPUTER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU my_cpu;</span><br><span class="line">RAM my_ram;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> storage_size; <span class="comment">//GB</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bandwidth;    <span class="comment">//MB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">COMPUTER(CPU c, RAM r,<span class="keyword">unsigned</span> <span class="keyword">int</span> s, <span class="keyword">unsigned</span> b);     <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">~COMPUTER() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个COMPUTER！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">my_cpu.Run();</span><br><span class="line">my_ram.Run();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPUTER开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">my_cpu.Stop();</span><br><span class="line">my_ram.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPUTER停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//COMPUTER类的构造函数，内嵌对象采用初始化列表初始化</span></span><br><span class="line"><span class="comment">//一共会调用两次复制构造函数，形实结合调用依次，初始化列表调用依次</span></span><br><span class="line"><span class="comment">//当COMPUTER构造函数结束以后，形实结合那个形参的生命周期就结束，于是执行析构函数</span></span><br><span class="line">COMPUTER::COMPUTER(CPU c, RAM r, <span class="keyword">unsigned</span> <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> b) :my_cpu(c), my_ram(r)</span><br><span class="line">&#123;</span><br><span class="line">storage_size = s;</span><br><span class="line">bandwidth = b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个COMPUTER！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CPU <span class="title">a</span><span class="params">(P6, <span class="number">300</span>, <span class="number">2.8</span>)</span></span>;</span><br><span class="line">a.Run();</span><br><span class="line">a.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RAM <span class="title">b</span><span class="params">(DDR3, <span class="number">1600</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">b.Run();</span><br><span class="line">b.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">COMPUTER <span class="title">my_computer</span><span class="params">(a, b, <span class="number">128</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line">my_computer.Run();</span><br><span class="line">my_computer.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return之前会执行析构函数，先析构my_computer，和它的两个内嵌成员，然后析构CPU a和RAM b</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200209232217.png" style="zoom:80%;"></p><p>PS：结构体，联合体，枚举类的内容在上一篇文章Cpp基础（6）中。</p>]]></content>
    
    <summary type="html">
    
      设计程序的过程，就是设计类的过程
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（6）结构体与链表</title>
    <link href="http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-02T09:03:07.000Z</published>
    <updated>2020-02-03T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种特殊形态的类，与类的唯一区别是：类的缺省访问权限是<code>private</code>，结构体的缺省访问权限是<code>public</code>。</p><p>那么什么时候用结构体而不用类：定义主要用来保存数据，没没有什么操作的类型。人们习惯将结构体的数据成员设为公有，这时使用结构体更方便。</p><p>结构体相当于构造了一个新的数据类型，用一组变量描述同一个“事物”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;    <span class="comment">//注意大括号后的" ; "</span></span><br></pre></td></tr></table></figure><p>定义结构体变量的方式：</p><ol><li>直接用已声明的结构体类型定义变量名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student student1, student2;</span><br></pre></td></tr></table></figure><ol><li>在声明类型的同时定义变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;student1,student2;</span><br></pre></td></tr></table></figure><p>结构体数据类型的特性与普通数据类型的特性是一致的，可以赋值，做函数参数，有指向结构体的指针，结构体数组等等。</p><h2 id="定义结构体类型的变量"><a href="#定义结构体类型的变量" class="headerlink" title="定义结构体类型的变量"></a><strong>定义结构体类型的变量</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">mike.id_num = <span class="number">2123000</span> + mike.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202181848.png" alt="QQ图片20200202181848" style="zoom:80%;"></p><h2 id="结构体变量赋值"><a href="#结构体变量赋值" class="headerlink" title="结构体变量赋值"></a><strong>结构体变量赋值</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike1 = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student mike2;</span><br><span class="line">mike2 = mike1;</span><br><span class="line">mike2.id_num = <span class="number">2123000</span> + mike2.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike1.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike1.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike2.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike2.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182213.png" alt="QQ图片20200202182213" style="zoom:80%;"></p><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a><strong>结构体做函数参数</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(student one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">one.id_num = <span class="number">2123000</span> + one.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; one.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">one.name[i] = <span class="built_in">toupper</span>(one.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">renew(mike);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182733.png" alt="QQ图片20200202182733" style="zoom:80%;"></p><h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student *one = &amp;mike;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202183112.png" alt="QQ图片20200202183112" style="zoom:80%;"></p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student myclass[<span class="number">3</span>] = &#123; <span class="number">123</span>,<span class="string">"mike"</span>,<span class="number">133</span>,<span class="string">"tom"</span>, <span class="number">143</span>,<span class="string">"jack"</span>&#125;;</span><br><span class="line">student *one = myclass;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202190921.png" alt="QQ图片20200202190921" style="zoom:80%;"></p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举：如果一个变量只有几种可能的取值，则可以将该变量定义为<strong>枚举类型</strong>。</p><p>枚举类型的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个枚举数据类型weekday</span></span><br><span class="line"><span class="keyword">enum</span> weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; <span class="comment">//花括号内sun,mon,...,sat等称为枚举元素</span></span><br><span class="line"><span class="comment">//定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> weekday workday,weekend;</span><br><span class="line">weekday workday,weekend</span><br><span class="line"><span class="comment">//枚举变量赋值</span></span><br><span class="line">workday = sun; weekend = moon;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>枚举类型按常量处理，不能对它们赋值。<code>sun = mon;</code> （错误）</li><li>枚举类型不能直接输出元素的名字。<code>enum color{red,green,white,black}; color cloth = red; cout&lt;&lt;cloth;  //结果为0。</code></li><li>枚举类型可以比较。<code>if(cloth &gt; white)  count++</code></li><li>一个整型不能直接赋给一个枚举变量。<code>workday = 2;</code> （错误）</li><li>枚举元素有值：<ul><li>定义时枚举元素如未指定值，编译系统按定义顺序取默认值依次为0,1,2,3,….</li><li>也可以给枚举元素指定对应的值，<code>enum day {sun=7,mon=1, tue, wed, thu, fri, sat};</code> 这时有<code>sun=7, mon=1, tue=2, wed=3,......</code></li><li>若要把整数赋给枚举变量应先进行强制类型转换，<code>workday = (enum weekday) 2;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> color&#123;red,yellow, green=<span class="number">3</span>,blue&#125;;</span><br><span class="line"><span class="keyword">enum</span> color cl;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cl = blue;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"red="</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow="</span> &lt;&lt; yellow &lt;&lt; <span class="string">" green="</span> &lt;&lt; green &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"blue="</span> &lt;&lt; blue &lt;&lt; <span class="string">" cl="</span> &lt;&lt; cl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出枚举类型的内容</span></span><br><span class="line"><span class="keyword">switch</span> (cl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> red:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> yellow:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"yellow\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> green:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> blue:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202193831.png" alt="QQ图片20200202193831" style="zoom:80%;"></p><p><strong>例子</strong>：计算工资</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202195012.png" alt="QQ图片20200202195012" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> day&#123;Mon,Tue,Wed,Thu,Fri,Sat,Sun&#125;;</span><br><span class="line">day workDay;</span><br><span class="line"><span class="keyword">double</span> times, wages = <span class="number">0</span>, hourlyPay, hours;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the hourly wages rate."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hourlyPay;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter hours worked daily"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hours;</span><br><span class="line"><span class="keyword">switch</span> ((day)i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Sat:times = <span class="number">1.5</span>*hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Sun:times = <span class="number">2</span> * hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:times = hours;</span><br><span class="line">&#125;</span><br><span class="line">wages = wages + times * hourlyPay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The wages for the week are "</span> &lt;&lt; wages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200510.png" alt="QQ图片20200202200510" style="zoom:80%;"></p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><strong>共用体</strong>：为了节省内存空间，可以将几种不同类型的变量存放到同一段内存单元中，这段内存单元所对应的数据结构称为共用体。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200904.png" alt="QQ图片20200202200904" style="zoom:50%;"></p><p><strong>共用体的定义</strong>：<code>uniom 共用体名{ 成员列表; }变量列表;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;      <span class="comment">// 直接定义</span></span><br><span class="line"></span><br><span class="line">data a,b,c;  <span class="comment">//分开定义</span></span><br></pre></td></tr></table></figure><p>共用体的引用：不能引用共用体变量，只能引用共用体变量中的成员。</p><p><strong>共用体类型数据的特点</strong>：</p><ol><li>同一内存段可以存放几种不同类型的成员，但在同一时刻时只能存放其中一种。</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</li><li>共用体变量的地址和它的各成员的地址都是同一地址，如<code>&amp;a, &amp;a.i, &amp;a.ch, &amp;a.f</code>都是同一地址值。</li><li>共用体不能初始化，不能对整个共用体赋值。</li><li>在函数中，可以使用共用体的指针，但不能使用名字做函数参数。</li><li>共用体的空间是所有成员中最大的一个。</li></ol><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202203319.png" alt="QQ图片20200202203319" style="zoom:50%;"></p><p><strong>例子</strong>：</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202204157.png" alt="QQ图片20200202204157" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> job;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Class;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">position</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;category;</span><br><span class="line">&#125;preson[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是一种非常常用的动态数据结构，可以用来表示顺序访问的线性群体：</p><ul><li>链表头：指向第一个链表结点的指针；</li><li>链表结点：链表中的每一个元素，包括：当前结点的数据，下一个结点的地址；</li><li>链表尾：不再指向其他结点的结点，其地址部分放一个<code>NULL</code>，表示链表到此结束。</li></ul><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202213412.png" alt="QQ图片20200202213412" style="zoom:50%;"></p><h2 id="关于new-amp-delete"><a href="#关于new-amp-delete" class="headerlink" title="关于new &amp; delete"></a>关于new &amp; delete</h2><p><code>new</code>：C++运算符，动态地分配内存空间，并将所分配的内存的地址赋给指针变量。</p><p><code>delete</code>：C++运算符，将动态分配的内存空间归还给系统。</p><p><strong>用法一</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;;   </li></ul><p>​       分配某种类型大小的一片连续内存空间，并将内存空间的首地址赋给指针变量。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202215333.png" alt="QQ图片20200202215333" style="zoom:80%;"></p><p><strong>用法二</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;(初值);   </li></ul><p>​       分配空间，并将初始值存入所分配的空间中。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;[&lt;常量表达式&gt;];   </li></ul><p>​       分配指定类型的数组空间，并将数组的首地址赋给指针变量。</p><ul><li>delete[ ]&lt;指针变量&gt;;</li></ul><p>​       将指针变量所指向一维数组内存空间归还给系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(p+i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202220229.png" alt="QQ图片20200202220229" style="zoom:80%;"></p><p>当new &amp; delete 用于结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;next &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203093844.png" alt="QQ图片20200203093844" style="zoom:80%;"></p><h2 id="逐步建立链表"><a href="#逐步建立链表" class="headerlink" title="逐步建立链表"></a>逐步建立链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094349.png" alt="QQ图片20200203094349" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094355.png" alt="QQ图片20200203094355" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094400.png" alt="QQ图片20200203094400" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094405.png" alt="QQ图片20200203094405" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">student *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">student *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *head, *temp;</span><br><span class="line"><span class="keyword">int</span> num, n = <span class="number">0</span>;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">-1</span>)    <span class="comment">//-1作为结束符？</span></span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">temp-&gt;id = num;</span><br><span class="line">temp-&gt;next = <span class="keyword">new</span> student;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *pointer = create();</span><br><span class="line"><span class="keyword">while</span> (pointer-&gt;next != <span class="literal">NULL</span>)     <span class="comment">//遍历链表的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer-&gt;id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pointer = pointer-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203100110.png" alt="QQ图片20200203100110" style="zoom:80%;"></p><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203101525.png" alt="QQ图片20200203101525" style="zoom:50%;"></p><p><strong>例子</strong>：在链表中将值为n的结点删掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">dele</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *follow;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)   <span class="comment">//head为空时，说明链表为空表</span></span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;id == n)  <span class="comment">//若第一个节点是要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;id != n)  <span class="comment">//寻到要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)          <span class="comment">//若没到找到要删除的目标</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = temp-&gt;next;  <span class="comment">//删除目标结点</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><p>1.将结点unit插入链表的<strong>最前面</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104316.png" alt="QQ图片20200203104316" style="zoom:50%;"></p><p>2.将结点unit插入链表的<strong>中间</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104321.png" alt="QQ图片20200203104321" style="zoom:50%;"></p><p>3.将结点unit插入链表的<strong>最后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104324.png" alt="QQ图片20200203104324" style="zoom:50%;"></p><p>例子：插入结点值为n的结点（按大小顺序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">insert</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *unit, *follow;</span><br><span class="line">temp = head;</span><br><span class="line">unit = <span class="keyword">new</span> student;</span><br><span class="line">unit-&gt;id = n;</span><br><span class="line">unit-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)  <span class="comment">//如果链表为空，直接插入</span></span><br><span class="line">&#123;</span><br><span class="line">head = unit;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((temp-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;id &lt; n))  <span class="comment">//寻找第一个不小于n的结点temp</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == head)     <span class="comment">//如果temp为第一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">unit-&gt;next = head;</span><br><span class="line">head = unit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//如果temp为最后一个结点</span></span><br><span class="line">temp-&gt;next = unit;</span><br><span class="line"><span class="keyword">else</span>                     <span class="comment">//如果temp为一个中间结点</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = unit;</span><br><span class="line">unit-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111706.png" alt="QQ图片20200203111706" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111715.png" alt="QQ图片20200203111715" style="zoom:50%;"></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111959.png" alt="QQ图片20200203111959" style="zoom:50%;"></p><p><strong>删除结点temp</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112004.png" alt="QQ图片20200203112004" style="zoom:50%;"></p><p><strong>将结点unit插入到temp之后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112008.png" alt="QQ图片20200203112008" style="zoom:50%;"></p><h2 id="例子：约瑟夫环问题"><a href="#例子：约瑟夫环问题" class="headerlink" title="例子：约瑟夫环问题"></a>例子：约瑟夫环问题</h2><p><strong>问题描述</strong>：n个孩子围坐成一圈，并按顺时针编号为1,2,3, ……,n，从编号为p的小孩顺时针依次报数，由1报到m，当报到m时，该小孩从圈中出去，然后下一个小孩再从1报数，当报到m时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号（假设小孩的个数不多于300个）。</p><p><strong>关于输入</strong>：n,p,m的值在1行内输入，以空格间隔</p><p><strong>关于输出</strong>：按出圈的顺序输出编号，编号之间以逗号间隔。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203115945.png" alt="QQ图片20200203115945" style="zoom:50%;"></p><p><strong>思路</strong>：</p><p>首先定义结点的结构体，列出需要的函数的，然后再考虑每个函数需要完成的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">Node *next;</span><br><span class="line">Node *ahead;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, P, M = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入人数N，从几号开始P，报到哪个数M："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P &gt;&gt; M;</span><br><span class="line">Node *head = Create(N);       <span class="comment">//创建N个结点的环</span></span><br><span class="line">head = Search(head, P);       <span class="comment">//找到第P个结点</span></span><br><span class="line"><span class="keyword">while</span> (head-&gt;next != head)    <span class="comment">//不断释放第M个元素，直到只剩一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">head = Release(head, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span>            <span class="comment">//创建包含N个结点的双向循环链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">Node *node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;num = n;</span><br><span class="line">Node *head = node;        <span class="comment">//指向第一节点</span></span><br><span class="line">Node *tail = head;        <span class="comment">//指向最后一个节点</span></span><br><span class="line"><span class="keyword">while</span> (n++ &lt; N)</span><br><span class="line">&#123;</span><br><span class="line">node = <span class="keyword">new</span> Node;     <span class="comment">//创建新节点</span></span><br><span class="line">node-&gt;num = n;       <span class="comment">//赋值</span></span><br><span class="line">tail-&gt;next = node;   <span class="comment">//插入新节点</span></span><br><span class="line">node-&gt;ahead = tail;</span><br><span class="line">tail = tail-&gt;next;   <span class="comment">//尾巴后移一个</span></span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = head;</span><br><span class="line">head-&gt;ahead = tail;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span>  <span class="comment">//从head开始寻找第P个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;num != P)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span>  <span class="comment">//释放Head开始的第M个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">Node *temp = head;</span><br><span class="line"><span class="keyword">while</span> (count &lt; M)             <span class="comment">//寻找第M个节点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;ahead-&gt;next = temp-&gt;next;   <span class="comment">//移除第M个节点</span></span><br><span class="line">temp-&gt;next-&gt;ahead = temp-&gt;ahead;  <span class="comment">//移除第M个节点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;num &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">head = temp-&gt;next;                <span class="comment">//释放第M个节点所占的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203134747.png" alt="QQ图片20200203134747" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中结构体与链表的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（5）函数</title>
    <link href="http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/"/>
    <id>http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-30T11:41:22.000Z</published>
    <updated>2020-02-02T04:13:30.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义和声明"><a href="#函数的定义和声明" class="headerlink" title="函数的定义和声明"></a>函数的定义和声明</h2><p>函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）<strong>定义</strong>包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        ret* = val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型是指<strong>函数返回值的数据类型</strong>，若函数类型与return语句中表达式的值不一致，则以函数类型为准，系统自动进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y ? x : y);   <span class="comment">//返回时会转换为整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作<strong>函数原型</strong>（function prototype）。</p><p>建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p><p>需要注意的是：<strong>函数不能嵌套定义</strong>，函数间可以互相调用，但不能调用<code>main</code>函数。</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fact(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5! is"</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130201451.png" alt="QQ图片20200130201451" style="zoom: 50%;"></p><p>一个函数调用的执行过程可以分为3个阶段：</p><ol><li>首先把实参值传入被调用函数形参的对应单元中，中断主调函数当前的执行，并且保存返回地点（称为断点）。</li><li>执行被调用函数语句，直到<code>return</code>语句返回。若被调用函数中没有<code>return</code>语句，则直到其全部语句执行完毕后自动返回到位于主调函数中的断点处。</li><li>从保存的断点处，主调函数继续执行其他剩余语句。</li></ol><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“<strong>值传递</strong>”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130202050.png" alt="QQ图片20200130202050" style="zoom:50%;"></p><p>函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名，</p><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是<code>void</code>，它表示函数不返回任何值。</p><h2 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h2><p>根据变量在程序中作用范围的不同，可以将变量分为：</p><p><strong>局部变量</strong>：在函数内或块内定义，只在这个函数或块内起作用的变量；</p><p><strong>全局变量</strong>：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p><p>当全局变量与局部变量<strong>同名</strong>时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量，即在局部变量的作用范围内，全局变量不起作用。</p><p>需要注意的是，不在必要时不要使用全局变量。因为全局变量在程序的全部指向过程中都占用存储单元；过多地使用全局变量，程序的可读性变差；会增加函数之间的“关联性”，降低了函数的独立性，使函数可移植性降低。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130204440.png" alt="QQ图片20200130204440" style="zoom: 50%;"></p><h2 id="自动对象与局部静态对象"><a href="#自动对象与局部静态对象" class="headerlink" title="自动对象与局部静态对象"></a>自动对象与局部静态对象</h2><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为<strong>自动对象</strong>（automatic object）。</p><p>形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。</p><p>有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。<strong>局部静态对象</strong>（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的函数统计它自己被调用了多少次</span></span><br><span class="line"><span class="keyword">size_t</span> count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cout_calls() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>指针用做函数参数，在函数内部改变指针的值只能改变局部变量，不会影响实参原来的值；在函数内部通过解引用操作改变指针所指内容的值，即实参指针所指内容的值也发生了改变。</p><p><strong>例子</strong>：编写一个函数，使用指针形参交换两个整数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;a, *s = &amp;b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(r, s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/1.png" alt="1" style="zoom:80%;"></p><p>需要注意的是，下面的函数并不能满足要求，因为在函数内部改变指针的值（改变指针所指的地址）只能改变局部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h2><p>我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。</p><p>与值传递（实参的值被拷贝给形参，形参和实参是两个相互独立的变量）不同的是，引用形参是传引用的方式，形参是对应的实参的别名，形参绑定到初始化它的对象，如果改变了形参的值，也就是改变了对应实参的值。</p><p>用引用形参重写上面例子中的程序，引用形参绑定初始化它的对象，p绑定我们传给函数的int对象a，改变p的值也就是改变p所引对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200131142122.png" alt="QQ图片20200131142122" style="zoom:80%;"></p><h3 id="使用引用形参避免拷贝"><a href="#使用引用形参避免拷贝" class="headerlink" title="使用引用形参避免拷贝"></a>使用引用形参避免拷贝</h3><p>拷贝大类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p><p><strong>如果函数无须改变引用形参的值，最好将其声明为常量引用</strong>。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量s的内容；二是限制了该函数所能接受的实参类型，我们无法把<code>const</code>对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string 对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个string对象是否含有大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasUpper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span>  <span class="comment">//无须修改参数的内容，设为常量引用类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串的所有大写字母转成小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeToLower</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为一次返回多个结果提供了有效的途径。（对于引用的操作实际上是作用在引用所引的对象上）</p><p><strong>例子</strong>：定义一个名为find_char的函数，返回string对象中某个指定字符第一次出现的位置，同时能“返回”该字符出现的次数。</p><p>一种思路是定义一个新的数据类型，包含位置和数量两个成员，显然比较复杂；另一种更简单的方法是，给函数传入一个额外的引用实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (decltyoe(ret) i = <span class="number">0</span>; i!=s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret == s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;         <span class="comment">//记录c第一次出现的位置</span></span><br><span class="line">            ++occurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;                 <span class="comment">//出现次数通过occurs隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p>数组有两个特殊性质：不允许拷贝数组，以及使用数组时通常会将其转换成指针。所以我们不能以值传递的方式使用数组参数，当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这三个print函数是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>当编译器处理对<code>print</code>函数的调用时，只检查传入的参数是否是<code>const int*</code>类型；如果我们传给<code>print</code>函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。以数组为形参的函数也必须确保使用数组时不会越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=*p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组名做函数参数"><a href="#多维数组名做函数参数" class="headerlink" title="多维数组名做函数参数"></a>多维数组名做函数参数</h3><p>当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，而多维数组的首元素是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个print等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;   <span class="comment">//（*matrix)的括号不能少</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure><p>例子：求一个$3\times 4$的矩阵的所以元素中的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxvalue</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = p[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(p[i][j] &gt; <span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span> = p[i][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Max value is"</span> &lt;&lt; maxvalue(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参也可以是数组的引用，此时引用形参绑定到对应的实参上，也就是绑定到数组上。但此时函数只能作用于固定大小的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span>    <span class="comment">//只能将函数作用于大小为10的数组，(&amp;arr)的括号不能少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>我们已经知道：函数不能嵌套定义，函数可以嵌套调用。那么一个函数能调用“自己”嘛？答案是可以的</p><p>例子：已知 n，求n的阶乘$n!$</p><script type="math/tex; mode=display">\begin{align*}n!&=(n-1)!*n \\ (n-1)!&=(n-2)!*(n-1) \\ &\dots \\ 2!&=1!*2 \\ 1!&=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);     <span class="comment">//每次调用，数据规模缩小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fact(<span class="number">4</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深入理解递归的过程"><a href="#深入理解递归的过程" class="headerlink" title="深入理解递归的过程"></a>深入理解递归的过程</h2><p>递归调用与普通调用在实质上是一样的。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100341.png" alt="QQ图片20200201100341" style="zoom:50%;"></p><p>通过下面的两个例子来理解递归的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100347.png" alt="QQ图片20200201100347" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100351.png" alt="QQ图片20200201100351" style="zoom:50%;"></p><h2 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h2><h3 id="用递归来完成递推"><a href="#用递归来完成递推" class="headerlink" title="用递归来完成递推"></a>用递归来完成递推</h3><p>递归的关注点放在求解目标上，重在表现第i次与第i+1次的关系，让程序变得简明。必须要确定第1次的返回结果。</p><p><strong>例子</strong>：斐波那契数列</p><script type="math/tex; mode=display">\begin{align*}fab(n)&=fab(n-1)+fab(n-2) \\ fab(1)&=1,\, fab(2)=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>(f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟连续发生的动作"><a href="#模拟连续发生的动作" class="headerlink" title="模拟连续发生的动作"></a>模拟连续发生的动作</h3><p>主要是搞清楚连续发生的动作是什么；搞清楚不同动作之间的关系；搞清楚边界条件是什么。</p><p><strong>例子1</strong>：将一个十进制整数转换成二进制数</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201110807.png" alt="QQ图片20200201110807" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x / <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">convert(x / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">convert(x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong>：汉诺塔问题</p><p>相传在古代印度有位僧人整天把三根柱子上的金盘倒来倒去，他想把64个一个比一个小的金盘从一根柱子上移到另一个柱子上去。移动过程中恪守下述规则：每次只允许移动一只盘，且大盘不得落在小盘上面。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112556.png" alt="QQ图片20200201112556" style="zoom:50%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112717.png" alt="QQ图片20200201112717" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span> <span class="comment">//表示将m个盘子从A经过B移动到C</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//直接可解结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//如果m不为1，则要调用move(m-1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, A, C, B);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, B, A, C);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入盘数n="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"在3根柱子上移"</span> &lt;&lt; n &lt;&lt; <span class="string">"个盘子的步骤为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112602.png" alt="QQ图片20200201112602" style="zoom: 80%;"></p><h3 id="进行“自动的分析”"><a href="#进行“自动的分析”" class="headerlink" title="进行“自动的分析”"></a>进行“自动的分析”</h3><p>先假设有一个函数能给出答案，再利用这个函数分析如何解决问题；搞清楚最简单的情况下答案是什么。</p><p><strong>例子</strong>：放苹果</p><p>把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？注意：5,1,1和1,5,1是同一种分法。</p><p>思路：</p><ol><li><p>假设有一个函数f(m,n)能解决这个问题，那么最简单的情况是<code>m&lt;=1||n&lt;=1</code>，此时只有1种分法。</p></li><li><p>当<code>n&gt;m</code>时，必有盘子会空着，空着的盘子不影响结果，那么有<code>f(m,n)=f(m,m)</code>。</p></li><li><p>当<code>n&lt;=m</code>时，分两种情况：</p><p>(1)如果有盘子空着，那么减少一个盘子也不会影响结果，有<code>f(m,n)=f(m,n-1)</code>。</p><p>(2)如果盘子全满，那么每个盘子至少有1个苹果，那么只需考虑剩下m-n个苹果在n个盘子中的分法，则有</p><p><code>f(m,n)=f(m-n,n)</code>。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">1</span> || n &lt;= <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line"><span class="keyword">return</span> count(m, m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> count(m, n - <span class="number">1</span>) + count(m - n, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count(m, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201114810.png" alt="QQ图片20200201114810" style="zoom:80%;"></p><h3 id="递归问题解法小结"><a href="#递归问题解法小结" class="headerlink" title="递归问题解法小结"></a>递归问题解法小结</h3><p>面对一个问题时：</p><ol><li>假设有一个函数f()可以解决问题；接下来考虑这个函数是什么样的？</li><li>找到f^n()与f^n-1()之间的关系；</li><li>确定f()的参数；</li><li>分析并写出边界条件。</li></ol><p><strong>例子1</strong>：组合问题</p><p>用递归法计算从n个人中选择k个人组成一个委员会，求不同的组合的个数一共是多少？</p><p><strong>思路</strong>：</p><ul><li>由n个人里选k个人的组合数=由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数；</li><li>当n = k或k = 0时，组合数为1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comm</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> comm(n - <span class="number">1</span>, k) + comm(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two integers n and k: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C(n,k) = "</span> &lt;&lt; comm(n, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202104441.png" alt="QQ图片20200202104441" style="zoom:80%;"></p><h2 id="探索式递归"><a href="#探索式递归" class="headerlink" title="探索式递归"></a>探索式递归</h2><p><strong>例子1</strong>：下楼问题</p><p>从楼上走到楼下共有h个台阶，每一步有3种走法：走1个台阶；走2个台阶；走3个台阶。问可以走出多少种方案？将所有的方案输出。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201183838.png" alt="QQ图片20200201183838" style="zoom: 33%;"></p><p><strong>思路</strong>：</p><ol><li><p>既然要列出所有方案，所以需要用一个数组存放每步走的步数，可设为<code>take[99]</code>，步数存放在<code>take[ ]</code>中，满足条件就打印出来；</p></li><li><p>假设有一个函数<code>Try( )</code>能解决问题，接着寻找Try^n^( )与Try^n+1^( )的关系；</p></li><li><p>Try^n^( )代表走完第n步的状态，即已经填完第n个<code>take[ ]</code>；</p></li><li><p>Try^n( )与Try^n+1( )的关系：在走完第n步后，再走第n+1步时，有三种选择（走1、2、3步），每个选择下有三种可能性：</p><ul><li>如果剩下的台阶数小于想要走的步数：返回</li><li>如果剩下的台阶数恰好等于要走的步数：打印输出</li><li>如果剩下的台阶数大于想要走的步数：走下去</li></ul></li><li>Try( )的参数如何确定：Try^n^( )与Try^n+1^( )之间哪些数据是不一样的？而且是需要由Try^n( )传递给Try^n+1^( )的？</li></ol><p>​       Try^n^( )代表走完第n步的情况，Try^n+1^( )代表走完第n+1步的情况；</p><p>​       Try^n^( )需要将走完第 n步后剩余的台阶数传递  给Try^n+1^( )。</p><p>​       因此可以将Try^n^( )定义为：<code>Try(i, s)</code>，<code>i</code>表示剩余的台阶数，<code>s</code>表示步数。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201185823.png" alt="QQ图片20200201185823" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> take[<span class="number">99</span>];    <span class="comment">//记录每一个走的台阶数</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;     <span class="comment">//num记录解决方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Try</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">take[s] = j;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"solution"</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Try(i - j, s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//take[s]=0;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"how many stairs:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">Try(h, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; num &lt;&lt; <span class="string">" solutions."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201191406.png" alt="QQ图片20200201191406" style="zoom:80%;"></p><p><strong>例子2</strong>：字母全排列</p><p>从键盘读入一个英文单词（全部字母小写，且该单词中各个字母均不相同），输出该单词英文字母的所有全排列。</p><p>如输入<code>abc</code>，则打印出<code>abc</code>, <code>acb,</code> <code>bac</code>, <code>bca</code>, <code>cab</code>, <code>cba</code>。</p><p><strong>思路</strong>：</p><p>需要反复做的事情是：选择第n个位置的字母，依次检查每个字母，如果某个字母没被选择过，则进行：</p><ol><li>将该字母放第n个位置；</li><li>标记该字母已经被选择；</li><li>如果全部位置都已选完，打印输出；否则，为下一个位置选择字母；</li><li>把刚刚标记过的字母重新标记为“未选择”；</li></ol><p>假设一个函数<code>ranker( )</code>能够完成上述事情，每次调用之间的区别在于位置n，<code>ranker(1)</code>—&gt;<code>ranker(2)</code>—&gt;<code>ranker(3)</code>……—&gt;<code>ranker(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> in[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">//存放输入的单词</span></span><br><span class="line"><span class="keyword">char</span> out[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//存放准备输出的字符串</span></span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//记录第i个字母是否已经使用过</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;         <span class="comment">//记录输入的单词的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ranker</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==length)       <span class="comment">//如果全部字母已经被选择完，则打印输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)  <span class="comment">//依次查看每个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!used[i])          <span class="comment">//如果某个字母没有被选用</span></span><br><span class="line">&#123;</span><br><span class="line">out[n] = in[i];    <span class="comment">//选入该字母</span></span><br><span class="line">used[i] = <span class="number">1</span>;       <span class="comment">//标记该字母已经被选择</span></span><br><span class="line">ranker(n + <span class="number">1</span>);     <span class="comment">//为下一个位置寻找字母</span></span><br><span class="line">used[i] = <span class="number">0</span>;   <span class="comment">//回溯，标记字母未被使用，让其可重新被选择</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the word: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">length = <span class="built_in">strlen</span>(in);</span><br><span class="line">ranker(<span class="number">0</span>);   <span class="comment">//从第一个字母开始</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201195215.png" alt="QQ图片20200201195215" style="zoom:80%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201201948.png" alt="QQ图片20200201201948" style="zoom: 50%;"></p><p><strong>例子3</strong>：分书问题</p><p>有编号分别为1, 2, 3, 4, 5的五本书，准备分给A，B，C，D，E五个人，每个人阅读兴趣用一个二维数组加以描述。请写一个程序，输出所有分书方案，让人人都能拿到喜欢的书。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201202457.png" alt="QQ图片20200201202457" style="zoom: 50%;"></p><p><strong>思路</strong>：</p><ol><li>假设函数<code>trybook( )</code>可以解决问题，从第0个人开始分书，函数<code>trybook(i)</code>应该要完成：</li><li>试着给第<code>i</code>个人分书，从0号书开始试，当第<code>i</code>个人喜欢第<code>j</code>个书，且<code>j</code>书还没被选走时（因此要建一个数组记录书被选走的状态），那么第<code>i</code>个人就得到第<code>j</code>本书；</li><li>如果不满足上述条件，则什么也不做，返回循环条件；</li><li>若满足条件，则做三件事情：<ul><li>做事：将第<code>j</code>个书分给第<code>i</code>个人，同时记录<code>j</code>书已被选用；</li><li>判断：查看是否将所有5个人所要的书分完，若分完，则输出每个人所得之书；若未分完，去寻找其他解决方案；</li><li>回溯：让第<code>i</code>个人退回<code>j</code>书，恢复<code>j</code>书尚未被选用的状态。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//book[5]记录书是否被选用，选用记为1</span></span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//take[5]记录第i个人领到那本书</span></span><br><span class="line"><span class="keyword">int</span> num;             <span class="comment">//num记录分书方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trybook</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="comment">//第i个人</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">4</span>; j++)  <span class="comment">//第j本书</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((like[i][j] &gt; <span class="number">0</span>) &amp;&amp; (book[j] == <span class="number">0</span>)) <span class="comment">//若第i个人喜欢第j本书，且第j本书还没被选用</span></span><br><span class="line">&#123;</span><br><span class="line">take[i] = j;  <span class="comment">//把第j本书分给第i个人</span></span><br><span class="line">book[j] = <span class="number">1</span>;  <span class="comment">//记录第j本书已经被选用</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">4</span>)   <span class="comment">//如果第5个人已经拿到书，即书已分完，则输出方案</span></span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; num &lt;&lt; <span class="string">"个方案"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k] &lt;&lt; <span class="string">"号书给"</span> &lt;&lt; <span class="keyword">char</span>(k + <span class="number">65</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>       <span class="comment">//如果书没分完，则继续给下一个人分书</span></span><br><span class="line">trybook(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//take[i] = -1;  把第i个人的书退回，实际上可以不加这一条</span></span><br><span class="line">book[j] = <span class="number">0</span>;   <span class="comment">//回溯，把第j本书标记为未选用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">trybook(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202101401.png" alt="QQ图片20200202101401" style="zoom:80%;"></p><h3 id="探索式递归问题的解法"><a href="#探索式递归问题的解法" class="headerlink" title="探索式递归问题的解法"></a>探索式递归问题的解法</h3><p>第n步需要做什么？对于面前的每种选择：</p><ol><li>把该做的事情做了；</li><li>判定是否得到解；</li><li>递归（调用第n+1步）；</li><li>看是否需要回溯。</li></ol>]]></content>
    
    <summary type="html">
    
      复习了C++中函数的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（4）字符数组与字符串</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-01-27T03:08:57.000Z</published>
    <updated>2020-01-27T14:29:00.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127110928.png" alt="QQ图片20200127110928" style="zoom:67%;"></p><h2 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h2><p>只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符-字符数组-字符串的输入与输出"><a href="#字符-字符数组-字符串的输入与输出" class="headerlink" title="字符/字符数组/字符串的输入与输出"></a>字符/字符数组/字符串的输入与输出</h2><h3 id="一个字符的输入"><a href="#一个字符的输入" class="headerlink" title="一个字符的输入"></a>一个字符的输入</h3><h4 id="直接用cin输入字符。"><a href="#直接用cin输入字符。" class="headerlink" title="直接用cin输入字符。"></a>直接用<code>cin</code>输入字符。</h4><p><code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;c)     <span class="comment">//abc def g</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;      <span class="comment">//abcdefg</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用cin-get-函数输入"><a href="#用cin-get-函数输入" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>可以用于读入<strong>一个字符</strong>；有2中形式：</p><p>无参数<code>cin.get()</code>，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( (c=<span class="built_in">cin</span>.<span class="built_in">get</span>())!= EOF )  <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;                    <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>一个参数<code>cin.get(char)</code>     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="comment">//读取一个字符赋给字符变量c</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">cin</span>.<span class="built_in">get</span>(c) )     <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>要注意的是，<code>cin.get()</code>遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1,ch2;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入两个字符："</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();  </span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch2);  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;(<span class="keyword">int</span>)ch2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输入a[Enter]，读取到结束符<code>&#39;/n&#39;</code>，其仍在缓冲区中被存入<code>ch2</code>，在输出a之后，第二次输出<code>&#39;/n&#39;</code>即换行，而输出的第二个ASCII码值为10，即<code>&#39;/n&#39;</code>的ASCII值，说明<code>cin.get()</code>遇到结束符并不会将之删除。</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127172134.png" alt="QQ图片20200127172134" style="zoom: 80%;"></p><h4 id="用getchar-输入字符"><a href="#用getchar-输入字符" class="headerlink" title="用getchar()输入字符"></a>用<code>getchar()</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( c = getchar() )  <span class="comment">//abc def g   不跳过任何字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><h3 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h3><h4 id="直接用cin输入字符"><a href="#直接用cin输入字符" class="headerlink" title="直接用cin输入字符"></a>直接用<code>cin</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127120550.png" alt="QQ图片20200127120550" style="zoom:80%;"></p><h4 id="用cin-get-函数输入-1"><a href="#用cin-get-函数输入-1" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>有三个参数的<code>cin.get()</code>函数：<code>cin.get(ch, 10, &#39;/n&#39;)</code></p><p>读取10-1（10减1=9，最后一个为<code>&#39;/0&#39;</code>）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符<code>&#39;/n&#39;</code>，则提前结束读取（如果第3个参数没有指定，则默认为<code>&#39;/n&#39;</code>），而<strong>结束符仍在缓冲区中</strong>；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。</p><p>还要一点要注意，<code>cin.get(ch, 10, &#39;/n&#39;)</code>，当第一个输入字符为结束符时，缓冲区将无该结束符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1,<span class="number">10</span>,<span class="string">'o'</span>);  <span class="comment">//指定终止符为'o'</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ch2,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127173835.png" alt="QQ图片20200127173835" style="zoom:80%;"></p><p>输入：we are good friends[Enter]，由于遇到结束符 <code>&#39;o&#39;</code> ，首先读入we are g到<code>ch1</code>，此时ood friends仍在缓冲区，当执行<code>cin.get(ch2,10)</code>会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。</p><h4 id="用cin-getline-函数输入"><a href="#用cin-getline-函数输入" class="headerlink" title="用cin.getline()函数输入"></a>用<code>cin.getline()</code>函数输入</h4><p>用法与上面的<code>cin.get()</code>类似，但也有区别：</p><p><code>cin.get()</code>当输入的字符串在结束符之前的长度超过接收长度时，不会引起<code>cin</code>函数的错误，剩余的字符会留在缓冲区，后面若有<code>cin</code>操作，会继续从缓冲区读取；当<code>cin.getline()</code>输入超长时，会引起<code>cin</code>函数的错误，后面的<code>cin</code>操作将不再执行。</p><p><code>cin.get()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符<code>&#39;/n&#39;</code>留在输入队列中，然而<code>cin.getline()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符抛弃。</p><p><code>cin.get()</code>遇到结束符是停止读取，缓冲区指针不移动；<code>cin.getline()</code>遇到结束符时，缓冲区指针移到终止标志字符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(ch1,<span class="number">10</span>,<span class="string">'o'</span>);      <span class="comment">//指定终止符为'o'</span></span><br><span class="line">   <span class="built_in">cin</span>.getline(ch2,<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//注意与上节的区别</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127191238.png" alt="QQ图片20200127191238" style="zoom:80%;"></p><p>一个<strong>需要注意</strong>的地方：<code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但<strong>最后一个Enter会在缓冲区</strong>。而无参数<code>cin.get()</code>，可用于<strong>舍弃输入流中的不需要的字符</strong>，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   <span class="comment">//当执行cin.getline(a[1],10)时，[Enter]被读取到a[1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127192425.png" alt="QQ图片20200127192425" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();     <span class="comment">//用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127193235.png" alt="QQ图片20200127193235" style="zoom:80%;"></p><h3 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h3><h4 id="用cout输出字符数组"><a href="#用cout输出字符数组" class="headerlink" title="用cout输出字符数组"></a>用<code>cout</code>输出字符数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Computer"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220421.png" alt="QQ图片20200127220421" style="zoom:80%;"></p><p>需要注意的是，<code>cout</code>输出有终止条件（一般是碰到<code>&#39;\0&#39;</code>），当用字面值初始化字符数组时，会自动在串尾加上<code>&#39;\0&#39;</code>；当用列表初始化字符数组时，若不在串尾加上’\0’，用<code>cout</code>输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>] = &#123; <span class="string">'C'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>,<span class="string">'p'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220426.png" alt="QQ图片20200127220426" style="zoom:80%;"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.getline(str, <span class="number">200</span>)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'Z'</span>)&#123;</span><br><span class="line">str[i] = <span class="string">'A'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'z'</span>)&#123;</span><br><span class="line">str[i] == <span class="string">'a'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">str[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127203829.png" alt="QQ图片20200127203829" style="zoom:80%;"></p><p>2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数<code>strcat</code>，每个输入的串的长度不超过20。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">40</span>], str2[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str1,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cin</span>.getline(str2, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++);</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++);</span><br><span class="line"><span class="keyword">if</span> (len1 &gt;= len2) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++)</span><br><span class="line">str1[len1++] = str2[len2];   <span class="comment">//后置++，先执行表达式，再len+1</span></span><br><span class="line">str1[len1] = <span class="string">'\0'</span>;   <span class="comment">//必须要加，要不然cout&lt;&lt;str1会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++)</span><br><span class="line">str2[len2++] = str1[len1];</span><br><span class="line">str2[len2] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127213528.png" alt="QQ图片20200127213528" style="zoom:80%;"></p><p>3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127214732.png" alt="QQ图片20200127214732" style="zoom:80%;"></p><p>当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((str[i] &gt;= <span class="string">'A'</span>&amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) || (str[i] &gt;= <span class="string">'a'</span>&amp;&amp;str[i] &lt;= <span class="string">'z'</span>))</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127215300.png" alt="QQ图片20200127215300" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中字符数组与字符串的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（3）数组</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-01-27T03:06:06.000Z</published>
    <updated>2020-01-27T14:32:08.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。</p><h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><p>数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个<strong>常量表达式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;   <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;     <span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];       <span class="comment">// 错误：cnt不是常量表达式</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。</p><h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;             <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><p>当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p>数组能存放大多数类型的对象，可以定义一个<strong>存放指针的数组</strong>；又因为数组本身是对象，所以允许定义<strong>数组的指针及数组的引用</strong>。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];                <span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ？ */</span>      <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;    <span class="comment">//Parray是一个指针，指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;     <span class="comment">//arrRef是一个引用，引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;     <span class="comment">//arry是一个引用，引用一个含有10个指针的数组</span></span><br></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>3.27</strong> 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> ia[buf_size];                <span class="comment">//非法的，因为buf_size不是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">4</span>*<span class="number">7</span><span class="number">-14</span>];                  <span class="comment">//正确，因为4*7-14是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[txt_size()];              <span class="comment">//非法的，因为txt_size没有被定义为常量表达式 constexpr</span></span><br><span class="line"><span class="keyword">char</span> st[<span class="number">11</span>] = <span class="string">"fundamental"</span>      <span class="comment">//非法的，因为用字符串字面值初始化，没有空间存放空字符</span></span><br></pre></td></tr></table></figure><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>与标准库类型<code>vector</code> 和<code>string</code> 一样，数组的元素也能使用范围<code>for</code> 语句或下标运算符来访问。数组的索引从0开始。</p><p>数组下标通常定义为<code>size_t</code>类型，<code>size_t</code>是一种机器相关的无符号类型，在<code>cstddef</code>头文件中定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100</span></span><br><span class="line"><span class="keyword">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;        <span class="comment">//列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>vector</code> 和<code>string</code> 一样，当需要遍历数组的所有元素时，最好的办法是使用范围<code>for</code>语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于scores中的每个计数值输出当前的计数值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>必须要<strong>检查数组下标的值</strong>在合理范围内，下标越界会产生缓冲区溢出。</p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p>3.31编写一段程序，定义一个含有10个<code>int</code>的数组，令每个元素的值就是其下标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> val: a)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.32 将上一题创建的数组拷贝给另外一个数组，利用<code>vector</code>重写程序，实现类似的功能。</p><p>//如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz], b[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz: j++)</span><br><span class="line">        b[j] = a[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//用<code>vector</code>重写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vInt, vInt2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        vInt.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++)</span><br><span class="line">        vInt2.push_back(vInt[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val: vInt2)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>输出100以内的所有素数。</p><p>一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足：</p><script type="math/tex; mode=display">1<c\le \sqrt{n}</script><p>循环结构的N-S图：</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/QQ图片20200126204152.png" alt="QQ图片20200126204152" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="built_in">sqrt</span>(<span class="number">100.0</span>); i++)&#123;</span><br><span class="line">        sum = i;</span><br><span class="line">        <span class="keyword">if</span>(a[sum]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(sum&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                sum = sum + i;</span><br><span class="line">                a[sum] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++中并没有多维数组，通常所说的多维数组其实是数组的数组。按照由内而外的顺序阅读。</p><p>多维数组<strong>初始化</strong>的几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; &#125;;  <span class="comment">//每一行分别用花括号括起来</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">//不标识每行的花括号</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125; &#125;;  <span class="comment">//显示地初始每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;                <span class="comment">//只显示地初始化第1行</span></span><br></pre></td></tr></table></figure><p>多维数组的<strong>下标引用</strong>：如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果是给定类型的元素；如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。</p><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p>某学校有1000位老师，分布在20个不同的学院中，每个学院最多有12个系，请你编写一个程序，输入每位老师的所在院、系的编号（院编号1-20，系编号1-12），打印出各个系老师的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomainp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> teacher[<span class="number">21</span>][<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">int</span> school,department, i, j;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name&gt;&gt;school&gt;&gt;department;</span><br><span class="line">        teacher[school][department]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">21</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;<span class="number">13</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;teacher[i][j];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a><strong>数组的地址</strong></h3><p>在C++语言中，指针和数组有非常紧密的联系。数组名代表数组首元素的地址：数组名是指向数组第一个元素的指针。对于数组a[10]，数组名a代表数组a[10]中第一个元素a[0]的地址，即a与&amp;a[0]等价。需要注意的是，a是地址常量，不是变量，不能给a赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//输出a[0]的地址 0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//输出a[0]的值  10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>若a是指向数组第一个元素的指针，即a相当于<code>&amp;a[0]</code>。</p><ul><li><p>&amp;a是”指向数组“的指针，&amp;a+1将跨越16个字节，&amp;a相当于管辖范围”上升“了一级；</p></li><li><p><em>a是数组的第一个元素a[0]，即 </em>a等价于a[0]， *a相当于管辖范围“下降”了一级。</p></li></ul><p>在一些情况下数组的操作实际上是指针的操作。当使用数组作为一个<code>auto</code>变量的初始值时，得到的类型是指针而非数组。当使用<code>decltype</code>关键字时上述转换不会发生，<code>decltyoe(ia)</code>返回的类型是由整数构成的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;              <span class="comment">//相当于 auto ia2(&amp;ia[0]); ia2是一个整型指针</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//ia是含有整数的数组</span></span><br></pre></td></tr></table></figure><p>C++11新标准引入了<code>begin</code>和<code>end</code>函数，定义在<code>iterator</code>头文件中，这两个函数与容器中的两个同名成员功能类似，但由于数组不是类类型，因此这两个函数不是成员函数，使用时需要将数组作为它们的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure><h3 id="利用指针变量引用数组元素"><a href="#利用指针变量引用数组元素" class="headerlink" title="利用指针变量引用数组元素"></a>利用指针变量引用数组元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *pointer;</span><br><span class="line">pointer = a;         <span class="comment">//等价于 pointer = &amp;a[0];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer+i;   <span class="comment">//等价于a+i；等价于&amp;a[i]；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(pointer+i);<span class="comment">//等价于*(a+i)；等价于a[i];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer[i];  <span class="comment">//等价于*(pointer+i);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>需要注意的是：a++是没有意义的，但p++会引起p的变化。p可以指向数组最后一个元素以后的元素，称为尾后指针，就像尾后迭代器，尾后指针不能执行解引用和递增操作。<strong>指针做加减运算时一定要注意有效的范围</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;   <span class="comment">//a[0]=3</span></span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[-1].dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;   <span class="comment">//damage</span></span><br></pre></td></tr></table></figure><p>根据运算符的优先级有：</p><ul><li><p><code>*++p</code>相当于<code>a[++i]</code>，先将p自加，再做<code>*</code>运算。</p></li><li><p><code>*--p</code>相当于<code>a[--i]</code>，先将p自减，再做<code>*</code>运算。</p></li><li><code>*p++</code>相当于<code>a[i++]</code>，先做<code>*</code>运算，再将p自加。</li><li><code>*p--</code>相当于<code>a[i--]</code>，先做<code>*</code>运算，再将p自减。</li></ul><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针代替数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], i, *p = a;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p++;</span><br><span class="line">    <span class="keyword">for</span>(p--; p&gt;=a; )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; *p--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒置数组元素</span></span><br><span class="line"><span class="comment">//输入：1 2 3 4 5 6 7 8 9 0</span></span><br><span class="line"><span class="comment">//输出：0 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p;</span><br><span class="line">    <span class="keyword">for</span>(p = a, q = a+<span class="number">9</span>; p&lt;q; p++, q--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=*p; *p=*q; *q=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt;*p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的地址"><a href="#二维数组的地址" class="headerlink" title="二维数组的地址"></a>二维数组的地址</h3><p>数组名相当于指向数组第一个元素的指针。</p><ul><li><p>*a等价于a[0]，相当于a下降了一级；</p></li><li><p>&amp;a表示“指向二维数组”的指针，相当于上升了一级。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125; &#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//a是指向数组第一个元素的指针，而数组的第一个元素是一个含有4元素的数组，即a是指向一维数组的指针，     //a相当于一个“包含4个int型元素的一维数组”的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//0x0013FF60  a+1将跨越16个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//0x0013FF60</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//*a是数组的第一个元素，而数组的第一个元素是一个数组，即*a是一个指向整数的指针，</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//0x0013FF50 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF54  *a+1将跨越4个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子1：遍历数组元素"><a href="#例子1：遍历数组元素" class="headerlink" title="例子1：遍历数组元素"></a><strong>例子1：遍历数组元素</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//for (p=&amp;a[0][0]; p&lt;&amp;a[0][0]+12; p++)</span></span><br><span class="line">  <span class="comment">//for (p=a[0]; p&lt;a[0]+12; p++)</span></span><br><span class="line">    <span class="keyword">for</span> (p=*a; p&lt;*a+<span class="number">12</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子2：输入i，j；输出a-i-j"><a href="#例子2：输入i，j；输出a-i-j" class="headerlink" title="例子2：输入i，j；输出a[i] [j]"></a>例子2：输入i，j；输出a[i] [j]</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>], i, j;</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//cout &lt;&lt; setw(4) &lt;&lt; p[i][j];    </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;*(*(p+i)+j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ol><li><p>从<code>p=a</code>开始，a相当于指向<code>a[3][4]</code>的“第一个元素”的指针；所谓“第一个元素”是指一个 “包含4个int型元素的一维数组”；所以，a相当于一个 “包含4个int型元素的一维数组”的地址；因此<strong>p的基类型</strong>应该是 “包含4个int型元素的一维数组”。</p></li><li><p>如何定义一个指向 “包含4个int型元素的一维数组” 的指针变量？ ———- <code>int (*p)[4]</code></p></li><li><p><code>*(*(p+i)+j)</code>是什么？</p><p><code>p</code>指向一个“包含4个int型元素的一维数组”；</p><p><code>p+i</code>  是第<code>i+1</code>个“包含4个Int 型元素的一维数组”的地址；<code>p+i</code>等价于<code>&amp;a[i]</code>；</p></li></ol><p>​       <code>*(p+i)</code>等价于<code>a[i]</code>；<code>*(p+i)+j</code>等价于<code>a[i]+j</code>；</p><p>​       因为：<code>a[i]+j</code>等价于<code>&amp;a[i][j]</code>，所以：<code>*(*(p+i)+j)</code>等价于<code>a[i][j]</code>。</p><ol><li><p><code>p[i][j]</code>是什么？</p><p>p[i]等价于 <code>*(p+i)</code>； <code>p[i][j]</code> 等价于 <code>*(*(p+i)+j)</code>，等价于<code>a[i][j]</code>。</p></li></ol><h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><p>C++11新标准中新增了范围<code>for</code>语句，可以使用范围<code>for</code>语句处理多维数组，为了避免数组被自动转成指针，处理最内层的循环外，其他所有循环的控制变量应该都是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt=<span class="number">3.</span> colCnt=<span class="number">4</span>, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">       col = cnt;</span><br><span class="line">       ++cnt;  </span><br><span class="line">&#125;   <span class="comment">//ia=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;</span></span><br></pre></td></tr></table></figure><p>也可以使用标准库函数<code>begin</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p=<span class="built_in">begin</span>(ia); p!=<span class="built_in">end</span>(ia); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q=<span class="built_in">begin</span>(*p); q!=<span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="string">' '</span>；    <span class="comment">//依次输出ia的元素的值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pc;</span><br><span class="line">    pc = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出hello</span></span><br><span class="line">    pc++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">    pc = <span class="built_in">buffer</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//ABC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中数组的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（2）引用与指针</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/</id>
    <published>2020-01-27T03:02:17.000Z</published>
    <updated>2020-01-27T14:31:11.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><p>复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。</p><p>一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。</p><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成<code>$d</code>的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。</p><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。</p><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号<code>&amp;</code>开头。</p><p>引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;      <span class="comment">//refVal指向ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;            <span class="comment">//错误。引用必须被初始化</span></span><br><span class="line"></span><br><span class="line">refVal = <span class="number">2</span>;              <span class="comment">//把值赋给了ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;   <span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，即ival</span></span><br><span class="line"><span class="keyword">int</span> i = refVal;          <span class="comment">//相当于i = ival</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i, &amp;r2 = i2;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同：</p><p>（1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。</p><p>（2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。</p><p><strong>指针运算符</strong><code>*</code>，<strong>取地址符</strong><code>&amp;</code></p><p>指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p><strong>指针变量</strong>：专门用于存放指针（某个变量的地址）的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer;       <span class="comment">//定义名字为pointer的指针变量</span></span><br><span class="line">pointer = &amp;c;       <span class="comment">//将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c</span></span><br><span class="line"><span class="comment">//pointer = c;      //错误：因为pointer是存放地址的变量，所以只能存放地址</span></span><br></pre></td></tr></table></figure><p>通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer = &amp;c;  <span class="comment">//*pointer为“pointer所指向的存储单元的内容"，即是变量c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;c &lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//取变量c的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;pointer &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//取指针变量c的地址</span></span><br></pre></td></tr></table></figure><p><strong>赋值和指针</strong>：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;         <span class="comment">//pi被初始化</span></span><br><span class="line">pi = &amp;ival;          <span class="comment">//pi所存的地址改变，指向ival</span></span><br><span class="line">*pi = <span class="number">0</span>;             <span class="comment">//ival的值被改变，指针pi所存的地址没有改变</span></span><br></pre></td></tr></table></figure><p><strong>&amp;<code>与</code>*`的运算优先级</strong>：同级</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/QQ图片20200125205145.png" alt="QQ图片20200125205145" style="zoom:50%;"></p><p><strong>空指针</strong>（null pointer）不指向任何对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>     <span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;          <span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;       <span class="comment">//需要首先#include&lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure><p>使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。</p><p><code>void*</code>指针：可用于存放任意对象的地址。利用<code>void*</code>指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个<code>void*</code>指针。不能访问其内存空间中所存的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中引用与指针的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（1）基础语法</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-01-27T02:59:54.000Z</published>
    <updated>2020-01-27T14:11:39.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//变量创建的语法： 数据类型 变量名 = 变量初始值</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量</strong>创建的语法： 数据类型 变量名 = 变量初始值</p><p>定义<strong>常量</strong>的两种方法：</p><ol><li><code>#define</code> 宏常量名 常量值 </li><li><code>const</code> 修饰的变量  <code>const</code> 数据类型 常量名 = 常量值</li></ol><p>定义变量或常量时不要用C++中已经使用的关键字</p><p>C++中给标识符（变量，常量）命名时，要注意：<br>1.标识符不可以是关键字<br>2.标识符只能由字母，数字，下划线组成<br>3.标识符的第一个字母只能是字母或者下划线<br>4.标识符中区分大小写<br>5.给变量命名时最好能做到见名知意，方便阅读</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型存在的意义：给不同类型的变量分配合适的内存空间</p><p><strong>整型</strong>的几种类型：<br>1.短整型    short      2字节   -2^15 - 2^15-1<br>2.整型      int        4字节   -2^31 - 2^31-1   //int最常用<br>3.长整型    long       4字节   -2^31 - 2^31-1<br>4.长长整型  long long  8字节   -2^63 - 2^63-1</p><p><strong><code>sizeof</code></strong> 关键字可以得到数据类型所占的内存的大小<br>语法： <code>sizeof</code>（数据类型/变量名）</p><p><strong>实型/浮点型</strong>：用于表示小数<br>1.单精度 float   4字节  7位有效数字<br>2.双精度 double  8字节  15-16位有效数字</p><p><strong>字符型</strong>：用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><p><strong>字符串型</strong>：用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><p><strong>转义字符</strong>： 用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><strong>布尔类型</strong><code>bool</code>：代表真或假的值   占用1个字节<br><code>bool</code>类型只有两个值：<code>true</code>（本质是1）  <code>false</code>（本质是0）</p><p><strong>数据的输入</strong>：用于从键盘获取数据<br>语法：<code>cin &gt;&gt;</code> 变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">short num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"short所占的内存空间为"</span> &lt;&lt; <span class="keyword">sizeof</span>(num1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;   <span class="comment">//编译器会把小数默认为双精度数，所以要在3.14后加上f                   </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f1="</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d1="</span> &lt;&lt; d1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的  setprecision( ) </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">12.3456789</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 默认以6精度，所以输出为 12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成4精度，所以输出为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">8</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成8精度，所以输出为12.345679</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// fixed和setprecision的作用还在，依然显示12.3457</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::fixed); <span class="comment">// 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">6</span>); <span class="comment">// 恢复成原来的样子，输出为12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">3e2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f2="</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看字符型变量对应的ASCII码 a-97  A-65</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ch = <span class="number">97</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据的输入</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入字符串变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算术运算符</strong>：加+  减-  乘*  除/<br>            取模（取余）%  只有整型变量可以进行取模运算<br>需要注意：<br>1.进行运算的变量类型，如两个整型相除结果仍是整数<br>2.除数不能为0，取模运算除数也不能为0<br>3.只有整型变量可以进行取模运算，小数不可以</p><p><strong>赋值运算符</strong>：用于将表达式的值赋给变量<br>赋值=   加等于+=    减等于-=    乘等于*=    除等于/=     模等于%=</p><p><strong>比较运算符</strong>：用于表达式的比较，并返回一个真值或假值<br>相等于==    不等于!=    小于&lt;     大于&gt;     小于等于&lt;=    大于等于&gt;=</p><p><strong>逻辑运算符</strong>：用于根据表达式的值返回真值或假值<br>非!     与&amp;&amp;     或||</p><p>要注意<strong>运算符</strong>的优先级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a2=11, b2=110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// a3=11, b3=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较运算符</span></span><br><span class="line"> a = <span class="number">10</span>;</span><br><span class="line"> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a != b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构<br>1.顺序结构：程序按顺序执行，不发生跳转<br>2.选择结构：依据条件是否满足，有选择的执行相应功能<br>3.循环结构：依据条件是否满足，循环多次执行某段代码</p><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a><strong>选择结构</strong></h4><p><strong>if语句：</strong><br>1.单行格式if语句：if (条件) { 条件满足执行的语句}<br>2.多行格式if语句：if (条件) { 条件满足执行的语句}  else{条件不满足执行的语句}<br>3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}<br>4.嵌套if语句<br>注意：if条件后面不要加分号</p><p><strong>三目运算符</strong>：实现简单的判断<br>语法：表达式1 ? 表达式2 : 表达式3<br>解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果<br>      如果表达式1的值为假，执行表达式3，并返回表达式3的结果<br>注意：C++中三目运算符返回的是变量，可以继续赋值</p><p><strong>switch语句</strong>：执行多条件分支语句<br>语法：switch(表达式)<br>{<br>    case 结果1：执行语句;break;<br>    case 结果2：执行语句;break;<br>    …<br>    default:执行语句;break;<br>}<br>注意：1. <code>switch</code>语句中的表达式的数据类型只能是整型或字符型</p><pre><code>        2. case里如果没有break，那么程序会一直向下执行        3.对于多条件判断，switch的结构清晰，执行效率高</code></pre><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>while循环结构</strong>：满足循环条件，执行循环结构<br>  语法：while (循环条件) {循环结构}<br>  注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环</p><p><strong>do … while循环语句</strong>：满足循环条件，执行循环语句<br>  语法：do {循环语句} while (循环条件)<br>  注意：do…while先执行一次循环语句，再判断循环条件</p><p><strong>for 循环语句</strong>：满足循环条件<br>  语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句}<br>  注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体</p><p><strong>嵌套循环</strong></p><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p><strong>break 语句</strong>：用于跳出选择结构或者循环结构<br>  使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch<br>                         出现在循环语句中，作用是跳出当前的循环语句<br>                         出现在嵌套循环中，跳出最近的内层循环结构</p><p><strong>continue语句</strong>：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环<br>  注意：continue不会使循环终止，而break会跳出循环</p><p><strong>goto语句</strong>：可以无条件跳转语句<br>  语法：goto 标记<br>             如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br>  注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//嵌套if语句</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了北大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了清华"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了人大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三目运算符</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">0</span>;</span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;         <span class="comment">//b=100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//a=10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//b=100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套循环体</span></span><br><span class="line"><span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++的一些基础语法
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>搭建自己的博客</title>
    <link href="http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-18T03:08:31.000Z</published>
    <updated>2020-01-18T05:42:11.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h1><p>GIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a>，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。</p><h1 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h1><p>在官网选择LTS版本下载安装即可：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>。</p><h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h1><p>在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><p>启动服务：依次执行以下命令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">npm</span> <span class="string">stall</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">s</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">c</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>之后每次更新博客内容后都要执行 hexo c —&gt;hexo g —&gt;hexo d，来重新部署。</p><h1 id="4-将Hexo部署到GitHub"><a href="#4-将Hexo部署到GitHub" class="headerlink" title="4.将Hexo部署到GitHub"></a>4.将Hexo部署到GitHub</h1><p>在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.1.jpg" alt="1.1" style="zoom:67%;"></p><p>回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"yourname"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>创建SSH</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>打开提示已经创建好的.ssh文件夹，其中<code>id_rsa</code>是私人密钥，<code>id_rsa.pub</code>是公共密钥。在GitHub中打开setting —&gt; New SSH key，将<code>id_rsa.pub</code>里面的信息复制进去。</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.2.jpg" alt="1.2" style="zoom: 50%;"></p><p>在blog文件夹中打开博客配置文件<code>_config.yml</code>，将最后几行修改为：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/yourname/yourname.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>安装deploy-git</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>最后重新部署博客</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">c</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>这样就可以在  <a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a>  访问自己的博客了。</p><h1 id="5-设置主题"><a href="#5-设置主题" class="headerlink" title="5.设置主题"></a>5.设置主题</h1><p>我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在<code>blog</code>文件夹下右键GIt Bash Here，下载主题：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>打开<code>blog</code>目录下的博客站点配置文件<code>_config.yml</code>，在开头的<code>Site</code>中添加自己博客的信息，注意将<code>language</code>改为<code>zh-CN</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span> <span class="meta"># 标题</span></span><br><span class="line"><span class="symbol">subtitle:</span> <span class="meta"># 副标题</span></span><br><span class="line"><span class="symbol">description:</span> <span class="meta"># 站点描述</span></span><br><span class="line"><span class="symbol">author:</span> <span class="meta"># 作者</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-CN</span><br><span class="line"><span class="symbol">timezone:</span></span><br></pre></td></tr></table></figure><p>往下拉，将<code>theme</code>改为<code>next</code>：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>重新部署博客即可看到主题已经替换。</p><p>接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。</p><h3 id="设置scheme"><a href="#设置scheme" class="headerlink" title="设置scheme"></a>设置scheme</h3><p>在<code>\blog\themes\next</code>文件夹中打开主题配置文件<code>_config.yml</code>，找到外观<code>scheme</code>，想使用哪一种就把前面的注释符#去掉，我选用的是<code>Mist</code>。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="meta">#scheme: Pisces</span></span><br><span class="line"><span class="meta">#scheme: Gemini</span></span><br></pre></td></tr></table></figure><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在主题配置文件<code>_config.yml</code>中找到菜单<code>menu</code>，将需要的项前的#去掉，我保留了<code>about</code>关于，<code>categories</code>分类，<code>tags</code>标签，<code>archives</code>归档。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span> || user</span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || th</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive</span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><p>创建菜单需要的页面：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>about</span><br><span class="line">hexo new<span class="built_in"> page </span>tags</span><br><span class="line">hexo new<span class="built_in"> page </span>categories</span><br></pre></td></tr></table></figure><p>在<code>\blog\source</code>下就会生成对应的文件夹，打开其中的<code>index.md</code>文件，将type设置为相应的内容，以<code>about</code>为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-01</span><span class="number">-17</span> <span class="number">20</span><span class="string">:16:07</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"about"</span> </span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="设置背景动画"><a href="#设置背景动画" class="headerlink" title="设置背景动画"></a>设置背景动画</h3><p>在主题配置文件<code>_config.yml</code>中找到<code>Animation Settings</code>，我使用的是<code>Canvas-nest</code>，将<code>Canvas-nest</code>下的enable状态改为true即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br></pre></td></tr></table></figure><p>——————————————————————————</p><p>到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。</p><p>2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。</p>]]></content>
    
    <summary type="html">
    
      最近想搭建一个自己的博客来记录一下学习过程，也能起到一定的督促作用，于是从网上找了一些教程学习了如何用Hexo+GitHub来搭建个人博客，下面记录一下搭建的过程。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://nekomoon404.github.io/2020/01/12/hello-world/"/>
    <id>http://nekomoon404.github.io/2020/01/12/hello-world/</id>
    <published>2020-01-12T07:14:03.207Z</published>
    <updated>2020-01-12T07:14:03.207Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
