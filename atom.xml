<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-10-20T12:53:49.307Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础（12）</title>
    <link href="http://nekomoon404.github.io/2020/10/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89/</id>
    <published>2020-10-20T07:50:22.000Z</published>
    <updated>2020-10-20T12:53:49.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元解线性方程组：线性代数里面很基础的一个知识点，算法步骤：</p><p>枚举每一列c：</p><ol><li>找到当前列绝对值最大的一行</li><li>用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）</li><li>用初等行变换(1) 将该行的第一个数变成 1（其余所有的数字依次跟着变化）</li><li>用初等行变换(3) 将下面所有行的当前列的值变成 0</li></ol><blockquote><p>例题（Acwing 883）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i++)    <span class="comment">//找到当前列绝对值最大的一行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c]) &lt; eps)  <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c; i &lt; n + <span class="number">1</span>; i ++)  swap(a[t][i], a[r][i]);  <span class="comment">//把这一行换到最上面（未确定阶梯型的行，并不是第一行）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= c; i --) a[r][i] /= a[r][c];    <span class="comment">// 将该行的第一个数变成 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++)  <span class="comment">//将下面所有行的当且列的值变成0（其余的数也要跟着变化）</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n] &gt; eps))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;     <span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//多解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> t = gauss();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)  <span class="built_in">puts</span>(<span class="string">"Infinite group solutions"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No solution"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><blockquote><p>求组合数I（Acwing 885）：</p><p>给定n组询问，每组询问给定两个整数$a,b$，请你输出$C^b_a\, mod \, (10^9+7)$的值。</p><p>数据范围：$1 \le n \le 10000, 1 \le b \le a \le 2000$</p><p>关于组合数的相关知识可以参考：<a href="https://oi-wiki.org/math/combination/" target="_blank" rel="noopener">排列组合</a>；组合数学</p></blockquote><p>组合数的公式：</p><script type="math/tex; mode=display">C^b_a=\frac{a!}{b!(a-b)!}</script><p>本题中$a$和$b$的数据范围是$1 \le b \le a \le 2000$，需要计算的$C_a^b$总数不超过400万，因此我们可以先处理出所有$C^b_a$的值，它有下面的递推公式：</p><script type="math/tex; mode=display">C^b_a=C^b_{a-1} + C^{b-1}_{a-1}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N][N];   <span class="comment">//c[i][j] 表示 C_i^j，即从i个不同的东西从抽出j个的组合数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求组合数II（Acwing 886）</p><p>给定n组询问，每组询问给定两个整数$a,b$，请你输出$C^b_a\, mod \, (10^9+7)$的值。</p><p>数据范围：$1 \le n \le 10000, 1 \le b \le a \le 10^5$</p></blockquote><p>第二题和第一题的区别是$a$和$b$的数据范围是$1 \le b \le a \le 10^5$，没办法将$C_a^b$全预处理完。那我们可以预处理出所有的$a!$，记为<code>fact[i]</code>，又$(a/b) \,mod \,p \ne (a \, mod \, p)/(b \, mod\, p)$，需要将除法转化为乘法，即转化为计算逆元$a/b \equiv a <em> x(mod \, x)$，记为<code>infact[i]</code>，那么$C_a^b$就等于`fact[a] </em> infanct[b-a] * infact[b]`。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>   <span class="comment">//求快速幂， 利用快速幂求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL) res * a % p;</span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = (LL) fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL) infact[i - <span class="number">1</span>] * qmi(i, mod - <span class="number">2</span>, mod) % mod;  <span class="comment">//求逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL) fact[a] * infact[b] % mod * infact[a - b] % mod);  <span class="comment">//注意这里乘两个数之后就要取一次模，防止溢出LL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求组合数III（Acwing 887）</p><p>给定n组询问，每组询问给定两个整数$a,b,p$，其中$p$是质数，请你输出$C^b_a\, mod \, p$的值。</p><p>数据范围：$1 \le n \le 20, 1 \le b \le a \le 10^{18}, 1 \le p \le 10^5$。</p></blockquote><p>第三题的查询数$n$很小，但$a, b$的值都爆大有$10^{18}$，这时可以使用<strong>卢卡斯定理</strong>：</p><script type="math/tex; mode=display">C^b_a \equiv C_{a \, mod \, p}^{b \, mod \, p} \cdot C_{a /p}^{b/p}(mod \, p)</script><p>这时的时间复杂度为$O(\log_p N \cdot p \cdot \log p)=O(p \log N \log p)$。</p><blockquote><p>关于卢卡斯定理的证明可以参考：<a href="https://oi-wiki.org/math/lucas/" target="_blank" rel="noopener">卢卡斯定理</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span>   <span class="comment">//快速幂，利用快速幂求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( k &amp; <span class="number">1</span>)  res = (LL) res * a % p;    <span class="comment">//计算a! / (a - b)! (mod p) </span></span><br><span class="line">        a = (LL) a * a % p;    <span class="comment">////计算 1 / b! (mod p)</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   <span class="comment">//计算C_a^b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL) res * j % p;</span><br><span class="line">        res = (LL) res * qmi(i, p - <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p)  <span class="keyword">return</span> C(a, b);</span><br><span class="line">    <span class="keyword">return</span> (LL) C(a % p, b % p) * lucas(a / p, b / p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;   <span class="comment">//注意这里要用LL 存a, b，数据范围是1到10^18</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lucas(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入$a,b$，求$C^b_a$的值。注意结果可能很大，需要使用高精度计算。</p><p>数据范围：$1 \le b \le a \le 5000$</p></blockquote><p>第四题从定义出发，不要求结果取模，而是用高精度表示，我们需要实现高精度乘法和高精度除法，但是直接计算效率比较低，一般是要先将$a, b$分解质因数，这样只需要高精度乘法就可以了。</p><script type="math/tex; mode=display">\begin{align*}C_a^b = \frac{a!}{b!(a-b)!}=p_1^{\alpha_1} \cdot p_2^{\alpha_2} \dots p_k^{\alpha_k} \end{align*}</script><p>如何计算$a!$中$p_i$的次数，可以用下面的公式：</p><script type="math/tex; mode=display">a!中p的次数=\lfloor\frac{a}{p} \rfloor + \lfloor\frac{a}{p^2} \rfloor + \lfloor\frac{a}{p^3} \rfloor + \dots</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;   <span class="comment">//cnt 存质因数的个数</span></span><br><span class="line"><span class="keyword">int</span> sum[N];   <span class="comment">//存a分解质因数后，a!中p_i的指数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">//线性筛求质因数</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])  primes[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span>   <span class="comment">//求a分解质因数后，a!中p的指数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        res += a / p;</span><br><span class="line">        a /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)    <span class="comment">//高精度乘法，一个很大的数，乘一个较小的数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;     <span class="comment">//这里不需要处理前导0，因为本题中不会乘0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    get_primes(a);   <span class="comment">//求a的质因数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = primes[i];</span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(a - b, p) - <span class="built_in">get</span>(b, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++)</span><br><span class="line">            res = mul(res, primes[i]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      高斯消元，求组合数
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（11）</title>
    <link href="http://nekomoon404.github.io/2020/10/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89/</id>
    <published>2020-10-18T06:12:45.000Z</published>
    <updated>2020-10-18T14:26:16.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p><strong>1 ~ N 中与 N 互质的数的个数被称为欧拉函数</strong>，记为$\phi(N)$。若在算数基本定理中，$N=p_1^{a_1}p_2^{a_2}\dots p_k^{a_k}$（分解质因数） ，则：</p><script type="math/tex; mode=display">\phi(N)=N \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k})</script><blockquote><p>互质是公约数只有1的两个整数。</p></blockquote><p>证明利用了<strong>容斥原理</strong>：</p><ol><li><p>从1到N中去掉$p_1,p_2,\dots,p_k$的所有倍数；</p></li><li><p>有些数会被减掉两次，需要再加回来，即加上所有$p_i * p_j$的倍数；</p></li><li>若某些数是$p_1, p_2, p_3$的公倍数，那么它在第一步被减去三次，在第二步被加上三次，相当于是没处理掉，因此要再减去所有$p_i<em>p_j</em>p_k$的倍数；</li><li>按此规律继续下去，加上所有四个质因数的倍数；减去所有5个质因数的倍数；……</li></ol><script type="math/tex; mode=display">\begin{align*}N &-\frac{N}{p_1}-\frac{N}{p_2}\dots-\frac{N}{p_k} \\&+\frac{N}{p_1p_2}-\frac{N}{p_1p_3}\dots-\frac{N}{p_{k-1}p_k} \\&+\frac{N}{p_1p_2p_3}-\frac{N}{p_1p_2p_4}\dots-\frac{N}{p_{k-2}p_{k-1}p_k} \\&-\frac{N}{p_1p_2p_3p_4}-\dots\\&\dots\end{align*}</script><p>而上面两式是相等的，即证。</p><p>用上面的公式计算欧拉数的时间复杂度为$O(\sqrt{n})$，瓶颈在分解质因数，而分解质因数的时间复杂度为$O(\sqrt{n})$。</p><blockquote><p>给定n个正整数$a_i$，请你求出每个数的欧拉函数。</p><p>数据范围：$1  \le n \le 100, 1 \le a_i \le 2∗10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = a;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res / i * (i <span class="number">-1</span>);   <span class="comment">//套用欧拉函数的公式，注意这里要先除再乘，防止int溢出</span></span><br><span class="line">                <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">                    a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>)  res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>用筛法求欧拉函数</strong></li></ul><blockquote><p>给定一个正整数n，求1~n中每个数的欧拉函数之和。</p><p>数据范围：$1 \le n \le 10^6$。</p></blockquote><p>若是用上面的公式就1~n中每个数的欧拉函数，那么时间复杂度就是$O(n\sqrt{n})$，若是借用之前讲的筛质数的线性筛的思路，可以将时间复杂度优化到$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_euler</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;      <span class="comment">//i是质数，i的互质数（从1到i之中的）的个数是i - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;      <span class="comment">//primes[j]一定是primes[j] * i的最小质因数</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)  <span class="comment">//如果primes[j]是i的最小质因数</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  res += phi[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get_euler(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线性筛法的代码上作添加即可，用<code>phi[i]</code>存数<code>i</code>的欧拉函数（从1到i的互质数的个数）：</p><ol><li>如果<code>st[i]=false</code>，即<code>i</code>是质数，那么<code>i</code>的欧拉函数就是<code>i-1</code>；</li><li>如果$i \, mod \, p_j = 0$，则$p_j$是$i$的最小质因数，也是$p_j<em>i$的最小质因数；而$p_j</em>i$的分解质因数的结果只比$i$分解质因数的结果多了一项：$p_j$，又因为$p_j$是$i$的质因数，因此在$\phi(i)$的公式中已经计算过了$(1-\frac{1}{p_j})$这一项，那么有$\phi(p_j<em>i)= \phi(i) </em> p_j$；</li><li>如果$i \, mod \, p_j \ne 0$，$p_j$是$p_j<em>i$的最小质因数，但不是$i$的最小质因数，若设$\phi(i)= i \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k})$，则$\phi(p_j </em> i)= p_j <em> i \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k}) (1-\frac{1}{p_j})$，那么有$\phi(p_j</em>i)=p_j <em> \phi(i) </em>(1-\frac{1}{p_j})=\phi(i) * (p_j-1)$。</li></ol><p><strong>欧拉函数的一个用处——欧拉定理</strong>：若$a$与$n$互质，则有$a^{\phi(n)}\equiv 1(mod \, n)$。</p><blockquote><p>同余：两个整数$a, b$，若它们除以正整数$m$所得的余数相等，则称$a, b$对于模$m$同余，记作$a \equiv b( \mod m)$。读作$a$同余于$b$模$m$，或读作$a$与$b$关于模$m$同余。</p></blockquote><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><blockquote><p>给定n组$a_i,b_i,p_i$，对于每组数据，求出 $a_i^{b_i} \mod p_i$ 的值。</p><p>数据范围：$1 \le n \le 100000, 1 \le a_i,b_i,p_i \le 2∗10^9$</p></blockquote><p><strong>快速幂可以在$O(\log n)$的时间复杂度，求出$a^k \, mod \,p$的值</strong>，其中$1 \le a, p, k \le 10^9$。</p><p>思路是：预处理出这些值，$a^{2^0} \, mod\, p$，$a^{2^1} \, mod\, p$，$a^{2^2} \, mod\, p$，……，$a^{2^{\log k}} \, mod\, p$，然后让：</p><script type="math/tex; mode=display">a^k=a^{2^{x_1}} \cdot a^{2^{x_2}} \dots a^{2^{x_t}} =a^{2^{x_1}+2^{x_2}+\dots +2^{x_t}}</script><p>而具体的$x_1, x_2, \dots, x_t$则可以由$k$的二进制表示所有为1的位获得，如$(k)_{10}=(110110)_2$， 则有$k=2^1+2^2+2^4+2^5$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;   <span class="comment">//数论中的很多问题都会爆int， 会用到long long </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 a^k mod p 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, k, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;k, &amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qmi(a, k, p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>快速幂求逆元</strong></li></ul><p><strong>乘法逆元</strong>的定义：若整数$b，m$互质，并且对于任意的整数$ a$，如果满足$b|a$，则存在一个整数$x$，使得$a/b≡a∗x(mod \,m)$，则称$x$为$b$的模$m$乘法逆元，记为$b^{−1}(mod \,m)$。$b$存在乘法逆元的充要条件是$b$与模数$m$互质。当模数$m$为质数时，$b^{m−2}$即为$b$的乘法逆元。</p><p>$b \cdot x \equiv 1(mod \, p)$，由费马小定理：$b^{p-1} \equiv 1(mod \, p)$，即$b \cdot b^{p-2} \equiv 1(mod \, p)$，因此我们要求的逆元$x$就是$b^{p-2}$，当然前提是$b$与模数$p$互质，其$p$是质数，这就转换了求快速幂的问题，<code>qmi(a, p - 2, p)</code></p><blockquote><p>给定$n$组$a_i,p_i$，其中$p_i$是质数,求$a_i$模$p_i$的乘法逆元，若逆元不存在则输出impossible。注意：请返回在0∼p−1之间的逆元。</p><p>数据范围：$1 \le n \le 10^5,1 \le a_i,p_i \le 2∗10^9$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 a^k mod p 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = qmi(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">if</span>(a % p)  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>裴蜀定理：对于任意正整数$a, b$，一定存在非零整数$x, y$，使得$ax+by=(a, b)$。</p><blockquote><p>$(a, b)$表示$a,b$的最大公约数</p></blockquote><p>要证明存在可以使用构造法，扩展欧几里得算法就提供了一种构造的思路。</p><blockquote><p>给定$n$对正整数$a_i,b_i$，对于每对数，求出一组$x_i,y_i$，使其满足$a_i∗x_i+b_i∗y_i=gcd(a_i,b_i)$。</p><p>数据范围：$1 \le n \le 10^5 , 1 \le a_i,b_i \le 2∗10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        exgcd(a, b, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设$a x+by=d $，由欧几里得算法知，$(a, b)=(b, a \,mod \, b)$，则有：$by+(a \, mod \, b)=d$；又因为$(a \, mod\, b)=a-\lfloor\frac{a}{b} \rfloor \cdot b$，代入得：$ax+b(y-\lfloor \frac{a}{b} \rfloor \cdot x)=d$，因此在递归<code>d=exgcd(b, a % b, y, x)</code>后要令<code>y -= a \b * x</code>。</p><p>扩展欧几里得算法的一个应用：<strong>求解线性同余方程</strong></p><blockquote><p>给定$n$组数据$a_i,b_i,m_i$，对于每组数求出一个$x_i$，使其满足$a_i∗x_i≡b_i(mod\,  m_i)$，如果无解则输出impossible。</p><p>数据范围：$1 \le n \le 10^5 , 1 \le a_i,b_i, m_i \le 2∗10^9$</p></blockquote><p>若存在一个$x$，使得$ax \equiv b(mod\, m)$，即是存在一个$y$，使得$ax=my+b$，即$ax-my=b$，令$y’=-y$，则等价于方程$ax+my’=b$有解，这就是扩展欧几里得算法的形式了，上式有解的充分必要条件是$b$是$a$和$m$的最大公约数的倍数，即$(a, m)|b$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span>(b % d)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);   <span class="comment">//如果b不是gcd(a, b)的倍数，那一定无解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>) x * (b / d) % m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><blockquote><p>可参考：<a href="https://oi-wiki.org/math/crt/" target="_blank" rel="noopener">中国剩余定理</a></p></blockquote><p><strong>中国剩余定理</strong> (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中$m_1, m_2,  \dots, m_k$  <strong>两两互质</strong>）：</p><script type="math/tex; mode=display">\begin{cases}x &\equiv a_1(\mod m_1)  \\x &\equiv a_2(\mod m_2)  \\&\dots\\x &\equiv a_k(\mod m_k)  \\\end{cases}</script><p>求解步骤：</p><ol><li>求所有模数的积， $M=m_1m_2\dotsm_k$</li><li>对于第$i$个方程：$M_i=\frac{M}{m_i}$，求$M_i$在模$m_i$的逆元$M_i^{-1}$（可以扩展欧几里得算法解，令$b=1$）</li><li>方程组的唯一解：$a= \sum^k_{i=1} a_iM_iM_i^{-1}(\mod n)$</li></ol><blockquote><p>表达整数的奇怪方式：</p><p>给定 $2n$ 个整数$a_1,a_2,…,a_n$和$m_1,m_2,…,m_n$,求一个最小的非负整数 $x$，满足$∀i∈[1,n],x≡mi(\mod a_i)$。</p><p>数据范围：$1 \le a_i \le 2^31−1 , 0 \le m_i \le a_i, 1 \le n \le 25$。</p></blockquote><p>注意本题中的$a_i, m_i$并没有任何限制，而中国剩余定理中要求$m_1, m_2, \dots,m_k$两两互斥</p>]]></content>
    
    <summary type="html">
    
      欧拉函数，快速幂，扩展欧几里得算法,中国剩余定理
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（10）</title>
    <link href="http://nekomoon404.github.io/2020/10/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89/</id>
    <published>2020-10-15T13:05:35.000Z</published>
    <updated>2020-10-17T12:43:57.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者素数。</p><h4 id="1-质数的判定——试除法"><a href="#1-质数的判定——试除法" class="headerlink" title="1.质数的判定——试除法"></a>1.质数的判定——试除法</h4><p>暴力做法，1到$n$遍历——时间复杂度$O(n)$</p><p>优化：n的约数都是成对出现，因此枚举时只枚举其中较小的一个，即2到$\sqrt{n}$，时间复杂度$O(\sqrt{n})$（<strong>推荐写成<code>1 &lt;= n / i</code></strong>，若是<code>i &lt;= sqrt(n)</code>，比较费时间；若是<code>i * i &lt;= n</code>，当n接近<code>int</code>的最大值时，<code>i * i</code>有溢出风险。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-分解质因数——试除法"><a href="#2-分解质因数——试除法" class="headerlink" title="2.分解质因数——试除法"></a>2.分解质因数——试除法</h4><p>每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的因数，把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。</p><blockquote><p>给定n个正整数$a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的<strong>底数</strong>和<strong>指数</strong>。</p></blockquote><p>暴力做法：从小到大枚举所有数，$O(n)$</p><p>优化：n中最多只包含一个大于$\sqrt{n}$的质因数，最坏情况$O(\sqrt{n})$，最好情况$O(\log n)$（如当$n-2^k$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)  <span class="comment">// i 一定是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">//求底数的指数</span></span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">n /= i;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%d\n"</span>, i, s);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-筛质数"><a href="#3-筛质数" class="headerlink" title="3.筛质数"></a>3.筛质数</h4><blockquote><p>给定一个正整数n，请你求出1~n中质数的个数。</p></blockquote><p>朴素做法：将所有数从小到大排列，依次把每个数的倍数删掉，剩下的数就是从2到n的质数。（如果p没有被删掉，说明从2到p-1中不存在任何一个p的约数，那p一定是质数。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)  st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n \log n)$</p><script type="math/tex; mode=display">\begin{align*}& \frac{n}{2}+\frac{n}{3}+\dots+\frac{n}{n}\\=&n(\frac{1}{2}+\frac{1}{3}+\dots+\frac{1}{n}) --调和级数\\ =&n(\ln n + c)--c是欧拉常数，\approx0.5772 \\<&n \log n\end{align*}</script><p>优化：并不需要把每个数的倍数删掉，<strong>只需把每个质数的倍数删掉</strong>，代码只需很小的改动。——时间复杂度：$O(n \log \log n)$，很接近$O(n)$了。（1到n中有$n / \ln n$个质数）</p><blockquote><p>埃氏筛法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)  st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：<strong>线性筛法</strong>，也称为欧拉筛法，思路是：<strong>n只会被它的最小质因子筛掉</strong>。当$n=10^7$时，线性筛法大概比埃氏筛法快一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">//线性筛法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])   prime[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)  <span class="keyword">break</span>;   <span class="comment">//prime[j]一定是i的最小质因数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>i % prime[j] == 0</code>，<code>prime[j]</code>一定是<code>i</code>的最小质因数，<code>prime[j]</code> 一定是<code>prime[j] * i</code>的最小质因数；如果<code>i % prime[j] != 0</code>，说明<code>prime[j]</code>一定小于<code>i</code>的最小质因数，所以<code>prime[j]</code>也一定是<code>prime[j] * i</code>的最小质因数。</p><p>任何一个合数一定会被筛掉，它一定存在一个最小质因数，设为<code>prime[j]</code>，当<code>i</code>枚举到<code>x / prime[j]</code>时，它就会被筛掉。因为我们是<strong>用最小质因子来筛数，而每个数只有一个最小质因子，因此时间复杂度是线性的，即$O(n)$</strong>。</p><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="1-试除法求约数"><a href="#1-试除法求约数" class="headerlink" title="1.试除法求约数"></a>1.试除法求约数</h4><blockquote><p>给定n个正整数$a_i$，对于每个整数$a_i$,请你按照从小到大的顺序输出它的所有约数。</p></blockquote><p>思路和试除法判断质数相似，从小到大枚举n的约数（只枚举一对中小的那个），时间复杂度为$O(\sqrt{n})$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_divisors(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i != n / i)  res.push_back(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-约数个数"><a href="#2-约数个数" class="headerlink" title="2.约数个数"></a>2.约数个数</h4><p>定理：如果一个数因数分解之后可以写成：$N=p_1^{ \alpha_1} \cdot p_2^{\alpha_2} \cdot \dots p_k^{\alpha_k}$，那么它的<strong>约数个数</strong>为：$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$。</p><p>（数N的约数d一定可以写成：$d=p_1^{ \beta_1} \cdot p_2^{\beta_2} \cdot \dots p_k^{\beta_k}$，其中对每一个$\beta_i$，一定有$0 \le \beta_i \le \alpha_i$；N的每一个约数就对应着一组不同的$\beta_i$的取值，因此N的约数的个数就是$\beta_i$的不同取值的组合数，即$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$。）</p><blockquote><p>冷知识：<code>int</code>范围内的整数，约数个数最多的数，它的约数大约有1500个</p><p>给定n个正整数$a_i$，请你输出这些数的乘积的约数个数，答案对$10^9+7$取模。</p></blockquote><p>题目是让求数$a_1 \cdot a_2 \dots a_n$的乘积的约数的个数，我们可以分别求出每个数的约数的个数，把所有的约数和指数用一个哈希表存起来，然后套用公式即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>)  primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes)  res = res * (prime.second + <span class="number">1</span>) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-约数之和"><a href="#3-约数之和" class="headerlink" title="3.约数之和"></a>3.约数之和</h4><p>定理：如果一个数因数分解之后可以写成：$N=p_1^{ \alpha_1} \cdot p_2^{\alpha_2} \cdot \dots p_k^{\alpha_k}$，那么它的<strong>约数之和</strong>为：$(p_1^{ 0} + p_1^{1}+ \dots p_1^{\alpha_1})(p_2^{ 0} + p_2^{1}+ \dots p_2^{\alpha_2}) \dots (p_k^{ 0} + p_k^{1}+ \dots p_k^{\alpha_k})$。</p><p>（将上式展开，一共有$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$项，每一项都是$p_1^{ \beta_1} \cdot p_2^{\beta_2} \cdot \dots p_k^{\beta_k}$，都是N的一个约数，且每个数都不同，则上式就是N的约数之和。）</p><blockquote><p>给定n个正整数$a_i$，请你输出这些数的乘积的约数之和，答案对$10^9+7$取模。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>)  primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes)   <span class="comment">//代码和上题基本一样，只需按求约数和的公式改动一下即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = prime.first, a = prime.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a--)   t = (t * p + <span class="number">1</span>) % mod;   <span class="comment">//这一步可以用分治优化到log a的复杂度，但在这个题中其实没必要</span></span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-求最大公约数"><a href="#4-求最大公约数" class="headerlink" title="4.求最大公约数"></a>4.求最大公约数</h4><p>欧几里得算法，也叫辗转相除法。a和b的最大公约数$=$ a模b和b的最大公约数，$(a, b)=(b, a \, mod \,b)$，这样就可以用递归写了，时间复杂度为$O(\log n)$。</p><p>（设$a \,mod\, b=a-c \cdot b$，则$(a, b)=(b, a-c \cdot b)$。由d能整除a，d能整除b，则d能整数ax + by，这证上式成立。）</p><blockquote><p>给定n对正整数$a_i,b_i$，请你求出每对数的最大公约数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;   <span class="comment">//a和0的最大公约数是a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gcd(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第四章数学知识内容：数论（质数，约数）
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（9）</title>
    <link href="http://nekomoon404.github.io/2020/10/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89/</id>
    <published>2020-10-14T10:38:41.000Z</published>
    <updated>2020-10-15T13:02:05.366Z</updated>
    
    <content type="html"><![CDATA[<p>第三章 搜索与图论（三）</p><p>定义无向连通图的<strong>最小生成树</strong> （Minimum Spanning Tree，MST）为<strong>边权和最小的生成树</strong>。</p><blockquote><p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p><p>可参考：<a href="https://oi-wiki.org/graph/mst/" target="_blank" rel="noopener">最小生成树</a></p></blockquote><p>最小生成树问题对应的图都是无向图，一般有两种常用的解法：</p><ul><li>Prim算法：（和Dijkstra算法很像）<ul><li>朴素版Prim算法——稠密图，时间复杂度$O(n^2)$；</li><li>堆优化版Prim算法——稀疏图，时间复杂度$O(m \log n)$</li></ul></li><li>Kruskal算法——稀疏图，时间复杂度$O(m \log n)$</li></ul><blockquote><p>算法的选择：如果是稠密图，一般就用朴素版Prim算法；如果是稀疏图，一般就用Kruskal算法。堆优化版Prim算法一般不常用。</p></blockquote><h3 id="朴素版Prim算法"><a href="#朴素版Prim算法" class="headerlink" title="朴素版Prim算法"></a>朴素版Prim算法</h3><p>朴素版Prim算法适用于解决稠密图的最小生成树问题，其思路和Dijkstra算法很像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化所有距离为正无穷 dist[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">t = 集合s外距离最近的点;        <span class="comment">//集合s表示当前在连通块中的所有的点</span></span><br><span class="line">    用t更新其他点到**集合**的距离;   <span class="comment">//注意这里与Dijkstra算法的区别</span></span><br><span class="line">                                <span class="comment">//点到集合的距离：当前点能连到集合内部的点的边中最短的边的距离；若没有一条边是连到集合内部的，距离就定义为正无穷</span></span><br><span class="line">    s[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">生成树就是：每次选到的t，其距离对应的那条边，所组成的树</span><br></pre></td></tr></table></figure><blockquote><p>例题：Prim算法求最下生成树（Acwing 858)</p><p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><p>输出格式：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>数据范围：$1 \le n \le 500, 1 \le m \le 10^5$，图中涉及边的边权的绝对值均不超过10000。</p><p>（实际问题：如在城市之间铺路，允许路之间交叉，求铺路总长度的最小值）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];   <span class="comment">//稠密图用邻接矩阵存比较好</span></span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//dist[]表示点到集合的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//st[]存点是否已经在连通块中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//注意题目中给的点的编号，从1开始，那j就从1开始</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))   <span class="comment">//找到集合外距离最近的点t</span></span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF)  <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)   res += dist[t];   <span class="comment">//注意：要先累加再更新，否则会把负的自环更新进来</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)   <span class="comment">//用t更新其他点到集合的距离</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = prim();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prim算法的堆优化思路和Dijkstra堆优化的思路是一样的：用堆维护上面的dist[]数组，每次找最小值的时间复杂度是$O(1)$，共执行$n$次就是$O(n)$；更新堆中的一个元素是$O(\log n)$，共$m$条边，执行了$m$次就是$O(m \log n)$，所以堆优化版的Prim算法的时间复杂度就是$O(m \log n)$。</p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法适用于解决稀疏图的最小生成树问题，其思路如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将所有边按权重从小到大排序;   <span class="comment">//Kruskal算法的瓶颈，O(mlogm)</span></span><br><span class="line">从小到大枚举每条边 a——b，权重是w</span><br><span class="line">    <span class="keyword">if</span> a,b不连通（边不在集合中）</span><br><span class="line">        将这条边加入到集合中（其实就是将a和b之间连一条边）  <span class="comment">//可以理解为并查集的简单应用</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//不需要用邻接矩阵或邻接表来存图，只需用结构体把每条边存起来即可</span></span><br></pre></td></tr></table></figure><blockquote><p>例题：Kruskla算法求最小生成树（Acwing 858）</p><p>题目和前一道题一样，数据范围变了变：$1 \le n≤10^5, 1 \le m \le 2∗10^5$，显然这是一个稀疏图问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];  <span class="comment">//并查集中的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;E) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; E.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//并查集的find函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  p[i] = i;    <span class="comment">//初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a != b)   <span class="comment">//如果a和b在并查集中没有连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res  += w;    <span class="comment">//res存最小生成树中边权的总和</span></span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果循环结束后，连通的边数小于n-1，说明n个点没有全部连通，即不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>)  <span class="keyword">return</span> INF;   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = kruskal();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p><strong>二分图：节点由两个集合组成，且两个集合内部没有边的图</strong>。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。</p><blockquote><p>可参考：<a href="https://oi-wiki.org/graph/bi-graph/" target="_blank" rel="noopener">二分图</a>，介绍了二分图的概念和性质</p></blockquote><p>二分图，通常有两类问题：</p><ul><li>染色法判定二分图，（DFS），时间复杂度$O(n+m)$</li><li>匈牙利算法，最坏情况下时间复杂度$O(nm)$，但实际运行时间一般远小于$O(nm)$</li></ul><p>二分图的性质：<strong>一个图是二分图，当且仅当图中不含奇数环</strong>。<strong>抽象为染色问题</strong>，一点为黑色，那连通块中与它相邻的点一定为白色；若连通块中一个点的颜色确定了，整个连通块中点的颜色就确定了。<strong>由于图中不含有奇数环，所以整个染色过程一定是没有矛盾的</strong>。</p><p>染色法判定二分图的思路如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  遍历所有点</span><br><span class="line">    <span class="keyword">if</span> i 没被染色</span><br><span class="line">        dfs(i, <span class="number">1</span>); 用深度优先遍历将i所在的连通块中的点都染色; <span class="number">1</span>表示点i当前的颜色</span><br></pre></td></tr></table></figure><blockquote><p>例题：染色法判定二分图</p><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。</p><p>输出格式：如果给定图是二分图，则输出“Yes”，否则输出“No”。</p><p>数据范围：$1 \le n\le 10^5, 1 \le m \le 10^5$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;   <span class="comment">//用邻接表存稀疏图</span></span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;       <span class="comment">//给当前点染色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];   </span><br><span class="line">        <span class="keyword">if</span>(!color[j])   <span class="comment">//若当前点未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(j, <span class="number">3</span> - c))  <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//两种颜色1和2， 3 - c 就表示与c不同的另一种颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)  <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果与u相邻的点颜色与其相同，说明冲突了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b), add(b, a);   <span class="comment">//无向图，存两次边</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法（二分图最大匹配）"><a href="#匈牙利算法（二分图最大匹配）" class="headerlink" title="匈牙利算法（二分图最大匹配）"></a>匈牙利算法（二分图最大匹配）</h3><p><strong>二分图的匹配</strong>：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p><p><strong>二分图的最大匹配</strong>：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p><p>匈牙利算法又称为KM算法，可以用来求解解决二分图最大权匹配。</p><blockquote><p>可以参考：<a href="https://oi-wiki.org/topic/graph-matching/bigraph-weight-match/" target="_blank" rel="noopener">二分图最大权匹配</a></p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201015201734.png" style="zoom:50%;"></p><p>（奇妙比喻）匈牙利算法的思路是：遍历左边的男生，第一个，第二个都顺利找到了心仪的且还是单身的女伴，到了第三个男生，发现心仪的女生已经有所属了，但他没有放弃，回去看这位女生所属的男生，发现他还有其他心仪的女生，OK那就交换一下，这样三个男生就都有女伴了。</p><p>时间复杂度：遍历每个男生，n；每个男生找女伴时最多再遍历m边条，因此最坏情况下，时间复杂度为$O(nm)$，但实际运行的复杂度远小于$O(mn)$。</p><blockquote><p>例题：二分图的最大分配（Acwing 861）</p><p>给定一个二分图，其中左半部包含$n_1$个点（编号1~$n_1$），右半部包含$n_2$个点（编号1~$n_2$），二分图共包含m条边。数据保证任意一条边的两个端点都不可能在同一部分中。请你求出二分图的最大匹配数。</p><p>输入格式：第一行包含三个整数 n1、 n2 和 m。接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。</p><p>输出格式：输出一个整数，表示二分图的最大匹配数。</p><p>数据范围：$1 \le n_1,n_2 \le 500, 1 \le u \le n_1, 1 \le v \le n_2, 1 \le m \le 10^5$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会找左边集合中的点指向哪些边</span></span><br><span class="line"><span class="keyword">int</span> n1, n2, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> match[N];  <span class="comment">//右边集合中的点与哪些点相连</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//每次不要重复搜一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])      <span class="comment">//遍历当前男生相连的女生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])     <span class="comment">//如果这个女生之前没找过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))   <span class="comment">//如果这个女生还没有所属，或者其所属可以找到其他女生，那这次配对就成功了</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)      <span class="comment">//枚举每个男生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))  res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>图论题的难点是如何把问题抽象成图论问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      求最小生成树（Prim算法，Kruskal算法），二分图（染色法，匈牙利算法）。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（8）</title>
    <link href="http://nekomoon404.github.io/2020/10/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89/</id>
    <published>2020-10-13T08:24:04.000Z</published>
    <updated>2020-10-14T08:39:11.491Z</updated>
    
    <content type="html"><![CDATA[<p>常见的最短路问题：</p><ol><li><p><strong>单源最短路</strong>：求一个点到其他所有点的最短距离，如从1号点到N号点的最短路。又可分为：</p><ul><li><p><strong>所有边的权重都是正数</strong>，一般有两种解法：</p><ul><li>朴素的Dijkstra算法（时间复杂度$O(n^2)）$，适合用于稠密图（$m$接近于$n^2$）；</li><li>堆优化版的Dijkstra算法（时间复杂度$O(m \log n)$），适合用于稀疏图（$m$接近于$n$）；</li></ul><p>（设图中点的数量为$n$，边的数量为$m$）（稠密图用邻接矩阵来存，稀疏图用邻接表来存）</p></li><li><p><strong>存在权重是负数的边</strong>，一般也有两种解法：</p><ul><li>Bellman-Ford算法（时间复杂度$O(nm)$）；</li><li>SPFA算法（一般情况下时间复杂度$O(m)$，最坏情况下$O(nm)$），但并不是所有情况都可用SPFA，如限制经过的边数不超过$k$。</li></ul></li></ul></li><li><p><strong>多源汇最短路</strong>：可能有多个询问，每次询问从其中一个点走到另一点的最短距离，即起点和终点不确定（源点——起点，汇点——终点）：</p><ul><li>Floyd算法（时间复杂度$O(n^3)$）</li></ul></li></ol><p><strong>最短路问题考察的重点难点是：建图，即把原问题抽象成一个最短路问题，如何定义点和边</strong>；重点不在证明算法的正确性上。</p><p>（有向图和无向图的最短路问题其实是没有区别的，无向图可以看作是特殊的有向图，我们可以用有向图的最短路算法来解决无向图的问题。）</p><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化距离 dis[<span class="number">1</span>] = <span class="number">0</span>, dis[i] = 正无穷</span><br><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点</span><br><span class="line">    t加到s中</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每次循环都可以确定一个点的最短距离，循环n次后就得到了每个点到起点的最短距离</span><br></pre></td></tr></table></figure><blockquote><p>例题：Dijkstra求最短路I（Acwing 849）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出-1。</p><p>数据范围：$1 \le n \le500, 1 \le m \le 105$，图中涉及边长均不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//找到不在s中的距离最近的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))  <span class="comment">//如果dist[t]比dist[j]大的话，那t显然不满足最短路的要求</span></span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;   <span class="comment">//将找到的t存入s中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>回顾一下朴素Dijkstra算法中的各步骤的时间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点————总共n^<span class="number">2</span>次</span><br><span class="line">    t加到s中————总共n次</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）————总共m次（与边数有关）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见朴素Dijkstra算法中最耗时的是第一步：在<code>st[]=false</code>的点中找到<code>dist[]</code>最小的点，即是t，整个算法的时间复杂度为$O(n^2)$。在一组数中找到最小的数，正是堆擅长做的，在堆中求最小值的时间复杂度为$O(1)$，但这也会影响第三步，在堆中修改一个数的时间复杂度为$O(\log n)$。因此堆优化的Dijkstra算法中各步骤的时间复杂度为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点————总共n次</span><br><span class="line">    t加到s中————总共n次</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）————总共 m*logn次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见堆优化Dijkstra算法中最耗时的变成了第三步，整个算法的时间复杂度为$O(m \log n)$。</p><p>实现堆有两种方法：手写堆（可以支持修改任意一个元素）；优先级队列（不支持修改任意一个元素，每修改一次就在队列中加一个新的数）。一般来说堆优化版的Dijkstra算法就使用STL中的优先级队列就行了。同时也要注意，稀疏图的存储方式用邻接表要好一些。</p><blockquote><p>例题：Dijkstra求最短路II（Acwing 850）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出-1。</p><p>数据范围：$1 \le n, m \le 1.5 \times 10^5$，图中涉及边长均不小于0，且不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//first存点到起点的距离，second存点的下标（第几个点）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;   <span class="comment">//稀疏图用邻接表存，与之前写过的区别是：多个w[N]来存每条边的权重（边长）</span></span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class="comment">//小根堆</span></span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())    <span class="comment">//队列中最多只有m个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])  <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])    </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];       <span class="comment">//dist[j] = dist[ver] + w[i];  也是可以的</span></span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>Bellman-Ford算法是用来解决存在权重是负数的边的最短路问题的，它的主要步骤为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n 次：</span><br><span class="line">    <span class="keyword">for</span> 所有边a, b, w:  （a指向b，权重/边长为w）</span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], dist[a] + w);  （和Dijkstra类型，dist[]存点到起点的最短距离）</span><br></pre></td></tr></table></figure><p>Bellman-Ford遍历完所有边后，所有的点都满足：<code>dist[b] &lt;= dist[a] + w</code>（三角不等式），这个更新的过程叫作：松弛操作。</p><p>要注意的是：<strong>若存在负权回路，则最短路不一定是存在的</strong>（若负环是在从起点到终点的某一条路径中，绕负权回路无数圈，最短路就是<strong>负无穷</strong>了）。<strong>Bellman-Ford算法可以求出是否存在负权回路</strong>，其迭代的次数是有实际意义的，如当前迭代了k次，<code>dist[]</code>数组的含义是从起点经过不超过K条边到各个点的最短距离；<strong>迭代完n次，第n次还有更新的话</strong>就表示存在一条最短路径，其含有的边数为n条。如果一条最短路径上有n条边，但只有n-1个点，根据抽屉原理，路径上一定存在环，且又因为第n次更新了，所有环的权重一定是负的，<strong>即存在负权回路</strong>。</p><blockquote><p>例题：有边数限制的最短路（Acwing 853）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。注意：图中可能 存在负权回路 。</p><p>输入格式：第一行包含三个整数n，m，k。接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。如果不存在满足条件的路径，则输出“impossible”。</p><p>数据范围：$1 \le n,k \le 500,1 \le m \le 10000$，任意边长的绝对值不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> dist[N], backup[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;   <span class="comment">//a，b表示边的起点和终点，w表示边的权重</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需要做个特殊的处理：每次遍历前先将dist[]数组备份一下；只用上一次迭代的结果来更新</span></span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//这里的判断条件也要注意一下，防止两个正无穷之间连了条负边，后一个负无穷可能会更新</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m; i++)   <span class="comment">//读入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = bellman_ford();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">-1</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA算法也是用来解决存在权重是负数的边的最短路问题的，它要求路径中没有负环（负权回路），其实大多数最短路题目中都是没有负环的，SPFA算法也算是单源最短路问题中限制最少的算法了。SPFA算法相当于是在Bellman Ford算法的基础上做优化，回顾下Bellman Ford算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n 次：</span><br><span class="line">    <span class="keyword">for</span> 所有边a, b, w:  （a指向b，权重/边长为w）</span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], dist[a] + w);  （和Dijkstra类型，dist[]存点到起点的最短距离）</span><br></pre></td></tr></table></figure><p>每次迭代要更新<code>dist[b]</code>时如果<code>dist[b]</code>在当前迭代中想要变小，那就要求<code>dist[a]</code>要变小，只要<code>dist[a]</code>变小了，<code>dist[b]</code>才会变小。SPFA就是从这一点作优化，利用宽度优先搜索BFS来做优化，其思路如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">起点放入队列 queue</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空:  (queue存的是所有dist[]变小了的节点)</span><br><span class="line">&#123;</span><br><span class="line"> 取出队头 t = q.fornt();</span><br><span class="line"> q.pop();</span><br><span class="line"> 更新t的所有出边 t-b, 权重为w</span><br><span class="line"> 若更新成功，且队列中没有b，就把b加入队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题：SPFA求最短路（Acwing 851）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。数据保证不存在负权回路。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出”impossible”。</p><p>数据范围：$1 \le n,m \le 10^5$，图中涉及边长绝对值均不超过10000。</p></blockquote><p>（代码与Dijkstra算法的很像）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;  </span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())    </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];   <span class="comment">// j表示当前这个点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])   <span class="comment">//当j此前不在对列中，才将j加入到队列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">-1</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SPFA算法也可以用来判断路径中是否存在负环</strong>（判断负环一般用SPFA算法，时间复杂度低）。</p><blockquote><p>例题2：SPFA判断负环（Acwing 852）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你判断图中是否存在负权回路。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：如果图中存在负权回路，则输出“Yes”，否则输出“No”。</p><p>数据范围：$1 \le n \le 2000,1 \le m \le 10000$，图中涉及边长绝对值均不超过10000。</p></blockquote><p>用<code>dist[x]</code>数组表示从起点到当前点的最短距离，<code>cnt[x]</code>数组表示当前的最短路中边的数量，每次更新时有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist[x] = dist[x] + w[i];</span><br><span class="line">cnt[x] = cnt[t] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果过程中每一更新后<code>cnt[x] &gt;= n</code>，根据抽屉原理，路径上至少有一个点出现了两次，说明路径上存在一个环，又因为更新成功了，所有环一定是负环。</p><p>（代码只需在前一道题的基础上稍加修改即可）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;  </span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];   </span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为不需要求具体的距离了，所有不需要初始化了</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//负环不一定是从点1开始能到达的，可能出现在以某个点为起点的路径中，所以需要把所有点加入到队列中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())    </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];   <span class="comment">// j表示当前这个点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])   <span class="comment">//当j此前不在对列中，才将j加入到队列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span>(spfa())  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p><strong>Floyd算法是用来解决多源汇最短路问题的</strong>，时间复杂度为$O(n^3)$，其思路是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用一个邻接矩阵d[i][j]存储图中所有的边;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">循环结束之后，d[i][j]存的是从点i到点j的最短路的长度</span><br></pre></td></tr></table></figure><p>Floyd算法是基于动态规划，$d[k, i, j]$表示从点$i$到点$j$，只经过1到$k$这些中间点，的最短距离，更新$d[k, i, j]$时有：</p><script type="math/tex; mode=display">d[k, i, j]= d[k-1, i, k] +d[k-1, k, j]</script><p>（关于动态规划的知识，之后会细讲。）</p><blockquote><p>例题：Floyd算法求最短路（Acwing 854）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。数据保证图中不存在负权回路。</p><p>输入格式：第一行包含三个整数n，m，k。接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p><p>输出格式：共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。</p><p>数据范围：$1 \le n \le 200, 1 \le k \le n^2, 1 \le m \le 20000$，图中涉及边长绝对值均不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> d[N][N];  <span class="comment">//用矩阵d存两点间的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;   <span class="comment">//循环结束之后，d[i][j]就存的是点i到点j之间的最短距离了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)        <span class="comment">//初始化距离矩阵d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i == j)  d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)   <span class="comment">//读取各边及其长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        </span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], w);   <span class="comment">//可能出现重边，只需保留其最小值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    floyd();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; INF / <span class="number">2</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最短路（Dijkstra，bellman-ford，spfa，Floyd）
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（7）</title>
    <link href="http://nekomoon404.github.io/2020/10/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89/</id>
    <published>2020-10-11T08:09:19.000Z</published>
    <updated>2020-10-12T08:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三章  搜索与图论</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>深度优先搜索—DFS，宽度优先搜索—BFS</strong></p><div class="table-container"><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th></th></tr></thead><tbody><tr><td>DFS</td><td>栈stack</td><td>$O(h)$</td><td>不具有最短性</td></tr><tr><td>BFS</td><td>队列queue</td><td>$O(2^h)$</td><td>“最短路”</td></tr></tbody></table></div><p>DFS中关键的两点是：<strong>回溯</strong>和<strong>剪枝</strong>，DFS可以从<strong>搜索树</strong>的角度来考虑。DFS解题最重要的考虑搜索的<strong>顺序</strong>。</p><blockquote><p>DFS例题1：排列数字（Acwing 842）</p><p>给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。</p><p>输入格式：共一行，包含一个整数n。</p><p>输出格式：按字典序输出所有排列方案，每个方案占一行。</p><p>数据范围：$1 \le n \le 7$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201011170111.png" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   <span class="comment">//注意i从1开始，因为要枚举的数是从1到n</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS例题2：n-皇后问题（Acwing 843）</p><p>n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数n，请你输出所有的满足条件的棋子摆法。</p><p>输入格式：共一行，包含整数n。</p><p>输出格式：每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。输出方案的顺序任意，只要不重复且没有遗漏即可。</p><p>数据范围：$1 \le n \le 9$。</p></blockquote><p>思路1：搜索顺序类似于全排列，从第一行开始，枚举皇后可以放到哪。可以提前判断当前方案一定是不合法的，就不用继续向下搜索了，直接回溯即可，这一过程就是“<strong>剪枝</strong>”。（时间复杂度：$O(n \cdot n!)$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[<span class="number">2</span> * N], udg[<span class="number">2</span> * N];  <span class="comment">//分别代表列，对角线，反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">puts</span>(g[i]);  <span class="comment">//打印棋盘的每一行</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//遍历每一列</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">'Q'</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：按棋盘格子开始枚举，放下皇后是一个分支，不放是另一个分支。（时间复杂度：$O(2^{n^2})$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N], col[N], dg[<span class="number">2</span> * N], udg[<span class="number">2</span> * N];  <span class="comment">//分别代表列，对角线，反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> s)</span>    <span class="comment">//x, y, s分别代表当前遍历的格子的行，列，已经摆好的皇后的个数</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (y == n)  y = <span class="number">0</span>, x ++;   <span class="comment">//遍历完一行后，转向下一行</span></span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个格子不放皇后</span></span><br><span class="line">    dfs(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个格子放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">'Q'</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        dfs(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>BFS的优势是可以搜索到最短路</strong>。（最短路问题包含DP动态规划问题，DP是没有环的最短路问题。）</p><p><strong>不是所有的问题都是最短路问题，只有当所有边的权重都相同时，才可以用BFS求最短路</strong>，一般情况下都要用专门的最短路算法求。</p><blockquote><p>BFS例题1：走迷宫（Acwing 844）</p><p>给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。</p><p>输入格式：第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。</p><p>输出格式：输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p>数据范围：$1 \le n,m \le 100$。</p></blockquote><p>从起点开始搜，第一步把所有距离为1的点搜一遍，第二步把所有距离为2的点搜一遍，……，</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012183018.png" style="zoom:50%;"></p><p>BFS解题的基本框架：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始状态放入队列 queue;</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空</span><br><span class="line">&#123;</span><br><span class="line">t = 队头;</span><br><span class="line">拓展 t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">//存放地图</span></span><br><span class="line"><span class="keyword">int</span> d[N][N];  <span class="comment">//存放每一个点到起点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;PII&gt; q;  <span class="comment">//存每个点的坐标(x, y)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);  <span class="comment">//初始化d，表示没有被搜索过</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//从(0, 0) 开始</span></span><br><span class="line">    q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">//用向量表示搜索的四个方向：上，右，下， 左</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();  <span class="comment">//取队头元素</span></span><br><span class="line">        q.pop();  <span class="comment">//将队头元素弹出，队列里保持只有一个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.push(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m <span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS例题2：八数码（Acwing 845）</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201014164329.png" style="zoom:80%;"></p><p>可以把3*3矩阵的一个状态看作图论中的一个点，若从一个状态经过一次操作可以变成另一个状态，就在对应的两个点之间连一条边。</p><p>本题难点：</p><ul><li><p>状态表示复杂，可以将3*3矩阵中的数用一个字符串来表示，如<code>&quot;1234x5678&quot;</code>，<code>queue&lt;string&gt; queue</code>；<code>dist[]</code>数组可以用字典来存，如<code>unordered_map&lt;string, int&gt; dist</code></p></li><li><p>如何记录每个状态的“距离” <code>dist[]</code>数组：（1）3*3矩阵；（2）枚举x能移动的位置；（3）将x移动后的矩阵恢复成字符串</p></li></ul><h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p><strong>树是特殊的图——无环连通图</strong>。<strong>图分为有向图和无向图</strong>，而无向图又可以看作是特殊的有向图，因此我们只需考虑有向图的遍历问题即可。</p><p>有向图的<strong>存储方式</strong>：</p><ol><li><strong>邻接矩阵</strong>：<code>g[a][b]</code>，表示$a \to b$的一条边；</li><li><strong>邻接表</strong>：每个节点上开一个单链表，<strong>存这个点可以走到哪些点</strong>。若有新连接的边，一般在链表的头节点插入新的点。</li></ol><p>树与图的<strong>遍历方式</strong>：</p><ol><li><strong>深度优先遍历</strong> </li><li><strong>宽度优先遍历</strong></li></ol><blockquote><p>深度优先遍历例题：树的重心（Acwing 846）</p><p>给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p>输入格式：第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。</p><p>输出格式：输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。（树的重心可能不唯一）</p><p>数据范围：$1 \le n \le 10^5$。</p></blockquote><p>在树的深度优先遍历时，可以求出每棵子树中的点的数量。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012201101.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;    </span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;  <span class="comment">//idx 存当前的边数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];  <span class="comment">//表示当前点是否已经被搜过了；在深度优先遍历或者宽度优先遍历中每个点只会被遍历一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = N;   <span class="comment">//存最后的结果，即删除重心后，使剩余连通块点的数目的最大值最小 的那个值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>    <span class="comment">//深度优先遍历，返回以u为根的子树中的点的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;  <span class="comment">//标记当前点已经被搜过了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sum存当前子树中点的数目，res存将当前点删除后，剩余连通块中点的数目的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = dfs(j);</span><br><span class="line">            res = <span class="built_in">max</span>(res, s);</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);</span><br><span class="line">    </span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b), add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>);   <span class="comment">//搜索的是图中的结点编号，结点编号从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>宽度优先遍历例题：图中点的层次（Acwing 847）</p><p>给定一个n个点m条边的有向图，图中可能存在<strong>重边</strong>和<strong>自环</strong>。所有边的长度都是1，点的编号为1~n。请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。</p><p>数据范围：$1 \le n,m \le 105$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012201600.png" style="zoom: 40%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> d[N], q[N];   <span class="comment">//q[]存 用数组模拟的队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++];    <span class="comment">//取出队头，并弹出队头</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;   <span class="comment">//将下一步能走的点放入队列（其实就是队头，队列中一直只有一个元素）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>图的宽度优先遍历的一个很经典的应用是：<strong>图的拓扑序列</strong>，拓扑序列是针对有向图的。<strong>若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列</strong>。</p><p>也就是说，当把图按照拓扑序排列好后，所有的边都是从前指向后的（点在序列中的顺序）。并不是所有图都有拓扑序列，如存在环的图。<strong>一个有向无环图，一定存在拓扑序列</strong>，因此有向无环图也叫作拓扑图。</p><p>点的<strong>入度</strong>与<strong>出度</strong>：</p><ul><li><p>入度：一个点有多少条边指向自己，就是它的入度；</p></li><li><p>出度：一个点有多少条边从自己出去，就是它的出度。</p></li></ul><p>入度为0的点可以作为起点（当前最前面的位置），一个有向无环图，至少存在一个入度为0的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">所有入度为<span class="number">0</span>的点入队列 <span class="built_in">queue</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空</span><br><span class="line">&#123;</span><br><span class="line">    t = 队头;</span><br><span class="line">    枚举t的所有出边 t-j</span><br><span class="line">    &#123;   删掉t-j, j的入度减<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j的入度为<span class="number">0</span>):</span><br><span class="line">        队头 = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N];   <span class="comment">//d[] 表示一个点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>)  q[++ tt] = j;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;  <span class="comment">//若所有点已经入队，那队尾就是n-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">        d[b] ++;    <span class="comment">//d[]表示一个点的入度，注意这里要入度++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(topsort())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);  <span class="comment">//q[]中的次序恰好就是拓扑序列</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第三章内容：深度优先搜索、宽度优先搜索、树与图的存储、树与图的深度优先遍历，树与图的宽度优先遍历，拓扑排序。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（6）</title>
    <link href="http://nekomoon404.github.io/2020/10/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89/</id>
    <published>2020-10-09T10:17:48.000Z</published>
    <updated>2020-10-11T07:14:08.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>主要讲两部分内容：<strong>存储结构</strong>—（开放寻址法，拉链法），<strong>字符串哈希方式</strong></p><p>哈希表的主要作用是把一个比较大的空间映射到一个比较小的空间（如0-N），如$x \in (-10^9,10^9)$，哈希函数$h(x) \in (0,10^5)$。</p><p>如何构造哈希函数：</p><ol><li>直接取模  $x \quad\% \quad 10^5 \in (0,10^5)$；（取模的这个数一般要取成质数，且要离2的几次方尽量远，这样冲突的几率是较小的）</li><li>冲突：直接取模会把不同的数映射到相同的数。处理冲突的方式可以分为：开放寻址法和拉链法</li></ol><p>在算法题中一般不需要在哈希表中进行删除操作，一般只有添加和查找操作。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>拉链法：开一个一维数组<code>h[]</code>来存储所有的哈希值。每一次当把一个$x$映射到某一个数时，假设第$1$个数插入11，,$h(11)=3$，就在3下面拉一条链（单链表），存下11，即<code>e[1]=11; ne[1]=h[3]=0; h[3]=1</code>；如果第$4$次插入另一个数23，$h(23)=3$，就将23插入到h[3]下面这条链表中，插到头节点，即让<code>e[4] = 23; ne[4] = h[3]= 1, ne[23]=4</code>。</p><p>当要查找数11时，先求$h(11)=3$，循环<code>for(i = h[k]; i != -1; i = ne[i])</code>，首先<code>i = h[3] = 4</code>，而<code>e[4]=23</code>不等于11；就让<code>i=ne[4]=1</code>，<code>e[1]=11</code>，因此就找到了11。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201010165518.png" style="zoom: 67%;"></p><blockquote><p>例题1：模拟散列表</p><p>维护一个集合，支持如下几种操作：</p><p>“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；</p><p>现在要进行N次操作，对于每个询问操作输出对应的结果。</p><p>输入格式：第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。</p><p>输出格式：对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。</p><p>数据范围：$1 \le N \le 10^5$，$-10^9 \le x \le 10^9$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;  <span class="comment">//让负数模N的结果也是正数</span></span><br><span class="line">    e[idx] = x;       <span class="comment">//e[]存第idx个插入的数的值</span></span><br><span class="line">    ne[idx] = h[k];   <span class="comment">//ne[]存第idx个插入的数的next节点，每次在拉链上插入都是插入到头节点</span></span><br><span class="line">    h[k] = idx ++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  insert(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法：只开一个数组，但数组长度要开到题目给出的数据范围的2-3倍（经验值）。</p><p>添加：$h(x)=k$，先找到k，从第k个坑位开始找，直到找到第一个空的坑位为止，插入。</p><p>查找：从第k个坑位开始，从前往后找，每一次看当前坑位是否有数，若是x则查找成功；若不是x，就往后找；若坑位没数，则查找失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>;  <span class="comment">//先找到大于200000的最小质数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null = <span class="number">0x3f3f3f3f</span>;   <span class="comment">//找一个数表示坑位没人，要在题目数据范围之外</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x在哈希表中已经存在，就返回x的位置；若x在哈希表中不存在，就返回它应该存储的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N)  k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//按字节来初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h4><p>字符串哈希方式——字符串前缀哈希法</p><p><code>str=&quot;ABCABCDEYXCAcwing&quot;</code>，预处理出所有前缀的哈希，如<code>h[0]=0</code>；<code>h[1]=&quot;A&quot;的哈希值</code>；<code>h[2]=&quot;AB&quot;的哈希值</code>,……</p><p>如何来定义某一个前缀的哈希值：把字符串看成一个P进制的数，如$”ABCD”=(1234)_P=1 \times P^3+ 2 \times P^2 + 3 \times P^2 + 4 \times P^0$，若字符串很长，那转化后的数会很大，因此可以让其模上一个较小的数$Q$，这样就能把字符串映射到$0 $~ $Q-1$之间的数。计算前<code>i</code>个字符的前缀就是：<code>h[i] = h[i-1]* p + str[i]</code></p><p>要注意的是：<strong>不能把一个字母映射到0</strong>；前一小节中哈希数字时可能发生冲突，这里的字符串哈希是假定我们人品够好，<strong>不去考虑冲突的情况</strong>，当然也有经验值：$P=131或13331$，$Q=2^{64}$时，$99.99\%$不会遇到冲突。</p><p>这样做的好处：<strong>可以利用前缀哈希，计算出任意一个子段的哈希值</strong>。</p><p>如已知从1到R的哈希值<code>h[R]</code>，从1到L-1的哈希值<code>h[L-1]</code>，由于左边时高位，右边是低位。先将<code>h[L-1]</code>这一段往左移若干位，让它和<code>h[R]</code>这一段右端点对齐（就是让哈希值位数相等，相当于在<code>h[L]</code>后面补0啦），然后两段哈希值相减，用公式表示就是：</p><script type="math/tex; mode=display">h[R]-h[L-1] \times P^{R-L+1}</script><p>还有一个技巧是：我们最后要模$2^{64}$，那直接可以用<code>unsinged long long</code>来存哈希值<code>h[]</code>，若溢出就等价于模$2^{64}$。</p><p>字符串哈希相较于kmp的独特作用：<strong>快速判断两个区间内的字符串是否相同</strong>。</p><blockquote><p>字符串哈希例题（Acwing 841）</p><p>给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数$l_1,r_1,l_2,r_2$，请你判断$[l_1,r_1]$和$[l_2,r_2]$这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。</p><p>输入格式：第一行包含整数n和m，表示字符串长度和询问次数。第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。接下来m行，每行包含四个整数$l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。注意，字符串的位置从1开始编号。</p><p>输出格式：对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。每个结果占一行。</p><p>数据范围：$1 \le n,m \le 10^5$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];  <span class="comment">//h[N]存字符串的哈希值，p[N]存p的几次方</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l <span class="number">-1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)     <span class="comment">//预处理p[]，即p的几次方；以及h[]，即字符串的前缀哈希值</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p><strong>vector</strong>：<strong>可变数组</strong>，采用倍增的思想——在数组扩展空间使，将其原来的空间再扩大一倍，对空间为n的大小只需扩展$\log (n)$次即可，对每一次的扩展只用$O(1)$来实现。（系统为某一程序分配空间时，所需时间与空间大小无关，与请求次数有关）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个vector</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个vector，指定长度为100，先初始化为1</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求变长数组a的长度，时间复杂度为O(1)；所有容器都有</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断变长数组a是否为空，时间复杂度为O(1)；所有容器都有</span></span><br><span class="line">a.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空变长数组a；.clear()并不是所有容器都有，如队列，就没有.clear( )</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向变长数组a的末尾压入数x</span></span><br><span class="line">a.push_back(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将变长数组a的末尾元素删除</span></span><br><span class="line">a.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取变长数组a的第一个元素和最后一个元素</span></span><br><span class="line">a.front(), a.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取迭代器第一个元素和最后一个元素(指针)</span></span><br><span class="line">a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//三种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"><span class="comment">//vector &lt;int&gt; :: iterator i;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector是支持比较运算的，按字典序比较</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">4</span>, <span class="number">3</span>), b(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)  <span class="built_in">puts</span>(<span class="string">"a &lt; b"</span>);    <span class="comment">//输出 a &lt; b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二元组：pair &lt;int, int&gt;、pair &lt;int, string&gt;、pair &lt;int, char&gt;等</span></span><br><span class="line"><span class="comment">//在进行排序时先以first的字典序进行排列，后以second的字典序进行排列</span></span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII a;       </span><br><span class="line"><span class="built_in">vector</span> &lt;PII&gt; a;  <span class="comment">//与vector操作类似，但push_back(&#123;x, c&#125;)，注意&#123;&#125;</span></span><br><span class="line"><span class="comment">//向a中添加一个元素</span></span><br><span class="line">a = maek_pair(x, y);</span><br><span class="line">a = &#123;x, y&#125;;</span><br><span class="line"><span class="comment">//取出a中的第一、二个元素</span></span><br><span class="line">a.first, a.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设某个东西有两种不同的属性，这时就可以用pair存；若要按某种属性进行排序，就把这个属性存入pair中的first。</span></span><br></pre></td></tr></table></figure><p><strong>string</strong>： C++封装好的<strong>字符串</strong>，可支持多种操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求字符串的长度</span></span><br><span class="line">s.<span class="built_in">size</span>(), s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串是否为NULL</span></span><br><span class="line">s.empty();</span><br><span class="line"><span class="comment">//将字符串置为空字符串</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可在字符串末尾添加字符或字符串</span></span><br><span class="line">s += <span class="string">'A'</span>;</span><br><span class="line">s += 'ABCD';</span><br><span class="line"></span><br><span class="line"><span class="comment">//取子串substr(下x, y)(重点)，取下标从x开始的长度为y的子串。</span></span><br><span class="line">s.substr(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回字符串的的首地址</span></span><br><span class="line">s.C_str();</span><br></pre></td></tr></table></figure><p><strong>queue：队列</strong>，先进先出，通常用于广度优先（bfs）等算法，可支持插入队尾，弹出队头等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队尾插入元素x</span></span><br><span class="line">q.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将队头元素弹出</span></span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line">q.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取队头、队尾元素</span></span><br><span class="line">q.front(), q.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不能使用clear()，若要清空，可以直接建一个新的队列</span></span><br><span class="line">q = <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; ();</span><br></pre></td></tr></table></figure><p><strong>priority_queue：优先队列</strong>（实现原理是堆），队列中的元素按照某种顺序规则排序，<strong>默认是大根堆</strong>，A*算法等是需要用到的。</p><blockquote><p>堆(Heap)分为小根堆和大根堆两种，对于一个小根堆，它是具有如下特性的一棵完全二叉树：<br>    (1)若树根结点存在左孩子，则根结点的值(或某个域的值)小于等于左孩子结点的值(或某个域的值)； </p><p>​     (2)若树根结点存在右孩子，则根结点的值(或某个域的值)小于等于右孩子结点的值(或某个域的值)； </p><p>​     (3)以左、右孩子为根的子树又各是一个堆。 </p><p>大根堆的定义与上述类似，只要把小于等于改为大于等于就得到了。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成小根堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,  greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向堆中插入一个元素x</span></span><br><span class="line">q.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回堆顶元素</span></span><br><span class="line">q.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出堆顶元素</span></span><br><span class="line">q.pop();</span><br></pre></td></tr></table></figure><p><strong>stack：栈</strong>，与队列类似，区别是先进后出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈顶插入一个元素</span></span><br><span class="line">stk.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出栈顶元素</span></span><br><span class="line">stk.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">stk.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line">stk.empty();</span><br></pre></td></tr></table></figure><p><strong>deque：双端队列</strong>，既可以对队头操作，与可以对队尾操作，但是时间复杂度相对较高；双端队列可支持的操作较多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取双端队列大小</span></span><br><span class="line">q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双端队列是否为NULL</span></span><br><span class="line">q.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空双端队列，无需按q = deque &lt;int&gt; ()重新赋值</span></span><br><span class="line">q.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个元素(队头)、最后一个元素(队尾)</span></span><br><span class="line">q.front(), q.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//队尾插入、弹出一个元素</span></span><br><span class="line">q.push_back(x), q.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头插入、弹出一个元素</span></span><br><span class="line">q.push_front(x), q.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可使用随机寻址 []</span></span><br><span class="line"><span class="comment">//也支持迭代器q.begin()、q.end()</span></span><br></pre></td></tr></table></figure><p><strong>set/multiset，map/multimap，是基于平衡二叉树（红黑树），动态维护有序序列</strong>。</p><p><strong>set/multiset：集合</strong>，集合中的元素是从小至大排好序的。<strong>set里面所有的元素都不可重复</strong>（集合的互异性），自动去重的功能。<strong>multiset里面所有的元素可以重复</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持迭代器，也支持--(前驱)、++(后继)操作，时间复杂度为O(logn)</span></span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; iterator :: it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素x，时间复杂度为O(1)</span></span><br><span class="line">s.insert(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素x，若输入是一个数，就删除所有x，时间复杂度为O(k+logn)；若输入一个迭代器，就删除这个迭代器</span></span><br><span class="line">s.erase(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回集合元素的个数</span></span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回某一个元素的个数</span></span><br><span class="line">s.count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line">s.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素x是否在集合中出现，如果不出现则返回s.end()，否则返回对应的迭代器</span></span><br><span class="line">s.<span class="built_in">find</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作: 返回大于等于x的第一个元素（大于等于x的最下的数）的迭代器</span></span><br><span class="line">lower_bound(x);</span><br><span class="line"><span class="comment">//返回大于x的第一个元素的迭代器</span></span><br><span class="line">upper_bound(x);</span><br></pre></td></tr></table></figure><p><strong>map/multimap</strong>： STL的一个<strong>关联容器</strong>，它<strong>提供一对一的hash</strong>。map/multimap 在插入元素时，内部按照key进行从小到大进行排序。核心为映射key - value，支持随机访问[]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">multiimap &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ms;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">p = make_pair(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入的数是一个pair</span></span><br><span class="line">m.insert(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除，输入的参数是pair或者迭代器</span></span><br><span class="line">m.erase(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">m.<span class="built_in">find</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以完全像数组一样来使用map，时间复杂度为O(logn)</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line">a[<span class="string">"yxc"</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也支持lower_bound()，upper_bound()</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set，unordered_map，unordered_multiset，unordered_multimap</strong>，哈希表。和上面类似，可以理解为无序版，增删改查的时间复杂度为$O(1)$。但不支持<code>lower_bound()</code>，<code>upper_bound()</code>，迭代器的<code>++</code>，<code>--</code>。</p><p><strong>bitset：压位</strong></p><p>C++中的<code>bool</code>数据类型是占一个字节，如要开一个1024个<code>bool</code>的数组，就要$1024 B=1KB$的空间，bitset可以在一个字节压8位，则就只要$128B$的空间。<strong>bitset</strong>使用的内存是正常的bool数组的八分之一。</p><p>如要存一个10000<em>10000的<code>bool</code>矩阵，那就需要$10^8 B = 100 MB$的空间，若题目限制空间为$64MB$，则可以使用<em>*bitset</em></em>进行压位，就只需12MB的空间了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10000&gt; s;</span><br><span class="line"><span class="comment">//支持各种位运算操作 </span></span><br><span class="line">~, &amp;, |, ^, </span><br><span class="line">&gt;&gt; , &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line">    </span><br><span class="line">s.count();  <span class="comment">//返回有多少个1</span></span><br><span class="line">s.any();   <span class="comment">//判断是否至少有一个1</span></span><br><span class="line">s.none();  <span class="comment">//判断是否全为0</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">set</span>();       <span class="comment">//把所有位置成1</span></span><br><span class="line">s.<span class="built_in">set</span>(k, v);   <span class="comment">//把第k位变成v</span></span><br><span class="line">s.reset();     <span class="comment">//把所有位置变成0</span></span><br><span class="line">s.flip();      <span class="comment">//等价于~</span></span><br><span class="line">s.flip(k);     <span class="comment">//把第k位取反</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      哈希表，STL
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（5）</title>
    <link href="http://nekomoon404.github.io/2020/10/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89/</id>
    <published>2020-10-07T12:31:03.000Z</published>
    <updated>2020-10-09T09:20:35.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p><strong>Trie树是用来快速存储和查找字符串集合的数据结构。</strong></p><blockquote><p>Trie树的基础知识可以参考：</p><p>Trie树例题：Trie字符串统计（Acwing 835）</p><p>维护一个字符串集合，支持两种操作：</p><ol><li><p>“I x”向集合中插入一个字符串x；</p></li><li><p>“Q x”询问一个字符串在集合中出现了多少次。</p></li></ol><p>共有N个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p><p>输入格式：第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。</p><p>输出格式：对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。</p><p>数据范围：$1 \le N \le 2 \times 10^4$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007210654.png" style="zoom: 67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//son[N][26]存Trie树中每个节点的儿子</span></span><br><span class="line"><span class="comment">//cnt[]表示以当前节点为结尾的单词的个数</span></span><br><span class="line"><span class="comment">//idx表示当前用到的下标，注意：下标是0的点，即是根节点，又是空节点</span></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span>  <span class="comment">//插入操作：在当前的Trie树中插入一个字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span>   <span class="comment">//返回字符串出现的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  insert(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Trie树例题2：最大异或对</p><p>在给定的N个整数$A_1，A_2……A_N$中选出两个进行xor（异或）运算，得到的结果最大是多少？</p><p>输入格式：第一行输入一个整数N。第二行输入N个整数$A_1$～$A_N$。</p><p>输出格式：输出一个整数表示答案。</p><p>数据范围：$1 \le N \le 10^5$，$0 \le A_i  \le 2^31$。</p></blockquote><p>异或运算是按位运算（二进制），相同得0，不同得1。同样先考虑暴力做法，可以用两重循环来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//枚举第一个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)   <span class="comment">//枚举第二个数</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, a[i] ^ a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑用Trie树来优化内层循环，即从$a_0$到$  a_{i-1}$中找到与$a_i$异或最大的数。本题的数据范围是$0 \le a_i \le 2^31$，因此每个数可以看出一个31位的二进制串，假设$a_i=101110…1$，要找到与$a_i$异或最大的数，就要异或结果高位是1比较好，因此按$a_i$的位数从左往右找，在$a_0$到$  a_{i-1}$中，先找第30位是0的数，再从这部分数中找第29位是1的数，依次类推。在Trie树中，对于每个$a_i$，先查找再插入。</p><blockquote><p>Trie树 不光可以存储字符串，也可以存储整数，也可以存储二进制数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//在Trie树中插入一个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//从最高位开始存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;    <span class="comment">//取二进制的每一位数</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//在当前的树中找出与x异或结果最大的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])          <span class="comment">//优先寻找是否有与当前位数相反的子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + !u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> + u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        insert(a[i]);         <span class="comment">//这里先插入再查找是为了避免处理边界问题，少写判断，即一开始树是空的</span></span><br><span class="line">        <span class="keyword">int</span> t = query(a[i]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, a[i] ^ t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的作用：</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p>并查集可以在近乎$O(1)$的时间内完成这两个操作。</p><p>基本思想：每一个集合用一棵树（不一定是二叉树）来维护，树根的编号就是整个集合的编号，对于每一点都存储其父节点是谁，<code>p[x]</code>表示<code>x</code>的父节点。</p><p>问题1：如何判断树根： <code>if(p[x] == x)</code></p><p>问题2：如何求x的集合编号：<code>while(p[x] != x)  x = p[x];</code></p><p>问题3：如何合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号，<code>p[x]=y</code></p><p>针对问题2的优化：<strong>路径压缩</strong>。一旦从一个点往上找找到了根节点，就把这条路径上所有的点都指向根节点。</p><blockquote><p>并查集例题1（Acwing 836）：</p><p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p><p>现在要进行m个操作，操作共有两种：</p><ol><li>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作</li><li>“Q a b”，询问编号为a和b的两个数是否在同一个集合中；</li></ol><p>输入格式：第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。</p><p>数据范围：$1 \le n, m \le 10^5$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//返回x的祖宗节点 + 路劲压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)  p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  p[i] = i;  <span class="comment">//最开始每个数各自在一个集合中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];  </span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>)  p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);  <span class="comment">//将数a和b所在的两个集合合并，即让find(a)的父节点是find(b)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);   <span class="comment">//询问数a和b是否在同一个集合内，即find(a)是否等于find(b)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集例题2：连通块中点的数量（Acwing 837）</p><p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。现在要进行m个操作，操作共有三种：</p><ol><li>“C a b”，在点a和点b之间连一条边，a和b可能相等；</li><li>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；</li><li>“Q2 a”，询问点a所在连通块中点的数量。</li></ol><p>输入格式：第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p><p>数据范围：$1 \le n, m \le 10^5$</p></blockquote><p>可以发现这道题的前两个操作和并查集是一样的，我们可以用一个集合维护连通块，一个连通块中的点就在一个集合当中。当在两个连通块之间连一条边时，起到的作用就是把两个集合合并。额外的操作是统计一个集合中点的数量。</p><p>用cnt[N]表示每个集合中点的数量，我们只保证根节点的cnt[]是有意义的。将数a和b所在的两个集合合并时，即让find(a)的父节点是find(b)，然后让find(b)的cnt等于find(a)的cnt加上find(b)的cnt。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], cnt[N];  <span class="comment">//size[]存放每个集合中点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//返回x的祖宗节点 + 路劲压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)  p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//最开始每个数各自在一个集合中</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; </span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">4</span>];  </span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="keyword">continue</span>;   <span class="comment">//如果a和b在同一个集合中，那么就忽略这次合并操作</span></span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];  <span class="comment">//合并集合时，更新集合中点的数量，即find(b)的size[]</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);  <span class="comment">//将数a和b所在的两个集合合并，即让find(a)的父节点是find(b)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);   <span class="comment">//询问数a和b是否在同一个集合内，即find(a)是否等于find(b)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[<span class="built_in">find</span>(a)]);  <span class="comment">//询问a所在的集合中点的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集例题3：食物链（Acwing 240）</p><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：</p><p>第一种说法是”1 X Y”，表示X和Y是同类。</p><p>第二种说法是”2 X Y”，表示X吃Y。</p><p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><p>1） 当前的话与前面的某些真的话冲突，就是假话；</p><p>2） 当前的话中X或Y比N大，就是假话；</p><p>3） 当前的话表示X吃X，就是假话。</p><p>你的任务是根据给定的N和K句话，输出假话的总数。</p><p>输入格式：第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。</p><p>输出格式：只有一个整数，表示假话的数目。</p><p>数据范围：$1 \le N \le 50000, 0 \le K \le100000$。</p></blockquote><p>通过确定每个点与根节点之间的关系，来确定任意两个点之间的关系。由于三种动物的关系是循环被吃，就用每个点到根节点之间的距离来表示它与根节点之间的关系。如果一个点到根节点的距离是1，表示它可以吃根节点；如果一个点到根节点的距离是2，表示它被根节点吃（<strong>1吃根，2吃1，根吃2</strong>）；如果一个点到根节点的距离是3，表示它和根节点是同类…….如此类推，每3个 一循环。因此可以把集合中所有的点归为三类，<strong>用并查集维护每个点到根节点的距离</strong>，按<strong>点到根节点的距离对3取模</strong>：</p><ul><li>余1——可以吃根节点；</li><li>余2——可以被根节点吃；</li><li>余0——与根节点是同类。</li></ul><p>在用并查集维护时，每个点存的是其到父节点的距离，做路径压缩时，就更新为其到根节点的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  p[i] = i;  <span class="comment">//有n个动物，以1-N编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)  res ++;   <span class="comment">//如果x大于n，或者y大于n，则一定是假话；</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);   <span class="comment">//先找到x和y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>)  res ++;   <span class="comment">//当x 和 y 在同一个集合内时，x，y到根节点的距离模3不相等时一定是假话</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)    <span class="comment">//当x 和 y不在同一个集合内时，就要合并,q且要让两者是同类（这时还没法判断，因为不在一个集合内）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;  <span class="comment">//不妨让x的根节点的父节点 等于 y的根节点的父节点</span></span><br><span class="line">                    d[px] = d[y] - d[x];  <span class="comment">//这样(d[x] + d[px] - d[y]) % 3就等于0了，即x和y是同类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>)  res ++; <span class="comment">//当x和y在同一个集合内时，x到根节点距离模3比y的多1就是真话，否则就是假话</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)   <span class="comment">//当x和y不在同一个集合内时，合并集合，更新距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆，要支持的操作：</p><ol><li>插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li><li>删除任意一个元素</li><li>修改任意一个元素</li></ol><p>堆是一棵完全二叉树。小根堆：每个点的值都小于等于左右儿子的。</p><blockquote><p>堆的基础知识可以参考：数据结构与算法（19）优先级队列</p><p>完全二叉树的基础知识可以参考：</p></blockquote><p><strong>用数组模拟堆</strong>，堆的存储方式：用一个一维数组，1号点是根节点（下标从1开始），节点x的左儿子是2x，右儿子是2x+1。有<strong>两个基本操作</strong>：<code>down(x)</code>，把一个节点往下移，如果把一个节点的值变大了，它有可能就要往下移；<code>up(x)</code>，把一个节点往上移，如果把一个数变小了，它有可能就要往上移 。用这两个基本操作就可以实现上面的五个操作：</p><ol><li>插入一个数：<code>heap[++ size] = x; up[x];</code></li><li>求集合当中的最小值：<code>heap[1];</code></li><li>删除最小值：（用堆的最后一个元素覆盖掉堆顶元素）<code>heap[1] = heap[size]; size--; down(1);</code></li><li>删除任意一个元素：<code>heap[k] = heap[size]; size --; down(k); up(k);</code>（每次donw和up只会执行一个）</li><li>修改任意一个元素：<code>heap[k] = x; down(k); up(x);</code></li></ol><blockquote><p>堆例题1：堆排序（Acwing  838）</p><p>输入一个长度为n的整数数列，从小到大输出前m小的数。</p><p>输入格式：第一行包含整数n和m。第二行包含n个整数，表示整数数列。</p><p>输出格式：共一行，包含m个整数，表示整数数列中前m小的数。</p><p>数据范围：$1 \le m, n \le 10^5$，$1 \le 数列中元素 \le 10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;  <span class="comment">//t表示当前节点u，它的左右孩子，三者之间的最小值的下标</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])  t = u * <span class="number">2</span>;    <span class="comment">//t和左孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])  t = u * <span class="number">2</span> + <span class="number">1</span>;   <span class="comment">//t和右孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)   <span class="comment">//当前节点不是最小值时，down操作要求它与左右孩子中的最小值交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u], h[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);   <span class="comment">//下标从1开始</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建堆，后n / 2 个元素是在最低层的，它们没有左右孩子，保持不动就行；让i = n / 2开始倒着进行down操作即可建堆</span></span><br><span class="line">    <span class="comment">//从 i = n / 2 开始，是保证每次down的时候，下面的孩子节点已经是堆了；这样建堆的时间复杂度是O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i ; i--)  down(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, h[<span class="number">1</span>]);   <span class="comment">//取堆顶元素，即堆中的最小值</span></span><br><span class="line">        <span class="comment">//删除堆顶元素</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆例题2：模拟堆（Acwing 839）</p><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><p>“I x”，插入一个数x；</p></li><li><p>“PM”，输出当前集合中的最小值；</p></li><li><p>“DM”，删除当前集合中的最小值（数据保证此时的最小值唯一）；</p></li><li><p>“D k”，删除第k个插入的数；</p></li><li><p>“C k x”，修改第k个插入的数，将其变为x；</p></li></ol><p>输入格式：第一行包含整数N。接下来N行，每行包含一个操作指令，操作指令为”I x”，”PM”，”DM”，”D k”或”C k x”中的一种。</p><p>输出格式：对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。每个结果占一行。</p><p>数据范围：$1 \le N \le 10^5$，$-10^9 \le x \le 10^9$</p></blockquote><p>这道题的难点在于操作4和5，怎么快速地找到第k个插入的数。这就需要额外维护两个数组，用ph[k]存第k个插入的点在堆中的位置(下标)，hp[k]表示堆中的位置为k的点是第几个插入的点；如ph[j] = k, hp[k] = j; 可以理解为映射。这样例题1代码中普通的<code>swap()</code>操作就要改成这里的堆的特有的交换操作<code>heap_swap()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], cnt;  </span><br><span class="line"><span class="keyword">int</span> ph[N], hp[N]; </span><br><span class="line"><span class="comment">//ph[k]存第k个插入的点在堆中的位置(下标)，hp[k]表示堆中的位置为k的点是第几个插入的点；如ph[j] = k, hp[k] = j; 可以理解为映射</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  <span class="comment">//a，b是数在堆中的位置，这个需要注意一下</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]], ph[hp[b]]);   </span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;  <span class="comment">//t表示当前节点u，它的左右孩子，三者之间的最小值的下标</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])  t = u * <span class="number">2</span>;    <span class="comment">//t和左孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])  t = u * <span class="number">2</span> + <span class="number">1</span>;   <span class="comment">//t和右孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)   <span class="comment">//当前节点不是最小值时，down操作要求它与左右孩子中的最小值交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;  <span class="comment">//m记录插入了多少个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"I"</span>))  <span class="comment">//插入一个数x</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            up(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"PM"</span>)) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h[<span class="number">1</span>]);  <span class="comment">//输出集合中最小的数，即堆顶</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"DM"</span>))  <span class="comment">//删除集合中最小的数，即堆顶</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"D"</span>))   <span class="comment">//删除插入的第k个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            heap_swap(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            down(k);  up(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//修改第k个插入的数，将其变为x</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            down(k);  up(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Trie树，并查集，堆。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（4）</title>
    <link href="http://nekomoon404.github.io/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/</id>
    <published>2020-10-05T10:30:14.000Z</published>
    <updated>2020-10-07T12:28:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>第二章 数据结构</p><ul><li>链表</li><li>栈与队列</li><li>kmp</li></ul><p>这节课主要讲如何<strong>用数组模拟链表，栈与队列</strong>。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>我们知道链表可以通过结构体+指针来实现，但每次创建一个新节点就要通过<code>new Node;</code> 来实现，这一过程是很慢的，在做笔试题时一般不会采用这样的动态链表的方式，常用的是用数组来模拟链表，又分为两种：</p><ul><li>单链表，其中在算法题中用的最多的是邻接表，它最主要的应用是存储图和树</li><li>双链表，主要作用是优化某些问题</li></ul><blockquote><p>关于链表的基础知识可以参考之前写的 Cpp基础（6）结构体与链表</p></blockquote><p>数组模拟<strong>单链表</strong>：用两个数组<code>e[N]</code>和<code>ne[N]</code>，它们通过下标关联起来，下标从0开始，<code>e[i]</code>用来存放第<code>i</code>个节点的值，<code>ne[i]</code>用来存放第<code>i</code>个节点指向的next节点的下标，空节点的下标用-1来表示。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110923.png" style="zoom: 67%;"></p><ul><li><p>单链表例题（Acwing 826）：</p><p>实现一个单链表，链表初始为空，支持三种操作：</p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头节点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">//ne[i] 表示节点i的next指针是多少（指向的下一个节点的下标）</span></span><br><span class="line"><span class="comment">//idx 表示当前已经用到了哪个点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标是k的点的后面（下标是k表示第k+1个插入链表中的数，与其位置无关）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点从链表中删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( m-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'H'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k)  head = ne[head];  <span class="comment">//若要删除的节点是头节点</span></span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);   <span class="comment">//下标从0开始，第k个插入的数下标是k-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])  <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双链表</strong>的每个节点有两个指针，一个指向前面的点 ，一个指向后面的点，用数组<code>l[]</code>存放节点左边的点的下标，用数组<code>r[]</code>存放节点右边的点的下标。这里我们偷个懒，让下标是0的点是head，让下标是1的点是tail。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110934.jpg" style="zoom: 40%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110939.jpg" style="zoom:42%;"></p><ul><li><p>双链表例题（Acwing 827）</p><p>实现一个双链表，双链表初始为空，支持5种操作：</p><p>(1) 在最左侧插入一个数；</p><p>(2) 在最右侧插入一个数；</p><p>(3) 将第k个插入的数删除；</p><p>(4) 在第k个插入的数左侧插入一个数；</p><p>(5) 在第k个插入的数右侧插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0表示head， 1表示tail</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;   <span class="comment">//第k的插入的数下标就是k + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标是k的点的右边插入x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx ++;  <span class="comment">//注意这里的顺序不能变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除下标是k的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"L"</span>)   <span class="comment">//注意这里要用双引号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"R"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"IL"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i])  <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><ul><li><p><strong>栈：先进后出</strong></p></li><li><p><strong>队列：先进先出</strong></p></li></ul><blockquote><p>栈与队列的基础知识可以参考之前写的 数据结构与算法（7）栈与队列</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//****************栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt --;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt &gt; <span class="number">0</span>)  <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt)  <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然用数组模拟的队列还可以取队尾元素 q[tt];</span></span><br></pre></td></tr></table></figure><ul><li><p>数组模拟栈例题（Acwing 828）</p><p>实现一个栈，栈初始为空，支持四种操作：</p><p>(1) “push x” – 向栈顶插入一个数x；</p><p>(2) “pop” – 从栈顶弹出一个数；</p><p>(3) “empty” – 判断栈是否为空；</p><p>(4) “query” – 查询栈顶元素。</p><p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。数据范围：$1 \le M \le 100000$，$1 \le x \le 10^9$。所有操作保证合法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"push"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            stk[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"pop"</span>)  tt --;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"empty"</span>)  <span class="built_in">cout</span> &lt;&lt; (tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>数组模拟队列例题（ACwing 829）</p><p>实现一个队列，队列初始为空，支持四种操作：</p><p>(1) “push x” – 向队尾插入一个数x；</p><p>(2) “pop” – 从队头弹出一个数；</p><p>(3) “empty” – 判断队列是否为空；</p><p>(4) “query” – 查询队头元素。</p><p>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。数据范围：$1 \le M \le 100000$，$1 \le x \le 10^9$。所有操作保证合法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"push"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            q[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"pop"</span>)  hh ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"empty"</span>)  <span class="built_in">cout</span> &lt;&lt; (hh &lt;= tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h3><p><strong>单调栈</strong>的常见题型：给定一个序列，求序列中每一个数左边离它最近的且比它小的数是多少。</p><ul><li>例题：给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</li></ul><blockquote><p>保证栈中的数是单调递增的，遍历数列中的数，对于数列中第i个数，若栈非空且栈顶元素大于等于它，就弹出栈顶，直到栈顶比它小，则栈顶即为所求；若栈空，说明不存所求。之后再把第i个数存入栈顶。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;  <span class="comment">//输入数据比较多时还是用scanf比较快</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x)  tt --;</span><br><span class="line">        <span class="keyword">if</span>(tt)  <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        </span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每个元素，最多只会进栈一次出栈一次，因此时间复杂度为$O(n)$。</p></blockquote><p>单调队列的常见题型：求滑动窗口中的最大值/最小值</p><ul><li>例题：滑动窗口（Acwing 154）</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007100602.png" style="zoom: 80%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007103030.png" style="zoom:33%;"></p><blockquote><p>遍历序列中的元素，i表示滑动窗口右端点元素的下标，用一个单调队列来维护当前的滑动窗口，保证队列中的元素是单调递增的，即每插入一个新元素，便判断队尾是否大于等于它，若是就弹出队尾，再把新元素插入队尾，这样每次求滑动窗口中的最小值只需取出队头即可。求滑动窗口中的最大值同理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];  <span class="comment">//单调队列q[N]，存放下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求滑动窗口中的最小值</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;  <span class="comment">//队头和队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经弹出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])  hh++;  <span class="comment">//每次只会出现一次，因此可以用if</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])  tt--;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求滑动窗口中的最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;  <span class="comment">//队头和队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经弹出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])  hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])  tt--;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用单调栈或者单调队列解题的思路都是：先用暴力做法求解，再考虑暴力做法的栈或队列中哪些元素是没有用的，删掉这些没用的元素，再看剩下的元素有没有单调性，如果有就可以考虑用栈或队列做优化。</p></blockquote><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>给定一个模式串S（长度为M），以及一个模板串P（长度为N），所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串P在模式串S中多次作为子串出现。求出模板串P在模式串S中所有出现的位置的起始下标。</p><p>数据范围：$1 \le N \le 10^5$，$1 \le M \le 10^6$。</p><blockquote><p>KMP算法的知识可以参考之前写的 数据结构与算法（20）串——3.KMP算法</p></blockquote><p>对于模板串要处理出一个：它的一个以第i个元素为右端点的后缀和一个前缀相等，相等的最大长度是多少。如<code>next[i]=j</code>，则说明<code>p[1,j]=p[i-j+1]</code>。</p><p><img src="/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/QQ图片20201007200936.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> p[N], s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求模板串P的next[]数组的过程，相当于是把P也当成模式 串，两个P进行kmp匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)  <span class="comment">//每次是s[i]和p[j+1]匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//匹配成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n);  <span class="comment">//输出模板串P在模式串S中出现的位置的起始下标</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第二章内容：链表，栈与队列，KMP。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（3）</title>
    <link href="http://nekomoon404.github.io/2020/10/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/</id>
    <published>2020-10-02T07:21:03.000Z</published>
    <updated>2020-10-03T15:29:59.894Z</updated>
    
    <content type="html"><![CDATA[<p>第一章 基础算法</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>算法6：双指针，通常有两种情况：</p><ul><li><p>两个指针分别指向两个序列，如归并排序</p></li><li><p>两个指针指向同一个序列，可以是一个在首一个在尾，两个指针共同维护一段区间，如快速排序</p></li></ul><p>代码结构一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; check(i, j))  <span class="comment">//i和j满足某种性质</span></span><br><span class="line">        j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面就是每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个指针在所有循环中总共移动的次数不超过$n$，双指针算法就是将朴素的两层for遍历（时间复杂度为$O(n^2)$）优化到$O(n)$。</p><p>解题的思路一般是：从朴素做法入手，从中发现一些问题的性质，如<strong>单调性</strong>等，将原来的$O(n^2)$时间复杂度优化到$O(n)$。</p><p>双指针的几个例子：</p><ol><li>读入一行字符串，其中有若干个单词，每个单词中间有一个空格隔开，要求输出每一个单词。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">' '</span>)  j++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++)  <span class="built_in">cout</span> &lt;&lt; str[k];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最长连续不重复子序列：给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</li></ol><blockquote><p><code>i</code>表示一段区间的右边界，<code>j</code>表示这段区间的左边界。遍历<code>i</code>，找到这段区间最左能到多远，即<code>j</code>的位置，当<code>i</code>向右移时，<code>j</code>一定是向右移或者是不动，一定不会向左移，即是这个问题的单调性，<code>i</code>和<code>j</code>在循环走过的长度都不会超过n，因此时间复杂度是$O(n)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];  <span class="comment">//s[]用来存放区间内每个数字出现的次数</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] --;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组元素的目标和：给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。<br>请你求出满足A[i] + B[j] = x的数对(i, j)。数据保证有唯一解。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i] + b[j] &gt; x)  j--;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>算法7：位运算</p><p>算法题中位运算的常用操作：</p><ul><li><p>求一个整数$n$的二进制表示中第$k$位数字是几，如$n=15=(1111)_2$，个位是第0位开始算。</p><ol><li>先把第$k$位移到最后一位，<code>n &gt;&gt; k</code>；</li><li>看个位数字是几，<code>n &amp; 1</code>；两步合并就是：<code>n &gt;&gt; k &amp; 1</code></li></ol></li><li><p><code>lowbit(x)</code>操作：返回<code>x</code>的最后一位1，如<code>x = 1010，lowbit(x) = 10</code>；<code>x = 101000，lowbit(x)=1000</code></p><ul><li><code>lowbit(x)</code>的实现：<code>x &amp; -x</code>，相当于是<code>x &amp; (~x + 1)</code>。（<code>~</code>表示取反）</li><li><code>lowbit(x)</code>的应用：统计<code>x</code>中1的个数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)  x -= lowbit(x), res++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>算法8：离散化</p><p>这里特指<strong>整数的离散化</strong>，它所针对的问题是：假设有一个数组，其元素个数很少，但元素的值域很大，如<code>a[5]={1, 3, 100, 2000, 500000}</code>，我们又需要以这些元素为下标进行一些其他的操作。再开一个500000长度的数组显然是不明智的，因此就需要离散化，将这些值域很大的数字映射到从0开始的连续的自然数。要进行离散化需要考虑两个问题：</p><ol><li><code>a[]</code>中可能有重复元素 $\to$ 去重；</li><li>如何快速地算出<code>a[i]</code>离散化后的值 $\to$ <code>a[]</code>是有序的，即找到数字的下标即可 $\to$ 二分</li></ol><p>代码模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;  <span class="comment">//存储所有待离散化的值</span></span><br><span class="line">sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());  <span class="comment">//将所有值排序</span></span><br><span class="line">alls.eras(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());  <span class="comment">//去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//找到第一个大于等于x的数的下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">//映射到1,2,3,...；若要映射到0, 1, 2, 3, ....就return r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p><p>数据范围：$-10^9 \le x \le 10^9$，$1\le n, m \le 10^5$，$-10^9 \le l \le r \le 10^9$，$-10000 \le c \le 10000$。</p><blockquote><p>可见相比于整个数轴的范围，要取的数是比较稀疏的，但是跨度很大，这些数的下标就可以用离散化的思想来处理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;  <span class="comment">//n, l, r分别需要10^5，所以需要用到的下标个数就是300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;  <span class="comment">//alls存放所要用到的数的下标，包括赋予了值的数的下标，以及待计算的区间的左右边界的下标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query;  <span class="comment">//add存放取出的数的下标和赋予的值，query存放待计算的区间的左右边界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];   <span class="comment">//a[]存放之前赋予过的值，s[]是a[]的前缀和，方便计算区间和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;   <span class="comment">//映射到1, 2, 3, ......方便后续的前缀和操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//读入n行，每行包含两个整数x和c</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x, c&#125;);</span><br><span class="line">        alls.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对alls序列排序和去重</span></span><br><span class="line">    sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将add中存放的下标和值的数对，下标按照alls排序后的顺序，值填入到数组a[]中，方便后续的前缀和计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理前缀和，到这一步就和之前讲过的前缀和一样了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)  s[i] += s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理待计算的区间的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以自己实现unique函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span>(!i || a[i] != a[i<span class="number">-1</span>])</span><br><span class="line">            a[j++] = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a[0]~a[j-1]中就存好了a[]中所有不重复的数字</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>算法9：区间合并</p><p> 若两个区间有交集，那就可以把它们合并到一个较长的区间，可以扩展到多个区间。</p><p>例子：给定$n$个区间$[l_i,r_i]$，要求合并所有有交集的区间。<strong>注意如果在端点处相交，也算有交集</strong>。</p><p>输出合并完成后的区间个数。例如：[1,3]和[2,6]可以合并为一个区间[1,6]。</p><p>数据范围：$1\le n \le 100000$，$-10^9 \le l_i \le r_i \le 10^9$。</p><p>解题思路：</p><ol><li>按区间左端点排序；</li><li>扫描整个区间，扫描的过程中把所有有交集的区间合并。每次维护一个当前的区间$[st, ed]$，设已扫描到第$i$个区间$[st_i, ed_i]$，那第$i$个区间和当前的区间的关系有：<ul><li>第$i$个区间在当前的区间的内部；$\to$ 当前区间不变</li><li>第$i$个区间与当前的区间有交集，但不全在其内部；$\to$ 当前区间更新成$[st, ed_i]$</li><li>第$i$个区间与当前的区间没有有交集。$\to$ 当前区间更新成$[st_i, ed_i]$</li></ul></li></ol><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002205419.jpg" style="zoom:40%;"></p><p>（与区间有关的题目的思路大多都是贪心）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//定义一个pair，存放区间的左右端点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());   <span class="comment">//sort先按segs.first排序，即先按区间左端点排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;   <span class="comment">//当前维护的区间的左右端点为st, ed</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)      <span class="comment">//第i个区间与当前区间没有交集，则可以把当前区间存入res，然后更新当前区间为第i个区间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>)  res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);   <span class="comment">//第i个区间与当前区间有交集，那就更新当前区间的右端点为两者右端点的最大值</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="comment">//加了一个st != -2e9的判断是为了确保开始输入的区间数量不为0，即初始的st已经变化过了</span></span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge(segs);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      双指针算法，位运算，离散化，区间合并。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（2）</title>
    <link href="http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</id>
    <published>2020-09-29T12:27:11.000Z</published>
    <updated>2020-10-03T15:28:54.452Z</updated>
    
    <content type="html"><![CDATA[<p>第一章 基础算法</p><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>算法4：高精度（只有C++需要），一般有四种情况：</p><ol><li>两个大整数相加 A + B，A、B的位数 $\le 10^6$；</li><li>两个大整数相减 A - B，A、B的位数 $\le 10^6$；</li><li>一个大整数乘以一个小整数 A * a，A的位数$\le 10^6$，a$\le 10000$；</li><li>一个大整数除以一个小整数 A / a，A的位数$\le 10^6$，a$\le 10000$；</li></ol><p>首先要考虑的是一个大整数如何存储？方法是可以将其中的每一位保存在一个数组中，为了方便运算，让<code>a[0]</code>存数字的个位，<code>a[1]</code>存数字的十位……依次存高位。如数字以<code>string</code>类型输入<code>a = &quot;123456&quot;</code>，用<code>vector&lt;int&gt;</code>来存储，<code>A=[6,5,4,3,2,1]</code>。</p><p>（1）加法</p><p>两个数组的加法运算就是来模拟人工手算的过程，从个位开始逐位相加，逢十进一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C = A + B</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())  <span class="keyword">return</span> add(B, A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;   <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t); <span class="comment">//结束后检查下最高位是否需要进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">//a="123456"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = add(A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在空间上做进一步的优化，即进行压位处理，数组中的每一个元素不止存放数字的一位，而是多位。（不常用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % base);</span><br><span class="line">        t /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (a[i] - <span class="string">'0'</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (b[i] - <span class="string">'0'</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; C.back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">"%09d"</span>, C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）减法</p><p>两个数组的减法运算也是来模拟人工手算的过程，从个位开始逐位相减，不够就向前一位借1，加10。</p><p>算法的思路：</p><ul><li>如果A$\ge$B，就计算$A - B$；如果A$&lt;$B，就计算 $-(B - A)$。</li><li>在每一位上，若$A_i-B_i-t \ge 0$，就计算$A_i-B_i-t$；若$A_i-B_i-t &lt; 0$，就计算$A_i-B_i+10-t $，其中$t$代表借位。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//数组中最后一个元素存放的是数字的最高位，从最高位开始比较</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])  </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C = A - B</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;   <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.push_back( (t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;   <span class="comment">//当前的t小于0，需要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();   <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">//a="123456"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cmp(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(A, B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）乘法</p><p>也是模拟手算乘法，区别是：逐位相乘时是乘以整个被乘数b。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200929213523.jpg" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)   <span class="comment">//注意这里将最高位的进位问题一起处理了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())   t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();  <span class="comment">//当被乘数是0时，要将结果的前导0去掉</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）除法</p><p>同样的思路，模拟手算的过程，注意区别：除法是从最高位开始除的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; div(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)   <span class="comment">//余数r通过引用传入</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)     <span class="comment">//除法从数字的高位开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法中C先存的是数字的高位，与定义的先存低位相反，要先翻转一下</span></span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//这里一定要记得减去'0'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和，差分"><a href="#前缀和，差分" class="headerlink" title="前缀和，差分"></a>前缀和，差分</h3><p>算法5：前缀和，差分</p><p> 前缀和：设一个数组$a_1,a_2,a_3,\dots,a_n$，（注意下标从1开始），定义其前缀和为$S_i=a_1+a_2+\dots+a_i$，规定$S_0=0$。</p><ul><li>如何求前缀和$S_i$：<code>for</code>遍历即可；</li><li>前缀和的作用：可以方便地求出序列中某一段的和，如求下标区间$[l,r]$内的元素的和，即可用$S_r-S_{l-1}$，时间复杂度为$O(1)$。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];     <span class="comment">//计算前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[r] - s[l - <span class="number">1</span>]);    <span class="comment">//计算区间和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀和也可以扩展到二维，求区间和$\to$求子矩阵和。用$S_{ij}$表示左上角的子矩阵的和。如下图若要求以$(x_1,y_1)$为左上角，以$(x_2,y_2)$为右下角的子矩阵的和，那就可以转化成求：</p><script type="math/tex; mode=display">S_{x_2y_2}-S_{x_2y_1-1}-S_{x_1-1y_2}+S_{x_1-1y_1-1}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002102715.jpg" style="zoom:38%;"></p><p>如何求子矩阵和$S_{ij}$：两层<code>for</code>遍历<code>i</code>,<code>j</code>，</p><script type="math/tex; mode=display">S_{ij}=S_{i-1j}+S_{ij-1}-S_{i-1j-1}+a_{ij}</script><blockquote><p>主要的思想就是<a href="https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">容斥原理</a>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>差分是前缀和的逆运算</strong>，设一个数组$a_1, a_2, \dots, a_n$，现构造一个数组$b_1,b_2,\dots, b_n$，使得$a_i=b_1+b_2+\dots+b_n$，即$a$数组的元素是$b$数组的前缀和，$b$数组的元素是$a$数组的<strong>差分</strong>。则有：</p><script type="math/tex; mode=display">\begin{align*}b_1 &= a_1 \\b_2 &= a_2-a_1\\b_3 &= a_3-a_2\\&\dots \\b_n &= a_n-a_{n-1}\end{align*}</script><p>差分的作用：</p><ul><li>若有$b$数组，就可以通过求前缀和的方法求得原数组$a$，时间复杂度$O(n)$。</li><li>若要对$a$数组下标为$[l,r]$区间的一段元素都加上$c$，则要$O(n)$的时间复杂度；若考虑改动$b$数组，那只要改变两个元素，即让$b_l+c$，让$b_{r+1}-c$，则只要$O(1)$的时间复杂度，这样由数组$b$得到的数组$a$的下标为$[l,r]$的一段就都加上了$c$。</li><li>那若有了数组$a$，如何得到数组$b$：可以假设数组$a$初始全部是0，依次在区间[1,1]加上$a_1$，在区间[2,2]加上$a_2$，……，在区间[n,n]加上$a_n$，即转换到对数组$b$的操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        insert(i, i, a[i]);    <span class="comment">//求得数组b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += b[i<span class="number">-1</span>];   <span class="comment">//求数组b的前缀和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差分也有二维的形式，原矩阵元素$a_{ij}$，差分矩阵元素$b_{ij}$，使得$a_{ij}$是差分矩阵$b_{ij}$的前缀和。</p><p>其作用也可由上面的一维差分类比过来：给矩阵$a$的某一个子矩阵（左上角为$(x_1,y_1)$，右下角为$(x_2,y_2)$）中的元素全都加上一个数$c$，可以转化成：</p><script type="math/tex; mode=display">\begin{align*}b_{x_1y_1} &+=c\\b_{x_2+1y_1} &-=c\\b_{x_1y_2+1} &-=c\\b_{x_2+1y_2+1} &+=c\end{align*}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002131539.jpg" style="zoom:38%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            insert(i, j, i, j, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Acwing算法基础第一章的内容：高精度加减乘除，前缀和，差分。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（1）</title>
    <link href="http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</id>
    <published>2020-09-29T12:26:56.000Z</published>
    <updated>2020-10-03T15:27:32.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开个新坑( ･´ω`･ )，算法基础系列用来记录自己在Acwing上学习和刷题的过程。共勉。</p></blockquote><p>第一章  基础算法</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法1：<strong>快速排序</strong></p><p>快排用到了<strong>分治</strong>的思想，对一个下标左边界为$l$，下标右边界为$r$的数组，进行快速排序一般可以分为三个步骤：</p><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003221835.jpg" style="zoom:33%;"></p><p>其中最关键的是第二步-<strong>调整区间</strong>。暴力做法虽然时间复杂度是常数，但空间占用比较多（需要开额外的数组）。下面是优化后的方法：</p><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003222346.jpg" style="zoom:33%;"></p><p>在解题中为了避免在处理边界问题上浪费太多时间，可以记一些快排的模板。</p><ul><li>快排模板题：给定你一个长度为$n$的整数数列。请你使用快速排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];   <span class="comment">// x = q[l]，题目的数据加强过，写成x = q[l]会超时</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;   <span class="comment">//先把i, j往外移一位。因为后面要先移位再判断</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)  swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度和空间复杂度：</p><blockquote><p>分析和证明过程可以参考：<a href="https://www.cnblogs.com/HDK2016/p/6876313.html" target="_blank" rel="noopener">【算法】快速排序</a></p></blockquote><div class="table-container"><table><thead><tr><th></th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>$O(n\log n)$</td><td>$O(\log n)$</td></tr><tr><td>最坏</td><td>$O(n^2)$</td><td>$O(n)$</td></tr><tr><td>平均</td><td>$O(n\log n)$</td><td>$O(\log n)$</td></tr></tbody></table></div><ul><li><p>扩展题：<strong>快速选择</strong>。</p><p>第$k$个数：给定一个长度为$n$的整数数列，以及一个整数$k$，请用快速选择算法求出数列从小到大排序后的第$k$个数。</p><p>数据范围：$1 \le n \le 100000$，$1 \le k \le n$。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003224748.jpg" style="zoom:33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速选择，时间复杂度O(2n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( q[ ++ i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>( q[ -- j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; j )  swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( k &lt;= sl ) <span class="keyword">return</span> quick_sort(l, j, k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> quick_sort(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法2：<strong>归并排序</strong></p><p>归并排序也用到了分治的思想，通常有三个步骤：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003225129.jpg" style="zoom:33%;"></p><p>归并排序中最关键的是第三步—<strong>归并</strong>，可以使用双指针，使时间复杂度为$O(n)$。</p><ul><li><p>归并排序模板题：给定你一个长度为$n$的整数数列。请你使用归并排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。</p><p>数据范围：$1 \le n \le 100000$.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid+<span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt; q[j])  tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>扩展题：<strong>逆序数对的数量</strong></p><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。</p><p>数据范围：$1 \le n \le 100000$。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230124.jpg" style="zoom:33%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230127.jpg" style="zoom:33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并的过程</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j])    tmp[K ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k ++] = q[j ++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>算法3：二分查找</p><ul><li>整数的二分查找</li></ul><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003230519.jpg" style="zoom:33%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230523.jpg" style="zoom:33%;"></p><p>例题：给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回“-1 -1”。</p><p>数据范围：$1 \le n \le 100000$，$1 \le q \le 10000$，$1 \le k \le 10000$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查找x的左边界，性质是左边界 右面的数都大于等于x</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x)  r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != x)  <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1 -1"</span> &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断题目是不是无解</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">" "</span>;    </span><br><span class="line">            <span class="comment">//查找x的右边界，性质是右边界 左面的数都小于等于x </span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>浮点数二分</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230529.jpg" style="zoom:33%;"></p><p>例题：给定一个浮点数n，求它的三次方根。结果保留6位小数。</p><p>数据范围：$-10000 \le n \le 10000$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据数据范围确定l和r</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)  <span class="comment">//通常要比题目要求的精度多2位 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      开个新坑( ･´ω`･ )，算法基础系列用来记录自己在Acwing上学习和刷题的过程。Acwing算法基础第一章的内容：快速排序，归并排序，二分查找。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>XGBoost原理简述</title>
    <link href="http://nekomoon404.github.io/2020/09/22/XGBoost%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <id>http://nekomoon404.github.io/2020/09/22/XGBoost%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</id>
    <published>2020-09-22T12:18:46.000Z</published>
    <updated>2020-09-22T13:09:43.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔记主要是参考了贪心学院在B站的公开课<a href="https://www.bilibili.com/video/BV1si4y1G7Jb" target="_blank" rel="noopener">XGBoost的技术剖析</a></p><p>这篇博客也讲的十分详细：<a href="https://blog.csdn.net/wuzhongqiang/article/details/104854890" target="_blank" rel="noopener">白话机器学习算法理论+实战番外篇之Xgboost</a>，有一些上面的课程没有讲到的内容，如节点的最优切分点划分，要进行特征遍历，作者没有使用等宽或等频分桶，而是提出了等值percentiles划分算法（Weight Quantile Sketch）。</p><p>集成算法，弱分类器的概念等等就先略去了。</p></blockquote><p>根据各个弱分类器之间有无依赖关系，集成算法可以分为Boosting和Bagging：</p><ul><li>Boosting流派：各分类器之间没有依赖关系，必须串行，比如Adaboost，GBDT，Xgboost；</li><li>Bagging流派：各分类器之间没有依赖关系，可各自并行，比如随机森林。</li></ul><p>为什么XGBoost这么火？</p><ul><li><p>算法可以并行，训练效率高；</p></li><li><p>比起其他算法，世界效果好；</p></li><li><p>由于可控参数（超参数）多，可以灵活调整；</p></li></ul><p>学习路径：</p><ul><li>如何构造目标函数？（XGBoost的目标函数不是连续型的）</li><li>目标函数直接优化难，如何近似？（泰勒级数，Taylor Expansion）</li><li>如何把树的结果引入到目标函数？</li><li>仍然难优化，要不要使用贪心算法？</li></ul><h3 id="1-如何构造目标函数"><a href="#1-如何构造目标函数" class="headerlink" title="1.如何构造目标函数"></a>1.如何构造目标函数</h3><p>回顾如何使用多棵树来预测：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202546.png" style="zoom: 45%;"></p><p>假设已经训练了K颗树，则对于第$i$个样本的（最终）预测值为：</p><script type="math/tex; mode=display">\hat{y_i} = \sum^k_{k=1}f_k(x_i), \, f_k \in \mathcal{F}</script><p>目标函数为：</p><script type="math/tex; mode=display">Obj = \sum^n_{i=1} l(y_i,\hat{y_i}) + \sum^k_{k=1} \Omega(f_k)</script><p>其中前一项为损失函数，$y_i$为真实值，$\hat{y_i}$为预测值，$l(y_i,\hat{y_i})$为针对当前问题的loss；后一项为Penalty，或者称Regulation，控制模型的复杂度，防止过拟合。</p><p>现在的问题是如何给每一个树加上Penalty / Regulation。</p><p>回顾在决策树中如何定义树的复杂度：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202606.png" style="zoom:50%;"></p><p>$\sum^n_{i=1}l(y_i,\hat{y_i})$中计算了所有样本的loss，loss函数包含了不同树模型的loss，这时就可以使用叠加式的训练（Additive Training），当训练第$k$个模型（树）时，前面的第1到第$k-1$颗树是已知的。</p><p>假设现在我们要去构建第$k$颗树，</p><ul><li><p>给定$x_i$；</p></li><li><p>$\hat{y_i}^{(0)} = 0 \gets$  Default case ;</p></li><li>$\hat{y_i}^{(1)} = f_1(x_i) = \hat{y_i}^{(0)} + f_1(x_i)$；</li><li>$\hat{y_i}^{(2)} = f_1(x_i) + f_2(x_i) = \hat{y_i}^{(1)} + f_2(x_i)$；</li><li>$\dots$</li><li>$\hat{y_i}^{(k)} = f_1(x_i) + f_2(x_i) + \dots + f_k(x_i)= \sum^{k-1}_{j=1}f_j(x_i)+f_k(x_i)=\hat{y_i}^{(k-1)} + f_k(x_i)$；</li></ul><p>其中$\hat{y_i}^{(k-1)}$表示前$k-1$颗树的预测值之和，$f_k(x_i)$表示第$k$颗树的预测值，两者之和要和真实值$y_i$越接近越好。</p><p>因为前$k-1$颗树是训练好的，则目标函数可以写成：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k)}) + \sum^k_{k=1}\Omega(f_k)\\    &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \sum^{k-1}_{j=1}\Omega(f_j)+\Omega(f_k)\end{align*}</script><p>其中$\hat{y_i}^{(k-1)}$和$\sum^{k-1}_{j=1}\Omega(f_j)$可以看作是常数，则当训练第$k$颗树时，我们要最小化：</p><script type="math/tex; mode=display">minimize \quad \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k)</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202613.png" style="zoom:50%;"></p><h3 id="2-使用泰勒级数优化目标函数"><a href="#2-使用泰勒级数优化目标函数" class="headerlink" title="2.使用泰勒级数优化目标函数"></a>2.使用泰勒级数优化目标函数</h3><p>由上一节我们可知，构建第$k$颗树时的目标函数是  ：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k)\end{align*}</script><p>回顾泰勒级数Taylor Expansion：</p><script type="math/tex; mode=display">f(x+\Delta x) \approx f(x) + f'(x) \cdot \Delta x + \frac{1}{2} f^{''}(x)\cdot \Delta x^2</script><p>令其中的$f(x) = l(y_i, \hat{y_i}^{(k-1)} )$，$\Delta x= f_k(x_i)$，则有：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k) \\    &= \sum^n_{i=1} \left[ l(y_i, \hat{y_i}^{(k-1)} ) +\partial_{\hat{y_i}^{(k-1)}} l(y_i, \hat{y_i}^{(k-1)} ) \cdot f_k(x_i) + \frac{1}{2}\partial^2_{\hat{y_i}^{(k-1)}} l(y_i, \hat{y_i}^{(k-1)} ) \cdot f^2_k(x_i) \right]+ \Omega(f_k) \\    &= \sum^n_{i=1} \left[ l(y_i, \hat{y_i}^{(k-1)} ) +g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)\end{align*}</script><p>第一项$ l(y_i, \hat{y_i}^{(k-1)} )$是已知的，那么最下化目标函数就等价于：</p><script type="math/tex; mode=display">minimize \sum^n_{i=1} \left[ g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)</script><p>注：当训练第$k$颗树时，$\{h_i, g_i\}$是已知的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202618.png" style="zoom: 50%;"></p><h3 id="3-在树的形状已知的情况下，求目标函数的最小值"><a href="#3-在树的形状已知的情况下，求目标函数的最小值" class="headerlink" title="3.在树的形状已知的情况下，求目标函数的最小值"></a>3.在树的形状已知的情况下，求目标函数的最小值</h3><p>接下来我们要把$f_k(x_i)$和$\Omega(f_k)$参数化。考虑现有如下图的一个树，那我们如何把这颗树用参数化表示出来：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202623.png" style="zoom:50%;"></p><p>定义一个权重变量，或者称leaf value，$w=(w_1, w_2, w_3) = (15, 12, 20)$；</p><p>定义一个函数$q(x)$，表示样本$x$的位置，$q(x_1) =1, q(x_2)=3, q(x_3)= 1, q(x_4) = 2, q(x_5)=3$；</p><p>则有$f_k(x_i) = w_{q(x_i)} $ ，这样就把$f_k(x_i)$参数化了，但有个问题是$w$的下标还是个函数，为此我们还需定义一个函数$I_j=\{i | q(x_i)=j\}$，表示那些样本$x_i$会落在第$j$个位置上，它按叶节点的位置把样本重新组织。$I_1=\{1,3\},I_2=\{4\}, I_3=\{2, 5\}$。</p><p>这样我们原先以样本为单位累加得到$\sum^n_{i=1}  g_i \cdot f_k(x_i)=\sum^n_{i=1}  g_i \cdot w_{q(x_i)}$这一项，就可以换种思路，以叶节点为单位累加，以上图为例：</p><script type="math/tex; mode=display">\begin{align*}&g_1 \cdot w_{q(x_1)}+g_2 \cdot w_{q(x_2)}+g_3 \cdot w_{q(x_3)}+g_4 \cdot w_{q(x_4)}+g_5 \cdot w_{q(x_5)}\\=&g_1 \cdot w_{q(x_1)}+g_3 \cdot w_{q(x_3)}+ \\&g_2 \cdot w_{q(x_2)}+\\&g_4 \cdot w_{q(x_4)}+g_5 \cdot w_{q(x_5)}\\=& g_1 \cdot w_1+g_3 \cdot w_1+ \\&g_2 \cdot w_2+\\&g_4 \cdot w_3+g_5 \cdot w_3\\=&\sum^T_{j=1}(\sum_{i\in I_j } g_i) \cdot w_j\end{align*}</script><p>接着考虑如何定义一颗树的复杂度，可以是树的复杂度 = 叶节点个数 + leaf value，即：</p><script type="math/tex; mode=display">\Omega(f_k) = \gamma T + \frac{1}{2} \lambda \sum^T_{j=1} w_j^2</script><p>其中$T$是叶节点的个数，$w_j$是第$j$个叶节点的leaf value；$\gamma$和$\lambda$控制两部分的权重，是超参数。</p><p>最后将两部分结合起来，得到新的目标函数（<strong>假设树的形状已知</strong>）</p><script type="math/tex; mode=display">\begin{align*}& \sum^n_{i=1} \left[ g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)\\=& \sum^n_{i=1} \left[ g_i \cdot w_{q(x_i)} + h_i \cdot w^2_{q(x_i)} \right]+ \gamma T + \frac{1}{2} \lambda \sum^T_{j=1} w_j^2  \\=& \sum^T_{j=1} \left[(\sum_{i\in I_j } g_i) \cdot w_j  + \frac{1}{2}(\sum_{i\in I_j } h_i + \lambda) \cdot w^2_j\right] + \gamma T\end{align*}</script><p>令$G_j = \sum_{i\in I_j } g_i$，$H_j = \sum_{i\in I_j } h_i$，则使前一项最小的$w_j$值（回顾一元二次方程）为：</p><script type="math/tex; mode=display">w_j^* = -\frac{G_j}{H_j+\lambda}</script><p>此时目标函数的最小值为：</p><script type="math/tex; mode=display">Obj* = \frac{1}{2} \cdot \sum^T_{j=1} \frac{G_j^2}{H_j+\lambda} + \gamma T</script><p> 那么到目前我们解决了，<strong>在树的形状已知的情况下</strong>，可以求出第$k$树的最小的目标函数值。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202627.png" style="zoom:50%;"></p><p>那接下来我们要做的是在所有可能的形状的树中，寻找出$Obj^*$最小的那颗树。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202633.png" style="zoom:50%;"></p><h3 id="4-寻找树的形状"><a href="#4-寻找树的形状" class="headerlink" title="4.寻找树的形状"></a>4.寻找树的形状</h3><p>寻找树的形状可以用暴力算法（Brute Force Search），但这样做就效率太低了，复杂度也是节点个数的指数级的。 可行的方法是使用<strong>贪心算法</strong>去寻找。</p><p>回顾我们如何去构造一颗决策树。选择特征的依据是使不确定性变小，特征的score = 原（不确定性）- 分之后（不确定性），称为Information Gain（信息增益），每次分支的依据就是使信息增益最大化。那把这里的不确定性（Entropy）换成 $Obj$，就可以完成对有最小的$Obj^*$的树的寻找。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202638.png" style="zoom:50%;"></p><p>通过下面的例子来看一下如何寻找最好的树的形状，即寻找最好的Split。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202648.png" style="zoom:50%;"></p><p>xgboost贪心建树的思路：遍历所有特征以及所有分割点，每次算最好的那个。但这样做代价太大了，尤其是数据量很大，分割点很多的时候，计算起来非常复杂并且也无法读入内存进行计算。作者提出了一种近似分割的方式（可以理解为分割点分桶的思路），选出一些候选的分裂点，然后再遍历这些较少的分裂点来找到最佳分裂点。</p><p>进行分桶候选分裂点的一般思路是根据特征值的大小进行等宽分桶，或者进行等频分桶。这样做选择出的候选点确实少了很多，但这样划分是没什么依据的，缺乏可解释性。</p><p>作者采用了一种对loss的影响权重的等值percentiles（百分比分位数）划分算法（Weight Quantile Sketch）。考虑的是想让loss在左右子树上分布的均匀一些，而不是样本数量的均匀，因为每个样本对降低loss的贡献可能不一样，按样本均分会导致分开之后左子树和右子树loss分布不均匀，</p><p>其实这里这个损失函数还可以进一步化简的（和上面的化简不一样，上面的化简是把遍历样本转到了遍历叶子上得到基于决策树的目标函数，这里是从目标函数本身出发进行化简）：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922205540.png" style="zoom:45%;"></p><p>后面的每一个分类器都是在拟合每个样本的一个残差 $\frac{g_i}{h_i}$，$h_i$可以看做计算残差时某个样本的重要性，即每个样本对降低loss的贡献程度。第一个问题说的听清楚了吧。</p><blockquote><p>Xgboost引入了二阶导之后，相当于在模型降低残差的时候给各个样本根据贡献度不同加入了一个权重，这样就能更好的加速拟合和收敛。GBDT只用到了一阶导数，这样只知道梯度大的样本降低残差效果好，梯度小的样本降低残差不好，但是好与不好的程度在GBDT中无法展现。而xgboost这里就通过二阶导可以展示出来，这样模型训的时候就有数了</p></blockquote>]]></content>
    
    <summary type="html">
    
      学习了XGBoost的原理。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
      <category term="XGBoost" scheme="http://nekomoon404.github.io/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>贷款违约预测（1）赛题理解</title>
    <link href="http://nekomoon404.github.io/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/"/>
    <id>http://nekomoon404.github.io/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/</id>
    <published>2020-09-15T11:05:51.000Z</published>
    <updated>2020-09-28T11:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-赛题概况"><a href="#1-赛题概况" class="headerlink" title="1.赛题概况"></a>1.赛题概况</h3><p>比赛地址：<a href="https://tianchi.aliyun.com/competition/entrance/531830/introduction" target="_blank" rel="noopener">零基础入门金融风控-贷款违约预测</a></p><p>本次比赛以金融风控中的个人信贷为背景，根据贷款申请人的数据信息预测其是否有违约的可能，以此判断是否通过此项贷款，是一个二分类问题。</p><p>赛题的数据来自某信贷平台的贷款记录，包括47列变量信息，其中15列为匿名变量，比赛界面有对应的数据概况介绍，说明列的性质特征。总数据量120万条，其中，训练集80万条，测试集A 20万条，测试集B 20万条。</p><p><strong>预测指标</strong>：采用AUC作为评价指标，AUC越接近1.0，模型的预测性能越好。</p><h3 id="2-二分类问题中常见的评估指标"><a href="#2-二分类问题中常见的评估指标" class="headerlink" title="2.二分类问题中常见的评估指标"></a>2.二分类问题中常见的评估指标</h3><p>1.<strong>混淆矩阵（Confuse Matrix）</strong></p><p>二分类问题的预测结果可以根据情况分成以下四类：</p><p>（1）真正 TP（True Positive）：预测值为1，真实值为1</p><p>（2）假正 FP（False Positive）：预测值为1，真实值为0</p><p>（3）真负 TN（True Negative）：预测值为1，真实值为0</p><p>（4）假负 FN（False Negative）：预测值为0，真实值为1</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915195033.png" style="zoom: 80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y_pred = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">confusion_matrix(y_true, y_pred)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]], dtype=int64)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tn, fp, fn, tp = confusion_matrix([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).ravel()</span><br><span class="line">(tn, fp, fn, tp)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2.<strong>准确率（Accuracy）</strong></p><p>分类正确的样本数占总样本数的比例数。准确率在样本不均衡的数据集上不适用。</p><script type="math/tex; mode=display">Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script><p>3.<strong>精确率（Precision）</strong></p><p>又称查准率，正确预测为正样本（TP）占预测为正样本（TP+FP）的比例。</p><script type="math/tex; mode=display">Percision=\frac{TP}{TP+FP}</script><p>4.<strong>召回率（Recall）</strong></p><p>又称查全率，正确预测为正样本（TP）占正样本的（TP+FN）比例。</p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><p>5.<strong>F1 - score</strong></p><p>Precision和Recall指标有时是此消彼长的，即精准率高了，召回率就下降，在一些场景下要兼顾精准率和召回率，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即；</p><script type="math/tex; mode=display">\frac{1}{F_{\beta}}=\frac{1}{1+\beta^2} \cdot \left( \frac{1}{P}+\frac{\beta^2}{R}\right) \\F_{\beta} = \frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P) + R}</script><p>当$\beta=1$时，也就是常见的F1-Score，是P和R的调和平均，当F1较高时，模型的性能越好。</p><script type="math/tex; mode=display">F1-Socre = \frac{2\times P \times R }{P+R}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y_pred = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'accuracy:'</span>,  metrics.accuracy_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'precision:'</span>, metrics.precision_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'recall:'</span>, metrics.recall_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'f1-score:'</span>, metrics.f1_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accuracy: <span class="number">0.25</span></span><br><span class="line">precision: <span class="number">0.3333333333333333</span></span><br><span class="line">recall: <span class="number">0.5</span></span><br><span class="line">f1-score: <span class="number">0.4</span></span><br></pre></td></tr></table></figure><p>6.<strong>P-R曲线（Precision-Recall Curve）</strong></p><p>描述精确率/召回率变化的曲线。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915201039.png" style="zoom: 60%;"></p><p>若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。</p><p>7.<strong>ROC曲线（Receiver Operating Characteristic）</strong></p><p>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现<strong>类别不平衡（Class Imbalance）</strong>现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化，ROC以及AUC可以很好的消除样本类别不平衡对指标结果产生的影响。</p><p>ROC曲线分别使用下面两个指标作为X轴和Y轴：</p><p>（1）真正率（True Positive Rate , TPR），又称灵敏度（sensitivity）：（其实和召回率一样）</p><script type="math/tex; mode=display">TPR = \frac{TP}{TP+FN}</script><p>（2）假正率（False Positive Rate , FPR），又称特异度（specificity）：</p><script type="math/tex; mode=display">FPR = \frac{FP}{TN+FP}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915202153.png" style="zoom:50%;"></p><p>8.<strong>AUC（Area Under Curve）</strong></p><p>曲线下面积，是处于ROC Curve下方的那部分面积的大小。对于ROC曲线下方面积越大表明模型性能越好，于是AUC就是由此产生的评价指标。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了模型较好的性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">y_true = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">y_score = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line">fpr, tpr, thresholds = metrics.roc_curve(y_true, y_score, pos_label=<span class="number">2</span>) </span><br><span class="line">auc=metrics.auc(fpr, tpr)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'ROC'</span>)</span><br><span class="line">plt.plot(fpr, tpr,<span class="string">'b'</span>,label=<span class="string">'AUC = %0.4f'</span>% auc)</span><br><span class="line">plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'TPR'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'FPR'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/output_4_1.png" style="zoom:80%;"></p><blockquote><p>参考：<a href="https://www.cnblogs.com/guoyaohua/p/classification-metrics.html" target="_blank" rel="noopener">【机器学习】一文读懂分类算法常用评价指标</a></p></blockquote><hr><p>Task02-Task05:</p><ul><li>数据探索性分析</li><li>特征工程</li><li>建模与调参</li><li>模型融合</li></ul><p>notebook已上传到<a href="https://github.com/nekomoon404/data-mining/tree/master/FinancialRiskControl" target="_blank" rel="noopener">GitHub仓库</a>，线上成绩为0.7360，仍需继续努力。</p>]]></content>
    
    <summary type="html">
    
      Datawhale的0基础入门金融风控之贷款违约预测挑战赛的Task1：赛题理解，后四个Task已放到Github上。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>DL笔记（16）Transfer Learning</title>
    <link href="http://nekomoon404.github.io/2020/08/13/ML%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89Transfer-Learning/"/>
    <id>http://nekomoon404.github.io/2020/08/13/ML%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89Transfer-Learning/</id>
    <published>2020-08-13T00:51:13.000Z</published>
    <updated>2020-08-13T02:56:46.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Transfer learning（迁移学习），是属于机器学习的一种研究领域，它专注于存储已有问题的解决模型，并将其利用在其他不同但相关问题上，正如人类可以将一个领域学习到的知识和经验，应用到其他相似的领域中去一样，机器同样也能做到。</p><p>传统的机器学习/数据挖掘只有在训练集数据和测试集数据都来自同一个feature space（特征空间）和统一分布的时候才运行的比较好，这意味着每一次换了数据都要重新训练模型，太麻烦了。比如：</p><p>（1）从数据类型/内容上看，对于新的数据集，获取新的训练数据很贵也很难。</p><p>（2）从时间维度上看，有些数据集很容易过期，即不同时期的数据分布也会不同。</p><blockquote><p>Transfer learning的概念参考了这篇博客<a href="https://cloud.tencent.com/developer/article/1636741" target="_blank" rel="noopener">迁移学习</a></p></blockquote><p><strong>not directly related</strong></p><p>以猫狗识别为例，解释“不直接相关”的含义：</p><ul><li><p>input <strong>domain（域）</strong>是类似的，但task是无关的，比如输入都是动物的图像，但这些data是属于另一组有关大象和老虎识别的task；</p></li><li><p>input domain是不同的，但task是一样的，比如task同样是做猫狗识别，但输入的是卡通类型的图像。</p></li></ul><blockquote><p>domain：包括两部分：1.feature space（特征空间）；2.probability（概率）。所以当我们说domain不同的时候，就得分两种情况。可能是feature space不同，也可能是feature space一样但probability不同。这里指的是前者，即feature space不同。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090714.png" style="zoom: 50%;"></p><p><strong>overview</strong></p><p>迁移学习是很多方法的集合，这里介绍一些概念：</p><ul><li>Target Data：和task直接相关的data；</li><li>Source Data：和task没有直接关系的data。</li></ul><blockquote><p>source是用于训练模型的域/任务，target是要用前者的模型对自己的数据进行预测/分类/聚类等机器学习任务的域/任务。</p></blockquote><p>按照labeled data和unlabeled data又可以划分为四种：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090728.png" style="zoom: 50%;"></p><h3 id="2-labelled-source-data-amp-labeled-target-data"><a href="#2-labelled-source-data-amp-labeled-target-data" class="headerlink" title="2. labelled source data &amp; labeled target data"></a>2. labelled source data &amp; labeled target data</h3><p>这里target data和source data都是带有标签的：</p><ul><li><p>target data：$(x^t,y^t)$，作为有效数据，通常量是很少的。如果target data量非常少，则被称为one-shot learning；</p></li><li><p>source data：$(x^s, y^s)$，作为不直接相关数据，通常量是很多的。</p></li></ul><h4 id="2-1-Model-Fine-tuning"><a href="#2-1-Model-Fine-tuning" class="headerlink" title="2.1. Model Fine-tuning"></a>2.1. Model Fine-tuning</h4><p>Model Fine-tuning（模型微调）的基本思想：用source data去训练一个model，再用target data对model进行fine-tune（微调）。“微调”类似于pre-training，就是把用source data训练出的model参数当做是参数的初始值，再用target data继续训练下去即可，但当直接相关的数据量非常少时，这种方法很容易会出问题。所以训练的时候要小心，有许多技巧值得注意。</p><p><strong>Conservation Training</strong></p><p>如果现在有大量的source data，比如在语音识别中有大量不同人的声音数据，可以拿它去训练一个语音识别的神经网络，而现在你拥有的target data，即特定某个人的语音数据，可能只有十几条左右，如果直接拿这些数据去再训练，肯定得不到好的结果</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090732.png" style="zoom:50%;"></p><p>此时我们就需要在训练的时候加一些限制，让用target data训练前后的model不要相差太多：</p><ul><li>可以让新旧两个model在看到同一笔data的时候，output越接近越好；</li><li>或者让新旧两个model的L2 norm越小越好，参数尽可能接近；</li><li>总之让两个model不要相差太多，防止由于target data的训练导致过拟合。</li></ul><p>这里的限制就类似于做regularization。</p><p><strong>Layer Transfer</strong></p><p>现在我们已经有一个用source data训练好的model，此时把该model的某几个layer拿出来复制到同样大小的新model里，接下来<strong>用target data去训练余下的没有被复制到的layer</strong>。这样做的好处是target data只需要考虑model中非常少的参数，这样就可以避免过拟合。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090735.png" style="zoom:50%;"></p><p>这个对部分layer进行迁移的过程，就体现了迁移学习的思想，那么哪些layer需要被复制迁移，哪些不需要呢？</p><p>值得注意的是，<strong>在不同的task上，需要被复制迁移的layer往往是不一样的</strong>：</p><ul><li><p>在语音识别中，往往迁移的是最后几层layer，再重新训练与输入端相邻的那几层。</p><p>由于人口腔结构不同，同样的发音方式得到的发音是不一样的，NN的前几层会从声音信号里提取出发音方式，再用后几层判断对应的词汇，从这个角度看，NN的后几层是跟特定的人没有关系的，因此可做迁移。</p></li><li><p>在图像处理中，往往迁移的是前面几层layer，再重新训练后面的layer。</p><p>CNN在前几层通常是做最简单的识别，比如识别是否有直线斜线、是否有简单的几何图形等，这些layer的功能是可以被迁移到其它task上通用的。</p></li><li><p>主要还是具体问题具体分析。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090739.png" style="zoom:50%;"></p><h4 id="2-2-Multitask-Learning"><a href="#2-2-Multitask-Learning" class="headerlink" title="2.2. Multitask Learning"></a>2.2. Multitask Learning</h4><p>Fine-tune仅考虑在target data上的表现，而Multitask Learning（多任务学习），则是同时考虑model在source data和target data上的表现。</p><p>如果两个task的输入特征类似，则可以用同一个神经网络的前几层layer做相同的工作，到后几层再分方向到不同的task上，这样做的好处是前几层得到的data比较多，可以被训练得更充分。有时候task A和task B的输入输出都不相同，但中间可能会做一些类似的处理，则可以让两个神经网络共享中间的几层layer，也可以达到类似的效果。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090743.png" style="zoom:50%;"></p><p>以上方法要求不同的task之间要有一定的“共性”，这样才有共用一部分layer的可能性。</p><p><strong>Multilingual Speech Recognition</strong></p><p>多任务学习可以应用在语音识别上，比如可以同时对法语、德语、西班牙语、意大利语训练一个model，它们在前几层layer上共享参数，而在后几层layer上拥有自己各自的参数。在机器翻译上也可以使用同样的思想，比如训练一个同时可以中翻英和中翻日的model。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090746.png" style="zoom:50%;"></p><p>注属于同一个语系的语言翻译，比如欧洲国家的语言，几乎都是可以做迁移学习的；而语音方面则可迁移的范围更广。下图展示了只用普通话的语音数据和加了欧洲语言后的语音数后得到的错误率对比，其中横轴为使用的普通话数据量，纵轴为错误率，可以看出使用了迁移学习后，只需要原先一半的普通话语音数据就可以得到几乎一样的准确率</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090749.png" style="zoom: 50%;"></p><h4 id="2-3-Progressive-Neural-Network"><a href="#2-3-Progressive-Neural-Network" class="headerlink" title="2.3. Progressive Neural Network"></a>2.3. Progressive Neural Network</h4><p>如果两个task完全不相关，硬是把它们拿来一起训练反而会起到负面效果。而在Progressive Neural Network（渐进式神经网络）中，每个task对应model的hidden layer的输出都会被接到后续model的hidden layer的输入上，这样做的好处是：</p><ul><li>task 2的data并不会影响到task 1的model，因此task 1一定不会比原来更差；</li><li><p>task 2虽然可以借用task 1的参数，但可以将之直接设为0，最糟的情况下就等于没有这些参数，也不会对本身的表现产生影响；</p></li><li><p>task 3也做一样的事情，同时从task 1和task 2的hidden layer中得到信息。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090753.png" style="zoom:50%;"></p><blockquote><p>论文<a href="https://arxiv.org/pdf/1606.04671.pdf" target="_blank" rel="noopener">arxiv.org/pdf/1606.04671.pdf)</a></p><p>关于Progressive Neural Network可以参考：<a href="https://www.cnblogs.com/wangxiaocvpr/p/6002214.html" target="_blank" rel="noopener">论文笔记之：Progressive Neural Network Google DeepMind</a>；<a href="https://zhuanlan.zhihu.com/p/146454996" target="_blank" rel="noopener">Progressive Neural Network</a></p></blockquote><h3 id="3-labelled-source-data-amp-unlabeled-target-data"><a href="#3-labelled-source-data-amp-unlabeled-target-data" class="headerlink" title="3. labelled source data &amp; unlabeled target data"></a>3. labelled source data &amp; unlabeled target data</h3><p>下面介绍target data不带标签，而source data带标签的情况：</p><ul><li><p>target data：$(x^t)$</p></li><li><p>source data：$(x^s, y^s)$</p></li></ul><h4 id="3-1-Domain-adversarial-Training"><a href="#3-1-Domain-adversarial-Training" class="headerlink" title="3.1. Domain-adversarial Training"></a>3.1. Domain-adversarial Training</h4><p>如果source data是有label的，而target data是没有label的，该怎么处理呢？比如source data是labeled MNIST数字集，而target data则是加了颜色和背景的unlabeled数字集，虽然都是做数字识别，但两者的情况是非常不匹配的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090756.png" style="zoom:50%;"></p><p>这个时候一般会把source data当做训练集，而target data当做测试集，如果不管训练集和测试集之间的差异，直接训练一个普通的model，得到的结果准确率会相当低。实际上，神经网络的前几层可以被看作是在抽取feature，后几层则是在做classification。如果把用MNIST训练好的model所提取出的feature做t-SNSE降维后的可视化，可以发现MNIST的数据特征明显分为紫色的十团，分别代表10个数字，而作为测试集的数据却是挤成一团的红色点，因此它们的特征提取方式根本不匹配。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090801.png" style="zoom:50%;"></p><p>所以我们希望前面的特征提取器(feature extractor)可以把domain的特性去除掉，不再使红点与蓝点分成两群，而是让它们都混在一起。这样我们就可以将用黑白MNIST训练好的model用在彩色MNIST数据上。</p><p>这里采取的做法是，在特征提取器(feature extractor)之后接一个<strong>域分类器(domain classifier)</strong>，以便分类出这些提取到的feature是来自于MNIST的数据集还是来自于MNIST-M的数据集，这个生成+辨别的架构与GAN非常类似。</p><p>只不过在这里，feature extractor可以通过把feature全部设为0，很轻易地骗过domain classifier，因此还需要给feature classifier增加任务的难度，它不只要骗过domain classifier，还要同时满足label predictor的需求。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090806.png" style="zoom: 50%;"></p><p>此时通过特征提取器得到的feature不仅可以消除不同domain的特性，还要保留原先digit的特性，既可以区分不同类别的数字集，又可以正确地识别出不同的数字。</p><p>通常神经网络的参数都是朝着最小化loss的目标共同前进的，但在这个神经网络里，三个组成部分的参数“各怀鬼胎”：</p><ul><li>对Label predictor，要把不同数字的分类准确率做的越高越好；</li><li>对Domain classifier，要正确地区分某张image是属于哪个domain；</li><li>对Feature extractor，要提高Label predictor的准确率，但要降低Domain classifier的准确率。</li></ul><p>这里可以看出，Feature extractor和Domain classifier的目标是相反的，要做到这一点，只需要在两者之间加一层梯度反转的layer即可（给domain classifier的梯度乘一个$-\lambda$），当NN做backward的时候，两者的参数更新往相反的方向走。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090809.png" style="zoom:50%;"></p><p>注意到，Domain classifier只能接受到Feature extractor给到的特征信息，而无法直接看到图像的样子，因此它最后一定会鉴别失败，所以如何提高Domain classifier的能力，让它经过一番“奋力挣扎”之后才牺牲是很重要的，如果它一直很弱，就无法把Feature extractor的潜能激发到极限。</p><h4 id="3-2-Zero-shot-Learning"><a href="#3-2-Zero-shot-Learning" class="headerlink" title="3.2. Zero-shot Learning"></a>3.2. Zero-shot Learning</h4><p>同样是source data有label，target data没有label的情况，但在Zero-shot Learning中的定义更严格一些，它假设source和target是两个完全不同的task，数据完全不相关。</p><p>在语音识别中，经常会遇到这个问题，毕竟词汇千千万万，总有一些词汇是训练时不曾遇到过的，它的处理方法是不要直接将识别的目标定成word，而是定成phoneme(音素)，再建立文字与phoneme之间的映射表即可。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090812.png" style="zoom:50%;"></p><p>在图像处理中，我们可以把每个类别都用其<strong>属性（attribute）</strong>表示，并且要具备独一无二的属性，在数据集中把每种动物按照特性划分，比如是否毛茸茸、有几只脚等，在训练的时候我们不直接去判断类别，而是去判断该图像的属性，再根据这些属性去找到最契合的类别即可。</p><p>有时候属性的维数也很大，以至于我们对属性要做embedding的降维映射，同样的，还要把训练集中的每张图像都通过某种转换投影到embedding space上的某个点，并且要保证属性投影的$g(y^i)$和对应图像投影的$f(x^i)$越接近越好，这里的$f()$和$g()$可以是两个神经网络。当遇到新的图像时，只需要将其投影到相同的embedding space，即可判断它与哪个属性对应的类别更接近。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090816.png" style="zoom:50%;"></p><p>但如果我们根本就无法找出每个动物的属性$y^i$是什么，那该怎么办？可以使用word vector，比如直接从维基百科上爬取图像对应的文字描述，再用word vector降维提取特征，映射到同样的空间即可。</p><p>以下这个loss function存在些问题，它会让model把所有不同的x和y都投影到同一个点上：</p><script type="math/tex; mode=display">f^*,g^*=\arg \min\limits_{f,g} \sum\limits_n ||f(x^n)-g(y^n)||_2</script><p>类似用t-SNE的思想，我们既要考虑同一对$x^n$和$y^n$距离要接近，又要考虑不属于同一对的$x^n$与$y^m$距离要拉大(这是前面的式子没有考虑到的)，于是有：</p><script type="math/tex; mode=display">f^*,g^*=\arg \min\limits_{f,g} \sum\limits_n \max(0, k-f(x^n)\cdot g(y^n)+\max\limits_{m\ne n} f(x^n)\cdot g(y^m))</script><p>其中$\max()$项的最小值是0，当：</p><script type="math/tex; mode=display">k-f(x^n)\cdot g(y^n)+\max\limits_{m\ne n} f(x^n)\cdot g(y^m)<0</script><p>即：</p><script type="math/tex; mode=display">f(x^n)\cdot g(y^n)-\max\limits_{m\ne n} f(x^n)\cdot g(y^m)>k</script><p>就表明此时$f(x^n)$和$g(y^n)$的inner product很大，即两者很接近，而$f(x^n)$和其他的$g(y^m)$即差的很远，它们的inner product很小。</p><p><strong>convex combination of semantic embedding</strong></p><p>还有另外一个简单的Zero-Shot learning的方法叫做convex combination of semantic embedding。假设我们现在有一个语音辨识系统，有一个word vector，这两个是从网络上下载下来的，就可以做这件事情。</p><p>我把一张图丢到neural network里面去，它的output没有办法决定是哪一个class，但它觉得有0.5的几率是lion，有0.5的几率是tiger。接下来你在去找lion跟tiger的word vector，然后把lion跟tiger的word vector得到新的vector(用1:1的比例混合,0.5V(tiger)+0.5V(lion))，那你再看哪一个word的vector跟这个混合之后的结果最接近。假设是liger最接近，那这个东西就是liger(狮虎)。这样就省去了Training。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813102225.png" style="zoom: 33%;"></p><p>Zero-shot Learning in Machine Translation</p><p>下面是一个机器翻译的例子，Google Neural Machine Translation。在training的时候，machine看过如何把英文翻译成韩文，知道怎么把韩文翻译为英文，知道怎么把英文翻译为日文，知道怎么把日文翻译为英文。但是它从来没有看过日文翻译韩文的data，但是可以翻，但是它从来没有看过韩文翻译日文的data，但是可以翻。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813103134.png" style="zoom: 40%;"></p><p>为什么zero-shot在这个task上是可行的呢？如果你今天用同一个model做了不同语言之间的translation以后，machine可以学到的事情是：对不同语言的input 句子都可以project（投影）到同一个space上面。句子在这个space上的位置只跟句子的semantic有关。</p><p>比如现在根据learn好的translation，那个translation有一个encoder，它会把input的句子变成vector，decoder根据这个vector解回一个句子，就是翻译的结果。那把不同语言都丢到这个encoder里面让它变成vector的话，那这些不同语言的不同句子在这个space上面有什么不一样的关系呢？</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813103139.png" style="zoom: 40%;"></p><p>它发现有日文、英文、韩文这三个句子，这三个句子讲的是同一件事情，通过encoder embedding之后，它们在space上面是差不多的位置。machine做的是发现一个sequence language，每一种不同的语言都先要先转成它知道的sequence language，在用这个sequence language转为另外一种语言。所以对某一个翻译task ，你的input语言和output语言machine没有看过，它也可以透过这种自己学出来的sequence language来做translation。</p><p>——————</p><p>最后简单介绍下Transfer Learning的另外两种情况：</p><ul><li><p>Target data有label，source data没有label:  <strong>Self-taught learning</strong>。它的基本思想是：</p><ul><li>Learning to extract better representation from the source data(unsupervised approach)</li><li>Extracting better representation for target data</li></ul><p>Self-taught learning和semi-supervised learning有些不一样的地方，semi-supervised learning在learning的时候会有一些labelled data和unlabeled data，可以说source data是unlabeled data，target data是label data，所以Self-taught learning也是一种semi-supervised learning。但它和一般的semi-supervised learning有些不一样，一般的semi-supervised learning会假设unlabeled data至少和labelled data是有关系的，但在Self-taught learning中，source data和target data的关系是比较远的。</p></li><li><p>Target label没有label，source data也没有label: <strong>Self-taught clustering</strong>。</p></li></ul><blockquote><p>论文：<a href="http://ai.stanford.edu/~hllee/icml07-selftaughtlearning.pdf" target="_blank" rel="noopener">Self-taught learning</a>；<a href="https://www.cse.ust.hk/~qyang/Docs/2008/dwyakicml.pdf" target="_blank" rel="noopener">Self-taught clustering</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      文本主要介绍了Transfer Learning（迁移学习）的两种类型：labelled source data &amp; labeled target data；labelled source data &amp; unlabeled target data。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Transfer Learning" scheme="http://nekomoon404.github.io/tags/Transfer-Learning/"/>
    
      <category term="Model Fine-tuning" scheme="http://nekomoon404.github.io/tags/Model-Fine-tuning/"/>
    
      <category term="Multitask Learning" scheme="http://nekomoon404.github.io/tags/Multitask-Learning/"/>
    
      <category term="Progressive Neural Network" scheme="http://nekomoon404.github.io/tags/Progressive-Neural-Network/"/>
    
      <category term="Domain-adversarial Training" scheme="http://nekomoon404.github.io/tags/Domain-adversarial-Training/"/>
    
  </entry>
  
  <entry>
    <title>DL笔记（15）Unsupervised Learning-Generative Model</title>
    <link href="http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89Unsupervised-Learning-Generative-Model/"/>
    <id>http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89Unsupervised-Learning-Generative-Model/</id>
    <published>2020-07-29T07:59:14.000Z</published>
    <updated>2020-08-12T07:59:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于Generative Model推荐一篇很好的文章，来自OpenAI的<a href="https://openai.com/blog/generative-models/" target="_blank" rel="noopener">Generative Models</a>。文章的开头引用了<em>Richard Feynman</em>的话，<em>“What I cannot create, I do not understand”</em>，我无法创造的东西，我也无法真正理解，机器可以做猫狗分类，但却不一定知道“猫”和“狗”的概念，但如果机器能自己画出“猫”来，它或许才真正理解了“猫”这个概念，这也是Generative Model想要让machine做的事。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729160702.png" style="zoom:67%;"></p><p>下面将简要介绍：PixelRNN、VAE和GAN这三种Generative model的方法。</p><h3 id="1-PixelRNN"><a href="#1-PixelRNN" class="headerlink" title="1. PixelRNN"></a>1. PixelRNN</h3><p>RNN可以处理长度可变的input，它的基本思想是可以根据过去发生的状态去推测下一个状态。PixelRNN的基本思想是每次只画一个pixel来生成一个image，这个pixel是由过去所有已产生的pixel共同决定的。例如一个$3\times 3$的Image，第一次给一个橙色的pixel，输入到NN中，output得到一个蓝色的pixel；然后再将上一步得到的橙色和蓝色的pixel一起输入到NN中得到一个浅蓝色的pixel；再下一步将这三个pixel输入到NN中得到一个灰色的pixel，以此类推就可以得到一个$3\times 3$的image。这种方法的精髓在于根据过去预测未来，画出来的图一般都是比较清晰的</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729161342.png" style="zoom:67%;"></p><p>（Reference[1]: <a href="https://arxiv.org/abs/1601.06759" target="_blank" rel="noopener"><em>Oord A, Kalchbrenner N, Kavukcuoglu K. Pixel recurrent neural networks[J]. arXiv preprint arXiv:1601.06759, 2016.</em></a>）</p><p>这个方法也适用于语音生成，可以用前面一段的语音去预测接下来生成的语音信号。也可以用在影像上，用前面一段video来预测后面的video。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729161919.png" style="zoom:67%;"></p><p>（Reference[2]: <a href="https://arxiv.org/abs/1609.03499" target="_blank" rel="noopener"><em>Oord A, Dieleman S, Zen H, et al. Wavenet: A generative model for raw audio[J]. arXiv preprint arXiv:1609.03499, 2016.</em></a> </p><p>Reference[3]:  <a href="https://arxiv.org/abs/1610.00527" target="_blank" rel="noopener"><em>Kalchbrenner N, Oord A, Simonyan K, et al. Video pixel networks[C]//International Conference on Machine Learning. 2017: 1771-1779.</em></a>）</p><p><strong>pokemon creation</strong></p><p>下面这个小例子是给machine792个pekemon的image，想让machine学会去生成pekeon的Image。</p><p><img src="/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8815%EF%BC%89Unsupervised-Learning-Generative-Model/QQ图片20200729163517.png" style="zoom:67%;"></p><p>在使用Generative model去生成宝可梦之前，有几个tips需要注意：</p><ul><li><p>为了减少运算量，将40×40的图像截取成20×20</p></li><li><p>如果将每个pixel都以[R, G, B]的vector表示的话，生成的图像都是灰蒙蒙的，原因如下：</p><ul><li><p>亮度比较高的图像，一般都是RGB值差距特别大而形成的，如果各个维度的值大小比较接近，则生成的图像偏向于灰色；</p></li><li><p>如果用sigmoid function，最终生成的RGB往往都是在0.5左右（归一化之后），导致色彩度不鲜艳；</p></li><li><p>解决方案：将所有色彩集合成一个1-of-N encoding，由于色彩种类比较多，因此这里先对相近的颜色做clustering聚类表示为一种颜色，最终获得了167种色彩组成的向量。我们用这样的向量去表示每个pixel，可以让生成的色彩比较鲜艳。</p></li></ul></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729163521.png" style="zoom:67%;"></p><p>相关数据连接如下：</p><ul><li>原始图像(40*40)数据的<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Pokemon_creation/image.rar" target="_blank" rel="noopener">链接</a></li><li>裁剪后的图像(20*20)数据<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Pokemon_creation/pixel_color.txt" target="_blank" rel="noopener">链接</a></li><li>数值与色彩(RGB)的映射关系<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Pokemon_creation/colormap.txt" target="_blank" rel="noopener">链接</a></li></ul><p>使用PixelRNN训练好模型之后，给它看没有被放在训练集中的3张图像的一部分，分别遮住原图的50%和75%，得到的原图如下：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729163524.png" style="zoom:67%;"></p><p>训练好的pixel RNN预测到的图片如下：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729164544.png" style="zoom:60%;"></p><p>做这种Generation的task有一个难点是，设计上的好坏较难去evaluate。接下来我们让训练好的model凭空去画，但如果什么都不给machine让它从头开始画的话，它得到的每一个image可能都是一样的，因此我们要故意加一些random，即machine在画下一个pixel的时候不一定是选几率最高的颜色，也有几率选几率比较低的颜色，这样它每次画出来的图才会有点不一样。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729163528.png" style="zoom:67%;"></p><h3 id="2-VAE"><a href="#2-VAE" class="headerlink" title="2. VAE"></a>2. VAE</h3><p>上一篇笔记中介绍过Auto-encoder，如果我们拿出其中的Decoder，给它随机的code，就可以生成对应的图像。但普通的Decoder生成效果并不好，VAE（Variational Auto-encoder，可变自动编码器）可以得到更好的效果。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729165853.png" style="zoom:67%;"></p><p>在VAE中，code不再直接等于Encoder的输出，这里假设目标降维空间为3维，那我们使Encoder分别输出$m_1,m_2,m_3$和$\sigma_1,\sigma_2,\sigma_3$，此外我们从正态分布中随机取出三个点$e_1,e_2,e_3$，将下式作为最终的编码结果：</p><script type="math/tex; mode=display">c_i = \exp(\sigma_i)\cdot e_i+m_i</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729165849.png" style="zoom:67%;"></p><p>再将$c_i$输入到Decoder里面得到output，我们希望MInimize reconstruction error。但此时，我们的训练目标不仅要最小化input和output之间的差距，还要同时最小化下式（比较“神妙”）：</p><script type="math/tex; mode=display">\sum\limits_{i=1}^3 (1+\sigma_i-(m_i)^2-e^{\sigma_i})</script><h4 id="2-1-Pokemon-Creation"><a href="#2-1-Pokemon-Creation" class="headerlink" title="2.1. Pokemon Creation"></a>2.1. Pokemon Creation</h4><p>与PixelRNN不同的是，VAE画出的图一般都是不太清晰的，但在某种程度上我们可以控制生成的image。假设我们现在把VAE用在Pokemon creation上面，在Trainig的时候我们input一个pokemon，然后reconstruct一个同样的pokemon，learn出来的code设为10维。Learn好这个VAE之后，我们把Decoder的部分拿出来。我们在给Decoder输入10维的vector时可以固定其中的8维，只选2维出来，我们可以在2维平面上sample一系列的点，加上我们固定的8维后Input到Decoder中看输出的image是什么样的。这样我们就可以解读code的每一个dimension是代表什么含义，然后去控制VAE去生成一些image。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729171354.png" style="zoom:67%;"></p><p>下面是固定code中的8维，让剩下的2维变化得到的image，发现image的变化确实是有些规律的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729171550.png" style="zoom:67%;"></p><h4 id="2-2-Writing-Poerty"><a href="#2-2-Writing-Poerty" class="headerlink" title="2.2. Writing Poerty"></a>2.2. Writing Poerty</h4><p>VAE还可以用来写诗，将input和output都换成是sentence，我们只需要得到某两句话对应的code，然后在降维后的空间中得到这两个code所在点的连线，从中间等间隔地取一些点，把这些点输入给Decoder，得到还原后的句子，就可以得到类似下图中的效果。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729172145.png" style="zoom: 80%;"></p><h4 id="2-3-Why-VAE"><a href="#2-3-Why-VAE" class="headerlink" title="2.3. Why VAE?"></a>2.3. Why VAE?</h4><p>VAE和传统的Auto-encoder相比，有什么优势呢？事实上，VAE就是加了噪声noise的Autoencoder，它的抗干扰能力更强，过渡生成能力也更强。</p><p>对原先的Autoencoder来说，假设我们得到了满月和弦月的code，从两者连线中随机获取一个点并映射回原来的空间，得到的图像很可能是完全不一样的东西，因为code和output得到的image是一一对应的。</p><p>而对VAE来说，它要保证在降维后的code空间中，加了noise的一段范围内的所有点都能够映射到目标图像，如下图所示，当某个点既被要求映射到满月、又被要求映射到弦月，则它最终映射出来的结果就很有可能是两者之间的过渡图像。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729172808.png" style="zoom:67%;"></p><p>再回过来头看VAE的结构，其中：</p><ul><li><p>$m_i$其实就代表原来的code</p></li><li><p>$c_i$则代表加了noise以后的code</p></li><li><p>$\sigma_i$代表了noise的variance，描述了noise的大小，这是由NN学习到的参数</p><p>（注：使用$\exp(\sigma_i)$的目的是保证variance是正的）</p></li><li><p>$e_i$是正态分布中随机采样的点</p></li></ul><p>注意到，损失函数仅仅让input和output差距最小是不够的，因为variance是由机器自己决定的，如果不加以约束，它自然会去让variance=0，这就跟普通的Autoencoder没有区别了。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729165857.png" style="zoom:67%;"></p><p>额外加的限制函数解释如下：</p><p>下图中，蓝线表示$e^{\sigma_i}$，红线表示$1+\sigma_i$，两者相减得到绿线。绿线的最低点$\sigma_i=0$，则variance $e^{\sigma_i}=1$，此时loss最低，而$(m_i)^2$项则是对code的L2 regularization，让它比较sparse，不容易过拟合。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729165901.png" alt></p><p>上面是比较直观的理由，以下是paper上比较常见的解释。我们回归到我们要做的事情是什么，假设要machine generate pokemon的image，那每一张pokemon的图都可以想成是高维空间中的一个点。假设它是20*20的image，在高维空间中也就是400维的点，在图上我们用一维描述它，但其实是一个高维的空间。那现在要做的就是estimate p(x)的分布，它表示一张图片像宝可梦的几率，然后就可以根据p(x)高的地方去sample出一张像宝可梦的图。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729204112.png" style="zoom:60%;"></p><p>Estimate the probability distributon可以用Gaussion mixture model。Guassion mixture model：现在有一个distribution(黑色的线)，这个黑色的distribution其实是很多的Gaussion(青蓝色)用不同的weight叠合起来的结果。如果你的gaussion数目够多，你就可以产生很复杂的distribution，公式为 $p(x)=\sum_{m}p(m)p(x|m)$ 。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729172813.png" style="zoom:67%;"></p><p>这样每一个$x$并不属于某一个class或者cluster，而是有一个vector来描述它不同面向的disstribution，描述它不同面向的特性，<strong>VAE其实就是Gaussian Mixture Model的Distributed representation的版本</strong>。</p><p>假设我们要sample一个vector $z$，$z$是从normal distribution中sample出来的，$z$的每一个dimension都代表了某种attribute（特质，特性）。由$z$可以决定Gaussian的mean $\mu$和variance $\sigma$，由于$z$是continous的，所有它有无穷的可能，那mean和variance也有无穷多的可能。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729172816.png" style="zoom:67%;"></p><p>$P(x)$的曲线是这样产生的：$z$上的每一个点都有可能被sample到，当sample出一个点后它就会对应到一个Gaussian，把它们mixture起来就得到了$P(x)$，即$P(x)=\int \limits_{z}P(z)P(x|z)dz $（注意因为$z$是continous的，所以这里要用积分，而不是sum）。</p><h4 id="2-4-Maximizing-Likelihood"><a href="#2-4-Maximizing-Likelihood" class="headerlink" title="2.4. Maximizing Likelihood"></a>2.4. Maximizing Likelihood</h4><p>那给出一个$z$怎么找出mean和variance呢，假设mean和variance都来自一个function，这个function就可以是一个NN。当然$z$的分布不一定是Gaussian，可以自己设定。那训练这个NN的目标就是要Maximiza the likelihood of the observed $x$，即使下式最大：</p><script type="math/tex; mode=display">L=\sum \limits_{x}\log P(x)</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729172821.png" style="zoom:67%;"></p><p>我们要做的就是调NN里的参数weight和bias，使得likelihood最大。然后我们需要引入另一个distribution $q(z|x)$，它是given $x$来决定在$z$的space上的mean和variance，还需要有另外一个NN’，input $x$之后会output对应的$z$的mean $\mu’(x)$和variance $\sigma’(x)$，即决定$z$要从什么样的mean和variance中被sample出来。</p><p>上图中上面的NN就相当于是VAE中的Decoder，下面的NN就相当于是VAE中的ENcoder。</p><p>下面是对$L=\sum \limits_{x}\log P(x)$的表达式的具体的推导：</p><p>推导$\log P(x)=L_b+KL(q(z|x)||P(z|x))$：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729214950.png" style="zoom:67%;"></p><p>我们本来要做的是找使得$L$最大的$P(x|z)$，现在转换为求使$L_b$最大的$P(x|z)$和$q(z|x)$。 </p><p>如果我们只找$p(x∣z)$ 这一项的话，然后去maximizing $L_b$ ，当增加$L_b$的时候，有可能会增加likehood，但不知道likehood跟lower bound之间到底有还差多少距离。你希望你做到的是：当lower bound上升的时候，likehood也跟着上升。但是有可能会遇到糟糕的事情是：lower bound上升的时候，likehood反而下降，因为不知道它们之间的差距是多少。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729221051.png" style="zoom:95%;"></p><p>引入$q(z|x)$这一项就是为了解决这一问题。如上图中蓝色的是likehood， $\log P(x)=L_b+KL$，如果你今天调 $q(z|x)$来maximizing $L_b$，会发现$q(z|x)$跟$\log P(x)$是没有关系的，即ikelihood不变，那maximizing $L_b$的同时也在minimize KL divergence，即让lower bound（$L_b$）跟likehood越来越接近。如果固定住 $p(x|z)$这一项，去调 $q(z|x)$这一项的话，会让$L_b$ 一直上升，直到KL divergence会完全不见。由于likehood一定要比lower bound大，这时你再调$p(x|z)$和$q(z|x)$来maximizing $L_b$的话，就可以保证likehood会一定增大。</p><p>这样做也会得到一个副产物，当maximize $L_b$这一项的时候，会让KL divergence越来越小，意味着会让 $q(z|x)$ 跟 $p(z|x)$越来越接近。所以接下来做的事情就是找$p(x|z)$跟$q(z|x)$，可以让$L_b$越大越好，就等同于让likehood越来越大，最后顺便会得到$q(z|x)$可以去approximation $p(z|x)$。</p><p>而$q$是个neural network，要去minimize $KL(q(z|x)||P(z))$就是去调NN‘让它产生的distribution和normal distribution越接近越好，而loss function就是之前讲过的那个式子$\sum \limits^{3} \limits_{i=1}(\exp(\sigma_i)-(1+\sigma_i)+(m_i)^2)$（这部分的推导可以参考VAE的原始论文）。</p><p>另外一项是转化为$\log P(x|z))$的期望值：</p><script type="math/tex; mode=display">P(x)=\int \limits_{z}P(z)P(x|z)dz=E_{q(z|x)}[\log P(x|z)]</script><p>可以理解是我们从$q(z|x)$中去sample data，要让$\log P(x|z)$越大越好，这其实就是Auto-encoder在做的事情。你可以把$x$输入到NN’中得到mean $\mu’(x)$和variance $\sigma’(x)$，根据这个mean和variance可以sample出一个$z$；接下来把z输入到NN，得到mean $\mu(x)$和variance $\sigma(x)$，我们的目标是让这个mean和variance代表的distribution是$x$的几率越大越好，在实际使用中往往不考虑variance，那我们就是让最后输出的mean和$x$越接近越好，这不就是Auto-encoder在做的事情。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729224154.png" style="zoom:90%;"></p><p><strong>Conditional VAE</strong></p><p>还有一种方法叫Conditional VAE，举个例子，如果你让VAE可以产生手写的数字，给它一个digit，然后它把这个digit的特性抽取出来(笔画的粗细等等)，然后丢进encoder的时候一方面给它有关这个数字特性的distribution，另外一方面告诉decoder它是什么数字。那你就可以根据这一个digit，generate跟它style相近的digit。Conditional VAE可以根据某一个digit画出跟它style相近的数字。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729230209.png" style="zoom:80%;"></p><p><strong>Problems of VAE</strong></p><p>VAE有一个缺点，它只是在努力做到让生成的图像与数据集里的图像尽可能相似，却从来没有想过怎么样真的产生一张新的图像，因此由VAE生成的图像大多是数据集中图像的线性变化，而很难自主生成全新的图像。假设Decoder output跟真正的image之间有一个pixel的差距，那有时不同的pixel落在不同的位置会得到非常不一样的结果，如下图中的两个数字“7”，人很容易发现其区别：左边的像是真的数字，而右边明显是fake。但对VAE来说，它们只是有一个pixel的差异，两张image都是一样好或者不好的。VAE做到的只是模仿，而不是创造，GAN的诞生，就是为了创造。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729224258.png" style="zoom:67%;"></p><h3 id="3-GAN"><a href="#3-GAN" class="headerlink" title="3. GAN"></a>3. GAN</h3><p>Generative Adversarial Network（GAN，对抗生成网络），基本思想类似天敌之间相互竞争，相互进步。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200812231603.png" style="zoom:67%;"></p><p>GAN由生成器(Generator)和判别器(Discriminator)组成：</p><ul><li>对判别器的训练：把生成器产生的图像标记为0，真实图像标记为1，丢给判别器训练分类，希望它能分辨real image和fake image；</li><li>对生成器的训练：调整生成器的参数，使产生的图像（fake image）能够“骗过”判别器，即判别器输出越接近1越好；</li><li>每次训练GAN时生成器和判别器要分开训练：先Fix住生成器，训练判别器的参数；再Fix 判别器，训练生成器的参数，如此反复。</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200812231826.png" style="zoom:80%;"></p><p>（PS：李老师后面会有专门介绍GAN的课程，之后再做详细记录吧。）</p>]]></content>
    
    <summary type="html">
    
      文本介绍了三种无监督学习的Generative Model：Pixel RNN，Variational Auto-encoder(VAE)和Generative Adversarial Network(GAN)。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Pixel RNN" scheme="http://nekomoon404.github.io/tags/Pixel-RNN/"/>
    
      <category term="VAE" scheme="http://nekomoon404.github.io/tags/VAE/"/>
    
      <category term="GAN" scheme="http://nekomoon404.github.io/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>DL笔记（14）Unsupervised Learning-Deep Auto-encoder</title>
    <link href="http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89Unsupervised-Learning-Deep-Auto-encoder/"/>
    <id>http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8814%EF%BC%89Unsupervised-Learning-Deep-Auto-encoder/</id>
    <published>2020-07-29T02:31:01.000Z</published>
    <updated>2020-07-29T04:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Auto-encoder"><a href="#1-Auto-encoder" class="headerlink" title="1. Auto-encoder"></a>1. Auto-encoder</h3><p><strong>Auto-encoder本质上就是一个自我压缩和解压的过程</strong>，比如在做图像处理时，我们想要获取压缩后的code，它代表了对原始数据的某种紧凑精简的有效表达，即降维结果，这个过程中我们需要：</p><ul><li>Encoder(编码器)，它可以把原先的图像压缩成更低维度的向量；</li><li>Decoder(解码器)，它可以把压缩后的向量还原成图像；</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103552.png" alt></p><p>注意到，Encoder和Decoder都是Unsupervised Learning，由于code是未知的，对Encoder来说，我们手中的数据只能提供图像作为NN的input，却不能提供code作为output；对Decoder来说，我们只能提供图像作为NN的output，却不能提供code作为input。</p><p>因此Encoder和Decoder单独拿出一个都无法进行训练，我们需要把它们连接起来，这样整个神经网络的输入和输出都是我们已有的图像数据，就可以同时对Encoder和Decoder进行训练，而降维后的编码结果就可以从最中间的那层hidden layer中获取。</p><h4 id="1-1-Compare-with-PCA"><a href="#1-1-Compare-with-PCA" class="headerlink" title="1.1. Compare with PCA"></a>1.1. Compare with PCA</h4><p>实际上PCA用到的思想与之非常类似，<strong>PCA的过程本质上就是按组件拆分，再按组件重构的过程</strong>。在PCA中，假设input一张image $x$（本应该是把$x-\bar{x}$当做input，这边我们把$\bar{x}$省略掉，通常在做NN的时候，你拿到的data其实会normalization的，即data的mean是0）。我们先把$x$乘上weight $W$，通过NN的一个layer得到得到component的weight $c$，然后再乘上$W^T$得到重组后的$\hat x$，同样我们期望重构后的$\hat x$与原始的$x$越接近越好，即Minimize $(x-\hat{x})^2$。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103708.png" alt></p><p>如果把这个过程看作是神经网络，那么原始的$x$就是input layer，重构$\hat x$就是output layer，中间组件分解权重$c$就是hidden layer，在PCA中它是linear的，我们通常又叫它瓶颈层(<strong>Bottleneck layer</strong>)</p><p>由于经过组件分解降维后的$c$，维数要远比输入输出层来得低，因此hidden layer实际上非常窄，因而有Bottleneck layer的叫法。对比于Auto-encoder，从input layer到hidden layer的按组件分解实际上就是编码(encode)过程，从hidden layer到output layer按组件重构实际上就是解码(decode)的过程。</p><p>这时候你可能会想，可不可以用更多层hidden layer呢？答案是肯定的</p><h4 id="1-2-Deep-Auto-encoder"><a href="#1-2-Deep-Auto-encoder" class="headerlink" title="1.2. Deep Auto-encoder"></a>1.2. Deep Auto-encoder</h4><p><strong>Multi Layer</strong></p><p>对deep的自编码器来说，实际上就是通过多级编码降维，再经过多级解码还原的过程，此时：</p><ul><li>从input layer到bottleneck layer的部分都属于<strong>Encoder​</strong>；</li><li>从bottleneck layer到output layer的部分都属于<strong>Decoder​</strong>；</li><li>bottleneck layer的output就是自编码结果<strong>code​</strong>。</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103712.png" alt></p><p>（paper: <a href="https://www.cs.toronto.edu/~hinton/science.pdf" target="_blank" rel="noopener"><em>Hinton G E, Salakhutdinov R R. Reducing the dimensionality of data with neural networks[J]. science, 2006, 313(5786): 504-507.</em></a>）</p><p>Training这个Deep Auto-encoder的方法就是用之前讲过的Backpropagation，在多层layer的中间会有一层特别“窄”的layer，即为Bottleneck layer，它的output就代表了一组Code。从整个NN的input到Bottleneck layer就是Encoder，从Bottleneck layer的output到整个NN的output就是Decoder。</p><p>注意到，如果按照PCA的思路，则<strong>Encoder的参数$W_i$需要和Decoder的参数$W_i^T$保持一致</strong>的对应关系，这可以通过给两者相同的初始值并设置同样的更新过程得到，这样做的好处是，可以节省一半的参数，降低overfitting的概率。但这件事情<strong>并不是必要的</strong>，实际操作的时候，你完全可以对神经网络进行直接训练而不用保持编码器和解码器的参数一致</p><p><strong>Visualize</strong></p><p>下图给出了Hinton分别采用PCA和Deep Auto-encoder对手写数字进行编码解码后的结果，从784维降到30维，然后再从30维reconstruct到784维，可以看出，Deep的自编码器还原效果比PCA要更好。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103715.png" alt></p><p>如果将其降到二维平面做可视化，不同颜色代表不同的数字，可以看到：</p><ul><li>通过PCA降维得到的编码结果中，不同颜色代表的数字被混杂在一起；</li><li>通过Deep Auto-encoder降维得到的编码结果中，不同颜色代表的数字被分散成一群一群的。</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103718.png" alt></p><h3 id="2-More-Application"><a href="#2-More-Application" class="headerlink" title="2. More Application"></a>2. More Application</h3><h4 id="2-1-Text-Retrieval"><a href="#2-1-Text-Retrieval" class="headerlink" title="2.1.  Text Retrieval"></a>2.1.  Text Retrieval</h4><p>Auto-encoder也可以被用在文字处理上，用Auto-encoder把一篇文章压成code。比如我们要做文字检索，很简单的一个做法是Vector Space Model，把每一篇文章都表示成空间中的一个vector。</p><p>假设查询者输入了某个词汇，那我们就把该查询词汇也变成空间中的一个点，并计算query和每一篇document之间的内积 inner product 或余弦相似度 cos-similarity（余弦相似度有均一化的效果，可能会得到更好的结果）。下图中跟query向量最接近的几个向量的cosine-similarity是最大的，于是可以从这几篇文章中去检索。实际上这个模型的好坏，就取决于从document转化而来的vector的好坏，它是否能够充分表达文章信息。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103721.png" alt></p><p><strong>Bag-of-word</strong></p><p>最简单的vector表示方法是Bag-of-word，维数等于所有词汇的总数，某一维等于1则表示该词汇在这篇文章中出现，此外还可以根据词汇的重要性在对应的维上乘weight。但这个模型是非常脆弱的，对它来说每个词汇都是相互独立的，无法体现出词汇之间的语义(semantic)。</p><p><strong>Auto-encoder</strong></p><p>虽然Bag-of-word不能直接用于表示文章，但我们可以把它作为Auto-encoder的input，通过降维来抽取有效信息，以获取所需的vector。同样为了可视化，这里将Bag-of-word降维到二维平面上，下图中每个点都代表一篇文章，不同颜色则代表不同的文章类型，发现同一类文章都有较好地聚集在一起。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103725.png" alt></p><p>如果用户做查询，就把查询的语句（query）用相同的方式映射到该二维平面上，并找出属于同一类别的所有文章即可。在矩阵分解(Matrix Factorization)中，我们介绍了LSA算法，它可以用来寻找每个词汇和每篇文章背后的隐藏关系(vector)，如果在这里我们采用LSA，并使用二维latent vector来表示每篇文章，得到的可视化结果如上图右下角所示，可见效果并没有Auto-encoder好。</p><h4 id="2-2-Similar-Image-Search"><a href="#2-2-Similar-Image-Search" class="headerlink" title="2.2. Similar Image Search"></a>2.2. Similar Image Search</h4><p>Auto-encoder同样可以被用在图像检索（Image Search）上。以图找图最简单的做法就是直接对输入的图片与数据库中的图片计算pixel的相似度，并挑出最像的图片，但这种方法的效果是不好的，因为单纯的pixel所能够表达的信息太少了。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729150042.png" style="zoom:60%;"></p><p>我们需要使用Deep Auto-encoder对图像进行降维和特征提取，并在编码得到的code所在空间做检索。下图展示了Encoder的过程，并给出了原图与Decoder后的图像对比。因为Auto-encoder是unsupervised的方法，所有通常我们不必担心数据量的问题。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103728.png" alt></p><p>这么做的好处如下：</p><ul><li>Auto-encoder可以通过降维提取出一张图像中最有用的特征信息，包括pixel与pixel之间的关系；</li><li>降维之后数据的size变小了，这意味着模型所需的参数也变少了，同样的数据量对参数更少的模型来说，可以训练出更精确的结果，一定程度上避免了过拟合的发生；</li><li>Auto-encoder是一个无监督学习的方法，数据不需要人工打上标签，这意味着我们只需简单处理就可以获得大量的可用数据；</li></ul><p>下图给出了分别以原图的pixel计算相似度和以auto-encoder后的code计算相似度的两种方法在图像检索上的结果，可以看到，通过pixel检索到的图像会出现很多奇怪的物品，而通过code检索到的图像则都是人脸</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103731.png" alt></p><p>可能有些人脸在原图的pixel上看起来并不像，但把它们投影到256维的空间中却是相像的，可能在投影空间中某一维就代表了人脸的特征，因此能够被检索出来。</p><h4 id="2-3-Pre-training-DNN"><a href="#2-3-Pre-training-DNN" class="headerlink" title="2.3. Pre-training DNN"></a>2.3. Pre-training DNN</h4><p>在训练神经网络的时候，我们一般都会对如何初始化参数比较困扰，预训练(pre-training)是一种寻找比较好的参数初始化值的方法，而我们<strong>可以用Auto-encoder来做pre-training</strong>。</p><p>以MNIST数据集为例，我们对每层hidden layer都做一次auto-encoder，<strong>使每一层都能够提取到上一层最佳的特征向量</strong></p><p>为了方便表述，这里用$x-z-\widetilde{x}$来表示一个自编码器，其中$x$表述输入输出层的维数，$z$表示隐藏层的维数。</p><ul><li><p>首先使input通过一个$784-1000-784$的自编码器，当该自编码器训练稳定后，就把参数$W^1$固定住，然后将数据集中所有784维的图像都转化为1000维的vector</p><p>注意：这里encoder做的不是降维而是升维，当编码后的维数比输入维数要高时，需要注意可能会出现编码前后原封不动的情况，$W^1$的一部分就是个identity matrix。为此需要额外加一个很强的正则项regularization，比如L1 regularization，强迫使code的分布是分散的。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103735.png" alt></p><ul><li>接下来把训练好的Auto-encoder中的$W^1$保留下来，再让这些1000维的vector通过一个$1000-1000-1000$的编码器，其$a^1$与$\widetilde{a}^1$越接近越好，当其训练稳定后，再把参数$W^2$保留下来fix住，对数据集再做一次转换。</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103738.png" alt></p><ul><li>接下来再用转换后的数据集去训练第三个$1000-500-1000$的自编码器，训练稳定后固定$W^3$，数据集再次更新转化为500维。</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103741.png" alt></p><ul><li><p>此时三个隐藏层的参数$W^1$、$W^2$、$W^3$就是训练整个神经网络时的参数初始值；</p></li><li><p>然后随机初始化最后一个隐藏层到输出层之间的参数$W^4$；</p></li><li><p>再用反向传播去调整一遍参数，因为$W^1$、$W^2$、$W^3$都已经是很好的参数值了，这里只是做微调，这个步骤也因此得名为<strong>Fine-tune</strong>。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103744.png" alt></p><p>由于现在训练机器的条件比以前更好，因此pre-training并不是必要的，但它也有自己的优势。如果你只有大量的unlabeled data和少量的labeled data，那你可以先用这些unlabeled data把$W^1$、$W^2$、$W^3$先初始化好，最后再用labeled data去微调$W^1$~$W^4$即可。因此pre-training在有大量unlabeled data的场景下(如半监督学习)是比较有用的。</p><h4 id="2-4-CNN"><a href="#2-4-CNN" class="headerlink" title="2.4. CNN"></a>2.4. CNN</h4><p><strong>CNN as Encoder</strong></p><p>处理图像通常都会用卷积神经网络CNN，它的基本思想是交替使用卷积层和池化层，让图像越来越小，最终展平，这个过程跟Encoder编码的过程其实是类似的</p><p>理论上要实现自编码器，Decoder只需要做跟Encoder相反的事即可，那对CNN来说，解码的过程也就变成了交替使用去卷积层Deconvolution和去池化层Unpooling即可。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103747.png" alt></p><p>那什么是去卷积层(Deconvolution)和去池化层(Unpooling)呢？</p><p><strong>Unpooling</strong></p><p>做pooling的时候，假如得到一个4×4的matrix，就把每4个pixel分为一组，从每组中挑一个最大的留下，此时图像就变成了原来的四分之一大小。如果还要做Unpooling，就需要提前记录pooling所挑选的pixel在原图中的位置，下图中用灰色方框标注。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103751.png" alt></p><p>然后做Unpooling，就要把当前的matrix放大到原来的四倍，也就是把2×2 matrix里的pixel按照原先记录的位置插入放大后的4×4 matrix中，其余项补0即可。当然这不是唯一的做法，在<code>Keras</code>中，pooling并没有记录原先的位置，做Unpooling的时候就是直接把pixel的值复制四份填充到扩大后的matrix里即可。</p><p><strong>Deconvolution</strong></p><p>实际上，Deconvolution就是convolution。这里以一维的卷积为例，假设输入是5维，过滤器(filter)的大小是3。</p><p>卷积的过程就是每三个相邻的点通过过滤器生成一个新的点，如下图左侧所示。在你的想象中，去卷积的过程应该是每个点都生成三个点，不同的点对生成同一个点的贡献值相加；但实际上，这个过程就相当于在周围补0之后再次做卷积，如下图右侧所示，两个过程是等价的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103754.png" alt></p><p>卷积和去卷积的过程中，不同点在于，去卷积需要补零且过滤器的weight与卷积是相反的：</p><ul><li>在卷积过程中，依次是橙线、蓝线、绿线；</li><li>在去卷积过程中，依次是绿线、蓝线、橙线。</li></ul><p>因此在实践中，做去卷积的时候直接对模型加卷积层即可。</p><h4 id="2-5-Generate"><a href="#2-5-Generate" class="headerlink" title="2.5. Generate"></a>2.5. Generate</h4><p>在用自编码器的时候，通常是获取Encoder之后的code作为降维结果，但实际上Decoder也是有作用的，我们可以拿它来生成新的image。以MNIST为例，训练好编码器之后，取出其中的Decoder，输入一个随机的code，就可以生成一张图像</p><p>假设将28×28维的图像通过一层2维的hidden layer投影到二维平面上，得到的结果如下所示，不同颜色的点代表不同的数字，然后在红色方框中，等间隔的挑选二维向量丢进Decoder中，就会生成许多数字的图像。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103800.png" alt></p><p>这往往需要我们先观察一下二维的code的分布，确定哪些region是有值的，然后sample出来。此外，我们还可以对code加L2 regularization，以限制code分布的范围集中在0附近，此时就可以直接以0为中心去随机采取样本点，再通过Decoder生成图像。观察生成的数字图像，可以发现横轴的维度可以理解是表示是否含有圆圈，纵轴的维度表示是否倾斜。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103803.png" alt></p><h3 id="3-Other-Auto-encoder"><a href="#3-Other-Auto-encoder" class="headerlink" title="3. Other Auto-encoder"></a>3. Other Auto-encoder</h3><h4 id="3-1-De-noising-Auto-encoder"><a href="#3-1-De-noising-Auto-encoder" class="headerlink" title="3.1. De-noising Auto-encoder"></a>3.1. De-noising Auto-encoder</h4><p>有一个方法可以让Auto-encoder做的更好，叫作De-noising Auto-encoder（去噪自编码器）。它的基本思想是，把输入的$x$加上一些噪声(noise)变成$x’$，再对$x’$依次做编码(encode)和解码(decode)，得到还原后的$y$。</p><p>值得注意的是，一般的自编码器都是让输入输出尽可能接近，但在去噪自编码器中，我们的目标是<strong>让解码后的$y$与加噪声之前的$x$越接近越好</strong>。这种方法可以<strong>增加系统的鲁棒性</strong>，因为此时的编码器Encoder不仅仅是在学习如何做编码，它还学习到了如何过滤掉噪声这件事情。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729103757.png" alt></p><p>（paper: <a href="https://www.cs.toronto.edu/~larocheh/publications/icml-2008-denoising-autoencoders.pdf" target="_blank" rel="noopener"><em>Vincent, Pascal, et al. “Extracting and composing robust features with denoising autoencoders.” ICML, 2008.</em></a>）</p><h4 id="3-2-Contractive-Auto-encoder"><a href="#3-2-Contractive-Auto-encoder" class="headerlink" title="3.2. Contractive Auto-encoder"></a>3.2. Contractive Auto-encoder</h4><p>Contractive Auto-encoder（收缩自动编码器）的基本思想是，在做encode编码的时候，要加上一个约束，它可以使得：input的变化对编码后得到的code的影响最小化。</p><p>这个描述跟去噪自编码器很像，只不过去噪自编码器的重点在于加了噪声之后依旧可以还原回原先的输入，而收缩自动编码器的重点在于加了噪声之后能够保持编码结果不变。</p><p>（paper: <a href="https://icml.cc/Conferences/2011/papers/455_icmlpaper.pdf" target="_blank" rel="noopener"><em>Rifai, Salah, et al. “Contractive auto-encoders: Explicit invariance during feature extraction.“ Proceedings of the 28th International Conference on Machine Learning (ICML-11). 2011.</em></a>）</p><p>其实还有很多nonlinear的dimension reduction的方法，比如Restricted Boltzmann Machine（受限玻尔兹曼机），它并不是neural network的方法，只是看起来有点像；Deep Belief Network（深度信念网络），它也和Deep neural network不是一回事。</p><h4 id="3-3-Seq2Seq-Auto-encoder"><a href="#3-3-Seq2Seq-Auto-encoder" class="headerlink" title="3.3. Seq2Seq Auto-encoder"></a>3.3. Seq2Seq Auto-encoder</h4><p>在之前介绍的自编码器中，输入都是一个固定长度的vector，但类似文章、语音等信息实际上不应该单纯被表示为vector，那会丢失很多前后联系的信息。Seq2Seq就是为了解决这个问题提出的，具体内容在RNN那次的笔记中有介绍。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729154125.png" style="zoom: 50%;"></p>]]></content>
    
    <summary type="html">
    
      文本介绍了Auto-encoder（自编码器）的基本思想，与PCA的联系，从单层编码到多层的变化；以及Auto-encoder的一些应用，包括在文字搜索和图像搜索上的应用，预训练DNN，利用CNN实现自编码器，加噪声的自编码器等。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Auto-encoder" scheme="http://nekomoon404.github.io/tags/Auto-encoder/"/>
    
      <category term="Fine-tune" scheme="http://nekomoon404.github.io/tags/Fine-tune/"/>
    
  </entry>
  
  <entry>
    <title>DL笔记（13）Unsupervised Learning-Neighbor Embedding</title>
    <link href="http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89Unsupervised-Learning-Neighbor-Embedding/"/>
    <id>http://nekomoon404.github.io/2020/07/29/ML%E7%AC%94%E8%AE%B0%EF%BC%8813%EF%BC%89Unsupervised-Learning-Neighbor-Embedding/</id>
    <published>2020-07-29T00:35:26.000Z</published>
    <updated>2020-07-29T02:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Manifold-Learning"><a href="#1-Manifold-Learning" class="headerlink" title="1.Manifold Learning"></a>1.Manifold Learning</h3><p>之前的两篇笔记中介绍了PCA和Word Embedding，它们都是线性降维的方法，本文要介绍的Neighbor Embedding是非线性降维的方法，它用的是降维之前每一个data point与它的“邻居”之间的关系来做降维，这种方法也叫作<strong>Manifold Learning（流行学习）</strong>，简单地可以理解为是高维空间中的低维空间。</p><p>样本点的分布可能是在高维空间里的一个流行(Manifold)，也就是说，样本点其实是分布在低维空间里面，只是被“扭曲”地塞到了一个高维空间里。比如地球的表面就是一个流行(Manifold)，它是一个二维的平面，但是被塞到了一个三维空间里。</p><p>在Manifold中，只有对距离很近用欧式距离判断其相似程度才会成立，如而在下图的S型曲面中，当点的距离比较远时，用欧氏距离是无法判断两个样本点的相似程度的。而Manifold Learning要做的就是把这个S型曲面降维展开，把塞在高维空间里的低维空间摊平，此时使用欧氏距离就可以描述样本点之间的相似程度，这会对接下来要做的cluster或者supervised learning都会有帮助的。类似的方法有很多，接下来简单介绍几种方法，最后介绍一下t-SNE。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085418.png" style="zoom: 50%;"></p><h3 id="2-Locally-Linear-Embedding"><a href="#2-Locally-Linear-Embedding" class="headerlink" title="2. Locally Linear Embedding"></a>2. Locally Linear Embedding</h3><p><strong>LLE（locally linear embedding，局部线性嵌入）</strong>的基本思想是：假设在原来的空间中，样本点的分布如下所示，我们关注$x^i$和它的邻居$x^j$，用$w_{ij}$来描述$x_i$和$x_j$的关系。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085428.png" style="zoom:50%;"></p><p>假设每一个样本点$x^i$都是可以用它的neighbor做linear combination组合而成，那$w_{ij}$就是拿$x^j$去组合$x^i$时的权重weight，因此找点与点的关系$w_{ij}$这个问题就转换成，找一组使得所有样本点与周围点线性组合的差距能够最小的参数$w_{ij}$：</p><script type="math/tex; mode=display">\sum\limits_i||x^i-\sum\limits_j w_{ij}x^j ||_2</script><p>接下来就要做Dimension Reduction，把$x^i$和$x^j$降维到$z^i$和$z^j$，并且保持降维前后两个点之间的关系$w_{ij}$是不变的。这就像是白居易的诗《长恨歌》中写到的“在天愿做比翼鸟，在地愿做连理枝”。</p><p>LLE的具体做法如下：</p><ul><li><p>在原先的高维空间中找到$x^i$和$x^j$之间的关系$w_{ij}$以后就把它固定住</p></li><li><p>使$x^i$和$x^j$降维到新的低维空间上的$z^i$和$z^j$</p></li><li><p>$z^i$和$z^j$需要minimize下面的式子：</p><script type="math/tex; mode=display">\sum\limits_i||z^i-\sum\limits_j w_{ij}z^j ||_2</script></li><li><p>即在原本的空间里，$x^i$可以由周围点通过参数$w_{ij}$进行线性组合得到，则要求在降维后的空间里，$z^i$也可以用同样的线性组合得到</p></li></ul><p>实际上，LLE并没有给出明确的降维函数，它没有明确地告诉我们怎么从$x^i$降维到$z^i$，只是给出了降维前后的约束条。<strong>在实际应用LLE的时候，对$x^i$来说，需要选择合适的邻居点数目K才会得到好的结果</strong>。用LLE或者其他类似的方法有一个好处就是，比如原来你不知道$x^i$、$x^j$，只知道$w_{i,j}$，那你也可用LLE来降维。</p><p>下图给出了原始paper中的实验结果，K太小或太大得到的结果都不太好，注意到在原先的空间里，只有距离很近的点之间的关系需要被保持住，如果K选的很大，就会选中一些由于空间扭曲才导致距离接近的点，而这些点的关系我们并不希望在降维后还能被保留。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085432.png" style="zoom:50%;"></p><h3 id="3-Laplacian-Eigenmaps"><a href="#3-Laplacian-Eigenmaps" class="headerlink" title="3. Laplacian Eigenmaps"></a>3. Laplacian Eigenmaps</h3><p>另一种方法叫<strong>Laplacian Eigenmaps（拉普拉斯特征映射）</strong>。之前在讲semi-supervised learning有提到smoothness assumption，即我们仅知道两点之间的欧氏距离是不够的，还需要观察两个点在high density区域下的距离。如果两个点在high density的区域里比较近，那才算是真正的接近。我们可以依据某些规则把样本点建立graph，那么smoothness的距离就可以使用graph中连接两个点路径上的edges数来近似。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085435.png" style="zoom:50%;"></p><p>简单回顾一下在semi-supervised：如果两个点$x^1$和$x^2$在高密度区域上是相近的，那它们的label $y^1$和$y^2$很有可能是一样的</p><script type="math/tex; mode=display">L=\sum\limits_{x^r} C(y^r,\hat y^r) + \lambda S\\S=\frac{1}{2}\sum\limits_{i,j} w_{i,j}(y^i-y^j)^2=y^TLy</script><p>其中$C(y^r,\hat y^r)$表示labeled data项，$\lambda S$表示unlabeled data项，它就像是一个regularization term，用于判断我们当前得到的label是否是smooth的。</p><p>其中如果点$x^i$与$x^j$是相连的，则$w_{i,j}$等于相似度，否则为0，$S$的表达式希望在$x^i$与$x^j$很接近的情况下，相似度$w_{i,j}$很大，而label差距$|y^i-y^j|$越小越好，同时也是对label平滑度的一个衡量</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085438.png" style="zoom: 50%;"></p><p>降维的基本原则：如果$x^i$和$x^j$在high density区域上是相近的，即相似度$w_{i,j}$很大，则降维后的$z^i$和$z^j$也需要很接近，总体来说就是让下面的式子尽可能小：</p><script type="math/tex; mode=display">S=\frac{1}{2}\sum\limits_{i,j} w_{i,j}(y^i-y^j)^2</script><p>注意，与LLE不同的是，这里的$w_{i,j}$表示$x^i$与$x^j$这两点的相似度，上式也可以写成$S=\sum\limits_{i,j} w_{i,j} ||z^i-z^j||_2$</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085442.png" style="zoom:50%;"></p><p>（paper：<a href="http://web.cse.ohio-state.edu/~belkin.8/papers/LEM_NIPS_01.pdf" target="_blank" rel="noopener"><em>Belkin, M., Niyogi, P. Laplacian eigenmaps and spectral techniques for embedding and clustering. Advances in neural information processing systems . 2002</em></a>）</p><p>但光有上面这个式子是不够的，假如令所有的z相等，比如令$z^i=z^j=0$，那上式就会直接停止更新。在semi-supervised中，如果所有label $z^i$都设成一样，会使得supervised部分的$\sum\limits_{x^r} C(y^r,\hat y^r)$变得很大，因此lost就会很大，但在这里少了supervised的约束，因此我们<strong>需要给$z$一些额外的约束</strong>：</p><ul><li>假设降维后$z$所处的空间为$M$维，则$Span \{z^1,z^2,…,z^N\}=R^M$，我们希望降维后的$z$占据整个$M$维的空间，而不希望它展开后在一个比$M$更低维的空间里</li><li>最终解出来的$z$其实就是Graph Laplacian $L$比较小的特征值所对应的特征向量。</li></ul><p>这也是Laplacian Eigenmaps名称的由来，我们找的$z$就是Laplacian matrix的特征向量。如果通过拉普拉斯特征映射找到$z$之后再对其利用K-means做聚类，就叫做<strong>谱聚类(spectral clustering)</strong>。</p><h3 id="4-t-SNE"><a href="#4-t-SNE" class="headerlink" title="4. t-SNE"></a>4. t-SNE</h3><p>t-SNE（T-distributed Stochastic Neighbor Embedding，t分布随机邻居嵌入）</p><p>前面的方法有一个缺点就是，<strong>只假设了相邻的点要接近，却没有假设不相近的点要分开</strong>，所以在MNIST使用LLE会遇到下图的情形，它确实会把同一个class的点都聚集在一起，却没有办法避免不同class的点重叠在一个区域，这就会导致依旧无法区分不同class的现象。COIL-20数据集包含了同一张图片进行旋转之后的不同形态，对其使用LLE降维后得到的结果是，同一个圆圈代表同张图像旋转的不同姿态，但许多圆圈之间存在重叠</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085450.png" style="zoom:80%;"></p><p>做t-SNE同样要降维，在原来$x$的分布空间上，我们需要计算所有$x^i$与$x^j$之间的相似度$S(x^i,x^j)$，然后需要将其做归一化：$P(x^j|x^i)=\frac{S(x^i,x^j)}{\sum_{k\ne i}S(x^i,x^k)}$，即$x^j$与$x^i$的相似度（similarity）占 除了$x^j$之外所有的点与$x^i$的simiarity之和的比例。将$x$降维到$z$，同样可以计算相似度$S’(z^i,z^j)$，并做归一化：$Q(z^j|z^i)=\frac{S’(z^i,z^j)}{\sum_{k\ne i}S’(z^i,z^k)}$。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085455.png" style="zoom:80%;"></p><p>注意，这里的归一化是有必要的，因为我们无法判断在$x$和$z$所在的空间里，$S(x^i,x^j)$与$S’(z^i,z^j)$的scale是否是一致的，需要将其映射到一个统一的概率区间，即(0,1)。</p><p>我们<strong>希望找到的投影空间$z$，可以让$P(x^j|x^i)$和$Q(z^j|z^i)$的分布越接近越好</strong>。用于<strong>衡量两个分布之间相似度的方法就是**</strong>KL散度(KL divergence)**，我们的目标就是让$L$越小越好，解法可以用Gradient Descent：</p><script type="math/tex; mode=display">L=\sum\limits_i KL(P(*|x^i)||Q(*|z^i))\\=\sum\limits_i \sum\limits_jP(x^j|x^i)log \frac{P(x^j|x^i)}{Q(z^j|z^i)}</script><p>（<strong>KL Divergence</strong></p><p>这里简单补充一下KL散度的基本知识。KL 散度，最早是从信息论里演化而来的，所以在介绍 KL 散度之前，我们要先介绍一下信息熵，信息熵的定义如下：</p><script type="math/tex; mode=display">H=-\sum\limits_{i=1}^N p(x_i)\cdot log\ p(x_i)</script><p>其中$p(x_i)$表示事件$x_i$发生的概率，信息熵其实反映的就是要表示一个概率分布所需要的平均信息量</p><p>在信息熵的基础上，我们定义KL散度为：</p><script type="math/tex; mode=display">D_{KL}(p||q)=\sum\limits_{i=1}^N p(x_i)\cdot (log\ p(x_i)-log\ q(x_i))\\=\sum\limits_{i=1}^N p(x_i)\cdot log\frac{p(x_i)}{q(x_i)}</script><p>$D_{KL}(p||q)$表示的就是概率$q$与概率$p$之间的差异，很显然，KL散度越小，说明概率$q$与概率$p$之间越接近，那么预测的概率分布与真实的概率分布也就越接近。）</p><h5 id><a href="#" class="headerlink" title=" "></a> </h5><p>t-SNE会计算所有样本点之间的相似度，运算量会比较大，当数据量大的时候跑起来效率会比较低。常见的做法是对原先的空间用类似PCA的方法先做一次降维，然后用t-SNE对这个简单降维空间再做一次更深层次的降维，以期减少运算量。</p><p>值得注意的是，t-SNE的式子无法对新的样本点进行处理，一旦出现新的$x^i$，就需要重新跑一遍该算法，所以<strong>t-SNE通常不是用来训练模型的，它更适合用于做基于固定数据的可视化</strong>。t-SNE常用于将固定的高维数据可视化到二维平面上。</p><p><strong>t-SNE Similarity Measure</strong></p><p>t-SNE中对如何计算similarity的选择是非常的“神妙的“，如果根据欧氏距离计算降维前的相似度，往往采用<strong>RBF function</strong> $S(x^i,x^j)=\exp (-||x^i-x^j||_2)$，这个表达式的好处是，只要两个样本点的欧氏距离稍微大一些，相似度就会下降得很快</p><p>在t-SNE之前有一种叫做SNE的方法，它在降维后的新空间采用与上述相同的相似度算法$S’(z^i,z^j)=e^{-||z^i-z^j||_2}$。而t-SNE的“神妙”之处在于，它在降维后的新空间所采取的相似度算法是与之前不同的，它选取了<strong>t-distribution</strong>中的一种，即$S’(z^i,z^j)=\frac{1}{1+||z^i-z^j||_2}$。</p><p>以下图为例，假设横轴代表了在原先$x$空间上的欧氏距离或者做降维之后在$z$空间上的欧氏距离，红线代表RBF function，是降维前的分布；蓝线代表了t-distribution，是降维后的分布</p><p>你会发现，降维前后相似度从RBF function到t-distribution：</p><ul><li>如果原先在高维空间中两个点距离($\Delta x$)比较近，则降维转换之后，它们的相似度($\Delta y$)依旧是比较接近的</li><li>如果原先在高维空间中两个点距离($\Delta x$)比较远，则降维转换之后，它们的相似度($\Delta y$)会被拉得更远</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085459.png" style="zoom:80%;"></p><p>也就是说t-SNE可以聚集相似的样本点，同时还会放大不同类别之间的距离，从而使得不同类别之间的分界线非常明显，特别适用于可视化，下图则是对MNIST和COIL-20先做PCA降维，再做t-SNE降维可视化的结果：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200729085502.png" style="zoom:80%;"></p><p><strong>Conclusion</strong></p><p>小结一下，本文主要介绍了三种非线性降维的算法：</p><ul><li>LLE(Locally Linear Embedding)，局部线性嵌入算法，主要思想是降维前后，每个点与周围邻居的线性组合关系不变，$x^i=\sum\limits_j w_{ij}x^j$、$z^i=\sum\limits_j w_{ij}z^j$；</li><li>Laplacian Eigenmaps，拉普拉斯特征映射，主要思想是在high density的区域，如果$x^i$、$x^j$这两个点相似度$w_{i,j}$高，则投影后的距离$||z^i-z^j||_2$要小；</li><li>t-SNE(t-distribution Stochastic Neighbor Embedding)，t分布随机邻居嵌入，主要思想是，通过降维前后计算相似度由RBF function转换为t-distribution，在聚集相似点的同时，拉开不相似点的距离，比较适合用在数据固定的可视化领域。</li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了一些非线性降维算法，包括LLE(Locally Linear Embedding，局部线性嵌入)、Laplacian Eigenmaps(拉普拉斯特征映射)和t-SNE(T-distributed Stochastic Neighbor Embedding，t分布随机邻居嵌入t-SNE)。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Manifold Learning" scheme="http://nekomoon404.github.io/tags/Manifold-Learning/"/>
    
      <category term="LLE(Locally Linear Embedding)" scheme="http://nekomoon404.github.io/tags/LLE-Locally-Linear-Embedding/"/>
    
      <category term="Laplacian Eigenmaps" scheme="http://nekomoon404.github.io/tags/Laplacian-Eigenmaps/"/>
    
      <category term="t-SNE" scheme="http://nekomoon404.github.io/tags/t-SNE/"/>
    
      <category term="KL Divergence" scheme="http://nekomoon404.github.io/tags/KL-Divergence/"/>
    
  </entry>
  
  <entry>
    <title>DL笔记（12）Unsupervised Learning-Word Embedding</title>
    <link href="http://nekomoon404.github.io/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/"/>
    <id>http://nekomoon404.github.io/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/</id>
    <published>2020-07-26T02:46:43.000Z</published>
    <updated>2020-07-26T03:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Word Embedding（词嵌入）</strong>就是specific用在word上的Dimension Reductionn，在word embedding里面我们希望machine做的是，machine在看了大量的文章以后，它可以自动地把每一个词汇用不同的vector来表示，而vector的dimension能代表某种含义，至少能够做到比如一些词汇有相近的语义或特殊的关系，可以在vector上呈现出来，而这些我们用来描述词汇的vector就称之为Word Embedding。</p><p><strong>1-of-N Encoding</strong></p><p>一个词汇用vector来描述它，最简单的方法就是<strong>1-of-N Encoding</strong>，假设这个vector的维数就等于世界上所有单词的数目，那么对每一个单词来说，只需要某一维为1，其余都是0即可；这样做的坏处是词汇与词汇之间的关系无法借用这种vector来传递出来，每一个词汇对应的vector都是独立的，无法建立起同类word之间的联系。</p><p><strong>Word Class</strong></p><p>还可以把有同样性质的word进行聚类(clustering)，划分成多个class，然后用word所属的class来表示这个word，但光做clustering是不够的，太粗略了，不同class之间关联依旧无法被有效地表达出来。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112225.png" style="zoom:67%;"></p><h3 id="1-Word-Embedding"><a href="#1-Word-Embedding" class="headerlink" title="1. Word Embedding"></a>1. Word Embedding</h3><p>在Word Embedding中，一个词汇不是硬归类在某一个cluster里面，每一个词汇都用一个continuous的vector来描述词，vector的每个dimension可能都代表着某种含义。Word Embedding把每一个word都投影到高维空间上，当然这个空间的维度要远比1-of-N Encoding的维度低，假如1-of-N Encoding有10w维，那Word Embedding只需要50~100维就够了，这实际上也是Dimension Reduction的过程。</p><p>类似<strong>语义(semantic)</strong>的词汇，在这个word embedding的投影空间上是比较接近的，而且该空间里的每一维都可能有特殊的含义。比如词嵌入的投影空间如下图所示，则横轴可以理解是代表了生物与其它东西之间的区别，而纵轴则代表了会动的东西与静止的东西之间的差别。Word embedding是一个无监督的方法(unsupervised approach)，只要让机器阅读大量的文章，它就可以知道每一个词汇embedding之后的特征向量应该长什么样子。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112236.png" style="zoom:67%;"></p><p>我们的任务就是训练一个neural network，input是词汇，output则是它所对应的word embedding vector，实际训练的时候我们只有data的input，该如何解这类问题呢？之前提到过一种<strong>基于神经网络的降维方法，Auto-encoder</strong>，就是训练一个model，让它的输入等于输出，取出中间的某个隐藏层就是降维的结果，自编码的本质就是通过自我压缩和解压的过程来寻找各个维度之间的相关信息；但word embedding这个问题是不能用Auto-encoder来解的，因为输入的向量通常是1-of-N编码，各维无关，很难通过自编码的过程提取出什么有用信息。</p><p>那找Word Embedding的基本思想就是：<strong>每一个词汇的含义都可以根据它的上下文来得到</strong>。A word can be understood by its context，you shall know a word by the cmpany it keeps.</p><p>比如机器在两个不同的地方阅读到了“马英九520宣誓就职”、“蔡英文520宣誓就职”，它就会发现“马英九”和“蔡英文”前后都有类似的文字内容，于是机器就可以推测“马英九”和“蔡英文”这两个词汇代表了可能有同样地位的东西，即使它并不知道这两个词汇是人名。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112239.png" style="zoom:67%;"></p><p>那如何用这个思想来找出word embedding的vector呢？有两种常用的做法：</p><ul><li><strong>Count based</strong>（基于计数的词嵌入）</li><li><strong>Prediction based</strong>（基于预测的词嵌入）</li></ul><h4 id="1-1-Count-based"><a href="#1-1-Count-based" class="headerlink" title="1.1. Count based"></a>1.1. Count based</h4><p>假如$w_i$和$w_j$这两个词汇常常在同一篇文章中出现(co-occur)，它们的word vector分别用$V(w_i)$和$V(w_j)$来表示，则$V(w_i)$和$V(w_j)$会比较接近。假设$N_{i,j}$是$w_i$和$w_j$这两个词汇在相同文章里同时出现的次数，我们希望它与$V(w_i)\cdot V(w_j)$的内积越接近越好，这个思想和之前的文章中提到的矩阵分解(matrix factorization)的思想其实是一样的。这种方法有一个很代表性的例子是<a href="http://nlp.stanford.edu/projects/glove/" target="_blank" rel="noopener">Glove Vector</a></p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112242.png" style="zoom:67%;"></p><h4 id="1-2-Prediction-based"><a href="#1-2-Prediction-based" class="headerlink" title="1.2. Prediction based"></a>1.2. Prediction based</h4><h5 id="1-2-1-Language-model"><a href="#1-2-1-Language-model" class="headerlink" title="1.2.1. Language model"></a>1.2.1. Language model</h5><p>Prediction based的方法可以用在Language Modeling上，即predict一个句子出现的几率，比如你想让machine去估测“wreck a nice beach”这个句子出现的几率。但实际上你没有办法去估测一个句子出现的几率，因为word数目就已经很多了，那由word组成的句子就更数不胜数，即使我们能搜到很多句子的database要预测的句子在database出现过的几率极小，且很可能是0。所以在预测句子出现的几率时，通常会将其拆分成小的片段，然后分别去计算每一片段出现的几率，比如我们要计算“wreck a nice beach”出现的几率，那就分别去计算”Start”后面接”wreck”的几率P(wreck|START)，”wreck”后面接”a”的几率P(a|wreck)……其中$P(b|a)$可以用统计的方法去计算，也可以用NN（Neural Network）来做，去计算input 一个词汇a，output词汇b的几率。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726152637.png" style="zoom:95%;"></p><p>Language Modeling其实很有用的，可以用在机器翻译或者语音识别当中，它们需要这样的语言模型，比如在做语言辨识使只考虑声学的特性是不够的，不同的sentence可能有相同的发音，所以需要一个语言模型来告诉你哪个句子出现的几率是最高的。下面是一篇最早用神经网络来解决Language Model的paper，<a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener"><em>Bengio Y, Ducharme R, Vincent P, et al. A neural probabilistic language model[J]. Journal of machine learning research, 2003, 3(Feb): 1137-1155.</em></a>，为后来深度学习在解决语言模型问题甚至很多别的nlp问题时奠定了坚实的基础。</p><blockquote><p>关于这篇论文的解读：<a href="https://www.jianshu.com/p/be242ed3f314" target="_blank" rel="noopener">A Neural Probabilistic Language Model 论文阅读及实战</a>，<a href="https://zhuanlan.zhihu.com/p/81392113" target="_blank" rel="noopener">解析NNLM-A Neural Probabilistic Language Model</a>，<a href="https://zhuanlan.zhihu.com/p/21240807" target="_blank" rel="noopener">A Neural Probabilistic Language Model</a></p></blockquote><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726152642.png" style="zoom:95%;"></p><h5 id="1-2-2-how-to-do-perdition"><a href="#1-2-2-how-to-do-perdition" class="headerlink" title="1.2.2. how to do perdition"></a>1.2.2. how to do perdition</h5><p>给定一个sentence，我们要训练一个神经网络，它要做的就是根据当前的word $w_{i-1}$，来预测下一个可能出现的word $w_i$是什么 。假设我们使用1-of-N encoding把$w_{i-1}$表示成feature vector，它作为neural network的input，output的维数和input相等，只不过每一维都是小数，代表在1-of-N Encoding中该维为1其余维为0所对应的word会是下一个word $w_i$的概率。</p><p>如果我们把第一个hidden layer的input $z_1,z_2,…$拿出来，即NN的input乘一个matrix transform（做dimension reduction）得到的feature，用来做代表这个word的vector，它们所组成的$Z$就是word的另一种表示方式，当我们input不同的词汇，向量$Z$就会发生变化。也就是说，第一层hidden layer的维数可以由我们决定，而它的input又唯一确定了一个word，因此提取出第一层hidden layer的input，实际上就得到了一组可以自定义维数的Word Embedding的向量。如果把这些vector都画到平面上，就有可能得到“相似的word有相近的vector”这种图。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112245.png" style="zoom:67%;"></p><h5 id="1-2-3-Why-prediction-works"><a href="#1-2-3-Why-prediction-works" class="headerlink" title="1.2.3. Why prediction works"></a>1.2.3. Why prediction works</h5><p>prediction-based方法是如何体现根据词汇的上下文来了解该词汇的含义这件事呢？</p><p> 假设在两篇文章中，“蔡英文”和“马英九”代表$w_{i-1}$，“宣誓就职”代表$w_i$，我们希望对神经网络输入“蔡英文”或“马英九”这两个词汇，输出都是”宣誓就职”，即vector中对应“宣誓就职”词汇的那个维度的概率值是高的。为了使这两个不同的input通过NN能得到相同的output，就必须在进入hidden layer之前，就通过weight的转换将这两个input vector投影到位置相近的低维空间上。</p><p>也就是说，尽管两个input vector作为1-of-N编码看起来完全不同，但经过linear transform之后，将两者都降维到某一个空间中，在这个空间里，经过转换后的new vector 1和vector 2是非常接近的，因此它们同时进入一系列的hidden layer，最终输出时得到的output是相同的。因此，词汇上下文的联系就自动被考虑在这个prediction model里面。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112248.png" style="zoom:67%;"></p><p>总结一下，对1-of-N编码进行Word Embedding降维的结果就是神经网络模型第一层hidden layer的输入向量$\left [ \begin{matrix} z_1\ z_2\ … \end{matrix} \right ]^T$，该向量同时也考虑了上下文词汇的关联，我们可以通过控制第一层hidden layer的大小从而控制目标降维空间的维数。</p><p>有一个Tips是，在用prediction based的word embedding时，我们用的network的hidden layer通常只有一层，而不会是deep，并且activation function会用linear的，这样就有很像PCA。（提出这个方法的作者曾表示想要找word embedding其实不必用deep network，用shallow的network就够了，而且会train得非常快；另一个理由是word embedding有点像feature extraction，word embedding这个model抽出的vector是要拿来当接下来其他NLP task的Input，其他task用的是deep的model，那或许特征提取的部分就不需用deep的model。）</p><h5 id="1-2-4-Sharing-Parameters"><a href="#1-2-4-Sharing-Parameters" class="headerlink" title="1.2.4. Sharing Parameters"></a>1.2.4. Sharing Parameters</h5><p>你可能会觉得通过当前词汇预测下一个词汇这个约束太弱了（即只看一个词汇去predict下一个词汇），由于不同词汇的搭配千千万万，即便是人也无法准确地给出下一个词汇具体是什么。所有你可以扩展这个问题，使用10个及以上的词汇去预测下一个词汇，可以帮助得到较好的结果。这里假设machine看的是前2个词汇，在实际使用中你可以extent到让machine看前10个词汇或前20个词汇，道理是一样的。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726160338.png" style="zoom: 80%;"></p><p>如果是一般的神经网络，我们直接把$w_{i-2}$和$w_{i-1}$这两个vector拼接成一个更长的vector作为input即可。但实际上，我们会用一个trick，希望和$w_{i-2}$相连的weight与和$w_{i-1}$相连的weight是tight在一起的，简单来说就是$w_{i-2}$与$w_{i-1}$的相同dimension对应到第一层hidden layer相同neuron之间的连线拥有相同的weight，即share parameters，在上图中，用同样的颜色标注相同的weight。（回想在CNN中，不同的fliter也会share同样的参数）。</p><p>如果我们不这么做，那把同一个word放在$w_{i-2}$的位置和放在$w_{i-1}$的位置，得到的Embedding结果是会不一样的，把两组weight设置成相同，可以使$w_{i-2}$与$w_{i-1}$的相对位置不会对结果产生影响。除此之外，这么做还可以通过共享参数的方式有效地减少参数量，不会由于input的word数量增加而导致参数量剧增。</p><h5 id="1-2-5-Formulation"><a href="#1-2-5-Formulation" class="headerlink" title="1.2.5. Formulation"></a>1.2.5. Formulation</h5><p>假设$w_{i-2}$的1-of-N编码为$x_{i-2}$，$w_{i-1}$的1-of-N编码为$x_{i-1}$，维数均为$|V|$，表示数据中的words总数。Hidden layer的input为向量$z$，长度为$|Z|$，表示降维后的维数。则有：</p><script type="math/tex; mode=display">z=W_1 x_{i-2}+W_2 x_{i-1}</script><p>其中$W_1$和$W_2$都是$|Z|×|V|$维的weight matrix，它由$|Z|$组$|V|$维的向量构成。我们强迫让$W_1=W_2=W$，此时$z=W(x_{i-2}+x_{i-1})$。因此，只要我们得到了这组参数$W$，就可以与1-of-N编码$x$相乘得到word embedding的结果$z$</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112255.png" style="zoom:67%;"></p><h5 id="1-2-6-In-Practice"><a href="#1-2-6-In-Practice" class="headerlink" title="1.2.6. In Practice"></a>1.2.6. In Practice</h5><p>那在实际操作上，我们如何保证$W_1$和$W_2$一样呢？以下图中的$w_i$和$w_j$为例，我们希望它们的weight是一样的：</p><ul><li><p>首先在训练的时候就要给它们一样的初始值</p></li><li><p>然后分别计算loss function $C$对$w_i$和$w_j$的偏微分，并对其进行更新</p><script type="math/tex; mode=display">w_i=w_i-\eta \frac{\partial C}{\partial w_i}\\w_j=w_j-\eta \frac{\partial C}{\partial w_j}</script><p>这个时候你就会发现，$C$对$w_i$和$w_j$的偏微分是不一样的，这意味着即使给了$w_i$和$w_j$相同的初始值，更新过一次之后它们的值也会变得不一样，因此我们必须保证两者的更新过程是一致的，即：</p><script type="math/tex; mode=display">w_i=w_i-\eta \frac{\partial C}{\partial w_i}-\eta \frac{\partial C}{\partial w_j}\\w_j=w_j-\eta \frac{\partial C}{\partial w_j}-\eta \frac{\partial C}{\partial w_i}</script></li><li><p>这个时候，我们就保证了$w_i$和$w_j$始终相等：</p><ul><li>$w_i$和$w_j$的初始值相同</li><li>$w_i$和$w_j$的更新过程相同</li></ul></li></ul><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112259.png" style="zoom:67%;"></p><p>如何去训练这个神经网络呢？注意到这个NN完全是unsupervised，你只需要上网爬一下文章数据直接“喂”给它即可。比如喂给NN的input是“潮水”和“退了”，希望它的output是“就”，之前提到这个NN的输出是一个由概率组成的vector，而targret“就“是只有某一维为1的1-of-N编码，我们希望minimize它们之间的cross entropy，也就是使得输出的那个vector在“就”所对应的那一维上概率最高。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112303.png" style="zoom:67%;"></p><h5 id="1-2-7-Various-Architectures"><a href="#1-2-7-Various-Architectures" class="headerlink" title="1.2.7. Various Architectures"></a>1.2.7. Various Architectures</h5><p>除了上面的基本形态，Prediction-based方法还可以有多种变形：</p><ul><li><p>CBOW(Continuous bag of word model)</p><p>用前后的词汇去预测中间的词汇</p></li><li><p>Skip-gram</p><p>用中间的词汇去预测前后的词汇</p></li></ul><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112306.png" style="zoom:67%;"></p><p>尽管word2vec是deep learning的一个应用，但这个neural network其实并不是deep的，它就只有一个linear的hidden layer。我们把1-of-N编码输入给神经网络，经过weight的转换得到Word Embedding，再通过第一层hidden layer就可以直接得到输出。其实过去有很多人使用过deep model，但这个task不用deep就可以实现，这样做既可以减少运算量，跑大量的data，又可以节省下训练的时间(deep model很可能需要长达好几天的训练时间)。</p><p>Word2Vec会有一些有趣的特性，当把同样类型的东西word vector摆在一起(Italy跟Rome摆在一起，Japen跟Tokyo摆在一起，每一个国家和它的首都之间是有类似的关系的)，或者把动词的三种时态摆在一起，动词的三态中间有某种类似的关系，如下右图中的三角形。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726163009.png" style="zoom: 80%;"></p><blockquote><p>关于<strong>word2vec</strong>，可以参考：<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">[NLP] 秒懂词向量Word2vec的本质</a>；<a href="https://zhuanlan.zhihu.com/p/53425736" target="_blank" rel="noopener">word2vec详解(CBOW，skip-gram，负采样，分层Softmax)</a></p></blockquote><h3 id="2-Application"><a href="#2-Application" class="headerlink" title="2. Application"></a>2. Application</h3><h4 id="2-1-Subtraction"><a href="#2-1-Subtraction" class="headerlink" title="2.1. Subtraction"></a>2.1. Subtraction</h4><p><em>机器问答</em></p><p>从得到的Word2vec里，我们可以发现一些原本并不知道的word与word之间的关系。把word vector两两相减，再投影到下图中的二维平面上，如果某些量量配对的word之间有相同关系，比如中下图每对word中的两个word是前者包含后者的关系，那它们的vector做Subtraction（相减）就会被投影到同一块区域。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112309.png" style="zoom:67%;"></p><p>利用这个概念，我们可以做一些简单的推论：</p><ul><li><p>在word vector的特征上，$V(Rome)-V(Italy)≈V(Berlin)-V(Germany)$</p></li><li><p>此时如果有人问“罗马之于意大利等于柏林之于？”，那机器就可以回答这个问题</p><p>因为德国的vector会很接近于“柏林的vector-罗马的vector+意大利的vector”，因此机器只需要计算$V(Berlin)-V(Rome)+V(Italy)$，然后选取与这个结果最接近的vector即可</p></li></ul><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112312.png" style="zoom:67%;"></p><h4 id="2-2-Multi-lingual-Embedding"><a href="#2-2-Multi-lingual-Embedding" class="headerlink" title="2.2. Multi-lingual Embedding"></a>2.2. Multi-lingual Embedding</h4><p><em>机器翻译</em></p><p>此外，Word2vec还可以建立起不同语言之间的联系。如果你要用上述方法分别训练一个英文的<strong>语料库(corpus)</strong>和中文的语料库，你会发现两者的word vector之间是没有任何关系的，因为Word Embedding只体现了上下文的关系，如果你的文章没有把中英文混合在一起使用，机器就没有办法判断中英文词汇之间的关系。</p><p>但是，如果你知道某些中文词汇和英文词汇的对应关系，你可以先分别获取它们的word vector，然后再去训练一个模型，把具有相同含义的中英文词汇投影到新空间上的同一个点。接下来遇到未知的新词汇，无论是中文还是英文，你都可以采用同样的方式将其投影到新空间，就可以自动做到类似翻译的效果。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112315.png" style="zoom:67%;"></p><p>参考文献：<a href="https://ai.stanford.edu/~wzou/emnlp2013_ZouSocherCerManning.pdf" target="_blank" rel="noopener"><em>Bilingual Word Embeddings for Phrase-Based Machine Translation, Will Zou, Richard Socher, Daniel Cer and Christopher Manning, EMNLP, 2013</em></a></p><h4 id="2-3-Multi-domain-Embedding"><a href="#2-3-Multi-domain-Embedding" class="headerlink" title="2.3. Multi-domain Embedding"></a>2.3. Multi-domain Embedding</h4><p><em>图像分类</em></p><p>这个Embedding不只局限于文字的应用，你也可以对文字+图像做Embedding。假设你已经得到horse、cat和dog这些<strong>词汇</strong>的vector在空间上的分布情况，你就可以去训练一个模型，把一些已知的horse、cat和dog<strong>图片</strong>去投影到和对应词汇相同的空间区域上。</p><p>比如对模型输入一张图像，使之输出一个跟word vector具有相同维数的vector，使dog图像的映射向量就散布在dog词汇向量的周围，horse图像的映射向量就散布在horse词汇向量的周围。训练好这个模型之后，输入新的未知图像，根据投影之后的位置所对应的word vector，就可以判断它所属的类别。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112318.png" style="zoom:67%;"></p><p>Paper:  <a href="https://papers.nips.cc/paper/5027-zero-shot-learning-through-cross-modal-transfer.pdf" target="_blank" rel="noopener">zero-shot learning through cross-modal transfer</a></p><p>我们知道在做图像分类的时候，很多情况下都是事先定好要分为哪几个具体的类别，再用这几个类别的图像去训练模型，由于我们无法在训练的时候穷尽所有类别的图像，因此在实际应用的时候一旦遇到属于未知类别的图像，这个模型就无能为力了。而使用<strong>image+word Embedding</strong>的方法，就算输入的图像类别在训练时没有被遇到过，比如上图中的cat，但如果这张图像能够投影到cat的word vector的附近，根据词汇向量与图像向量的对应关系，你自然就可以知道这张图像叫做cat。</p><h4 id="2-4-Document-Embedding"><a href="#2-4-Document-Embedding" class="headerlink" title="2.4. Document Embedding"></a>2.4. Document Embedding</h4><p><em>文档嵌入</em></p><p>除了Word Embedding，我们还可以对Document做Embedding。最简单的方法是把document变成bag-of-word，然后用Auto-encoder就可以得到该文档的语义嵌入(Semantic Embedding)，但光这么做是不够的。</p><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112321.png" style="zoom:67%;"></p><p>因为词汇的顺序代表了很重要的含义，两句词汇相同但语序不同的话可能会有完全不同的含义，比如</p><ul><li>白血球消灭了传染病——正面语义</li><li>传染病消灭了白血球——负面语义</li></ul><p><img src="/2020/07/26/ML%E7%AC%94%E8%AE%B0%EF%BC%8812%EF%BC%89Unsupervised-Learning-Word-Embedding/QQ图片20200726112324.png" style="zoom:67%;"></p><p>想要解决这个问题，具体可以参考下面的几种处理方法（都是unsupervised的做法）：</p><ul><li><strong>Paragraph Vector</strong>: <a href="https://arxiv.org/pdf/1405.4053.pdf" target="_blank" rel="noopener"><em>Le, Quoc, and Tomas Mikolov. “Distributed Representations of Sentences and Documents.“ ICML, 2014</em></a></li><li><strong>Seq2seq Auto-encoder</strong>: <a href="https://arxiv.org/pdf/1506.01057.pdf" target="_blank" rel="noopener"><em>Li, Jiwei, Minh-Thang Luong, and Dan Jurafsky. “A hierarchical neural autoencoder for paragraphs and documents.” arXiv preprint, 2015</em></a></li><li><strong>Skip Thought</strong>: <a href="https://papers.nips.cc/paper/5950-skip-thought-vectors.pdf" target="_blank" rel="noopener"><em>Ryan Kiros, Yukun Zhu, Ruslan Salakhutdinov, Richard S. Zemel, Antonio Torralba, Raquel Urtasun, Sanja Fidler, “Skip-Thought Vectors” arXiv preprint, 2015.</em></a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍了NLP领域中的Word Embedding（词嵌入），它是specific用在word上的Dimension Reduction方法，介绍了常用的两种方法：Count-based和Prediction-based，以及Word Embedding的一些应用。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Word embedding" scheme="http://nekomoon404.github.io/tags/Word-embedding/"/>
    
      <category term="1-of-N Encoding" scheme="http://nekomoon404.github.io/tags/1-of-N-Encoding/"/>
    
      <category term="Count based" scheme="http://nekomoon404.github.io/tags/Count-based/"/>
    
      <category term="Prediction based" scheme="http://nekomoon404.github.io/tags/Prediction-based/"/>
    
      <category term="Language model" scheme="http://nekomoon404.github.io/tags/Language-model/"/>
    
      <category term="Word2Vec" scheme="http://nekomoon404.github.io/tags/Word2Vec/"/>
    
  </entry>
  
  <entry>
    <title>DL笔记（11）Unsupervised Learning-PCA</title>
    <link href="http://nekomoon404.github.io/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/"/>
    <id>http://nekomoon404.github.io/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/</id>
    <published>2020-07-25T13:24:52.000Z</published>
    <updated>2020-07-26T13:24:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Unsupervised-Learning"><a href="#1-Unsupervised-Learning" class="headerlink" title="1.Unsupervised Learning"></a>1.Unsupervised Learning</h3><p>无监督学习(Unsupervised Learning)可以做的事大致分为两种：</p><ul><li>“化繁为简”<ul><li>聚类(Clustering)</li><li>降维(Dimension Reduction)</li></ul></li><li>“无中生有”：Generation</li></ul><p>对于无监督学习(Unsupervised Learning)来说，我们通常只会拥有$(x,\hat y)$中的$x$或$\hat y$，其中：</p><ul><li><strong>化繁为简</strong>就是把复杂的input变成比较简单的output，比如把一大堆没有打上label的树图片转变为一棵抽象的树，此时training data只有input $x$，而没有output $\hat y$；</li><li><strong>无中生有</strong>就是随机给function一个数字，它就会生成不同的图像，此时training data没有input $x$，而只有output $\hat y$。</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214439.png" style="zoom:67%;"></p><p>下面我们先简单介绍下Clustering，然后focus在dimension reduction上，而且只focus在linear dimension reduction上。</p><h3 id="2-Clustering"><a href="#2-Clustering" class="headerlink" title="2. Clustering"></a>2. Clustering</h3><p>Clustering（聚类），顾名思义，就是把相近的样本划分为同一类，比如对下面这些没有标签的image进行分类，手动打上cluster 1、cluster 2、cluster 3的标签，这个分类过程就是化繁为简的过程。那有一个很critical的问题：我们到底要分几个cluster？</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214453.png" style="zoom:67%;"></p><h4 id="2-1-K-means"><a href="#2-1-K-means" class="headerlink" title="2.1. K-means"></a>2.1. K-means</h4><p>最常用的聚类方法是<strong>K-means</strong>：</p><ul><li>我们有一大堆的unlabeled data $\{x^1,…,x^n,…,x^N\}$，我们要把它划分为K个cluster；</li><li>对每个cluster都要找一个center $c^i,i\in \{1,2,…,K\}$，initial的时候可以从training data里随机挑K个object $x^n$出来作为K个center $c^i$的初始值；</li><li>遍历所有的object $x^n$，并判断它属于哪一个cluster，如果$x^n$与第i个cluster的center $c^i$最接近，那它就属于该cluster，我们用$b_i^n=1$来表示第n个object属于第i个cluster，$b_i^n=0$表示不属于；</li><li>更新center：把每个cluster里的所有object取平均值作为新的center值，即$c^i=\sum\limits_{x^n}b_i^n x^n/\sum\limits_{x^n} b_i^n$；</li><li>重复进行以上的操作；</li></ul><p>注：如果不是从原先的data set里取center的初始值，可能会导致部分cluster没有样本点。</p><h4 id="2-2-HAC"><a href="#2-2-HAC" class="headerlink" title="2.2. HAC"></a>2.2. HAC</h4><p><strong>HAC（Hierarchical Agglomerative Clustering，层次聚类）</strong>。假设现在我们有5个样本点，想要做clustering：</p><ul><li><p>build a tree:</p><p>（整个过程类似建立<a href="https://www.jianshu.com/p/0b476f861bdc" target="_blank" rel="noopener">Huffman Tree</a>，只不过Huffman是依据词频，而HAC是依据相似度建树）</p><ul><li>对5个样本点两两计算相似度，挑出最相似的一对，比如样本点1和2；</li><li>将样本点1和2进行merge (可以对两个vector取平均)，生成代表这两个样本点的新结点；</li><li>此时只剩下4个结点，再重复上述步骤进行样本点的合并，直到只剩下一个root结点。</li></ul></li><li><p>pick a threshold：</p><p>选取阈值，形象来说就是在构造好的tree上横着切一刀，相连的叶结点属于同一个cluster；</p><p>下图中，不同颜色的横线和叶结点上不同颜色的方框对应着切法与cluster的分法，比如按红色的线切就会分成2个cluster，按蓝色的线切就会分成3个cluster。</p></li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214456.png" style="zoom:67%;"></p><p>HAC和K-means最大的区别在于如何决定cluster的数量，在K-means里，K的值是要你直接决定的；而在HAC里，你并不需要直接决定分多少cluster，而是去决定“这一刀切在树的哪里”</p><h3 id="3-Dimension-Reduction"><a href="#3-Dimension-Reduction" class="headerlink" title="3. Dimension Reduction"></a>3. Dimension Reduction</h3><p>clustering的缺点是<strong>以偏概全</strong>，它强迫每个object都要属于某个cluster。但实际上某个object可能拥有多种属性，或者多个cluster的特征，如果把它强制归为某个cluster，就会失去很多信息；或许我们应该用一个vector来描述该object，这个vector的每一维都代表object的某种属性（这个vector的dimension肯定要比object原来的feature数目少），这种做法就叫做<strong>Distributed Representation</strong>。如果原先的object是high dimension的，比如image，那现在用计算出来的它的某些attribute（属性，特征）来描述它，就可以使之从高维空间转变为低维空间，这就是所谓的<strong>降维(Dimension Reduction)</strong>。Distribution Representation和Dimension Reduction其实是一样的事情，只是叫法不同。</p><p>比如哟下图中动漫“全职猎人”中小杰的念能力分布，从表中可以看出我们不能仅仅把他归为强化系，而应该要用一个vector来表示他的attribute。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214500.png" style="zoom:67%;"></p><h4 id="3-1-Why-Dimension-Reduction-Help"><a href="#3-1-Why-Dimension-Reduction-Help" class="headerlink" title="3.1 Why Dimension Reduction Help?"></a>3.1 Why Dimension Reduction Help?</h4><p>接下来我们从另一个角度来看为什么Dimension Reduction可能是有用的。假设data为下图左侧中的3D螺旋式分布，你会发现用3D的空间来描述这些data其实是很浪费的，因为我们完全可以把这个卷摊平，此时只需要用2D的空间就可以描述这个3D的信息。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214449.png" style="zoom: 80%;"></p><p>如果以MNIST(手写数字集)为例，每一张image都有28*28的dimension，但我们反过来想，大多数28*28 dimension的vector转成image，看起来都不会像是一个数字，所以描述数字所需要的dimension可能远比28*28要来得少。</p><p>举一个极端的例子，下面这几张表示“3”的image，我们完全可以用中间这张image旋转$\theta$角度来描述，也就是说，我们只需要用$\theta$这一个dimension就可以描述原先28*28 dimension的图像。你只要抓住角度的变化就可以知道28维空间中的变化，这里的28*28维pixel就是之前提到的樊一翁的胡子，而1维的角度则是他的头，也就是“去芜存菁，化繁为简”的思想</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214503.png" style="zoom:67%;"></p><h4 id="3-2-How-to-do-Dimension-Reduction？"><a href="#3-2-How-to-do-Dimension-Reduction？" class="headerlink" title="3.2. How to do Dimension Reduction？"></a>3.2. How to do Dimension Reduction？</h4><p>那怎么去做Dimension Reduction呢，在Dimension Reduction里，我们要找一个function，这个function的input是原始的$x$，output是经过降维之后的$z$。最简单的方法是<strong>Feature Selection</strong>，即直接从原有的dimension里删掉一些直观上就对结果没有影响的dimension，就做到了降维，比如下图中从$x_1,x_2$两个维度中直接拿掉$x_1$；但这个方法不总是有用，因为很多情况下任何一个dimension其实都不能被拿掉，就像下图中的螺旋卷。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725214506.png" style="zoom: 67%;"></p><h3 id="4-PCA"><a href="#4-PCA" class="headerlink" title="4. PCA"></a>4. PCA</h3><p>另一个常见的方法叫做<strong>PCA</strong>（Principe Component Analysis，主成分分析）。PCA认为降维就是一个很简单的linear function，它的input x和output z之间是linear transform，即$z=Wx$，PCA要做的，就是根据training data的$x$<strong>把W给找出来</strong>。</p><h4 id="4-1-PCA-for-1-Dimension"><a href="#4-1-PCA-for-1-Dimension" class="headerlink" title="4.1 PCA for 1-Dimension"></a>4.1 PCA for 1-Dimension</h4><p>我们先考虑一个简单的case，假设$z$是1维的vector，也就是把$x$投影到一维空间，此时$W$是一个row vector。$z_1=w^1\cdot x$，其中$w^1$表示$w$的第一个row vector，我们<strong>假设$w^1$的长度为1，即$||w^1||_2=1$，此时$z_1$就是$x$在$w^1$方向上的投影</strong>。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725224416.png" style="zoom:67%;"></p><p>那我们到底要找什么样的$w^1$呢？假设我们现在已有的宝可梦样本点分布如下，横坐标代表宝可梦的攻击力，纵坐标代表防御力，我们的任务是把这个二维分布投影到一维空间上。我们希望选这样一个$w^1$，它使得$x$经过投影之后得到的$z_1$分布越大越好，也就是说经过这个投影后，不同样本点之间的区别，应该仍然是可以被看得出来的。即：</p><ul><li><p>我们希望找一个projection（投影）的方向，它可以让$x$经过projection后的variance越大越好；</p></li><li><p>我们不希望projection使这些data point通通挤在一起，导致点与点之间的奇异度消失；</p></li><li>要去maximize的对象是$z_1$的variance，其中variance的计算公式：$Var(z_1)=\frac{1}{N}\sum\limits_{z_1}(z_1-\bar{z_1})^2, ||w^1||_2=1$，$\bar {z_1}$是$z_1$的平均值。</li></ul><p>如下图给出了所有样本点在两个不同的方向上投影之后的variance比较情况，从这个图上，你可以看出$w^1$或许是代表宝可梦的强度，宝可梦可能有一个隐藏的factor代表它的强度，这个隐藏的factor同时影响了它的防御力跟攻击力，所以防御力跟攻击力是会同时上升的。</p><h4 id="4-2-PCA-for-n-D"><a href="#4-2-PCA-for-n-D" class="headerlink" title="4.2 PCA for n-D"></a>4.2 PCA for n-D</h4><p>当然我们不可能只投影到一维空间，我们还可以投影到更高维的空间</p><p>对$z=Wx$来说：</p><ul><li>$z_1=w^1\cdot x$，表示$x$在$w^1$方向上的投影</li><li>$z_2=w^2\cdot x$，表示$x$在$w^2$方向上的投影</li><li>…</li></ul><p>$z_1,z_2,…$串起来就得到$z$，而$w^1,w^2,…$分别是$W$的第1,2,…个row，需要注意的是，<strong>这里的$w^i$必须相互正交，此时$W$是正交矩阵(orthogonal matrix)</strong>，如果不加以约束，则算出来的的$w^1,w^2,…$实际上是相同的值 。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725224420.png" style="zoom:67%;"></p><h4 id="4-3-Lagrange-multiplier"><a href="#4-3-Lagrange-multiplier" class="headerlink" title="4.3. Lagrange multiplier"></a>4.3. Lagrange multiplier</h4><p>求解PCA，实际上已经有现成的函数可以调用，此外你也可以把PCA描述成neural network，然后用gradient descent的方法来求解，这里主要介绍用<strong>Lagrange multiplier（拉格朗日乘数法）</strong>求解PCA的数学推导过程。</p><p>（注：$w^i$和$x$均为列向量，下文中类似$w^i\cdot x$表示的是矢量内积，而$(w^i)^T\cdot x$表示的是矩阵相乘。）</p><p><strong>Step1: calculate $w^1$</strong></p><p>目标：maximize $(w^1)^TSw^1 $，条件：$(w^1)^Tw^1=1$</p><ul><li><p>首先计算出$\bar{z_1}$：</p><script type="math/tex; mode=display">\begin{split}&z_1=w^1\cdot x\\&\bar{z_1}=\frac{1}{N}\sum z_1=\frac{1}{N}\sum w^1\cdot x=w^1\cdot \frac{1}{N}\sum x=w^1\cdot \bar x\end{split}</script></li><li><p>然后计算maximize的对象$Var(z_1)$：</p><p>（其中$Cov(x)=\frac{1}{N}\sum(x-\bar x)(x-\bar x)^T$）</p><script type="math/tex; mode=display">\begin{split}Var(z_1)&=\frac{1}{N}\sum\limits_{z_1} (z_1-\bar{z_1})^2\\&=\frac{1}{N}\sum\limits_{x} (w^1\cdot x-w^1\cdot \bar x)^2\\&=\frac{1}{N}\sum (w^1\cdot (x-\bar x))^2\\&=\frac{1}{N}\sum(w^1)^T(x-\bar x)(x-\bar x)^T w^1\\&=(w^1)^T\frac{1}{N}\sum(x-\bar x)(x-\bar x)^T w^1\\&=(w^1)^T Cov(x)w^1\end{split}</script></li><li><p>当然这里想要求$Var(z_1)=(w^1)^TCov(x)w^1$的最大值，还要加上$||w^1||_2=(w^1)^Tw^1=1$的约束条件，否则$w^1$可以取无穷大。</p></li><li><p>令$S=Cov(x)$，它是：</p><ul><li>对称的(symmetric)</li><li>半正定的(positive-semidefine)，即所有特征值(eigenvalues)是非负的(non-negative)</li></ul><p>（看来是要复习一下研一上学的矩阵理论了(￣ω￣;)）</p></li><li><p>使用拉格朗日乘数法，利用目标和约束条件构造函数：</p><script type="math/tex; mode=display">g(w^1)=(w^1)^TSw^1-\alpha((w^1)^Tw^1-1)</script></li><li><p>对$w^1$这个vector里的每一个element做偏微分：</p><script type="math/tex; mode=display">\partial g(w^1)/\partial w_1^1=0\\\partial g(w^1)/\partial w_2^1=0\\\partial g(w^1)/\partial w_3^1=0\\...</script></li><li><p>整理上述推导式，可以得到：</p><p>其中，$w^1$是$S$的特征向量(eigenvector)</p><script type="math/tex; mode=display">Sw^1=\alpha w^1</script></li><li><p>注意到满足$(w^1)^Tw^1=1$的特征向量$w^1$有很多，我们要找的是可以maximize $(w^1)^TSw^1$的那一个，于是利用上一个式子：</p><script type="math/tex; mode=display">(w^1)^TSw^1=(w^1)^T \alpha w^1=\alpha (w^1)^T w^1=\alpha</script></li><li><p>此时maximize $(w^1)^TSw^1$就变成了maximize $\alpha$，也就是$S$的最大的特征值$\alpha$对应的那个特征向量，就是我们要找的$w^1$</p></li><li><p>结论：<strong>$w^1$是$S=Cov(x)$这个matrix中的最大的特征值$\lambda_1$对应的特征向量</strong></p></li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725224424.png" style="zoom:67%;"></p><p><strong>Step2: calculate $w^2$</strong></p><p>在推导$w^2$时，相较于$w^1$，多了一个限制条件：$w^2$必须与$w^1$正交(orthogonal)。</p><p>目标：maximize $(w^2)^TSw^2$，条件：$(w^2)^Tw^2=1,(w^2)^Tw^1=0$</p><p>结论：<strong>$w^2$也是$S=Cov(x)$这个matrix第二大的特征值$\lambda_2$对应的特征向量</strong></p><ul><li><p>同样是用拉格朗日乘数法求解，先写一个关于$w^2$的function，包含要maximize的对象，以及两个约束条件</p><script type="math/tex; mode=display">g(w^2)=(w^2)^TSw^2-\alpha((w^2)^Tw^2-1)-\beta((w^2)^Tw^1-0)</script></li><li><p>对$w^2$的每个element做偏微分：</p><script type="math/tex; mode=display">\partial g(w^2)/\partial w_1^2=0\\\partial g(w^2)/\partial w_2^2=0\\\partial g(w^2)/\partial w_3^2=0\\...</script></li><li><p>整理后得到：</p><script type="math/tex; mode=display">Sw^2-\alpha w^2-\beta w^1=0</script></li><li><p>上式两侧同乘$(w^1)^T$，得到：</p><script type="math/tex; mode=display">(w^1)^TSw^2-\alpha (w^1)^Tw^2-\beta (w^1)^Tw^1=0</script></li><li><p>其中$\alpha (w^1)^Tw^2=0,\beta (w^1)^Tw^1=\beta$，</p><p>而由于$(w^1)^TSw^2$是vector×matrix×vector=scalar，因此在外面套一个transpose（转置）不会改变其值，因此该部分可以转化为：</p><p>（注：$S$是symmetric matrix（对称矩阵）的，既有$S^T=S$。）</p><script type="math/tex; mode=display">\begin{split}(w^1)^TSw^2&=((w^1)^TSw^2)^T\\&=(w^2)^TS^Tw^1\\&=(w^2)^TSw^1\end{split}</script><p>我们已经知道$w^1$满足$Sw^1=\lambda_1 w^1$，代入上式：</p><script type="math/tex; mode=display">\begin{split}(w^1)^TSw^2&=(w^2)^TSw^1\\&=\lambda_1(w^2)^Tw^1\\&=0\end{split}</script></li><li><p>因此有$(w^1)^TSw^2=0$，$\alpha (w^1)^Tw^2=0$，$\beta (w^1)^Tw^1=\beta$，又根据</p><script type="math/tex; mode=display">(w^1)^TSw^2-\alpha (w^1)^Tw^2-\beta (w^1)^Tw^1=0</script><p>可以推得$\beta=0$</p></li><li><p>此时$Sw^2-\alpha w^2-\beta w^1=0$就转变成了$Sw^2-\alpha w^2=0$，即</p><script type="math/tex; mode=display">Sw^2=\alpha w^2</script></li><li><p>由于$S$是symmetric的，因此在不与$w_1$冲突的情况下，这里$\alpha$选取第二大的特征值$\lambda_2$时，可以使$(w^2)^TSw^2$最大</p></li><li><p>结论：<strong>$w^2$也是$S=Cov(x)$这个matrix中的特征向量，对应第二大的特征值$\lambda_2$</strong></p></li></ul><p>（实对称矩阵的不同特征值对应的特征向量是正交的，这个在线性代数或者矩阵理论课程中都有讲过，或者可以参考<a href="https://ccjou.wordpress.com/2011/02/09/實對稱矩陣可正交對角化的證明/" target="_blank" rel="noopener">實對稱矩陣可正交對角化的證明</a>，这是我上学期末在复习矩阵理论的时候发现了一个台湾线代老师的博客，里面有非常多讲解线代知识的文章，思路和内容都要比SJTU用的教材好太多，简直救我期末于水火ヾ(ｏ･ω･)ﾉ）</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725224427.png" style="zoom:67%;"></p><h4 id="4-4-PCA-decorrelation"><a href="#4-4-PCA-decorrelation" class="headerlink" title="4.4. PCA-decorrelation"></a>4.4. PCA-decorrelation</h4><p>$z=W\cdot x$的神奇之处在于$Cov(z)=D$，即$z$的covariance是一个diagonal matrix，推导过程如下图所示。PCA可以让不同dimension之间的covariance变为0，即不同new feature之间是没有correlation的，这样做的好处是，<strong>减少feature之间的联系从而减少model所需的参数量</strong>。</p><p>如果你把原来的input data通过PCA之后再给其他model使用，那这些model就可以使用简单的形式，而无需考虑不同dimension之间类似$x_1\cdot x_2,x_3\cdot x_5^3,…$这些交叉项，此时model得到简化，参数量大大降低，相同的data量可以得到更好的训练结果，从而可以避免overfitting的发生。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200725224431.png" style="zoom:67%;"></p><h3 id="5-PCA-Another-Point-of-View"><a href="#5-PCA-Another-Point-of-View" class="headerlink" title="5. PCA - Another Point of View"></a>5. PCA - Another Point of View</h3><p>上面我们进行了PCA的数学推导，下面从另一个角度更直观地介绍PCA做了什么。</p><h4 id="5-1-Reconstruction-Component"><a href="#5-1-Reconstruction-Component" class="headerlink" title="5.1. Reconstruction Component"></a>5.1. Reconstruction Component</h4><p>假设我们现在考虑的是手写数字识别，这些数字是由一些类似于笔画的basic component组成的，本质上就是一个vector，记做$u_1,u_2,u_3,…$，以MNIST为例，不同的笔画都是一个28×28的vector，把某几个vector加起来，就组成了一个28×28的digit，写成表达式就是：$x≈c_1u^1+c_2u^2+…+c_ku^k+\bar x$，其中$x$代表某张digit image中的pixel，它等于k个component的加权和$\sum c_iu^i$，加上所有image的平均值$\bar x$。</p><p>比如7就是$x=u^1+u^3+u^5$，我们可以用$\left [\begin{matrix}c_1\ c_2\ c_3…c_k \end{matrix} \right]^T$来表示一张digit image，如果component的数目k远比pixel的数目要小，那这个描述就是比较有效的。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082706.png" style="zoom:67%;"></p><p>实际上目前我们并不知道$u^1$~$u^k$具体的值，因此我们要找这样k个vector，使得$x-\bar x$与$\hat x$越接近越好：</p><script type="math/tex; mode=display">x-\bar x≈c_1u^1+c_2u^2+...+c_ku^k=\hat x</script><p>而用未知component来描述的这部分内容，叫做<strong>Reconstruction error</strong>，即$||(x-\bar x)-\hat x||$，接下来我们就要去找k个vector $u^i$去minimize这个error：</p><script type="math/tex; mode=display">L=\min\limits_{u^1,...,u^k}\sum||(x-\bar x)-(\sum\limits_{i=1}^k c_i u^i) ||_2</script><p>回顾PCA，$z=W\cdot x$，实际上我们<strong>通过PCA最终解得的$\{w^1,w^2,…,w^k\}$就是使reconstruction error最小化的$\{u^1,u^2,…,u^k\}$</strong>，简单证明如下：</p><ul><li>将所有的$x^i-\bar x≈c_1^i u^1+c_2^i u^2+…$写在一起，就可以用下图中的矩阵相乘来表示，我们的目标是使等号两侧矩阵之间的差距越小越好；</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082710.png" style="zoom:67%;"></p><ul><li><p>可以使用<strong>SVD（Singular Value Decomposition，奇异值分解）</strong>将每个matrix $X_{m×n}$都拆成matrix $U_{m×k}$、$\Sigma_{k×k}$、$V_{k×n}$的乘积，其中k为component的数目；</p><p>（SVD可以参考<a href="[https://ccjou.wordpress.com/%E5%B0%88%E9%A1%8C%E6%8E%A2%E7%A9%B6/%E5%A5%87%E7%95%B0%E5%80%BC%E5%88%86%E8%A7%A3%E5%B0%88%E9%A1%8C/](https://ccjou.wordpress.com/專題探究/奇異值分解專題/">奇異值分解專題</a>)，我之前也有纸质笔记，有时间的话可以整理一下，咕咕咕。）</p></li><li><p>值得注意的是，使用SVD拆解后的三个矩阵相乘，是跟等号左边的矩阵$X$最接近的，此时$U$就对应着$u^i$那部分的矩阵，$\Sigma\cdot V$就对应着$c_k^i$那部分的矩阵</p></li><li><p>根据SVD的结论，组成矩阵$U$的k个列向量(标准正交向量, orthonormal vector)就是$XX^T$最大的k个特征值(eignvalue)所对应的特征向量(eigenvector)，而$XX^T$实际上就是$x$的covariance matrix，因此$U$就是PCA的k个解组成的matrix；</p></li><li><p>因此我们可以发现，通过PCA找出来的Dimension Reduction的transform，实际上就是把$X$拆解成能够最小化Reconstruction error的component的过程，通过PCA所得到的$w^i$就是component $u^i$，而Dimension Reduction的结果就是参数$c_i$</p></li><li><p>简单来说就是，用PCA对$x$进行降维的过程中，我们要找的投影方式$w^i$就相当于恰当的组件$u^i$，投影结果$z^i$就相当于这些组件各自所占的比例$c_i$</p></li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082713.png" style="zoom:67%;"></p><ul><li><p>下面的式子简单演示了将一个样本点$x$划分为k个组件的过程，其中$\left [\begin{matrix}c_1 \ c_2\ … c_k \end{matrix} \right ]^T$是每个组件的比例；把$x$划分为k个组件即从n维投影到k维空间，$\left [\begin{matrix}c_1 \ c_2\ … c_k \end{matrix} \right ]^T$也是投影结果，其中$x$和$u_i$均为n维列向量。</p><script type="math/tex; mode=display">\begin{split}&x=\left [\begin{matrix}u_1\ u_2\ ...\ u_k\end{matrix}\right ]\cdot\left [\begin{matrix}c_1\\c_2\\...\\c_k\end{matrix}\right ]\\ \\&\left [\begin{matrix}x_1\\x_2\\...\\x_n\end{matrix}\right ]=\left [\begin{matrix}u_1^1\ u_2^1\ ... u_k^1 \\u_1^2\ u_2^2\ ... u_k^2 \\...\\u_1^n\ u_2^n\ ... u_k^n\end{matrix}\right ]\cdot\left [\begin{matrix}c_1\\c_2\\...\\c_k\end{matrix}\right ]\\\end{split}</script></li></ul><h4 id="5-2-NN-for-PCA"><a href="#5-2-NN-for-PCA" class="headerlink" title="5.2. NN for PCA"></a>5.2. NN for PCA</h4><p>现在我们已经知道，用PCA找出来的$\{w^1,w^2,…,w^k\}$就是k个component $\{u^1,u^2,…,u^k\}$，而$\hat x=\sum\limits_{k=1}^K c_k w^k$，我们要使$\hat x$与$x-\bar x$之间的差距越小越好，我们已经根据SVD找到了$w^k$的值，而对每个不同的样本点，都会有一组不同的$c_k$值，在PCA中我们已经证得，$\{w^1,w^2,…,w^k\}$这k个vector是标准正交化的(orthonormal)，因此：</p><script type="math/tex; mode=display">c_k=(x-\bar x)\cdot w^k</script><p>这个时候我们就可以使用神经网络来表示整个过程，假设$x$是3维向量，要投影到k=2维的component上：</p><ul><li>对$x-\bar x$与$w^k$做inner product的过程类似于neural network，$x-\bar x$在3维空间上的坐标就相当于是neuron的input，而$w^1_1$，$w^1_2$，$w^1_3$则是neuron的weight，表示在$w^1$这个维度上投影的参数，而$c_1$则是这个neuron的output，表示在$w^1$这个维度上投影的坐标值；对$c_2$也同理</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082717.png" style="zoom:67%;"></p><ul><li>得到$c_1$之后，再让它乘上$w^1$，得到$\hat x$的一部分</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082720.png" style="zoom: 50%;"></p><ul><li>对$c_2$进行同样的操作，乘上$w^2$，贡献$\hat x$的剩余部分，此时我们已经完整计算出$\hat x$三个分量的值</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082723.png" style="zoom:67%;"></p><ul><li><p>此时，PCA就被表示成了只含一层hidden layer的神经网络，且这个hidden layer是线性的激活函数，训练目标是让这个NN的input $x-\bar x$与output $\hat x$越接近越好，这件事就叫做<strong>Autoencoder</strong>。</p></li><li><p>注意，<strong>通过PCA求解出的$w^i$与直接对上述的神经网络做梯度下降所解得的$w^i$是会不一样的</strong>，因为PCA解出的$w^i$是正交的(orgonormal)，而用NN的方式得到的解无法保证$w^i$相互垂直，NN无法做到Reconstruction error比PCA小，因此：</p><ul><li>在linear的情况下，直接用PCA找$W$远比用神经网络的方式更快速方便</li><li>用NN的好处是，它可以使用不止一层hidden layer，它可以做<strong>deep</strong> autoencoder</li></ul></li></ul><h4 id="5-3-Weakness-of-PCA"><a href="#5-3-Weakness-of-PCA" class="headerlink" title="5.3. Weakness of PCA"></a>5.3. Weakness of PCA</h4><p>PCA也有很明显的弱点：</p><ul><li><p>它是<strong>unsupervised</strong>的，如果我们要将下图绿色的点投影到一维空间上，PCA给出的从左上到右下的划分很有可能使原本属于蓝色和橙色的两个class的点被merge在一起</p><p>这时要解决问题可能就需要引入label data，LDA（Linear Discriminant Analysis，线性判别分析）则是考虑了labeled data之后进行降维的一种方式，但属于supervised，不在本文讨论。</p></li></ul><blockquote><p>LDA不同于PCA方差最大化理论，LDA算法的思想是将数据投影到低维空间之后，使得同一类数据尽可能的紧凑，不同类的数据尽可能分散。因此，LDA算法是一种有监督的机器学习算法。同时，LDA有如下两个假设:(1) 原始数据根据样本均值进行分类。(2) 不同类的数据拥有相同的协方差矩阵。</p><p>（摘自文章<a href="https://zhuanlan.zhihu.com/p/51769969" target="_blank" rel="noopener">机器学习-LDA(线性判别降维算法)</a>）</p></blockquote><ul><li>它是<strong>linear</strong>的，对于下图中的彩色曲面，我们期望把它平铺拉直进行降维，但这是一个non-linear的投影转换，PCA无法做到这件事情，PCA只能做到把这个曲面打扁压在平面上，类似下图，而无法把它拉开。对类似曲面空间的降维投影，需要用到non-linear transformation</li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082726.png" style="zoom:67%;"></p><h3 id="6-More-Examples"><a href="#6-More-Examples" class="headerlink" title="6. More Examples"></a>6. More Examples</h3><h4 id="6-1-PCA-for-Pokemon"><a href="#6-1-PCA-for-Pokemon" class="headerlink" title="6.1. PCA for Pokemon"></a>6.1. PCA for Pokemon</h4><p>这里举一个实际应用的例子，用PCA来分析宝可梦的数据，假设总共有800只宝可梦，每只都用一个六维的vector来表示，即vector={HP, Atk, Def, Sp Atk, Sp Def, Speed}，然后我们用PCA来分析，首先要面对的问题是，要将6维的vector投影到多少维的空间上？</p><p>如果做可视化分析的话，投影到二维或三维平面可以方便人眼观察，实际上，宝可梦的$cov(x)$是6维，最多可以投影到6维空间。一个常用的方法是：我们可以先找出6个特征向量和对应的特征值$\lambda_i$，其中$\lambda_i$表示第$i$个投影维度的variance有多大(即在第i个维度的投影上点的散步程度有多大，variance越大，点的分布就越散，这也是我们所希望的)，然后我们就可以计算出每个$\lambda_i$的比例，ratio=$\frac{\lambda_i}{\sum\limits_{i=1}^6 \lambda_i}$</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082729.png" style="zoom:67%;"></p><p>从上图的ratio可以看出$\lambda_5$、$\lambda_6$所占比例不高，即第5和第6个principle component(可以理解为维度)所发挥的作用是比较小的，用这两个dimension做投影所得到的variance很小，投影在这两个方向上的点比较集中，意味着这两个维度表示的是宝可梦的共性，无法对区分宝可梦的特性做出太大的贡献，所以我们只需要利用前4个principle component即可。 </p><p>注意到新的维度本质上就是旧的维度的加权矢量和，下图给出了前4个维度的加权情况，从PC1到PC4这4个principle component都是6维度加权的vector，它们都可以被认为是某种组件，每一个宝可梦都可以由这4个principle component加权之和。</p><p>我们来仔细分析一下这四个component代表的“含义”：</p><ul><li><p>对第一个vector PC1来说，每个值都是正的，因此这个组件在某种程度上代表了宝可梦的强度</p></li><li><p>对第二个vector PC2来说，防御力Def很大而速度Speed很小，这个组件可以增加宝可梦的防御力但同时会牺牲一部分的速度</p></li><li><p>如果将宝可梦仅仅投影到PC1和PC2这两个维度上，则降维后的二维可视化图像如下图所示：</p><p>从该图中也可以得到一些信息：</p><ul><li>在PC2维度上特别大的那个样本点刚好对应着普普(海龟)，确实是防御力且速度慢的宝可梦</li><li>在PC1维度上特别大的那三个样本点则对应着盖欧卡、超梦等综合实力很强的宝可梦</li></ul></li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082731.png" style="zoom:67%;"></p><ul><li><p>对第三个vector PC3来说，sp Def很大而HP和Atk很小，这个组件是用生命力和攻击力来换取特殊防御力</p></li><li><p>对第四个vector PC4来说，HP很大而Atk和Def很小，这个组件是用攻击力和防御力来换取生命力</p></li><li><p>同样将宝可梦只投影到PC3和PC4这两个维度上，则降维后得到的可视化图像如下图所示：</p><p>该图同样可以告诉我们一些信息：</p><ul><li>在PC3维度上特别大的样本点依旧是普普，第二名是冰柱机器人，它们的特殊防御力都比较高</li><li>在PC4维度上特别大的样本点则是吉利蛋和幸福蛋，它们的生命力比较强</li></ul></li></ul><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082735.png" style="zoom:67%;"></p><h4 id="6-2-PCA-for-MNIST"><a href="#6-2-PCA-for-MNIST" class="headerlink" title="6.2. PCA for MNIST"></a>6.2. PCA for MNIST</h4><p>再次回到手写数字识别的问题上来，这个时候我们就可以熟练地把一张数字图像用多个组件(维度)表示出来了：</p><script type="math/tex; mode=display">digit\ image=a_1 w^1+a_2 w^2+...</script><p>这里的$w^i$就表示降维后的其中一个维度，即一个principle component，它是由原先28×28维进行加权求和的结果，因此$w^i$也是一张28×28的图像，下图列出了通过PCA得到的前30个组件的形状：</p><p>注：PCA就是求$Cov(x)=\frac{1}{N}\sum (x-\bar x)(x-\bar x)^T$的前30个最大的特征值对应的特征向量</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082738.png" style="zoom:67%;"></p><h4 id="6-3-PCA-for-Face-Recognition"><a href="#6-3-PCA-for-Face-Recognition" class="headerlink" title="6.3. PCA for Face Recognition"></a>6.3. PCA for Face Recognition</h4><p>同理，在人脸识别的例子中，通过PCA找出人脸的前30个component(维度)，如下图所示，用这些脸的组件做线性组合就可以得到所有的脸。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082741.png" style="zoom:67%;"></p><p>在对MNIST和Face的PCA结果展示的时候，你可能会注意到我们找到的组件好像并不算是组件，比如MNIST找到的几乎是完整的数字雏形，而Face找到的也几乎是完整的人脸雏形，但我们预期的组件不应该是类似于横折撇捺，眼睛鼻子眉毛这些吗？如果你仔细思考了PCA的特性，就会发现得到这个结果是可能的：</p><script type="math/tex; mode=display">digit\ image=a_1 w^1+a_2 w^2+...</script><p>注意到linear combination的weight $a_i$可以是正的也可以是负的，因此我们可以通过把组件进行相加或相减来获得目标图像，这会导致你找出来的component不是基础的组件，但是通过这些组件的加加减减肯定可以获得基础的组件元素。</p><h4 id="6-4-NMF"><a href="#6-4-NMF" class="headerlink" title="6.4. NMF"></a>6.4. NMF</h4><p>如果你要一开始就得到类似笔画这样的基础组件，就要使用<strong>NMF(non-negative matrix factorization)，非负矩阵分解</strong>的方法。PCA可以看成对原始矩阵$X$做SVD进行矩阵分解，但并不保证分解后矩阵的正负，实际上当进行图像处理时，如果部分组件的matrix包含一些负值的话，如何处理负的像素值也会成为一个问题(可以做归一化处理，但比较麻烦)。而NMF的基本思想是，强迫使所有component的每一个dimension都是正的，且它的加权值$a_1$都必须是正的，也就是说<strong>所有图像都必须由组件叠加得到</strong>：</p><ul><li>Forcing $a_1$, $a_2$…… be non-negative<ul><li>additive combination</li></ul></li><li>Forcing $w_1$, $w_2$…… be non-negative<ul><li>More like “parts of digits”</li></ul></li></ul><p>(注：关于NMF的具体算法内容可参考paper <a href="https://papers.nips.cc/paper/1861-algorithms-for-non-negative-matrix-factorization.pdf" target="_blank" rel="noopener"><em>Daniel D. Lee and H. Sebastian Seung. “Algorithms for non-negative matrix factorization.”Advances in neural information processing systems. 2001.</em> </a>）</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726094309.png" style="zoom: 45%;"></p><p><strong>NMF for MNIST</strong></p><p>在MNIST数据集上，通过NMF找到的前30个组件如下图所示，可以发现这些组件都是由基础的笔画构成：</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082745.png" style="zoom:67%;"></p><p><strong>NMF for Face</strong></p><p>在Face数据集上，通过NMF找到的前30个组价如下图所示，相比于PCA这里更像是脸的一部分</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726082748.png" style="zoom:67%;"></p><h4 id="More-Related-Approaches"><a href="#More-Related-Approaches" class="headerlink" title="More Related Approaches"></a>More Related Approaches</h4><p>降维的方法有很多，这里再列举一些与PCA有关的方法：</p><ul><li><p>Multidimensional Scaling (<strong>MDS</strong>) [Alpaydin, Chapter 6.7]</p><p>MDS不需要把每个data都表示成feature vector，只需要知道特征向量之间的distance，就可以做降维，PCA保留了原来在高维空间中的距离，在某种情况下MDS就是特殊的PCA</p></li><li><p><strong>Probabilistic PCA</strong> [Bishop, Chapter 12.2]</p><p>PCA概率版本</p></li><li><p><strong>Kernel PCA</strong> [Bishop, Chapter 12.3]</p><p>PCA非线性版本</p></li><li><p>Canonical Correlation Analysis (<strong>CCA</strong>) [Alpaydin, Chapter 6.9]</p><p>CCA常用于两种不同的data source的情况，比如同时对声音信号和唇形的图像进行降维</p></li><li><p>Independent Component Analysis (<strong>ICA</strong>)</p><p>ICA常用于source separation，PCA找的是正交的组件，而ICA则只需要找“独立”的组件即可</p></li><li><p>Linear Discriminant Analysis (<strong>LDA</strong>) [Alpaydin, Chapter 6.8]</p><p>LDA是supervised的方式</p></li></ul><h3 id="7-Matrxi-Factorization"><a href="#7-Matrxi-Factorization" class="headerlink" title="7. Matrxi Factorization"></a>7. Matrxi Factorization</h3><p>接下来用一个简单的推荐系统的例子来介绍下<strong>矩阵分解</strong>的思想。有时候存在两种object，它们之间会受到某种共同<strong>潜在因素</strong>(latent factor)的操控，如果我们找出这些潜在因素，就可以对用户的行为进行预测，这也是<strong>推荐系统</strong>常用的方法之一。</p><p>假设我们现在去调查每个人购买的手办数目，ABCDE代表5个人，每个人或者每个手办的动漫人物实际上都是有着傲娇的属性或天然呆的属性（老师是老二次元实锤）。我们可以用vector去描述人和公仔的属性，如果某个人的属性和某个公仔的属性是match的，即他们背后的vector很像(内积值很大)，这个人就会偏向于拥有更多这种类型的公仔。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726095546.png" style="zoom:67%;"></p><p><strong>matrix expression</strong></p><p>但是，我们没有办法直接观察某个人背后这些潜在的属性，也不会有人在意一个肥宅心里想的是什么（肥宅大哭），我们同样也没有办法直接得到动漫人物背后的属性；我们目前有的，只是动漫人物和人之间的关系，即每个人已购买的公仔数目，我们要通过这个关系去推测出动漫人物与人背后的<strong>潜在因素(latent factor)</strong>。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726095550.png" style="zoom:67%;"></p><p>我们可以把每个人的属性用vector $r^A$、$r^B$、$r^C$、$r^D$、$r^E$来表示，而动漫人物的属性则用vector $r^1$、$r^2$、$r^3$、$r^4$来表示，购买的公仔数目可以被看成是matrix $X$，对$X$来说，行数为人数，列数为动漫角色的数目。做一个假设：matrix $X$里的每个element，都是属于人的vector和属于动漫角色的vector的内积，比如，$r^A\cdot r^1≈5$，表示$r^A$和$r^1$的属性比较贴近，那A这个人就会买比较多凉宫春日的手办。</p><p>接下来就用下图所示的矩阵相乘的方式来表示这样的关系，其中$K$为latent factor的数量，这是未知的，需要你自己去调整选择，我们要找一组$r^A$~$r^E$和$r^1$~$r^4$，使得右侧两个矩阵相乘的结果与左侧的matrix $X$越接近越好，可以使用SVD的方法求解。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726095553.png" style="zoom:67%;"></p><p><strong>prediction</strong></p><p>但有时候，部分的information可能是会missing的，这时候就难以用SVD精确描述，但我们可以使用梯度下降的方法求解，loss function如下：</p><script type="math/tex; mode=display">L=\sum\limits_{(i,j)}(r^i\cdot r^j-n_{ij})^2</script><p>其中$r^i$值的是人背后的latent factor，$r^j$指的是动漫角色背后的latent factor，我们要让这两个vector的内积与实际购买该公仔的数量$n_{ij}$越接近越好，这个方法的关键之处在于，计算上式时，可以跳过missing的数据，最终通过gradient descent求得$r^i$和$r^j$的值。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726095556.png" style="zoom:67%;"></p><p>假设latent factor的数目等于2，则人的属性$r^i$和动漫角色的属性$r^j$都是2维的vector，这里实际进行计算后，把属性中较大值标注出来，可以发现：</p><ul><li>人：A、B属于同一组属性，C、D、E属于同一组属性</li><li><p>动漫角色：1、2属于同一组属性，3、4属于同一组属性</p></li><li><p>结合动漫角色，可以分析出动漫角色的第一个维度是天然呆属性，第二个维度是傲娇属性</p></li><li><p>接下来就可以预测未知的值，只需要将人和动漫角色的vector做内积即可</p></li></ul><p>这样就可以针对阿宅做一个简单的<strong>推荐系统</strong>了。</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726095559.png" style="zoom:67%;"></p><p><strong>more about matrix factorization</strong></p><p>实际上除了人和动漫角色的属性之外，可能还存在其他因素操控购买数量这一数值，因此我们可以将式子更精确地改写为：</p><script type="math/tex; mode=display">r^A\cdot r^1+b_A+b_1≈5</script><p>其中$b_A$表示A这个人本身有多喜欢买公仔，$b_1$则表示这个动漫角色本身有多受欢迎，这些内容是跟属性vector无关的，此时loss function被改写为：</p><script type="math/tex; mode=display">L=\sum\limits_{(i,j)}(r^i\cdot r^j+b_i+b_j-n_{ij})^2</script><p>当然你也可以加上一些regularization去对结果做约束。（有关Matrix Factorization和推荐系统更多内容的介绍，可以参考paper <a href="https://datajobs.com/data-science-repo/Recommender-Systems-[Netflix].pdf" target="_blank" rel="noopener"><em>Matrix Factorization Techniques For Recommender Systems</em></a>；有关Matrix Factorization的理论知识，可以参考：<a href="https://ccjou.wordpress.com/" target="_blank" rel="noopener">線代啟示錄</a>）</p><p><strong>for Topic Analysis</strong></p><p>如果把matrix factorization的方法用在topic analysis上，就叫做<strong>LSA(Latent semantic analysis)，潜在语义分析</strong>。我们只需要把动漫人物换成文章，人换成词汇，表中的值从购买数量换成词频即可，table里面的值就是term frequency，把这个term frequency乘上一个weight代表说这个term本身有多重要。</p><p>Evaluation一个term的重要性的常用的方式是：inverse document frequency(计算每一个词汇在整个paper有多少比率的document涵盖这个词汇，假如说，每个词汇，每个document都有，那它的inverse document frequency就很小，代表着这个词汇的重要性是低的，假设某个词汇只有某一篇document有，那它的inverse document frequency就很大，代表这个词汇对于这篇文章的重要性是高的，这个词汇的含义与文章的语义关联性就比较高。)</p><p>在这个task里，做matrix factorization，就会找到每一个document背后的latent factor，它可能指的是topic(主题)，这个topic有多少是跟财经有关的，有多少是跟政治有关的。document1跟document2有比较多的“投资，股票”这样的词汇，那document1跟document2就有比较高的可能背后的latent factor是比较偏向“财经”的。我们可以用词汇的重要性给词频加权，在各种文章中出现次数越多的词汇越不重要，出现次数越少则越重要。这个场景下找出的latent factor可能会是主题(topic)，比如某个词汇或某个文档有多少比例是偏向于财经主题、政治主题…</p><p><img src="/2020/07/25/ML%E7%AC%94%E8%AE%B0%EF%BC%8811%EF%BC%89Unsupervised-Learning-PCA/QQ图片20200726101618.png" style="zoom:67%;"></p><p>Topic analysis的方法多如牛毛，但基本的思想是差不多的，常见的方法有pLSA（probability latent semantic analysis，概率潜在语义分析）和LDA（latent Dirchlet allocation，隐含狄利克雷分布）。注意这里的LDA和之前在5.3节提到的LDA是不一样的。</p><blockquote><p>pLSA 可以参考：<a href="https://zhuanlan.zhihu.com/p/31235789" target="_blank" rel="noopener">pLSA原理及其代码实现</a>；</p><p>LDA 可以参考：<a href="https://zhuanlan.zhihu.com/p/31470216" target="_blank" rel="noopener">一文详解LDA主题模型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Unsupervised learning（无监督学习）可以做的事大致可以分为Clustering（聚类），Dimension Reduction（降维）和Generation。本文先简单介绍了Clustering，然后主要从数学推导和理解component的含义这两个角度来介绍了Dimension Redunction中常用的一种方法PCA(Principe Component Analysis，主成分分析），最后简单介绍了Matrix Factorization。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="K-means" scheme="http://nekomoon404.github.io/tags/K-means/"/>
    
      <category term="HAC" scheme="http://nekomoon404.github.io/tags/HAC/"/>
    
      <category term="PCA" scheme="http://nekomoon404.github.io/tags/PCA/"/>
    
      <category term="NMF" scheme="http://nekomoon404.github.io/tags/NMF/"/>
    
      <category term="Matrix Factorization" scheme="http://nekomoon404.github.io/tags/Matrix-Factorization/"/>
    
  </entry>
  
</feed>
