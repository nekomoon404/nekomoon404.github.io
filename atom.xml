<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-02-26T04:09:48.254Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法（12）广度/深度优先搜索</title>
    <link href="http://nekomoon404.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://nekomoon404.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</id>
    <published>2020-02-26T01:31:21.000Z</published>
    <updated>2020-02-26T04:09:48.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-广度优先搜索"><a href="#1-广度优先搜索" class="headerlink" title="1.广度优先搜索"></a>1.广度优先搜索</h1><h2 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1.算法"></a>1.1.算法</h2><ul><li>始自顶点s的<strong>广度优先搜索</strong>（Breadth-First-Search）<ul><li>访问顶点s</li><li>依次访问s所有尚未访问的邻接顶点</li><li>依次访问它们尚未访问的邻接顶点</li><li>…….如此反复，直至没有尚未访问的邻接顶点</li></ul></li></ul><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226100517.png" style="zoom:80%;"></p><p>这种搜索将首先访问s，在这个图中通过将s染黑表示它已经接受了访问。接下来需要访问S所有尚未访问的邻接顶点，由s通往它的那些刚被访问的邻居的边都被加粗，这暗示着这些边都已经被算法所采纳和保留，这些边都是非常重要的，它们携带了整个遍历过程中所发现的一些信息。反过来在原图中还会有一些边并不采纳（浅色线部分）在经过广度优先遍历之后，它们将不再保留而是被舍弃掉。</p><p>这个算法将不断地如此迭代反复，直到所有的顶点都接受了访问。所谓广度优先搜索的确是一种遍历，它会按照刚才所介绍的策略确定不同顶点接受访问的次序，并且按照这种次序对各顶点逐个地访问，而整个搜索过程的最终产物或成果不过是选自原图的一系列的加粗的边。</p><p>这里按照与起点s的距离将所有的顶点划分为若干个等价类，在同一等价类内部各顶点的边都不会被采纳，而只有连接于相邻等价类之间的某些边才会被采纳。所有被保留下来并且采纳的这些边将足以把所有的顶点连接起来构成一个连通图，且它是一个<strong>极大无环图</strong>。这就相当于一棵树，这棵树中涵盖了原图的所有的顶点，所以称之为<strong>支撑树</strong>（Spanning Tree）。对于树而言，以上策略及过程完全等同于<strong>层次遍历</strong>。</p><h2 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2.实现"></a>1.2.实现</h2><p>上述的策略可以实现而这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   Queue&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">   status ( v ) = DISCOVERED; Q.enqueue ( v ); <span class="comment">//初始化起点</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在Q变空之前，不断</span></span><br><span class="line">      <span class="keyword">int</span> v = Q.dequeue(); </span><br><span class="line">  dTime ( v ) = ++clock; <span class="comment">//取出队首顶点v</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( u ) ) &#123; <span class="comment">//若u尚未被发现，则</span></span><br><span class="line">            status ( u ) = DISCOVERED; Q.enqueue ( u ); <span class="comment">//发现该顶点</span></span><br><span class="line">            status ( v, u ) = TREE; parent ( u ) = v; <span class="comment">//引入树边拓展支撑树</span></span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="comment">//若u已被发现，或者甚至已访问完毕，则</span></span><br><span class="line">            status ( v, u ) = CROSS; <span class="comment">//将(v, u)归类于跨边</span></span><br><span class="line">         &#125;</span><br><span class="line">      status ( v ) = VISITED; <span class="comment">//至此，当前顶点访问完毕</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到遍历的起点总是某个预先指定的顶点v，既然图的广度优先遍历可以视作为树的层次遍历的一种推广，所以与后者相仿这里依然借助一个队列结构来实现。在v入队之前将它的状态由最初的undiscovered转化为discovered，接下来的<code>while</code>循环每次都通过<code>dequeue()</code>取出队首的顶点并且重新命名为<code>v</code>。</p><p>请注意 在每一个顶点刚刚出队并随即接受访问的同时，我们还需要给它打上一个时间标签<code>dTime</code>，在算法的入口处还有一个名为<code>clock</code>的引用型参数，它就像是一块钟表在整个算法的运行过程中都会给出时间的进度，任何时候如果你希望加注当前的时间标签，只需要将这块表取出来并读取上面的时刻。</p><p>按照算法的策略我们需要枚举出当前节点<code>v</code>的所有邻居，通过<code>for</code>循环语句来实现，<code>firstNbr</code>以及<code>nextNbr</code>接口在上文有介绍过。</p><p>经过整个的遍历搜索过程，每一个顶点的状态都会由最初的undiscovered转化为discovered，并最终转化为visited，这样的三个状态也就构成了每一个顶点在它的生命期内的三部曲。</p><p>下面以一个无向图为例来理解算法的过程：</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226105520.png" style="zoom: 75%;"></p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226105542.png" style="zoom:75%;"></p><h2 id="1-3-全图BFS"><a href="#1-3-全图BFS" class="headerlink" title="1.3.全图BFS"></a>1.3.全图BFS</h2><p>与起始顶点s相连通的每一个顶点都会被bfs搜索、发现并访问，即s顶点所属的那个连通域确实可以被悉数的遍历。然而问题是并非每幅图都只包含一个连通域，那么在含有多个连通域的时候从任何一个起点s出发未必能够抵达其它的连通域。那么这种情况如何处理，如何使得bfs搜索足以覆盖整幅图呢，可以采用下面的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         BFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次BFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226111027.png" style="zoom:80%;"></p><p>这里毕竟引入了一层新的循环而且至少从表面看来，这个循环的迭代次数将多达线性次。但这里并非对每一个顶点都启动一轮bfs搜索，而是只有在当前的顶点能够经过这个<code>if</code>判断（顶点尚未被发现）之后才启动这样一次搜索。这种处理方式可以保证对于每一个连通域只有一个顶点可能作为起点引起它所属的那个连通域被完全的遍历掉，每一个连通域启动而且只启动一次广度优先搜索，因此所有花费在搜索上的时间累计也不过是对全图的一次遍历，而不是多次。</p><h2 id="1-4-复杂度"><a href="#1-4-复杂度" class="headerlink" title="1.4.复杂度"></a>1.4.复杂度</h2><p>广度优先搜索算法的复杂度取决于不同实现方法，尤其是图结构自身的实现算法，这里不妨就以我们的实现版本为例，算法主体的复杂度部分是由while以及for所构成的两重循环。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226112909.png" style="zoom: 80%;"></p><h2 id="1-5-最短路径"><a href="#1-5-最短路径" class="headerlink" title="1.5.最短路径"></a>1.5.最短路径</h2><p>最好来讨论BFS算法的一个特性：最短距离性。</p><p>回顾此前所介绍的树结构，相对于树根节点任何一个节点v都对应于一条唯一的通路，这条路径的长度称作顶点v的深度depth(v)，于是我们可以对所有的顶点自上而下按照它们的深度进行等价类划分，在每一个等价类中的所有顶点所具有的深度指标都是彼此相等的。而树的层次遍历也可以认为是按照这一指标非降的次序，将所有的顶点逐一枚举出来。</p><p>那么这样一个遍历的过程是否也可以转化为图结构的遍历过程呢？表面看来似乎不太容易，因为此时与树结构极不相同的就是从起始顶点s出发可能有多条路径都最后通往同一个顶点，而且可能出现分叉。然而这样一个问题不难解决，实际上我们只需考察顶点之间的最短通路，并且将这两个顶点之间的距离取作这条最短通路的长度dist(v, s)。</p><p><img src="/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8812%EF%BC%89%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/QQ图片20200226115437.png" style="zoom: 33%;"></p><p>巧合的是图的BFS搜索与树的层次遍历一样都具有这样一种单调性，即BFS所给出的顶点序列按照这样到起点的距离也是按照非降次单调排列的。在我们最终所生成的BFS树中，每个顶点与s之间的那条通路恰好就是在原图中这两个顶点之间的最短通路。</p>]]></content>
    
    <summary type="html">
    
      本文针对图结构介绍其广度优先搜索与深度优先搜索算法，总体策略都是将图这种非线性结构转化为半线性结构，进而转化为线性结构进行研究 。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（11）图</title>
    <link href="http://nekomoon404.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/"/>
    <id>http://nekomoon404.github.io/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/</id>
    <published>2020-02-25T01:23:52.000Z</published>
    <updated>2020-02-25T07:59:39.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-基本术语"><a href="#1-1-基本术语" class="headerlink" title="1.1.基本术语"></a>1.1.基本术语</h2><ul><li><p>G = ( V;  E) = ( 顶点集;  边集)</p></li><li><p><strong>顶点</strong>（vertex）：n = |V|</p><p><strong>边</strong>（edge）|弧（arc）：e = |E|</p></li><li><p><strong>邻接关系</strong>（adjacency）：定义同一条边的两个顶点之间的关系</p><p>自环（self-loop）：同一顶点自我相邻</p><p>简单图（simple graph）：不含自环，这一章讨论的都是简单图</p></li><li><p><strong>关联关系</strong>（incidence）：顶点与其所属的边之间的关系</p><p>度（degree）：于同一顶点关联的边数</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225093718.png" style="zoom:80%;"></p><p>此前所学的几种数据结构都可以视作是图的特例，比如在向量和列表等线性结构中只有互为前驱与后继的元素之间才能够定义邻接关系，而树结构中只能在父节点与子节点之间才能够定义邻接关系。</p><p>图更为一般化，其中的任何两个节点之间都允许存在这样的一个邻接关系，我们这里讨论的图排除自环的存在。</p><h2 id="1-2-无向图-有向图"><a href="#1-2-无向图-有向图" class="headerlink" title="1.2.无向图/有向图"></a>1.2.无向图/有向图</h2><ul><li><p>若关联顶点u和v次序无所谓，则(u, v)为<strong>无向边</strong>（undirected edge）</p><p>所有边均为无方向的图，即为<strong>无向图</strong>（undigraph）</p></li><li><p>反之，<strong>有向图</strong>（digraph）中均为有向边（directed edge）</p><p>u，v分别称作边(u, v)的<strong>尾</strong>（tail）、<strong>头</strong>（head）</p></li><li><p>无向边、有向边并存的图，称作<strong>混合图</strong>（mixed graph）</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225095702.png" style="zoom:80%;"></p><p>在图这一章我们关注有向图，因为通过有向图完全可以表示并且实现无向图以及混合图，简单的做法是将任何一条无向边转化为彼此对称的一对有向边。</p><h2 id="1-3-路径-环路"><a href="#1-3-路径-环路" class="headerlink" title="1.3.路径/环路"></a>1.3.路径/环路</h2><ul><li><p>路径：$\pi$ = &lt;$V_0,V_1,\dots,V_k&gt;$</p><p>长度： | $\pi$ | = k</p></li><li><p>简单路劲：$V_i=V_j$  除非$i=j$，即路劲中不含重复顶点</p></li><li><p>环/环路：$V_0=V_k$</p></li><li><p>有向无环图（DAG）</p></li><li><p>欧拉环路：| $\pi$ | = | E |，即各边恰好出现一次</p></li><li><p>哈密尔顿环路：| $\pi$ | = | V |，即各顶点恰好出现一次</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225102106.png" style="zoom: 80%;"></p><h1 id="2-基于邻接矩阵实现图结构"><a href="#2-基于邻接矩阵实现图结构" class="headerlink" title="2.基于邻接矩阵实现图结构"></a>2.基于邻接矩阵实现图结构</h1><h2 id="2-1-Graph模板类"><a href="#2-1-Graph模板类" class="headerlink" title="2.1. Graph模板类"></a>2.1. Graph模板类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EType; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span> <span class="comment">//图Graph模板类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="comment">//所有顶点、边的辅助信息复位</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//所有顶点的</span></span><br><span class="line">         status ( i ) = UNDISCOVERED; dTime ( i ) = fTime ( i ) = <span class="number">-1</span>; <span class="comment">//状态，时间标签</span></span><br><span class="line">         parent ( i ) = <span class="number">-1</span>; priority ( i ) = INT_MAX; <span class="comment">//（在遍历树中的）父节点，优先级数</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有边的</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) type ( i, j ) = UNDETERMINED; <span class="comment">//类型</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">BFS</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp; )</span></span>; <span class="comment">//（连通域）广度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp; )</span></span>; <span class="comment">//（连通域）深度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">BCC</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp;, Stack&lt;<span class="keyword">int</span>&gt;&amp; )</span></span>; <span class="comment">//（连通域）基于DFS的双连通分量分解算法</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">TSort</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span>&amp;, Stack&lt;Tv&gt;* )</span></span>; <span class="comment">//（连通域）基于DFS的拓扑排序算法</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="function"><span class="keyword">void</span> <span class="title">PFS</span> <span class="params">( <span class="keyword">int</span>, PU )</span></span>; <span class="comment">//（连通域）优先级搜索框架</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 顶点</span></span><br><span class="line">   <span class="keyword">int</span> n; <span class="comment">//顶点总数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">insert</span> <span class="params">( Tv <span class="keyword">const</span>&amp; )</span> </span>= <span class="number">0</span>; <span class="comment">//插入顶点，返回编号</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//删除顶点及其关联边，返回该顶点信息</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv&amp; <span class="title">vertex</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的数据（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">inDegree</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的入度（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">outDegree</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的出度（该顶点的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">firstNbr</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的首个邻接顶点</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">nextNbr</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的（相对于顶点j的）下一邻接顶点</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> VStatus&amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">dTime</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的时间标签dTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">fTime</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v的时间标签fTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">parent</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v在遍历树中的父亲</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">priority</span> <span class="params">( <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//顶点v在遍历树中的优先级数</span></span><br><span class="line"><span class="comment">// 边：这里约定，无向边均统一转化为方向互逆的一对有向边，从而将无向图视作有向图的特例</span></span><br><span class="line">   <span class="keyword">int</span> e; <span class="comment">//边总数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)是否存在</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">( Te <span class="keyword">const</span>&amp;, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//在顶点v和u之间插入权重为w的边e</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te <span class="title">remove</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//删除顶点v和u之间的边e，返回该边信息</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> EType &amp; <span class="title">type</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的类型</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te&amp; <span class="title">edge</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的数据（该边的确存在）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">weight</span> <span class="params">( <span class="keyword">int</span>, <span class="keyword">int</span> )</span> </span>= <span class="number">0</span>; <span class="comment">//边(v, u)的权重</span></span><br><span class="line"><span class="comment">// 算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//广度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//深度优先搜索算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bcc</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//基于DFS的双连通分量分解算法</span></span><br><span class="line">   Stack&lt;Tv&gt;* tSort ( <span class="keyword">int</span> ); <span class="comment">//基于DFS的拓扑排序算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">prim</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//最小支撑树Prim算法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span> <span class="params">( <span class="keyword">int</span> )</span></span>; <span class="comment">//最短路径Dijkstra算法</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="function"><span class="keyword">void</span> <span class="title">pfs</span> <span class="params">( <span class="keyword">int</span>, PU )</span></span>; <span class="comment">//优先级搜索框架</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-邻接矩阵与关联矩阵"><a href="#2-2-邻接矩阵与关联矩阵" class="headerlink" title="2.2.邻接矩阵与关联矩阵"></a>2.2.邻接矩阵与关联矩阵</h2><ul><li><p><strong>邻接矩阵</strong>（adjacency matrix）：用二维矩阵记录顶点之间的邻接关系，矩阵元素与图中存在的边一一对应</p><p>$A(i,  j)=1$，若顶点$i$与$j$之间存在一条边；否则为0  （可以推广到带权图，即网络）</p><p>既然只考察简单图，则对角线元素统一设置为0</p><p>空间复杂度为$\Theta(n^2)$，与图中实际的边数无关</p></li><li><p><strong>关联矩阵</strong>（incidence matrix）：用二维矩阵记录顶点与边之间的关联关系</p><p>空间复制度为$\Theta(n*e)=O(n^3)$</p><p>空间利用率 &lt; 2/n</p></li></ul><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225103611.png" style="zoom: 60%;"></p><p>下面是几个实例：</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225105024.png" style="zoom:67%;"></p><h2 id="2-3-Vertex"><a href="#2-3-Vertex" class="headerlink" title="2.3. Vertex"></a>2.3. Vertex</h2><p>下面是顶点（vertex）的一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span> <span class="comment">//顶点对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Tv data; <span class="keyword">int</span> inDegree, outDegree;<span class="comment">//数据、出入度数</span></span><br><span class="line">   VStatus status; <span class="comment">//（如上三种）状态</span></span><br><span class="line">   <span class="keyword">int</span> dTime, fTime; <span class="comment">//时间标签</span></span><br><span class="line">   <span class="keyword">int</span> parent;   <span class="comment">//在遍历树中的父节点</span></span><br><span class="line">   <span class="keyword">int</span> priority; <span class="comment">//在遍历树中的优先级数（最短通路、极短跨边等）</span></span><br><span class="line">   Vertex ( Tv <span class="keyword">const</span>&amp; d = ( Tv ) <span class="number">0</span> ) : <span class="comment">//构造新顶点</span></span><br><span class="line">      data ( d ), inDegree ( <span class="number">0</span> ), outDegree ( <span class="number">0</span> ), status ( UNDISCOVERED ),</span><br><span class="line">      dTime ( <span class="number">-1</span> ), fTime ( <span class="number">-1</span> ), parent ( <span class="number">-1</span> ), priority ( INT_MAX ) &#123;&#125; <span class="comment">//暂不考虑权重溢出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>边（Edge）的一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EStatus; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">//边对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Te data;        <span class="comment">//数据</span></span><br><span class="line">   <span class="keyword">int</span> weight;     <span class="comment">//权重</span></span><br><span class="line">   EStatus status; <span class="comment">//（如上五种）状态</span></span><br><span class="line">   Edge ( Te <span class="keyword">const</span>&amp; d, <span class="keyword">int</span> w ) : data ( d ), weight ( w ), status ( UNDETERMINED ) &#123;&#125; <span class="comment">//构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-GraphMatrix"><a href="#2-4-GraphMatrix" class="headerlink" title="2.4. GraphMatrix"></a>2.4. GraphMatrix</h2><p>现在就可以给出基于邻接矩阵实现图结构的一种可行方式，<code>GraphMatrix</code>类派生于此前所定义的<code>Graph</code>模板类，将顶点集实现为向量结构，其长度恰好等于顶点的规模即n；将边集实现为向量的向量，相当于一个n×n的矩阵，它恰好就是此前所构思的邻接矩阵。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225113730.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> :</span> <span class="keyword">public</span> Graph&lt;Tv, Te&gt; &#123; <span class="comment">//基于向量，以邻接矩阵形式实现的图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Vector&lt; Vertex&lt; Tv &gt; &gt; V; <span class="comment">//顶点集（向量）</span></span><br><span class="line">   Vector&lt; Vector&lt; Edge&lt; Te &gt; * &gt; &gt; E; <span class="comment">//边集（邻接矩阵）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   GraphMatrix() &#123; n = e = <span class="number">0</span>; &#125; <span class="comment">//构造</span></span><br><span class="line">   ~GraphMatrix() &#123; <span class="comment">//析构</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有动态创建的</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++ ) <span class="comment">//边记录</span></span><br><span class="line">            <span class="keyword">delete</span> E[j][k]; <span class="comment">//逐条清除</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 操作接口：顶点查询、顶点修改、边查询、边修改 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们此前对向量所重载的方括号操作符<code>[]</code>，这里只需用<code>E[i][j]</code>这样一种形式即可指代在顶点<code>i</code>与 <code>j</code> 之间的一条边，既可以读出这条边的信息，也可以反过来修改其中的某些信息。</p><h2 id="2-5-顶点操作"><a href="#2-5-顶点操作" class="headerlink" title="2.5.顶点操作"></a>2.5.顶点操作</h2><p>按照这种实现方式，我们可以简明实现顶点操作中的大部分基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点的基本操作：查询第i个顶点（0 &lt;= i &lt; n）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Tv&amp; <span class="title">vertex</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].data; &#125; <span class="comment">//数据</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">inDegree</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].inDegree; &#125; <span class="comment">//入度</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">outDegree</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].outDegree; &#125; <span class="comment">//出度</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> VStatus&amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].status; &#125; <span class="comment">//状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">dTime</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].dTime; &#125; <span class="comment">//时间标签dTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">fTime</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].fTime; &#125; <span class="comment">//时间标签fTime</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">parent</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].parent; &#125; <span class="comment">//在遍历树中的父亲</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">priority</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="keyword">return</span> V[i].priority; &#125; <span class="comment">//在遍历树中的优先级数</span></span><br></pre></td></tr></table></figure><p>对于任意顶点i，如何枚举其所有的邻接顶点neighbor？为此首先需要实现一个名为<code>nextNbr</code>的接口，它的功能语义是如果我们现在已经枚举到顶点<code>i</code>的编号为 <code>j</code> 的邻居，那么它将返回接下来的下一个邻居。与顶点 <code>i</code> 潜在的可以相邻的点，无非就是它在邻接矩阵中所对应的那一行中数值为1的单元，对应于与<code>i</code>邻接的一个顶点。而第一个有效的邻居是通过<code>firstNbr</code>接口实现，它调用了<code>nextNbr</code>，将顶点<code>n</code>（并不实际存在）作为上一个有效的邻居。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225113618.png" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">nextNbr</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123;<span class="comment">//相对于顶点j的下一邻接顶点</span></span><br><span class="line">   <span class="keyword">while</span> ( ( <span class="number">-1</span> &lt; j ) &amp;&amp; ( !<span class="built_in">exists</span> ( i, --j ) ) ); <span class="comment">//逆向线性试探，O(n)</span></span><br><span class="line">   <span class="keyword">return</span> j; </span><br><span class="line">&#125;  <span class="comment">//改用邻接表可提高至O(1 + outDegree(i))</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">firstNbr</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> nextNbr ( i, n ); </span><br><span class="line">&#125; <span class="comment">//首个邻接顶点</span></span><br></pre></td></tr></table></figure><h2 id="2-6-边操作"><a href="#2-6-边操作" class="headerlink" title="2.6.边操作"></a>2.6.边操作</h2><p>同样地，利用邻接矩阵我们也可以便捷地实现很多边的基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的确认操作</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> <span class="comment">//边(i, j)是否存在</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= i ) &amp;&amp; ( i &lt; n ) &amp;&amp; ( <span class="number">0</span> &lt;= j ) &amp;&amp; ( j &lt; n ) &amp;&amp; E[i][j] != <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="comment">// 边的基本操作：查询顶点i与j之间的联边（0 &lt;= i, j &lt; n且exists(i, j)）</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> EStatus &amp; <span class="title">status</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;status; &#125; <span class="comment">//边(i, j)的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> Te&amp; <span class="title">edge</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;data; &#125; <span class="comment">//边(i, j)的数据</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span>&amp; <span class="title">weight</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="keyword">return</span> E[i][j]-&gt;weight; &#125; <span class="comment">//边(i, j)的权重</span></span><br></pre></td></tr></table></figure><p><strong>边插入</strong>：</p><p>假设我们需要在顶点<code>i</code>与顶点<code>j</code>之间连接一条有向边，假设这条边尚不存在，那么只需要将待插入的那条边的信息比如它的权重等等，封装为一个具体的边记录，然后将这个新的边记录地址存入于邻接矩阵中对应的那个单元，也可以说这个单元将指向这个新的边记录。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225115722.png" style="zoom:60%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">( Te <span class="keyword">const</span>&amp; edge, <span class="keyword">int</span> w, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="comment">//插入权重为w的边e = (i, j)</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) <span class="keyword">return</span>; <span class="comment">//确保该边尚不存在</span></span><br><span class="line">   E[i][j] = <span class="keyword">new</span> Edge&lt;Te&gt; ( edge, w ); <span class="comment">//创建新边</span></span><br><span class="line">   e++;   <span class="comment">//更新边计数</span></span><br><span class="line">   V[i].outDegree++;  <span class="comment">//更新关联顶点i的出度</span></span><br><span class="line">   V[j].inDegree++;   <span class="comment">//更新关联顶点i的入数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>边删除</strong>：</p><p>不妨假设从顶点 <code>i</code> 通往顶点 <code>j</code> 之间存在一条边，因此在邻接矩阵中对应的那一项就非空，而且这一项将指向一个对应的边记录。为了删除这条边，只需将这条边对应的记录释放并且归还给系统，然后令在邻接矩阵中对应于这一项的引用指向空。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225152142.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Te <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span> </span>&#123; <span class="comment">//删除顶点i和j之间的联边（exists(i, j)）</span></span><br><span class="line">   Te eBak = edge ( i, j ); </span><br><span class="line">   <span class="keyword">delete</span> E[i][j]; E[i][j] = <span class="literal">NULL</span>; <span class="comment">//备份后删除边记录</span></span><br><span class="line">   e--; </span><br><span class="line">   V[i].outDegree--; </span><br><span class="line">   V[j].inDegree--; <span class="comment">//更新边计数与关联顶点的度数</span></span><br><span class="line">   <span class="keyword">return</span> eBak; <span class="comment">//返回被删除边的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-顶点插入与删除"><a href="#2-7-顶点插入与删除" class="headerlink" title="2.7.顶点插入与删除"></a>2.7.顶点插入与删除</h2><p>顶点的插入与删除相对于边的操作要更为复杂，原因在于在此前的边操作中整个矩阵的规模并不会发生变化，而顶点的插入以及稍后的删除则会改变。为了在其中引入一个新的顶点，首先要将邻接矩阵中已有的各行分别向后扩展一个单元，即增加一列；接下来针对新引入的顶点还需在邻接矩阵中增加对应的一行；当然还需在第一级的边表中增加一个相应地单元用来指示或者说记录新引入的行向量；最后对应于这个新引入的顶点还需要在顶点向量中加入一个新的对应元素。</p><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8811%EF%BC%89%E5%9B%BE/QQ图片20200225153304.png" style="zoom:67%;"></p><p>这样的四个步骤可以实现为这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">insert</span> <span class="params">( Tv <span class="keyword">const</span>&amp; vertex )</span> </span>&#123; <span class="comment">//插入顶点，返回编号</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) E[j].insert ( <span class="literal">NULL</span> ); n++; <span class="comment">//各顶点预留一条潜在的关联边</span></span><br><span class="line">   E.insert ( Vector&lt;Edge&lt;Te&gt;*&gt; ( n, n, ( Edge&lt;Te&gt;* ) <span class="literal">NULL</span> ) ); <span class="comment">//创建新顶点对应的边向量</span></span><br><span class="line">   <span class="keyword">return</span> V.insert ( Vertex&lt;Tv&gt; ( vertex ) ); <span class="comment">//顶点向量增加一个顶点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点删除就是上述步骤的逆过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Tv <span class="title">remove</span> <span class="params">( <span class="keyword">int</span> i )</span> </span>&#123; <span class="comment">//删除第i个顶点及其关联边（0 &lt;= i &lt; n）</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有出边</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">exists</span> ( i, j ) ) </span><br><span class="line">         &#123; <span class="keyword">delete</span> E[i][j]; V[j].inDegree--; e--; &#125; <span class="comment">//逐条删除</span></span><br><span class="line">   E.<span class="built_in">remove</span> ( i ); n--; <span class="comment">//删除第i行</span></span><br><span class="line">   Tv vBak = vertex ( i ); V.<span class="built_in">remove</span> ( i ); <span class="comment">//删除顶点i</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有入边</span></span><br><span class="line">      <span class="keyword">if</span> ( Edge&lt;Te&gt; * x = E[j].<span class="built_in">remove</span> ( i ) ) </span><br><span class="line">         &#123; <span class="keyword">delete</span> x; V[j].outDegree--; e--; &#125; <span class="comment">//逐条删除</span></span><br><span class="line">   <span class="keyword">return</span> vBak; <span class="comment">//返回被删除顶点的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-优缺点"><a href="#2-8-优缺点" class="headerlink" title="2.8.优缺点"></a>2.8.优缺点</h2><p>邻接矩阵的<strong>优点</strong>有：</p><ul><li><p>直观，易于理解和实现</p></li><li><p>适用范围广泛：digrah / network / cyclic / …</p><p>尤其适用于稠密图（dense graph）</p></li><li><p>判断两点之间是否存在联边：$O(1)$</p></li><li><p>获取顶点的（出/入）度数：$O(1)$</p><p>添加、删除边后更新度数：$O(1)$</p></li><li><p>扩展性（scalability）：</p><p>得益于Vector良好的空间控制策略，空间溢出等情况可“透明地”予以处理</p></li></ul><p>邻接矩阵的<strong>缺点</strong>则是：</p><ul><li>空间利用率，它始终是需要$\Theta(n^2)$空间，与边数无关</li></ul><p>在实际问题中的图通常不会有$n^2$级的边数，不妨考虑下平面图（planar graph），即可嵌入平面的图，其中不相邻的边不相交。根据欧拉推导的公式：对于所有的平面图有，$v-e+f-c=1$，各字母分别表示顶点数、边数、区域面片数、连通域数。因此平面图的边数有：$e\le 3\times n-6=O(n) \ll n^2$，此时空间利用率$\approx 1/n$。而对于一般的稀疏图（sparse graph），空间利用率同样很低，因此可以采用压缩存储技术予以改进。</p>]]></content>
    
    <summary type="html">
    
      本文主要介绍图结构，相对于此前的线性结构（向量，列表）以及半线性结构（二叉树），图结构对其中元素的限定更少，因此它描述应用问题的能力也就更强
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（12）文件操作和模板</title>
    <link href="http://nekomoon404.github.io/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/"/>
    <id>http://nekomoon404.github.io/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-02-22T08:51:42.000Z</published>
    <updated>2020-02-25T11:18:01.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1.文件操作"></a>1.文件操作</h1><p>本节介绍如何利用C++语言来处理文件的一些操作，我们知道所有的数据在计算机上保存的时候都是具有一定的层次化的结构的，一个数据在计算机实质上被保存的就是一个个0,1的<strong>比特位</strong>，它是每位这样存放的。但是去处理每个比特位的话那么可能在很多时候这个数据在构建时就会变得非常的繁琐，并且具有很强的不规律性，所以我们进一步把这8个比特位构成的称之为<strong>字节</strong>。那么每一个byte它对应描述了一定的内容，而这些各个字节组成的一些具体的内容又称之为<strong>域</strong>或者<strong>记录</strong>。</p><ul><li><p>数据的层次：</p><ul><li>位       bit</li><li>字节   byte</li><li>域/记录</li></ul></li><li><p>把所有记录顺序地写入一个文件 $\to$ 顺序文件</p></li></ul><h2 id="1-1-文件和流"><a href="#1-1-文件和流" class="headerlink" title="1.1.文件和流"></a>1.1.文件和流</h2><ul><li><p>顺序文件：一个有限字符构成的顺序字符流</p></li><li><p>C++标准库中：<code>ifstream</code>，<code>ofstream</code>和<code>fstream</code>共3个类 $\to$ 用于文件操作，统称为文件流类。</p><ul><li><code>ifstream</code>用于将文件读取，从文件中读取数据</li><li><code>ofstream</code>用于向文件中写入数据</li><li><code>fstream</code>即可以从文件中读取数据，又可以向文件中写入数据</li></ul></li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222172254.png" style="zoom:50%;"></p><p>（图中箭头表示派生）</p><h2 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2.文件操作"></a>1.2.文件操作</h2><ul><li><p>使用/创建文件的基本流程：</p><p>1）打开文件：通过指定文件名，建立文件和文件流对象的关联；指明文件的使用方式；</p><p>2）读/写文件：利用读/写指针进行相应的操作</p><p>3）关闭文件</p></li></ul><h2 id="1-3-建立顺序文件"><a href="#1-3-建立顺序文件" class="headerlink" title="1.3.建立顺序文件"></a>1.3.建立顺序文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;  //包含头文件</span></span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"clients.dat"</span>, ios::out | ios:: binary)</span></span>;  <span class="comment">//打开文件</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222172248.png" style="zoom: 55%;"></p><ul><li>也可以先创建ofstream对象，再用open函数打开；</li><li>一般要判断打开是否成功；</li><li>文件名可以给出绝对路径，也可以给相对路径；</li><li>没有交代路径信息，就是在当前文件夹下找文件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">"test.out"</span>, ios::out | ios::binary);</span><br><span class="line"><span class="keyword">if</span>(!fout) &#123; <span class="built_in">cerr</span> &lt;&lt; <span class="string">"File open error!"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-文件的读写指针"><a href="#1-4-文件的读写指针" class="headerlink" title="1.4.文件的读写指针"></a>1.4.文件的读写指针</h2><ul><li><p>对于输入文件，有一个读指针；</p><p>对于输出文件，有一个写指针；</p><p>对于输入输出文件，有一个读写指针；</p></li><li><p>标识文件操作的当前位置，该指针在哪里 $\to$ 读写操作就在哪里进行</p></li></ul><p><strong>写指针</strong>：（location可以为负值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"a1.out"</span>, ios::app)</span></span>;</span><br><span class="line"><span class="keyword">long</span> location = fout.tellp();    <span class="comment">//取得写指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;</span><br><span class="line">fout.seekp(location);   <span class="comment">//将写指针移动到第10个字节处</span></span><br><span class="line">fout.seekp(location, ios::beg);  <span class="comment">//从头数location</span></span><br><span class="line">fout.seekp(location, ios::cur);  <span class="comment">//从当前位置数location</span></span><br><span class="line">fout.seekp(location, ios::<span class="built_in">end</span>);  <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><p><strong>读指针</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"a1.out"</span>, ios::in)</span></span>;</span><br><span class="line"><span class="keyword">long</span> location = fin.tellg();    <span class="comment">//取得写指针的位置</span></span><br><span class="line">location = <span class="number">10L</span>;</span><br><span class="line">fin.seekg(location);   <span class="comment">//将写指针移动到第10个字节处</span></span><br><span class="line">fin.seekg(location, ios::beg);  <span class="comment">//从头数location</span></span><br><span class="line">fin.seekg(location, ios::cur);  <span class="comment">//从当前位置数location</span></span><br><span class="line">fin.seekg(location, ios::<span class="built_in">end</span>);  <span class="comment">//从尾部数location</span></span><br></pre></td></tr></table></figure><h2 id="1-5-二进制文件读写"><a href="#1-5-二进制文件读写" class="headerlink" title="1.5.二进制文件读写"></a>1.5.二进制文件读写</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">fout.seekp(<span class="number">20</span>,ios::beg);</span><br><span class="line">fout.<span class="built_in">write</span>( (<span class="keyword">const</span> <span class="keyword">char</span>*)(&amp;x), <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">fin.seekg(<span class="number">0</span>,ios::beg);</span><br><span class="line">fin.<span class="built_in">read</span>( (<span class="keyword">char</span>*)(&amp;x), <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure><ul><li>二进制文件读写，直接读/写二进制数据，记事本看未必正确</li></ul><p>例子：从键盘输入几个学生的姓名和成绩，并以二进制文件形式存起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">ofstream <span class="title">OutFile</span><span class="params">(<span class="string">"D:\\tmp\\student.dat"</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s.szName &gt;&gt; s.nScore) &#123;</span><br><span class="line"><span class="keyword">if</span> (stricmp(s.szName, <span class="string">"exit"</span>) == <span class="number">0</span>)   <span class="comment">//名字为exit则结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">OutFile.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">&#125;</span><br><span class="line">OutFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200222181614.png" style="zoom: 55%;"></p><p>对二进制文件来进行读写的时候最好是能够保持一致，<strong>即以二进制的形式去写入就以二进制的形式来读出</strong>。例子2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"student.dat"</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s))) &#123;</span><br><span class="line"><span class="keyword">int</span> nReadedBytes = inFile.gcount();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">" "</span> &lt;&lt; s.nScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚才的两个例子当中介绍了如何对一个文件进行二进制形式的一个写入，或者是对一个文件具体以二进制的形式来进行读出，而在很多时候我们通常会对一个文件同时要进行读和写的操作。</p><p>例子3：将<code>student.dat</code>文件的Jane的名字改成Mike</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> nScore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student s;</span><br><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(<span class="string">"D:\\tmp\\student.dat"</span>, ios::in | ios::out | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!iofile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iofile.seekp(<span class="number">2</span> * <span class="keyword">sizeof</span>(s), ios::beg);    <span class="comment">//定位写指针到第三个记录</span></span><br><span class="line">iofile.<span class="built_in">write</span>(<span class="string">"Mike"</span>, <span class="built_in">strlen</span>(<span class="string">"Mike"</span>) + <span class="number">1</span>);</span><br><span class="line">iofile.seekg(<span class="number">0</span>, ios::beg);   <span class="comment">//定位读指针到开头</span></span><br><span class="line"><span class="keyword">while</span> (iofile.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;s, <span class="keyword">sizeof</span>(s)))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.szName &lt;&lt; <span class="string">" "</span> &lt;&lt; s.nScore &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">iofile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显示关闭文件（写或读之后都要显示关闭文件）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"test.dat"</span>, ios::in)</span></span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"test.dat"</span>,ios::out)</span></span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>例子4：文件拷贝，用法示例：<code>mycopy src.dat dest.dat</code>，即将<code>src.dat</code>拷贝到<code>dest.at</code>，如果<code>dest.dat</code>原来就有，则原来的文件会被覆盖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数的两个参数分别记录命令行操作相应的参数的个数以及参数对应的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"File name missing!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(argv[<span class="number">1</span>], ios::binary | ios::in)</span></span>;  <span class="comment">//打开文件用于读</span></span><br><span class="line"><span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Source file open error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(argv[<span class="number">2</span>], ios::binary | ios::out)</span></span>; <span class="comment">//打开文件用于写</span></span><br><span class="line"><span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"New file open error."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">inFile.<span class="built_in">close</span>();   <span class="comment">//打开的文件一定要关闭</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> c;   <span class="comment">//仅做示例，实际文件拷贝时不会是逐字节拷贝</span></span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">get</span>(c))    <span class="comment">//每次读取一个字符</span></span><br><span class="line">outFile.<span class="built_in">put</span>(c);      <span class="comment">//每次写入一个字符</span></span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h1><p>通过模板的使用就正式开始了泛型程序程序设计这样一个模块的学习。</p><p><strong>泛型程序设计</strong>（Generic Programming）</p><ul><li>算法实现时不指定具体要操作的数据的类型；</li><li>泛型—算法实现一遍 $\to$ 适用于多种数据结构</li><li>优势：减少重复代码的编写</li><li><p>大量编写模板，使用模板的程序设计：</p><ul><li>函数模板</li><li>类模板</li></ul></li><li><p><strong>函数模板的形式</strong>：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 类型参数1, <span class="title">class</span> 类型参数2,...&gt; 返回值类型 模板名(形参表)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp;<span class="title">x</span>, <span class="title">T</span> &amp;<span class="title">y</span>)&#123;</span></span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    Swap(n, m);     <span class="comment">//编译器自动生成 void Swap(int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    Swap(f, g);     <span class="comment">//编译器自动生成 void Swap(double &amp;, double &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数模板中可以有不止一个类型参数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T2</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>函数模板可以重载</strong>，只要它们的形参表不同即可，例如下面两个模板可以同时存在：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">arg1</span>. <span class="title">T</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>C++编译器遵循以下优先顺序：</p><ul><li>Step1：先找参数完全匹配的普通函数（非由模板实例化而得的函数）；</li><li>Step2：再找参数完全匹配的模板函数；</li><li>Step3：再找实参经过自动类型转换后能够匹配的普通函数；</li><li>Step4：上面的都找不到，则报错。</li></ul></li><li><p>要注意赋值兼容原则引起函数模板中类型参数的二义性</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T1</span> <span class="title">arg1</span>. <span class="title">T2</span> <span class="title">arg2</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arg1&lt;&lt;<span class="string">" "</span>&lt;&lt;arg2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>, <span class="number">7</span>);      <span class="comment">//ok, replace T with int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5.8</span>, <span class="number">7.8</span>);  <span class="comment">//ok, replace T with double</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>, <span class="number">7.8</span>);    <span class="comment">//error, replace T with int or double? 二义性</span></span><br></pre></td></tr></table></figure><h1 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3.类模板"></a>3.类模板</h1><ul><li><strong>类模板</strong>：在定义类的时候给它一个/多个参数，这个/些参数表示不同的数据类型；在调用类模板时，指定参数，由编译系统根据参数提供的数据类型自动产生相应的<strong>模板类</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;类型参数表&gt; <span class="class"><span class="keyword">class</span> 类模板名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>类模板里的成员函数，如在类模板外面定义时：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;型参数表&gt;</span><br><span class="line">返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1类模板的定义"><a href="#3-1类模板的定义" class="headerlink" title="3.1类模板的定义"></a><strong>3.1类模板的定义</strong></h2><ul><li>用类模板定义对象的写法如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表);</span><br></pre></td></tr></table></figure><ul><li>如果类模板有无参构造函数，那么也可以只写：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 key;</span><br><span class="line">T2 value;</span><br><span class="line">Pair(T1 k, T2 v) :key(k), value(v) &#123; &#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Pair</span>&lt;T1,T2&gt;:</span>:<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pair&lt;T1, T2&gt; &amp; p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> key &lt; p.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;student(<span class="string">"Tom"</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">//实例化出一个类Pair&lt;string,int&gt;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; student.key &lt;&lt; <span class="string">" "</span> &lt;&lt; student.value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>Tom 19</code></p><h2 id="3-2-使用类模板声明对象"><a href="#3-2-使用类模板声明对象" class="headerlink" title="3.2.使用类模板声明对象"></a>3.2.使用类模板声明对象</h2><ul><li>编译器由类模板生成类的过程叫<strong>类模板的实例化</strong><ul><li>编译器自动用具体的数据类型 $\to$ 替换类模板中的类型参数，生成模板类的代码</li></ul></li><li><p><strong>由类模板实例化得到的类叫模板类</strong></p><ul><li>为类型参数指定的数据类型不同，得到的模板类不同</li></ul></li><li><p>同一个类模板的两个模板类是不兼容的</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; *p;</span><br><span class="line">Pair&lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; a;</span><br><span class="line">p = &amp; a;  <span class="comment">//Wrong</span></span><br></pre></td></tr></table></figure><h2 id="3-3-函数模板作为类模板成员"><a href="#3-3-函数模板作为类模板成员" class="headerlink" title="3.3.函数模板作为类模板成员"></a>3.3.函数模板作为类模板成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>&gt; <span class="title">void</span> <span class="title">Func</span>(<span class="title">T2</span> <span class="title">t</span>)&#123;</span> <span class="built_in">cout</span> &lt;&lt; t; &#125;</span><br><span class="line">    <span class="comment">//若改为template&lt;class T&gt;将报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.Func(<span class="string">'K'</span>);  <span class="comment">//成员函数模板Func被实例化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：<code>K</code></p><h2 id="3-4-类模板与非类型参数"><a href="#3-4-类模板与非类型参数" class="headerlink" title="3.4.类模板与非类型参数"></a>3.4.类模板与非类型参数</h2><ul><li>类模板的参数声明中可以包括<strong>非类型参数</strong>，如<code>template&lt;class T, int elementsNumber&gt;</code><ul><li>非类型参数：用来说明类模板中的属性</li><li>类型参数：用来说明类模板中的属性类型，成员操作的参数类型和返回值类型</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">size</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：<code>Array&lt;int,40&gt;</code>和<code>Array&lt;int,50&gt;</code>完全是两个类，这两个类的对象之间不能互相赋值</p><h2 id="3-5-类模板与继承"><a href="#3-5-类模板与继承" class="headerlink" title="3.5.类模板与继承"></a>3.5.类模板与继承</h2><ul><li>类模板派生出类模板</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200224190624.png" style="zoom: 60%;"></p><ul><li>模板类（即类模板中类型/非类型参数实例化后的类）派生出类模板</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200224190812.png" style="zoom: 50%;"></p><ul><li>普通类派生出类模板</li><li>模板类派生出普通类</li></ul><h1 id="4-string类"><a href="#4-string类" class="headerlink" title="4. string类"></a>4. string类</h1><p>string类本身是一个模板类，而它本身其实是由一个类模板实例化得到的，string类是一个非常好用的类库，在很多字符串处理的场合都会用到string类。</p><h2 id="4-1-基础操作"><a href="#4-1-基础操作" class="headerlink" title="4.1.基础操作"></a>4.1.基础操作</h2><ul><li><code>string</code>类是一个模板类，它的定义为：<code>typedef basic_string&lt;char&gt;string</code>;</li><li>使用<code>string</code>类要包含头文件：<code>#include&lt;string&gt;</code></li><li><code>string</code>对象的初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;   <span class="comment">//一个参数的构造函数</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">S2</span><span class="params">(<span class="number">8</span>,<span class="string">'x'</span>)</span></span>;     <span class="comment">//两个参数的构造函数</span></span><br><span class="line"><span class="built_in">string</span> month = <span class="string">"March"</span>;</span><br></pre></td></tr></table></figure><ul><li>不提供以字符和整数为参数的构造函数，以下都是错误的初始化方法：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> error = <span class="string">'c'</span>;   <span class="comment">//错</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">error2</span><span class="params">(<span class="string">'u'</span>)</span></span>;   <span class="comment">//错</span></span><br><span class="line"><span class="built_in">string</span> error3 = <span class="number">22</span>;   <span class="comment">//错</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">error4</span><span class="params">(<span class="number">8</span>)</span></span>;     <span class="comment">//错</span></span><br></pre></td></tr></table></figure><ul><li>可以将字符赋值给string对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">s = <span class="string">'n'</span>;</span><br></pre></td></tr></table></figure><ul><li>构造的string对象太长而无法表达 $\to$ 会抛出<code>length_error</code>异常</li><li><code>string</code>对象的长度用成员函数<code>length()</code>读取：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.length() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><code>string</code>支持流读取运算符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> stringObject;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; stringObject;</span><br></pre></td></tr></table></figure><ul><li><code>string</code>支持<code>getline</code>函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);</span><br></pre></td></tr></table></figure><h2 id="4-2-string的赋值和连接"><a href="#4-2-string的赋值和连接" class="headerlink" title="4.2. string的赋值和连接"></a>4.2. string的赋值和连接</h2><ul><li>用’<code>=</code>‘赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1("cat"), s2;</span><br><span class="line">s2 = s1;</span><br></pre></td></tr></table></figure><ul><li>用<code>assign</code>成员函数复制，也可以部分复制</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("catpig"), s2, s3;</span><br><span class="line">s2.assign(s1);</span><br><span class="line">s3.assign(s1,<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">//从s1中下标为1的字符开始复制3个字符给s3</span></span><br></pre></td></tr></table></figure><ul><li>单个字符复制：<code>s2[5] = s1[3] = &#39;a&#39;;</code></li><li>逐个访问string对象中的字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.at(i) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li><p>成员函数<code>at</code>会做范围检查，如果超出范围，会抛出<code>out_of_range</code>异常，而下标运算符不做范围检查</p></li><li><p>用 <code>+</code> 运算符<strong>连接字符串</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("good"), s2("morning");</span><br><span class="line">s1 += s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;</span><br></pre></td></tr></table></figure><ul><li>用成员函数append连接字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1("good"), s2("morning");</span><br><span class="line">s1.append(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;  <span class="comment">//输出goodmorning</span></span><br><span class="line">s2.append(s1,<span class="number">3</span>,s1.<span class="built_in">size</span>());  <span class="comment">//s1.size()返回s1的字符数，</span></span><br><span class="line"><span class="comment">//取下标从3开始，s1.size()个字符，如果字符串内没有足够字符，则复制到字符串的最后一个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2;  <span class="comment">//输出morningd</span></span><br></pre></td></tr></table></figure><ul><li>子串：成员函数<code>substr()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span></span><br><span class="line"><span class="function">s2 </span>= s1.substr(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//从下标4开始5个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：o wor</span></span><br></pre></td></tr></table></figure><h2 id="4-3-比较string"><a href="#4-3-比较string" class="headerlink" title="4.3.比较string"></a>4.3.比较string</h2><ul><li>可以用关系运算符比较string对象的大小，==，&gt;，&gt;=，&lt;，&lt;=，!=，利用字符在字典中的顺序进行比较，且对字母的大小写敏感，返回值都是bool类型，成立返回true，否则返回false。</li></ul><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200225184157.png" style="zoom: 67%;"></p><h2 id="4-4-寻找string中的字符"><a href="#4-4-寻找string中的字符" class="headerlink" title="4.4.寻找string中的字符"></a>4.4.寻找string中的字符</h2><ul><li>成员函数<code>find()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>lo</code>第一次出现的地方，如果找到，返回<code>lo</code>开始的位置，即<code>l</code>所在的位置下标；如果找不到，返回<code>string::nps</code>(<code>string</code>中定义的静态常量)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.<span class="built_in">find</span>(<span class="string">"lo"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>rfind()</code>，如下例在<code>s1</code>中<strong>从后向前查找</strong><code>lo</code>第一次出现的地方，如果找到，返回<code>lo</code>开始的位置，即<code>l</code>所在的位置下标；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.rfind(<span class="string">"lo"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_first_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>abcd</code>中任何一个字符第一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_first_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_last_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找</strong><code>abcd</code>中任何一个字符最后一次出现的地方，如果找到，返回找到字母的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_last_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_first_not_of()</code>，如下例在<code>s1</code>中<strong>从前向后查找不在</strong><code>abcd</code>中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_first_not_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><ul><li>成员函数<code>find_last_not_of()</code>，如下例在<code>s1</code>中<strong>从后向前查找不在</strong><code>abcd</code>中的字符第一次出现的地方，如果找到，返回找到字符的位置；如果找不到，返回<code>string::nps</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">s1.find_last_not_of(<span class="string">"abcd"</span>);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/22/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%A8%A1%E6%9D%BF/QQ图片20200225185829.png" style="zoom:67%;"></p><h2 id="4-5-替换string的字符"><a href="#4-5-替换string的字符" class="headerlink" title="4.5.替换string的字符"></a>4.5.替换string的字符</h2><ul><li>成员函数<code>erase()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">s1.erase(<span class="number">5</span>);  <span class="comment">//去掉下标5及之后的字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.length();  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">size</span>();    <span class="comment">//输出：hello55</span></span><br></pre></td></tr></table></figure><ul><li>成员函数find()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello worlld"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">find</span>(<span class="string">"ll"</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//分别从下标1,2,3开始查找ll，输出：2;2;9</span></span><br></pre></td></tr></table></figure><ul><li>成员函数<code>replace()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">s1.replace(<span class="number">2</span>,<span class="number">3</span>,<span class="string">"haha"</span>);   <span class="comment">//将s1中从下标2开始的3个字符换成"haha"</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;   <span class="comment">//输出hehaha world</span></span><br><span class="line"></span><br><span class="line">s1.replace(<span class="number">2</span>,<span class="number">3</span>,<span class="string">"haha"</span>,<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//将s1中从下标2开始的3个字符换成"haha"中下标1开始的2个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1;   <span class="comment">//输出heha world</span></span><br></pre></td></tr></table></figure><h2 id="4-6-在string中插入字符"><a href="#4-6-在string中插入字符" class="headerlink" title="4.6.在string中插入字符"></a>4.6.在string中插入字符</h2><ul><li>成员函数<code>insert()</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"show insert"</span>)</span></span>;</span><br><span class="line">s1.insert(<span class="number">5</span>,s2);     <span class="comment">//将s2插入s1下标5的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：helloshow insert world</span></span><br><span class="line">s1.insert(<span class="number">2</span>,s2,<span class="number">5</span>,<span class="number">3</span>); <span class="comment">//将s2中下标5开始的3个字符插入s1下标2的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出：heinslloshow insert world</span></span><br></pre></td></tr></table></figure><h2 id="4-7-将string转换成C语言式"><a href="#4-7-将string转换成C语言式" class="headerlink" title="4.7.将string转换成C语言式"></a>4.7.将string转换成C语言式</h2><ul><li>成员函数<code>c_str()</code>，返回传统的<code>const char*</code>类型字符串，且该字符串以’<code>\0</code>‘结尾</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s1.c_str());  <span class="comment">//输出：hello world</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文的内容包括：文件操作，函数模板，类模板，string类
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（10）二叉树的遍历</title>
    <link href="http://nekomoon404.github.io/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://nekomoon404.github.io/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</id>
    <published>2020-02-21T03:42:13.000Z</published>
    <updated>2020-02-22T04:27:41.943Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>遍历：按照某种次序访问树中各节点，每个节点被访问恰好一次。</p><p>$T=V\cup L \cup R=\{root\} \cup L_ subtree(T) \cup R _ subtree(T)$</p></li><li><p>遍历结果  ~  遍历过程  ~  遍历次序  ~ 遍历策略</p><ul><li>先序遍历：<strong>V</strong>  |  L  |  R</li><li>中序遍历：L  |  <strong>V</strong>  |  R</li><li>后序遍历：L  |  R  |  <strong>V</strong></li><li>层次遍历：自上为下，先左后右</li></ul></li></ul><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221115804.png" style="zoom: 80%;"></p><h1 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h1><h2 id="1-1递归"><a href="#1-1递归" class="headerlink" title="1.1递归"></a>1.1递归</h2><p>以上三种典型的遍历策略都不难实现，因为它们的定义本身就是<strong>递归式的</strong>，以先序遍历为例，只需四句就可以实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_R</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（递归版）</span></span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">visit(x-&gt;data);</span><br><span class="line">travPre_R(x-&gt;lc, visit);</span><br><span class="line">travPre_R(x-&gt;rc, visit);</span><br><span class="line">&#125;  <span class="comment">//T(n) = O(1) + T(a) + T(n-a-1) = O(n)</span></span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度是线性的，即$O(n)$，然而这只具有渐近的意义。在实际的运行过程中，因为递归程序的实现机制，并不可能做到针对具体的问题来量体裁衣，而只能采用通用的方法。在运行栈中尽管每一个递归实例都的确只对应于一帧，但是因为它们必须具有通用格式，所以并不能做到足够的小。而针对于具体的问题，只要我们能够进行精巧的设计，完全是可以使得每一帧做到足够小的，尽管从big O的意义上讲，这两种策略所对应的每一帧都可以认为是常数，但是这种常数的差异实际上是非常巨大的。</p><p>因此作为树算法的一个重要基石，遍历算法非常有必要<strong>从递归形式改写为迭代形式</strong>，同时经过这样的改写之后，我们也可以对整个遍历算法的过程以及原理获得更加深刻的认识。稍加观察不难发现此处的两句递归调用都非常类似于<strong>尾递归</strong>，其特征是递归调用出现在整个递归实例体的尾部，这种递归是非常容易化解为迭代形式的，为此我们只需<strong>引入一个栈</strong>。</p><h2 id="1-2-迭代（版本1）"><a href="#1-2-迭代（版本1）" class="headerlink" title="1.2.迭代（版本1）"></a>1.2.迭代（版本1）</h2><p>改写之后的第一个跌打版本，如这段代码所示，作为初始化取一个栈s用以存放树节点的位置，即它们的引用。首先将当前的树根<code>x</code>推入栈中，以下进入一个主体的循环，每一次弹出当前的节点并且随即对它进行访问，此后如果当前这个节点拥有右孩子就将右孩子推入栈中，如果有左孩子 那么左孩子也会随后入栈，此后整个循环又进入下一步迭代直到整个栈变空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#1）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">if</span> (x) S.push(x); <span class="comment">//根节点入栈</span></span><br><span class="line"><span class="keyword">while</span> (!S.empty()) &#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">x = S.pop(); visit(x-&gt;data); <span class="comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span></span><br><span class="line"><span class="keyword">if</span> (HasRChild(*x)) S.push(x-&gt;rc); <span class="keyword">if</span> (HasLChild(*x)) S.push(x-&gt;lc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>左右孩子的入栈次序是先右后左</strong>，这是因为包括先序遍历在内的所有遍历，都先遍历左子树再去遍历右子树，在这个算法模式中既然<strong>每个节点都是在被弹出栈的时刻才接受访问</strong>，所以根据<strong>栈后进先出</strong>的特性，自然应该将希望后出栈的右子树先入栈了。</p><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221164625.png" style="zoom: 50%;"></p><ul><li><p>正确性：</p><ul><li><p>无遗落：每个节点都会被访问到</p><p>归纳假设：若深度为d的节点都能被正确访问到，则深度为d+1的也是</p></li><li><p>根先：对于任一子树，根被访问后才会访问其他节点</p><p>只需注意到：若u是v的真祖先，则u必先于v被访问到</p></li><li><p>左先右后：同一节点的左子树，限于右子树被访问</p></li></ul></li><li><p>效率：$O(n)$</p><ul><li>每步迭代，都有一个节点出栈并被访问；</li><li>每个节点入/出栈一次仅且一次；</li><li>每步迭代只需$O(1)$时间。</li></ul></li></ul><p>可以看到算法所输出的节点序列恰好就是我们所希望得到的先序遍历序列，第一个迭代版算法非常简明，然而遗憾的是这种算法策略并不容易直接推广到此后要研究的中序遍历和后序遍历算法，因此我们或许应该另辟蹊径寻找其它等效的策略。</p><h2 id="1-3-迭代（版本2）"><a href="#1-3-迭代（版本2）" class="headerlink" title="1.3.迭代（版本2）"></a>1.3.迭代（版本2）</h2><p>不妨从一个规模略大同时更具一般性的例子入手：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221165937.png" style="zoom:50%;"></p><p>可以发现这样一个规律：一旦树根节点接过控制权并接受访问，接下来被访问的就是它的左孩子以及左孩子的左孩子，以及同样地，当不能下去的时候才会进行一次新的转移，而每转移到一个具体的局部，做的事情都是尝试着沿着这样的一个左孩子的分支不断地下行。</p><p>对于任何一棵子树，都将起始于树根的接下来总是沿着左侧孩子分支不断下行的这样一条链称作是当前这棵子树的<strong>左侧链</strong>，而这个算法就是沿着这个左侧链逐渐展开。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221170918.png" style="zoom:50%;"></p><ul><li>沿着左侧分支：各节点与其右孩子（可能为空）一一对应；</li><li>从宏观上，整个遍历过程可划分为：<strong>自上而下对左侧分支的访问</strong>，及随后<strong>自下而上对一系列右子树的遍历</strong>；</li><li>不同右子树的遍历相互独立，自成一个子任务。</li></ul><p>新版本的迭代算符首先需要实现一个标准的例程<code>visitAlongLeftBranch</code>，它的任务就是来实现从根节点开始沿着left branch 不断下行，依次访问沿途所有节点的这样一个过程。</p><p>这个主算法则是反复地在每一个局部调用<code>visitAlongLeftBranch</code>这个例程来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongVine</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">visit(x-&gt;data); <span class="comment">//访问当前节点</span></span><br><span class="line">S.push(x-&gt;rc); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line">x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">visitAlongVine(x, visit, S); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line"><span class="keyword">if</span> (S.empty()) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line">x = S.pop(); <span class="comment">//弹出下一子树的树根</span></span><br><span class="line">&#125;  <span class="meta">#pop = #push = #visit = O(n) = 分摊O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之所以使用一个栈而不是队列的用意，依然是因为栈的后进先出的特性，对于左侧链的访问的是自上而下的，存入栈中的右子树也就是自上而下的，而接着对右子树的遍历是自下而上的，对栈来说就是自顶向底的，对栈的一系列依次的<code>pop</code>操作则恰好可以实现栈中右子树的自顶向底的访问。</p><p>下面看一个实例：（^代表空）</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200221172902.png" style="zoom:50%;"></p><h1 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h1><h2 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1.递归"></a>2.1.递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_R</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（递归版）</span></span><br><span class="line"><span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">travIn_R(x-&gt;lc, visit);</span><br><span class="line">visit(x-&gt;data);</span><br><span class="line">travIn_R(x-&gt;rc, visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222093308.png" style="zoom:50%;"></p><p>将递归转换为迭代的难点在于尽管右子树的递归遍历是尾递归，但左子树却严格地不是。解决方法可是是：找到第一个被访问的节点，将其祖先用栈保存，这样原问题就分解为依次对若干棵子树的遍历问题。</p><h2 id="2-2迭代"><a href="#2-2迭代" class="headerlink" title="2.2迭代"></a>2.2迭代</h2><p>同样从一个规模略大同时更具一般性的例子入手：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222093741.png" style="zoom: 33%;"></p><p>与先序遍历非常类似，整个中序遍历过程是从根节点开始，一直沿着左侧分支逐层向下，直到末端不能再向下的那个节点，因此可以将整个中序遍历分解为在不同尺度下的一系列的对左侧分支的逐步处理。我们可以将任何一棵二叉树抽象地规范为如下图所示的形式，整棵树可以分解为一条起自根节点的左侧链以及左侧链上各节点所对应的右孩子。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222094715.png" style="zoom:33%;"></p><p>在一个局部，当前节点$L_{d-1}$将控制权交给并访问它的左孩子$L_d$后，再遍历$L_d$的右子树$T_d$，然后回到并访问节点$L_{d-1}$，再遍历其右子树$T_{d-1}$，如此反复直到遍历全树。在这样的一个过程中存在着某种逆序性，我们最初的起点是在根节点处可是首先接受访问的却是它所对应的左侧链的末端节点，如果说这个的过程是自顶而下的话，那么各节点实际被访问的次序大体而言是呈一种自下而上的过程，因此仍然要使用栈结构来实现这一过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123; S.push(x); x = x-&gt;lChild; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line">Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">goAlongLeftBranch(x, S); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line"><span class="keyword">if</span> (S.empty()) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">x = S.pop();     <span class="comment">//x的左子树或为空，或已遍历（等效于空），故可以</span></span><br><span class="line">visit(x-&gt;data);  <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line">x = x-&gt;rChild;   <span class="comment">//转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222100937.png" style="zoom: 40%;"></p><p>我们知道递归的版本可以简明地实现$O(n)$的复杂度，尽管它的常系数非常之大，那么迭代版本的时间复杂度仍是$O(n)$，但常系数要小的多（分摊分析）。尽管单次调用<code>goAlongLeftBranch</code>就可能需要做$\Omega(n)$次入栈操作需要$\Omega(n)$时间，但这些左侧链的长度加起来也不过是n，因此迭代算法的复杂度仍是线性的，即$O(n)$。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222101806.png" style="zoom: 50%;"></p><p>此外还要其他版本的中序遍历的迭代实现，如版本2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( x ) &#123;</span><br><span class="line">         S.push ( x ); <span class="comment">//根节点进栈</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !S.empty() ) &#123;</span><br><span class="line">         x = S.pop(); <span class="comment">//尚未访问的最低祖先节点退栈</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该祖先节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//遍历祖先的右子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//遍历完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从左子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本4：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I4</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历（迭代版#4，无需栈或标志位）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) <span class="comment">//若有左子树，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问当前节点，并</span></span><br><span class="line">         <span class="keyword">while</span> ( !HasRChild ( *x ) ) <span class="comment">//不断地在无右分支处</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">return</span>; <span class="comment">//回溯至直接后继（在没有后继的末节点处，直接退出）</span></span><br><span class="line">            <span class="keyword">else</span> visit ( x-&gt;data ); <span class="comment">//访问新的当前节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//（直至有右分支处）转向非空的右子树</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-层次遍历"><a href="#3-层次遍历" class="headerlink" title="3.层次遍历"></a>3.层次遍历</h1><p>我们此前讨论的有根有序树，任何一棵二叉树都被指定了一个特殊的节点：根节点，由此就可以在垂直方向按照深度将所有节点划分为若干个等价类，因此可以认为所谓的<strong>有根性对应的就是垂直方向的次序。</strong></p><p>进一步地位于同一深度也属于同一等价类内部的所有节点，即所有的同辈节点也可以分出次序，比如对于二叉树可以通过左右的明确定义给出同辈节点之间的相对次序，因此可以认为<strong>有序给出沿水平方向的一个次序</strong>。</p><p>因此按照垂直方向和水平方向的次序可以在所有的节点之间定义一个整体的次序，并进而对它进行遍历。自高向低而在每一层自左向右逐一地访问树中的每一个节点的遍历策略及过程就是<strong>层次遍历</strong>。</p><p>此前的三种遍历策略：先序、中序和后序都无法保证所有节点严格地按照深度次序访问，都有后代限于祖先被访问的情况，即逆序，为此需要借助栈结构。反过来，在层次遍历中，所有节点的访问都满足顺序性，因此这里就需要借助与栈结构对称的<strong>队列结构</strong>。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222102518.png" style="zoom:50%;"></p><p>具体实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line">   Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line">   Q.enqueue ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">      BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lChild ); <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rChild ); <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个实例：</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222110506.png" style="zoom:50%;"></p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222110653.png" style="zoom:45%;"></p><h1 id="4-重构"><a href="#4-重构" class="headerlink" title="4.重构"></a>4.重构</h1><p>由任何一棵二叉树我们都可以导出三个序列：先序(preorder)、中序(inorder)和后序(postorder)遍历序列，这三个序列的长度相同，它们都是由树中的所有节点依照对应的遍历策略所确定的次序依次排列而成。那么如果我们已知某棵树的遍历序列，是否可以还原出这棵树的拓扑结构？什么情况下可以？什么情况下不可以？如果可以具体又应该使用什么样的方法？</p><p>关于二叉树重构的第一个结论是：<strong>只需中序遍历序列再加上先序与后序遍历序列之一</strong>，即可还原二叉树的完整拓扑结构。</p><p>用<strong>数学归纳</strong>来证明：假设对于规模小于大N的所有二叉树这个规律都是成立的，接下来考察规模恰好为N的二叉树。在先序遍历序列中可以地将左子树和右子树所对应的遍历子序列切分开。这样就将原来全树的重构问题化解为两棵子树的重构问题，这两棵子树在规模上都符合归纳假设，即它们都严格地小于大N，因此根据归纳假设无论是左子树还是右子树都可以重构出来。</p><p>当然你应该不难写出一个递归式的重构算法，需要特别注意的是无论是左子树还是右子树，都有可能是空树，在这种情况下树的规模应该是零。而<strong>不借助中序遍历序列</strong>而只凭借先序和后序遍历序列，是不能保证完成对左右子树的正确切分的。因为无论是L还是R都有可能是空树，在先序遍历或者后序遍历的表达中<strong>会出现歧义</strong>，我们无法根据先序遍历序列以及后序遍历序列来区分在这种情况下除去根节点之后的部分究竟是左子树还是右子树。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222115137.png" style="zoom: 60%;"></p><p><strong>在某些特定情况下</strong>由先序和后序遍历序列也可以还原树的整体结构。比如对于<strong>真二叉树</strong>，每个节点的度数都必须是偶数，即0度或2度，此时的左子树和右子树要么同时为空要么同时非空。</p><p>在任何给定的先序遍历序列中都可以找到其左子树L，进而在后序遍历序列中对它进行定位，而这个节点在它所属的这棵子树的后序遍历子序列中必然垫后，这就意味着我们可以明确地界定左右子树的范围，即左子树由哪些节点构成以及右子树由哪些节点构成都是可以确定的。</p><p>当然对称地在后序遍历序列中，右子树的树根位置也是确定的，因此通过右子树的树根节点依然可以反过来在先序遍历序列中进行定位，而且同样地可以确定左右子树的切分位置。也就是说我们在这里<br>确实可以进行分而治之从而通过递归的形式，完整地重构出一棵真二叉树原本的结构。</p><p><img src="/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/QQ图片20200222122643.png" style="zoom: 60%;"></p>]]></content>
    
    <summary type="html">
    
      二叉树的相关算法也往往需要对其中的元素按照某种次序来逐一访问，本文要介绍的遍历就是按照某种原则在二叉树的所有节点之间定义某种明确的线性次序，从而将半线性结构转换为我们已熟悉的线性结构的问题。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（11）虚函数和多态</title>
    <link href="http://nekomoon404.github.io/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://nekomoon404.github.io/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</id>
    <published>2020-02-20T10:03:49.000Z</published>
    <updated>2020-02-22T08:31:46.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><h2 id="1-1-虚函数"><a href="#1-1-虚函数" class="headerlink" title="1.1.虚函数"></a>1.1.虚函数</h2><ul><li>在类的定义中，前面有virtual 关键字的成员函数就是虚函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> base::<span class="built_in">get</span>() &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>virtual 关键字只用在类定义里的函数声明中，写函数体时不用。</li><li>构造函数和静态成员函数不能是虚函数。</li><li>虚函数和普通函数的本质区别在于虚函数可以参与多态，而普通成员函数不能。</li><li>派生类中和基类中虚函数同名同参数表的函数，不加<code>virtual</code>也自动成为虚函数。</li></ul><h2 id="1-2-多态的表现形式一"><a href="#1-2-多态的表现形式一" class="headerlink" title="1.2.多态的表现形式一"></a>1.2.多态的表现形式一</h2><ul><li>派生类的指针可以赋给基类<strong>指针</strong>。</li><li>通过基类指针调用基类和派生类中的同名虚函数时：<ul><li>若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li><li>若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul></li><li>这种机制就叫作<strong>多态</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hi"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Woof!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal *pa)</span> </span>&#123; pa-&gt;sayHi(); &#125;  <span class="comment">// 使用基类指针调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Animal a; Dog d;</span><br><span class="line">func(&amp;a);  <span class="comment">// 指向基类对象，则输出 Hi</span></span><br><span class="line">func(&amp;d);  <span class="comment">// 指向派生类对象，则输出 Woof!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-多态的表现形式二"><a href="#1-3-多态的表现形式二" class="headerlink" title="1.3.多态的表现形式二"></a>1.3.多态的表现形式二</h2><ul><li>派生类的指针可以赋给基类<strong>引用</strong>。</li><li>通过基类引用调用基类和派生类中的同名虚函数时：<ul><li>若该引用引用的是一个基类的对象，那么被调用的是基类的虚函数；</li><li>若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul></li></ul><h1 id="2-多态程序实例"><a href="#2-多态程序实例" class="headerlink" title="2.多态程序实例"></a>2.多态程序实例</h1><h2 id="2-1-例1几何形体处理程序"><a href="#2-1-例1几何形体处理程序" class="headerlink" title="2.1.例1几何形体处理程序"></a>2.1.例1几何形体处理程序</h2><p>几何形体处理程序：输入若干个几何形体的参数，要求按面积排序输出。输出时要指明形状。</p><p><strong>输入Input</strong>：第一行是几何形体数目n（不超过100），下面有n行，每行以一个字母c开头</p><p>若 c 是 ‘R’，则代表一个矩形，本行后面跟着两个整数，分别是矩形的宽和高；</p><p>若 c 是 ‘C’，则代表一个圆，本行后面跟着一个整数代表其半径；</p><p>若 c 是 ‘T’，则代表一个三角形，本行后面跟着三个整数，代表三条边的长度。</p><p><strong>输出Output</strong>：按面积从小到大依次输出每个几何形体的种类及面积，每行一个几何形体，输出格式为：形体名称：面积</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221210752.png" style="zoom:67%;"></p><p>类的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span><span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各成员函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Rectangle::Area() &#123;</span><br><span class="line"><span class="keyword">return</span> w * h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Rectangle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Circle::Area() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Circle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Triangle::Area() &#123;</span><br><span class="line"><span class="keyword">double</span> p = (a + b + c) / <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(p*(p - a)*(p - b)*(p - c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Triangle::PrintInfo() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle: "</span> &lt;&lt; Area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个指向<code>Shape</code>基类的指针数组<code>pShapes</code>来存放各个几何形体，数组中的每一个元素都是基类指针，因此它可以指向不同派生类的对象。<code>MyCompare</code>函数比较两个几何形体面积的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shape * pShapes[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyCompare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * s1, <span class="keyword">const</span> <span class="keyword">void</span> * s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> a1, a2;</span><br><span class="line">Shape **p1;         <span class="comment">//s1,s2是void*，不可写 *s1 来取得s1指向的内容</span></span><br><span class="line">Shape **p2;</span><br><span class="line">p1 = (Shape**)s1;   <span class="comment">//s1,s2指向Shapes数组中的元素，数组元素的类型是Shape*</span></span><br><span class="line">p2 = (Shape**)s2;   <span class="comment">//故p1,p2都是指向指针的指针，类型为Shae**</span></span><br><span class="line">a1 = (*p1)-&gt;Area(); <span class="comment">//*p1的类型是Shape*，是基类指针，故此句为多态</span></span><br><span class="line">a2 = (*p2)-&gt;Area();</span><br><span class="line"><span class="keyword">if</span> (a1 &lt; a2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a2 &lt; a1)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">int</span> n;</span><br><span class="line">Rectangle *pr;  Circle *pc;  Triangle *pt;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>R<span class="number">'</span>:</span><br><span class="line">pr = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pr-&gt;w &gt;&gt; pr-&gt;h;</span><br><span class="line">pShapes[i] = pr;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>C<span class="number">'</span>:</span><br><span class="line">pc = <span class="keyword">new</span> Circle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pc-&gt;r ;</span><br><span class="line">pShapes[i] = pc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">'</span>T<span class="number">'</span>:</span><br><span class="line">pt = <span class="keyword">new</span> Triangle();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pt-&gt;a &gt;&gt; pt-&gt;b &gt;&gt; pt-&gt;c;</span><br><span class="line">pShapes[i] = pt;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(pShapes, n, <span class="keyword">sizeof</span>(Shape*), MyCompare); <span class="comment">//按指针指向的几何形体的面积从小到大排序</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">pShapes[i]-&gt;PrintInfo();  <span class="comment">//多态，根据pShapes[i]指向的对象调用其对应的成员函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用多态来实现这个问题所带来的好处就是<strong>提高了程序的可扩充性</strong>，如果要添加新的几何形体如五边形，则只需要从Shape里派生出<code>Pentagon</code>，以及在<code>main</code>函数中的<code>swtich</code>语句中增加一个<code>case</code>，其余部分不变。</p><ul><li>用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，是很常见的做法。</li></ul><h2 id="2-2-例2"><a href="#2-2-例2" class="headerlink" title="2.2.例2"></a>2.2.例2</h2><p>再看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; fun2(); &#125; <span class="comment">//等价于 this-&gt;fun2，fun2是虚函数，所以这句是多态</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::fun2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base * pBase = &amp;d;</span><br><span class="line">pBase-&gt;fun1();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序运行的结果是<code>Derived::fun2()</code>，而不是<code>Base::fun2()</code>。这是因为<code>pBase-&gt;fun1</code>指至<code>pbase</code>是指向一个派生类的对象<code>d</code>的，那进到<code>fun1</code>里面，<code>this</code>指针指向的东西自然也就是这个<code>d</code>，所以此时<code>this</code>指针指向的是一个派生类的对象，那么根据多态的原则这条语句就会调用派生类的<code>fun2</code>，也就是<code>Derieved</code>类的<code>fun2</code>，所以会输出<code>Derieved</code>的<code>fun2</code>，即<code>Derived::fun2()</code>。</p><p>成员函数中调用虚函数有这样的规则：</p><ul><li><p><strong>在非构造函数，非析构函数的成员函数中调用虚函数，是多态</strong>。</p></li><li><p><strong>在构造函数和析构函数中调用虚函数，不是多态</strong>。编译时即可确定，调用的函数是自己的类或基类中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from myclass"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from myclass"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> :</span><span class="keyword">public</span> myclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类中和基类中虚函数同名同参数表的函数，不加`virtual`也自动成为虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">son() &#123; hello(); &#125;;</span><br><span class="line">~son() &#123; bye(); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">grandson gson;</span><br><span class="line">son *pson;</span><br><span class="line">pson = &amp;gson;</span><br><span class="line">pson-&gt;hello();  <span class="comment">//多态</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221223531.png" style="zoom:80%;"></p><h1 id="3-多态实现原理"><a href="#3-多态实现原理" class="headerlink" title="3.多态实现原理"></a>3.多态实现原理</h1><p>“多态”的关键在于通过基类指针或引用调用一个虚函数时，编译时不确定到底调用的是基类还是派生类的函数，运行时才确定——这叫“<strong>动态联编</strong>”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base:Print"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived:Print"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Base) &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="keyword">sizeof</span>(Derived);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出结果为：8,12。那么为什么这个对象的大小都多出了4个字节呢？</p><p><strong>多态实现的关键——虚函数表</strong>：</p><p>每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。虚函数表中列出了该类的虚函数地址，多出来的4个字节就是用来放虚函数表的地址的。</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221230451.png" style="zoom:67%;"></p><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200221230814.png" style="zoom:60%;"></p><p>多态在提高程序可扩充性时也会有一定的代价：多态程序在运行期间会有额外的时间和空间上的开销，即时间上编译时会查询虚函数表，空间上每个有虚函数的类的对象里都会多出4个字节来存放虚函数表的地址。</p><h1 id="4-虚析构函数"><a href="#4-虚析构函数" class="headerlink" title="4.虚析构函数"></a>4.虚析构函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~son() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">son *pson;</span><br><span class="line">pson = <span class="keyword">new</span> grandson;</span><br><span class="line"><span class="keyword">delete</span> pson;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序运行会输出<code>bye from son</code>，<code>pson</code>这个基类的指针指向了派生类的对象，当<code>delete pson</code>后会引起一些问题，直观上看因为<code>delete</code>掉的是一个基类的指针，所以会去调用基类的析构函数。但是逻辑上讲这个指针本身又指向的是一个派生类的对象，那么分配的也是一个派生类对应的这样的一个内存空间，那么这时它应该调用的还有派生类的析构函数，但是目前的程序设计角度上来看编译器是不会知道它需要调用派生类的机构函数的，这样可能导致一些问题。</p><p>我们希望做的是：</p><ul><li>通过基类的指针删除一个派生类的对象时，先调用派生类的析构函数，再调用基类的析构函数。</li></ul><p>解决方法是：</p><ul><li>把基类的析构函数声明为<code>virtual</code>，派生类的析构函数virtual可以不进行声明。</li><li>类如果定义了虚函数，则最好将析构函数也定义成虚函数。</li><li>注意：不允许以虚函数作为构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~son() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from son"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">grandson</span> :</span><span class="keyword">public</span> son &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~grandson() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"bye from grandson"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">son *pson;</span><br><span class="line">pson = <span class="keyword">new</span> grandson;</span><br><span class="line"><span class="keyword">delete</span> pson;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/20/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/QQ图片20200222161223.png" style="zoom:80%;"></p><h1 id="5-纯虚函数和抽象类"><a href="#5-纯虚函数和抽象类" class="headerlink" title="5.纯虚函数和抽象类"></a>5.纯虚函数和抽象类</h1><ul><li>纯虚函数：没有函数体的虚函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;   <span class="comment">//错误，A是抽象类，不能创建对象</span></span><br><span class="line">    A *pa; <span class="comment">//正确，可以定义抽象类的指针和引用</span></span><br><span class="line">    pa = <span class="keyword">new</span> A; <span class="comment">//错误，A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>抽象类：包含纯虚函数的类</p><ul><li>抽象类只能作为基类来派生新类使用；</li><li>不能创建抽象类的对象；</li><li>抽象类的指针和引用 $\to$ 由抽象类派生出来的类的对象。</li></ul></li><li><p>在抽象类中：</p><ul><li>在成员函数内可以调用纯需函数；</li><li>在构造函数/析构函数内部不能调用纯虚函数</li></ul></li><li>如果一个类从抽象类派生而来 $\to$ 它实现了基类中的所有纯需函数，才能成为非抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123; <span class="keyword">this</span>-&gt;f(); &#125;   <span class="comment">//ok</span></span><br><span class="line">    A() &#123; f();&#125;  <span class="comment">//错误</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B:f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;  <span class="comment">//将虚函数“实例化”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.g();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>B:f()</code></p>]]></content>
    
    <summary type="html">
    
      多态提供了一种根据指针/引用指向的对象类型来决定调用的函数的机制，通过虚函数来实现。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（9）二叉树</title>
    <link href="http://nekomoon404.github.io/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://nekomoon404.github.io/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-02-20T01:11:42.000Z</published>
    <updated>2020-02-21T03:31:16.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h1><p>回顾之前所学的向量结构（Vector）和列表结构（List），对于以查找为代表的静态操作和以插入为代表的动态操作，两者都无法兼顾静态和动态的高效性。而本章要介绍的树结构恰好能将二者的优势结合起来，即可快速查找，又可以快速插入和删除。树可以理解为列表的列表，或二维的列表。树并不是严格意义上的线性结构，但又带有一定的线性特征，因此树可以被称为半线性结构。</p><p>树是用来按照<strong>层次关系</strong>组织一系列数据项的一种方式，如：表达式、文件系统、函数调用和递归过程、Internet URL等等。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220093704.png" style="zoom:50%;"></p><h2 id="1-1-有根树"><a href="#1-1-有根树" class="headerlink" title="1.1.有根树"></a>1.1.有根树</h2><ul><li><p>树是特殊的图<strong>T = ( V, E)</strong>，可以认为树是定义在一组元素之间的二元关系，节点（<strong>Vertex</strong>）数 <strong>|V| = n</strong>，边（<strong>edge</strong>）数 <strong>|E| = e</strong>。</p></li><li><p>为树指定任一节点 r $\in$ V作为根后，树T 即称作<strong>有根树（rooted tree）</strong>。</p></li></ul><p>对于任何一组有根树都可以通过引入一个新的顶点，并且在新的这个顶点与此前各棵有根树的树根之间引入对应的一条连边，从而构成一棵规模更大的有根树，这棵新的有根树的树根就是所引入的这个新的节点，通常记作r，暗示着它就是root树根。而对于这棵更大的树，参与组成它的每一棵有根树都相对地称作是它的<strong>子树subtree</strong>。</p><ul><li>若：$T_1,T_2,\dots ,T_d$是有根树，则：$T=\left( (\cup V_i)\cup\{r\},\,(\cup E_i)\cup\{<r,r_i>|1\le i\le d\}  \right)$也是有根树。</r,r_i></li><li>相对于$T$，$T_i$称作以$r_i$为根的子树（subtree rooted at $r_i$），记作$T_i$ = subtree( $r_i$ )。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220095521.png" style="zoom: 40%;"></p><h2 id="1-2-有序树"><a href="#1-2-有序树" class="headerlink" title="1.2.有序树"></a>1.2.有序树</h2><ul><li><p>$r_i$称作$r$的<strong>孩子（child）</strong>，$r_i$之间互称<strong>兄弟（sibling）</strong>；</p><p>$r$为其<strong>父亲（parent）</strong>，d = degree( r )为$r$的（出）<strong>度</strong>（degree）。</p></li><li><p>可归纳证明： e（节点数总和）= $\sum_{r\in V}degree(r)$ = n - 1 = $\Theta(n)$，即任何<strong>一棵树中的边数与其中顶点的数目是同阶的</strong>，一棵树的总体规模也可度量为( n + e )，故在衡量相关复杂度时，可以n作为参照。</p></li><li>若指定$T_i$为$T$的第$i$棵子树，$r_i$作为$r$的第$i$个孩子（即在兄弟间定义了次序），则$T$称作<strong>有序树（ordered tree）</strong>。</li></ul><h2 id="1-3-连通与无环"><a href="#1-3-连通与无环" class="headerlink" title="1.3.连通与无环"></a>1.3.连通与无环</h2><p>上面从递归嵌套的角度定义了树，但我们并没有看到树结构相对于一般的图结构而言在拓扑上到底有什么不同。那么接下来将从<strong>连通性</strong>和<strong>无环性</strong>两个角度来揭示树结构的特性。</p><ul><li><p>V中的k+1个节点，通过E中的k条边依次相连，构成一条<strong>路径（path）</strong>：</p><p>$\pi=\{ \, (V_0,V_1),\, (V_1,V_2),\,\dots,\,(V_{k-1},V_k)\,    \}$</p></li><li><p><strong>路径长度</strong>：$|\pi|=$边数$=k$</p></li><li><p>任意节点之间均有路径的图，称作<strong>连通图（connected graph）</strong></p><p>若$V_k=V_0$，则该路径是<strong>环路（cycle/loop）</strong>，不含环路的图，称作<strong>无环图（acyclic graph）</strong>。</p></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220101809.png" style="zoom:40%;"></p><ul><li>树结构是<strong>无环连通图</strong>，即是极小连通图，也是极大无环图。</li><li>故在树中，<strong>任一节点V与根之间存在唯一路径</strong>，故可记 path(v, r) = path(v)</li><li>因此可以|path(v)|为指标，对所有节点做等价类划分。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220102245.png" style="zoom:50%;"></p><h2 id="1-4-深度与层次"><a href="#1-4-深度与层次" class="headerlink" title="1.4.深度与层次"></a>1.4.深度与层次</h2><ul><li>在不致歧义的情况下，路径、节点和子树可相互指代： path(v) ~ v ~ subtree(v)</li><li>v的<strong>深度</strong>：depth(v) = |path(v)|</li><li>path(v)上的节点均为v的<strong>祖先（ancestor）</strong>，v是它们的<strong>后代（descendent）</strong>；除v自身以外的祖先，是<strong>真</strong>（proper）祖先。</li><li><strong>在任一深度：v的祖先若存在则必然唯一；v的后代未必唯一</strong>。从这个意义上讲也应该将数称为半线性结构。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220103816.png" style="zoom:40%;"></p><ul><li>根节点是所有节点的（公共）祖先，深度为0；没有后代的节点称作叶子（leaf）。</li><li>所有叶子深度中的最大者称为子树的高度：height(v) = height( subtree( v ) )；注意与树根的高度（height(T))区分开。</li><li>特别低，只有一个节点的树的高度为1，空树的高度为-1。</li><li>depth( v )  +  height( v )  $\le$  height( T )</li></ul><h1 id="2-树的表示"><a href="#2-树的表示" class="headerlink" title="2.树的表示"></a>2.树的表示</h1><p>上一节介绍了树的基本概念，这一节将来讨论在计算机中如何从逻辑上来表示一棵树，从抽象数据类型的角度来看树结构应该提供大致如下这些接口：</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220105128.png" style="zoom:40%;"></p><h2 id="2-1-父节点"><a href="#2-1-父节点" class="headerlink" title="2.1.父节点"></a>2.1.父节点</h2><ul><li>除根外，任一节点有且仅有一个父节点。</li></ul><p>不妨将所有的节点组织为一个序列：其中的每一个元素都分别包括三项，data是节点本身的信息，rank或者position指明的是这个节点的记录在这个序列中所对应的秩或者是位置，而parent恰好就是节点唯一的父节点所对应的秩或者是位置。树根也有一个“虚构的”父节点-1或NULL。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220110308.png" style="zoom:40%;"></p><ul><li>空间性能：$O(n)$</li><li>时间性能：<ul><li>​          <code>parent()</code>：$O(1)$</li><li>​              <code>root()</code>：$O(n)$或$O(1)$</li><li><code>firstChild()</code>：$O(n)$</li><li><code>nextSibling()</code>：$O(n)$</li></ul></li></ul><p>这样做有一定的好处，不幸的是如果要向下索取某个节点的后代比如长子，依然需要去遍历所有的元素并且逐一地确认它的父节点是否就是当前查询的元素，这个基本操作在最坏情况下需要线性时间$O(n)$；而查找兄弟节点也是类似的在最坏情况下需要遍历整棵树。因此我们下一步改进自然就集中在这两种向下方向的查询上。</p><h2 id="2-2-孩子节点"><a href="#2-2-孩子节点" class="headerlink" title="2.2.孩子节点"></a>2.2.孩子节点</h2><p>不妨对于任何一个节点都将它的孩子汇聚起来构成一个更小的数据集，为<strong>每一个节点准备一个名为children的引用，所指向的是由它的所有的孩子构成的一个序列</strong>，如使用<strong>列表</strong>来实现这个序列，列表的长度分别等于对应节点当前的度数。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220111335.png" style="zoom: 50%;"></p><p>这个方法解决了向下的查找问题，而向上的查找优势却丧失殆尽，不难发现为了查找某一个节点的父亲不得不去遍历整个线性序列，并且逐一地翻看它所对应的孩子记录，在最坏的情况下仍需要线性时间$O(n)$。</p><h2 id="2-3-父节点-孩子节点"><a href="#2-3-父节点-孩子节点" class="headerlink" title="2.3.父节点+孩子节点"></a>2.3.父节点+孩子节点</h2><p>如果将刚才的两个线性的序列组合起来，即对于同一个节点不仅保留它的parent域，同时还要保留它的children这样的一个引用，那么刚才两个方向的优势是可以兼而有之的。如果要去查找父亲就在parent这一列中进行查找，需要$O(1)$的时间；如果要是去查找孩子，就在children所指向的序列中再去查找，若是长子就可在$O(1)$的时间内直接返回，若是其它的孩子最多是去遍历序列。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220112749.png" style="zoom:50%;"></p><p>但这种方法仍有一些不足：每一个节点的children引用所指向的序列在规模上有可能相差极其悬殊，每一个序列的长度恰好是节点对应的出度，而出度的总和为$\sum_{r\in V}degree(r)$ = n - 1 = $\Theta(n)$，与n同阶。而这种组织方式有时需要长达$O(n)$的一个数据集，为此需要找到一些新的办法，更加规范并相应也更简洁和高效。</p><h2 id="2-4-长子-兄弟"><a href="#2-4-长子-兄弟" class="headerlink" title="2.4.长子+兄弟"></a>2.4.长子+兄弟</h2><p>反观上小节方法存在根源在于每一个节点的出度是不尽相同的，为进行改进我们必须发现每个节点所具有的某种不变性。就向下的引用而言每一个节点只需记两个信息就够了，第一个就是它的长子，第二个是每一个节点的下一个兄弟。</p><ul><li>每个节点均设两个引用：<ul><li>纵向：<code>firstChild()</code></li><li>横向：<code>nextSibling()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220113446.png" style="zoom:50%;"></p><ul><li>如此，对于度数为d的节点，可在$O(n+1)$时间内遍历其所有孩子</li><li>若再设置parent引用，则<code>parent()</code>接口也仅需$O(1)$时间</li></ul><p>相对于此前的表示方法，这种表示方法的规整性非常的突出，由于每个节点只需记录两个引用，因此其点所需要占用的空间依然是常数，，而且都彼此接近，这是此前的常规方法所无法比拟的。</p><p>这种长子兄弟法不仅是树的一种很好的表示方法，而且也是对树的本质的一种更深刻的理解，在此后介绍二叉树<br>并且用二叉树来代表所有的树的时候，我们将再次用到这样一种表示方法。对于树这样的一个全集来说尽管二叉树只是它的一个特殊的子集，但是很有趣的是在施加了某些条件之后，二叉树却足以来表示和实现所有的树，而这样一种方法背后的原理在很大程度上就是基于长子兄弟法。</p><h1 id="3-二叉树"><a href="#3-二叉树" class="headerlink" title="3.二叉树"></a>3.二叉树</h1><p>这一节介绍树的一种特殊但又不失代表性的特例：二叉树（binary tree）</p><ul><li><p><strong>节点数不超过2</strong>的树，称作二叉树</p></li><li><p>同一节点的孩子和子树，均以左、右区分（隐含着有序性）</p><ul><li><code>lChild()</code>  ~  <code>lSubtree()</code></li><li><code>rChild()</code>  ~  <code>rSubtree()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115144.png" style="zoom:40%;"></p><h2 id="3-1-基数"><a href="#3-1-基数" class="headerlink" title="3.1.基数"></a>3.1.基数</h2><ul><li>二叉树中深度为k的节点至多$2^k$个</li><li>含n个节点、高度为h的二叉树中有：$h&lt;n&lt;2^{h+1}$<ul><li>当 $n=h+1$时，退化为一条单链</li><li>当$n=2^{h+1}-1$时，称作满二叉树（full binary tree）</li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115551.png" style="zoom:40%;"></p><p>由此也可见一棵二叉树在横向上的宽度与它在纵向上的高度是呈一个指数的关系的，宽度是高度的指数，而指数意味着爆炸（剧烈的增长），所以如果节点的总数固定，宽度大致与它相当，但是高度却会增长的非常的缓慢呈一个对数的形式。也就是说对于一棵二叉树而言，它非常倾向于“涨宽”，它“涨宽”的速度更快，而它的高度呢如果控制得当的话会增长的异常的缓慢，这个特点也是之后介绍的二叉搜索树的重要理论基础。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220115646.png" style="zoom:40%;"></p><h2 id="3-2-真二叉树"><a href="#3-2-真二叉树" class="headerlink" title="3.2.真二叉树"></a>3.2.真二叉树</h2><p>上面介绍的二叉树只对每个节点的出度做了个上限的约定，即不得超过2。这样一般性的一棵二叉树在很多操作，包括算法的实现以及对算法的理解上都会引来一些不必要的麻烦。而反过来一个比较有效的改进方法就是将任何的这样一棵一般性的二叉树转化为一棵<strong>真二叉树（proper binary tree）</strong>。</p><ul><li>通过引入$n_0+n_2$个外部节点，可是原有节点度数同一为2，如此即可将任一二叉树转化为真二叉树。</li><li>经过转换之后，从渐进意义上，全树自身的<strong>复杂度并未实质增加</strong>。</li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220120456.png" style="zoom:40%;"></p><p>在之后实现相应的算法的时候就会看到这种添加实际上完全是假想的，即并不需要真正去引入节点，只需要假想着它们存在，你的算法就可以更加简洁的实现而且更加简洁的被理解。</p><h2 id="3-3-描述多叉树"><a href="#3-3-描述多叉树" class="headerlink" title="3.3.描述多叉树"></a>3.3.描述多叉树</h2><p>接下来来介绍这一节最重要的一点：<strong>如何通过二叉树来描述多叉树</strong>。其实上需要的条件只有两条：<strong>有根</strong>和<strong>有序</strong>。</p><ul><li>二叉树是多叉树的特例，但在<strong>有根</strong>且<strong>有序</strong>时其描述能力却足以覆盖后者；</li><li>即任意有根有序的多叉树均可转换为二叉树——回顾“长子-兄弟”表示法；</li><li>为此只需将节点处旋转45度，将长子，兄弟与左、右孩子等效地相互对应：<ul><li><code>firstChild()</code>       ~    <code>lChild()</code></li><li><code>nextSibling()</code>    ~   <code>rChild()</code></li></ul></li></ul><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220121855.png" style="zoom: 80%;"></p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200220121900.png" style="zoom:67%;"></p><p>如果说这一章的任务是描述并且实现以及利用树结构的话，不如说我们只需研究并且实现二叉树。接下来几节将介绍二叉树结构的实现和相关的算法。</p><h1 id="4-二叉树实现"><a href="#4-二叉树实现" class="headerlink" title="4.二叉树实现"></a>4.二叉树实现</h1><p>在此前的几节先后介绍了树的概念，了解了树的特点，并且懂得了如何来表示一棵树。最重要的方法就是借助二叉树来表示任何一棵有根有序树，所以接着就来介绍如何在C++语言中实现一棵二叉树。</p><h2 id="4-1-BinNode模板类"><a href="#4-1-BinNode模板类" class="headerlink" title="4.1.BinNode模板类"></a>4.1.BinNode模板类</h2><p>二叉树的基本组成单位是<strong>二叉树节点（Binary Node， 或简称BinNode）</strong>，每一个BinNode的逻辑组成可以用下图来表示。每一个BinNode节点首先应该有一个data域，记录它携带的信息，这是BinNode节点的核心的要素；它也应该配备相应的引用域，分别指向左右孩子以及父亲；此外作为在树中的一个特定元素它也需要记录一些重要的指标，比如height 高度，对于红黑树而言就会有颜色的区别，对于左式堆而言有npl指标，所以也需要为它们留有余地。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221100854.png" style="zoom: 67%;"></p><p>下面定义名为<code>BinNode</code>的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BinNodePosi(T) BinNode<span class="meta-string">&lt;T&gt;* //节点位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span> &#123;</span> <span class="comment">//二叉树节点模板类</span></span><br><span class="line">    </span><br><span class="line">BinNodePosi(T) parent, lChild, rChild; <span class="comment">//父节点及左、右孩子</span></span><br><span class="line">T data; <span class="keyword">int</span> <span class="built_in">height</span>; <span class="comment">//数据，/高度（通用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">   BinNode() :</span><br><span class="line">      parent ( <span class="literal">NULL</span> ), lc ( <span class="literal">NULL</span> ), rc ( <span class="literal">NULL</span> ), <span class="built_in">height</span> ( <span class="number">0</span> ), npl ( <span class="number">1</span> ), color ( RB_RED ) &#123; &#125;</span><br><span class="line">   BinNode ( T e, BinNodePosi(T) p = <span class="literal">NULL</span>, BinNodePosi(T) lc = <span class="literal">NULL</span>, BinNodePosi(T) rc = <span class="literal">NULL</span>,</span><br><span class="line">             <span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> l = <span class="number">1</span>, RBColor c = RB_RED ) :</span><br><span class="line">      data ( e ), parent ( p ), lc ( lc ), rc ( rc ), <span class="built_in">height</span> ( h ), npl ( l ), color ( c ) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//统计当前节点后代总数，亦即以其为根的子树的规模</span></span><br><span class="line">BinNodePosi(T) insertAsLC(T <span class="keyword">const</span>&amp;); <span class="comment">//作为当前节点的左孩子插入新节点</span></span><br><span class="line">BinNodePosi(T) insertAsRC(T <span class="keyword">const</span>&amp;); <span class="comment">//作为当前节点的右孩子插入新节点</span></span><br><span class="line">BinNodePosi(T) succ(); <span class="comment">//取当前节点的直接后继</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树层次遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树先序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//子树后序遍历</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-BinNode接口实现"><a href="#4-2-BinNode接口实现" class="headerlink" title="4.2.BinNode接口实现"></a>4.2.BinNode接口实现</h2><p>这一小节介绍<code>BinNode</code>类的几个常用接口，首先是<code>insertAsLC</code>接口，我们要对传入的参数e进行封装<br>使之成为一个新的节点，并且将它作为当前节点的左孩子接入所属的这棵树中。当然作为入口条件可以假设当前节点的左孩子现在是空的。</p><p>这个功能的实现方法是：通过<code>BinNode</code>构造函数创建一个新的<code>BinNode</code>节点，而它的父节点就是<code>this</code>即当前这个节点。从下面的图来看，这一步就相当于将新的<code>BinNode</code>节点的<code>parent</code>引用指向当前的这个节点。这只是自下而上一个方向的连接，为了保证整体的一致性我们还需要相应地完成自上而下的连接，也就是令当前这个节点<code>this</code>的左孩子引用<code>lChild</code>能够指向新创建的节点，这一步可以通过直接用这个新生成的节点赋予当前节点的<code>lChild</code>引用来实现。</p><p><code>insertAsRC</code>接口实现的方式完全对称，只需相应地将左孩子引用替换为右孩子引用。两个插入操作的复杂度均为$O(1)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsLC(T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> lc = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="comment">//将e作为当前节点的左孩子插入二叉树,  O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::insertAsRC(T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> rc = <span class="keyword">new</span> BinNode(e, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="comment">//将e作为当前节点的右孩子插入二叉树,  O(1)</span></span><br></pre></td></tr></table></figure><p><code>BinNode</code>的<code>size()</code>接口，返回包括当前节点在内所有后代的总数，可以通过递归来实现，复杂度为$O(n=|size|)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> BinNode&lt;T&gt;::<span class="built_in">size</span>() &#123; <span class="comment">//统计当前节点后代总数，即以其为根的子树规模</span></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>; <span class="comment">//计入本身</span></span><br><span class="line"><span class="keyword">if</span> (lChild) s += lChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入左子树规模</span></span><br><span class="line"><span class="keyword">if</span> (rChild) s += rChild-&gt;<span class="built_in">size</span>(); <span class="comment">//递归计入右子树规模</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;  <span class="comment">//O(n = |size|)</span></span><br></pre></td></tr></table></figure><h2 id="4-3-BinTree模板类"><a href="#4-3-BinTree模板类" class="headerlink" title="4.3.BinTree模板类"></a>4.3.BinTree模板类</h2><p>在完成了对二叉树节点类<code>BinNode</code>的定义之后，我们就可以基于它来实现整体的binary tree简称<code>BinTree</code>这样一种模板类，代码的主体结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"BinNode.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BinTree</span> &#123;</span> <span class="comment">//二叉树模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> _size; BinNodePosi(T) _root; <span class="comment">//规模、根节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x的高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeightAbove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//更新节点x及其祖先的高度</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinTree() : _size(<span class="number">0</span>), _root(<span class="literal">NULL</span>) &#123; &#125; <span class="comment">//构造函数</span></span><br><span class="line">~BinTree() &#123; <span class="keyword">if</span> (<span class="number">0</span> &lt; _size) <span class="built_in">remove</span>(_root); &#125; <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_root; &#125; <span class="comment">//判空</span></span><br><span class="line">BinNodePosi(T) root() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _root; &#125; <span class="comment">//树根</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//操作接口</span></span><br><span class="line">BinNodePosi(T) insertAsRoot(T <span class="keyword">const</span>&amp; e); <span class="comment">//插入根节点</span></span><br><span class="line">BinNodePosi(T) insertAsLC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e); <span class="comment">//e作为x的左孩子（原无）插入</span></span><br><span class="line">BinNodePosi(T) insertAsRC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e); <span class="comment">//e作为x的右孩子（原无）插入</span></span><br><span class="line">BinNodePosi(T) attachAsLC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); <span class="comment">//T作为x左子树接入</span></span><br><span class="line">BinNodePosi(T) attachAsRC(BinNodePosi(T) x, BinTree&lt;T&gt;* &amp;T); <span class="comment">//T作为x右子树接入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(BinNodePosi(T) x)</span></span>; <span class="comment">//删除以位置x处节点为根的子树，返回该子树原先的规模</span></span><br><span class="line">BinTree&lt;T&gt;* secede(BinNodePosi(T) x); <span class="comment">//将子树x从当前树中摘除，并将其转换为一棵独立子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travLevel(visit); &#125; <span class="comment">//层次遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travPre(visit); &#125; <span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travIn(visit); &#125; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost</span><span class="params">(VST&amp; visit)</span> </span>&#123; <span class="keyword">if</span> (_root) _root-&gt;travPost(visit); &#125; <span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (BinTree&lt;T&gt; <span class="keyword">const</span>&amp; t) <span class="comment">//比较器（其余自行补充）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _root &amp;&amp; t._root &amp;&amp; lt(_root, t._root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>== (BinTree&lt;T&gt; <span class="keyword">const</span>&amp; t) <span class="comment">//判等器</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _root &amp;&amp; t._root &amp;&amp; (_root == t._root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;; <span class="comment">//BinTree</span></span><br></pre></td></tr></table></figure><p>需要注意的是：其中<code>updateHeight</code>这个接口是以<code>virtual</code>来修饰的，即虚函数。后面我们会看到二叉树，尤其是二叉搜索树是一个庞大的家族，其中的每一个成员对于高度的定义包括更新的方法都不尽相同，因此通过将它定义为虚方法可以便于各种派生类对这个方法进行适当的重写。</p><h2 id="4-4-高度更新"><a href="#4-4-高度更新" class="headerlink" title="4.4.高度更新"></a>4.4.高度更新</h2><p>对于任何一个节点<code>x</code>，它的高度是在以它为根的子树中，从它通往那个最深的叶节点的路径长度。有两种特殊情况：单节点的树高度取0，空树高度取-1，这里采用<strong>宏定义</strong>的封装的方式，通过重新命名一个新的等价意义上的高度，将常规情况下的高度与退化情况下的高度统一起来，使得此后对算法的描述和理解可以更为简便，同时也不致于影响到算法的正确性。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221110507.png" style="zoom: 40%;"></p><p>一个节点的高度恰好等于它的左孩子与右孩子高度中的更大者再加1，因此可以相应地得到对任意节点<code>x</code>进行高度更新的算法。 而如果<code>x</code>的祖先节点存在，那么祖先节点的高度可能因为<code>x</code>的高度变化而变化，整个这样的过程需要从x开始遍历它的所有历代祖先，算法的复杂度正比于x节点的深度，即$O(n=depth(x))$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stature(p) ( (p) ? (p)-&gt;height : -1 ) <span class="comment">//节点高度—约定空树高度为-1</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> BinTree&lt;T&gt;::updateHeight(BinNodePosi(T) x) <span class="comment">//更新节点x高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x-&gt;<span class="built_in">height</span> = <span class="number">1</span> + __max(stature(x-&gt;lc), stature(x-&gt;rc));</span><br><span class="line">&#125; <span class="comment">//具体规则，因树而异</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> BinTree&lt;T&gt;::updateHeightAbove(BinNodePosi(T) x) <span class="comment">//更新节点x及其历代祖先的高度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123; updateHeight(x); x = x-&gt;parent; &#125;</span><br><span class="line">&#125; <span class="comment">//可优化：一旦高度未变，即可终止。 O(n = depth(x))</span></span><br></pre></td></tr></table></figure><h2 id="4-5-节点插入"><a href="#4-5-节点插入" class="headerlink" title="4.5.节点插入"></a>4.5.节点插入</h2><p><code>insertAsRC</code>接口为原树中一个没有右孩子的节点插入一个右孩子节点，插入后原树的规模会增加1，<code>x</code>节点的高度有可能因为它新加入了一个孩子而发生变化，因此还要调用<code>updateHeightAbove</code>来对<code>x</code>这个节点以及它的历代祖先更新高度。</p><p><img src="/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91/QQ图片20200221112247.png" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinTree&lt;T&gt;::insertAsRC(BinNodePosi(T) x, T <span class="keyword">const</span>&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">_size++; x-&gt;insertAsRC(e); </span><br><span class="line">updateHeightAbove(x);   <span class="comment">//x及其祖先的高度可能增加，其余节点必然不变</span></span><br><span class="line"><span class="keyword">return</span> x-&gt;rc;</span><br><span class="line">&#125; <span class="comment">//e插入为x的右孩子，insertAsLC()完全对称</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      向量结构（Vector）和列表结构（List）两者都无法兼顾静态和动态的高效性，而本章要介绍的树结构恰好能将二者的优势结合起来。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（8）栈应用</title>
    <link href="http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-17T11:52:34.000Z</published>
    <updated>2020-02-18T15:07:01.394Z</updated>
    
    <content type="html"><![CDATA[<p>栈结构的经典应用场合大致可以分为以下四类：</p><ul><li><p><strong>逆序输出</strong> </p><ul><li><p>conversion：</p></li><li><p>输出次序与处理过程颠倒；递归深度和输出长度不易预知</p></li></ul></li><li><p><strong>递归嵌套</strong> </p><ul><li><p>stack permutation + parenthesis</p></li><li><p>具有自相似的问题可递归描述，但分支位置和嵌套深度不固定</p></li></ul></li><li><p><strong>延迟缓冲</strong> </p><ul><li><p>evaluation</p></li><li><p>线性扫描算法模式中，在欲读足够长之后，方能确定可处理的前缀</p></li></ul></li><li><p><strong>栈式计算</strong> </p><ul><li><p>RPN</p></li><li><p>基于栈结构的特定计算模式</p></li></ul></li></ul><h1 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h1><p>问题描述：给定任一10进制非负整数，将其转换为$\lambda$进制表示形式。</p><p>解法我们都很熟悉，即<strong>短除法</strong>：对给定的数做除法，留商取余，所得的余数再逆序输出。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217203706.png" style="zoom:50%;"></p><p>这样一个过程在用代码实现时一个问题需要考虑：计算的过程是由上而下的，而输出的过程是由下而上的，如果不借助对数我们很难预测最终会有多少个数位，也就是整个计算的深度到底有多少，那这个问题该如何解决呢？</p><p>回顾上篇文章中介绍的栈结构，我们只需引入一个栈，在计算的过程中，我们每得到一个数位（余数），就通过<code>push()</code>使它入栈，那么这些数位入栈的次序恰好就是它们被计算出来的次序（在图中是自上而下）。而<strong>栈的特性是后进先出</strong>（LIFO），一旦计算终止，我们就可以通过一系列<code>pop()</code>操作将这些数位按刚才的数位的逆序（在图中是自下而上）输出出来，从而得到所需要的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt; &amp; S, _int64 n, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line"><span class="comment">//薪进制下的数位符号，可视bae取值范围适当扩充</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> digit[] = </span><br><span class="line">&#123; <span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;   <span class="comment">//由低到高，逐一计算出薪进制下的各数位</span></span><br><span class="line">S.push( digit[ n % base ] );  <span class="comment">//余数（对应的数位）入栈</span></span><br><span class="line">n /= base;   <span class="comment">//n更新为其对base的除商</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-括号匹配"><a href="#2-括号匹配" class="headerlink" title="2.括号匹配"></a>2.括号匹配</h1><p><strong>括号匹配</strong>这个问题可以归为<strong>递归嵌套</strong>式问题，以括号匹配为代表的这类问题它们的共同特点是，具有某种意义上的自相似性，即它们的某一个局部往往和整体具有某种共性，同时这种局部作为分支它的位置以及嵌套的深度却难以在事先固定或者确定。</p><p>括号匹配是合法表达式的必要条件之一，下面是一个实例：</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217213522.png" style="zoom: 33%;"></p><p>我们的任务是给定任意一个含有括号的表达式如何来判定它是否是匹配的，为了简化问题不妨将括号之外的其余符号都暂时地忽略掉，只需要做一次线性扫描的预处理即可，这样就可以集中注意处理括号匹配的情况。</p><h2 id="2-1-构思"><a href="#2-1-构思" class="headerlink" title="2.1.构思"></a>2.1.构思</h2><p>为了得到这个问题的有效解法，我们或许应该继续沿用不断将问题简化的总体策略。为此需要首先来考察最基本的平凡情况：如果一个表达式不含任何的括号，从而实质上等价于一个空串，那么它自然是匹配的。</p><p>接下来我们注意到这样一个事实：如果某一个表达式E已经是括号匹配的，那么在它的左侧和右侧添加一对匹配的括号，整体依然将是匹配的；如果两个表达式E和F已经是各自匹配的，那么只要将它们串接起来就可以得到一个更大的匹配表达式。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217214959.png" style="zoom: 55%;"></p><p>然而很遗憾这两个性质都不能使得我们很好地运用此前所学的减而治之或者分而治之的策略。因此这两条性质只能作为括号匹配判断的必要条件而非充要条件，从逻辑推理的方向来看它是由左侧的前命题推向右侧的后命题，与简化问题的方向背道而驰。</p><p>而且它们也存在<strong>反例</strong>，这就让减而治之和分而治之都是行不通的。因此为了真正使这个问题能够得到有效的简化，必须发现并且借助这个问题所蕴含的某种<strong>充分性</strong>。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217215624.png" style="zoom: 55%;"></p><p>一种可行的方法是将以上的减而治之的策略颠倒过来，不是去试图减除一个表达式最外围的一对括号，而是<strong>试图去减除其中相互紧邻的一对左右括号</strong>。如果在一个表达式中能够发现一对彼此紧邻的左右括号，那么在将这对括号减除之后，剩余的部分是否匹配与此前的表达式是否匹配必然是互为充要条件的。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217230617.png" style="zoom:60%;"></p><p>那么如何找到这样一对括号呢？另外，更重要的是如何使得这种简化能够<strong>持续</strong>地进行下去呢？</p><p>实际针对上面的情况，正是<strong>栈</strong>可以大显身手的时候，借助栈结构的算法过程原理可以表示为下图。如果这是我们所使用的栈，那么其中所包含的就是我们已经扫描过但是仍待处理的部分，其中只需保存左括号。在接下来的扫描中一<strong>遇到左括号就令它入栈</strong>；而一旦<strong>遇到右括号</strong>不仅不需要令它入栈，反而应该<strong>令栈顶的那个左括号出栈</strong>。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217220736.png" style="zoom:60%;"></p><p>这样就刚好实现了上述的可行方法，算法的确可以持续地如此往复进行下去。如果最后一个括号被处理之后，整个栈恰好变空，那么就意味着原来的表达式是匹配的；反之，无论到最后栈非空或者在中途某个阶段提前变空，我们都可以判定原来的表达式是不匹配的。</p><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2.实现"></a>2.2.实现</h2><p>上节的构思可以具体兑现为这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;  <span class="comment">//exp[lo, hi)</span></span><br><span class="line">Stack&lt;<span class="keyword">char</span>&gt; S;   <span class="comment">//使用栈记录已发现但尚未匹配的左括号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++)   <span class="comment">//逐一检查当前符号</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'('</span> == <span class="built_in">exp</span>[i]) S.push(<span class="built_in">exp</span>[i]);   <span class="comment">//若遇左括号，则进栈</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!S.empty()) S.pop();    <span class="comment">//否则如果遇右括号，且栈非空，则令栈顶的左括号出栈</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//否则（遇右括号是栈已空），必不匹配</span></span><br><span class="line"><span class="keyword">return</span> S.empty();   <span class="comment">//最终，栈空当且仅当匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了判别low与high之间的这样一段表达式是否括号匹配，需要引入一个名为S的栈。以下的这个循环逐一地检查每一个字符，如果是左括号就令它入栈，否则就试图弹出栈顶，如果它的确存在的话应该就是与当前这个右括号匹配的那个左括号，而如果此时栈已经提前变空那么就意味着整个表达式失配，可以断定此时的失配是由于某一个右括号缺少与之匹配的左括号。</p><p>当处理完所有的字符并退出循环的时候，需要检查栈在当前是否是空的，只有当栈恰好为空时才说明表达式是匹配的，否则可以断定原来那个表达式是不匹配的，且是属于某一左括号缺失与之配对的右括号的情况。</p><h2 id="2-3-反思与拓展"><a href="#2-3-反思与拓展" class="headerlink" title="2.3.反思与拓展"></a>2.3.反思与拓展</h2><p>为更好地理解这个算法，我们不妨来看一个具体的实例：</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217222655.png" style="zoom: 60%;"></p><p>在理清这个实例的执行过程后，你可能会质疑我们为什么要使用栈呢[・_・?]。就这样一个特定的问题而言，只需借助一个简明的整数计数器就足以完成刚才的算法任务。如果令计算器初始为0，将算法的过程对应过来，若遇左括号计数器就加1；若遇右括号计算器就减1。最终如果计数器为0，则表达式匹配；如果计数器不为0，或在中途出现负数，则表达式不匹配。</p><p>实际上这个计数器所反映的就是刚才我们所使用的那个栈在任何时刻的规模，这样就不难理解其中的必然性了。那么既然如此我们为什么不使用更加简明的计数器，而要使用更为复杂的栈结构呢[・_・?]</p><p>这背后的原因在于<strong>采用栈结构可以便捷地推广至多种括号并存的情况</strong>，这时如果想要使用多个计数器也是行不通的，比如一个简单的反例<code>[  (  ]  )</code>，因为如果孤立地通过计数器来考察方括号或者是圆括号，两个计数器都是可以正常工作并且在最终复位为0的，而这个表达式显然是不匹配的。</p><p>通过下面这个实例来解释这个算法如何扩展到多个括号并存的情况。当遇到一个左括号，无论是什么形式都放入栈中；遇到一个右括号，则<strong>判断此时栈顶的左括号是否与它匹配</strong>，若匹配则令栈顶的左括号出栈。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200217224705.png" style="zoom:65%;"></p><p>同样地在经过了这样一趟线性的扫描之后，只有当栈最终为空，我们才可以断定原来这个包含多种括号的表达式是匹配的。反过来这时括号不匹配的情况相对于此前单括号的情景要多出一种，即当遇到右括号时，发现此时栈顶的左括号与之不匹配，如刚才举的反例<code>[  (  ]  )</code>，则表达式必是不匹配的，因为实际上这样每次“消去”的一对括号必是紧邻的一对括号。</p><p>扩展后括号匹配算法可以实现为下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; <span class="comment">//表达式括号匹配检查，可兼顾三种括号</span></span><br><span class="line">Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//使用栈记录已发现但尚未匹配的左括号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) <span class="comment">/* 逐一检查当前字符 */</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">exp</span>[i]) &#123; <span class="comment">//左括号直接进栈；右括号若与栈顶失配，则表达式必不匹配</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'('</span>: <span class="keyword">case</span> <span class="string">'['</span>: <span class="keyword">case</span> <span class="string">'&#123;'</span>: S.push(<span class="built_in">exp</span>[i]); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span> ((S.empty()) || (<span class="string">'('</span> != S.pop())) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span> ((S.empty()) || (<span class="string">'['</span> != S.pop())) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span> ((S.empty()) || (<span class="string">'&#123;'</span> != S.pop())) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>; <span class="comment">//非括号字符一律忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> S.empty(); <span class="comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后需要指出的是，实际上这样一种拓展还可以进一步地进行，也就是并不限于某几种特定的括号，甚至不需要对这些括号到底有多少种做出限定，就像在HTML语言中那样只要表达式中能够按照合理的语法，就能够定义任何一种匹配标志，我们都可以来进行这种意义上的匹配检查。</p><h1 id="3-栈混洗"><a href="#3-栈混洗" class="headerlink" title="3.栈混洗"></a>3.栈混洗</h1><p>本节介绍一个与上一节括号匹配问题非常相关的问题：栈混洗问题。栈混洗就是按照某种约定的规则对栈中的元素进行重新的排列。初始情况下所有的元素都存在栈A中，这里约定分别<strong>用尖括号和方括号来表示栈顶以及栈底</strong>，栈混洗的目标是将所有这些元素都通过某种方式转入到另一个初始为空的栈B中，为此需要借助一个中转栈S。</p><ul><li><p>栈 A = $&lt;a_1,a_2,\dots,a_n]$、B = S = $\varnothing$</p></li><li><p>只允许的操作：</p><ul><li>将A的顶元素弹出并压入S；  //<code>S.push(A.pop())</code></li><li>或将S的顶元素弹出压入B。  //<code>B.push(S.pop())</code></li></ul></li><li><p>若经过一系列以上的操作后，A中元素全部转入B中；</p><p>则B = $[a_{k1},a_{k2},\dots,a_{kn}&gt;$则称之为A的一个栈混洗（stack permutation）</p></li></ul><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218172757.png" style="zoom: 67%;"></p><p>在遵守以上规则的前提下同一输入序列可能导出不同的栈混洗序列，比如 A = &lt;1, 2, 3, 4]就可能得到：</p><p>B = [1, 2, 3, 4&gt;，[4, 3, 2, 1&gt;，[3, 2, 4, 1&gt;，……</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218173218.png" style="zoom: 80%;"></p><h2 id="3-1-计数"><a href="#3-1-计数" class="headerlink" title="3.1.计数"></a>3.1.计数</h2><p>那么长度为n的序列，可能的栈混洗总数$SP(n)$为多少呢？</p><p>假定输入栈 A = &lt; 1, 2, 3, ……, n ]，关注1号元素，它第一个被推入栈S中，假设它是第K个从S出栈的元素，当它出栈后S已为空，相应地A剩余最靠底的n-k个元素。此时B中最靠底的k-1个元素和A中最靠底的n-k个元素，它们的栈混洗实际上是相互独立的。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218174416.png" style="zoom:64%;"></p><p>因此对应于1号元素作为第k个元素被推入B中的情况，对应的栈混洗总数就应该是这两个相互独立的子序列所各自对应的栈混洗总数的乘积$SP(k-1)\times SP(n-k)$，又k可以取1到n，因此长度为n的序列，可能的栈混洗总数为：</p><script type="math/tex; mode=display">SP(n)=\sum_{k=1}^n SP(k-1)\times SP(n-k)=catalan(n)=\frac{(2n)!}{(n+1)!n!}</script><h2 id="3-2-甄别"><a href="#3-2-甄别" class="headerlink" title="3.2.甄别"></a>3.2.甄别</h2><p>对于输入序列&lt; 1, 2, 3, ……, n ] 的任一个排列 [$p_{1},p_{2},\dots,p_{n}$ &gt; 如何来判断它究竟是不是一个合法的栈混洗？</p><p>先从简单的例子入手，考虑由三个元素所构成的一个输入序列，则$SP(3)=5$，而三个数的全排列为$3!=6$，对于这种情况有一种排列不是栈混洗，显然不是栈混洗的排列是[ 3, 1, 2&gt;。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218175039.png" style="zoom:67%;"></p><p>实际上任意的三个元素能否按照某种相对的次序出现在最终的栈混洗中，与其它的元素实是无关的，因此推而广之对于任何三个互异的整数 $1\le i &lt; j&lt;k \le n$，如果在某个排列中出现了 <code>k  i   j</code>，那么它就必然不是栈混洗。这是栈混洗所必须禁止的一种特征，称之为禁形。</p><p>Kunth在他的《The Art of Computer Programming》中证明了 一个排列permutation是一个<strong>栈混洗的充要条件就是其中不含禁形</strong>。</p><p>由此可以导出一个算法：不断地枚举所有的<code>i j k</code>的组合，但其复杂度高达$O(n^3)$。进一步地可以将这样一个判别的依据简化：判断栈混洗的充要条件是，对于每一对互异的<code>i</code>&lt;<code>j</code>，在排列中不会出现 <code>j+1 i j</code> 这样的一个模式，由此导出的枚举算法的复杂度是$O(n^2)$。</p><p>而借助栈结构可以实现一个线性时间$O(n)$的甄别算法，其思想是：完全按照栈混洗的定义引入三个栈，并且通过<strong>对栈混洗过程的模拟</strong>以一种验证的方式来判别某一个排列是否的确为栈混洗。具体地对于输出序列中的任何一个元素，都采用一种<strong>贪心算法</strong>的原则以S为中介 将其从A转移至B中，只要这个贪心的过程能够持续进行并最终将所有的元素顺利地从A转入B中，那么就可以判断它是一个栈混洗。反之每次通过<code>pop</code>操作试图从S中弹出当前的元素时，如果S已经变空，或者要弹出的元素不是S栈顶的元素，就可以立即判断这个栈混洗是非法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参照LeetCode面试题31：栈的压入，弹出序列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">auto</span> i=pushed.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j=popped.<span class="built_in">begin</span>();j!=popped.<span class="built_in">end</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S.empty()||S.top()!=*j)</span><br><span class="line">        <span class="keyword">if</span>(i==pushed.<span class="built_in">end</span>())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> S.push(*i++);</span><br><span class="line">        S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-栈混洗与括号匹配的关系"><a href="#3-3-栈混洗与括号匹配的关系" class="headerlink" title="3.3.栈混洗与括号匹配的关系"></a>3.3.栈混洗与括号匹配的关系</h2><p>n个元素的任何一个栈混洗都对应于中转栈S的n次<code>push</code>操作以及n次<code>pop</code>操作所构成的一个序列。如果将每<code>push</code>都换成一个左括号，而将每次<code>pop</code>对应一个右括号，就会发现同一元素所对应的那对<code>push</code>、<code>pop</code>操作都恰好对应于一对彼此匹配的括号。反过来由n对括号所构成的任何一个合法的表达式，实际上也可以解释为对n个元素进行栈混洗的一个合法的过程，也相应地对应于某一个输出的栈混洗。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218181634.png" style="zoom:67%;"></p><p>因此合法的栈混洗序列与合法的括号匹配表达式之间存在一个一一对应的关系，n个元素的栈混洗有多少种n对括号所能构成的合法表达式也就有多少种。</p><h1 id="4-中缀表达式求值"><a href="#4-中缀表达式求值" class="headerlink" title="4.中缀表达式求值"></a>4.中缀表达式求值</h1><p>中缀表达式求值问题属于栈结构的另一种典型应用场合：延迟缓冲，在中缀表达式求值这样一类线性扫描算法中我们并不能保证处理的速度和读取的速度同步，而往往是需要预读足够多的信息之后才能够确定足以处理的一个前缀。这节中只考虑语法正确的算术表达式，即给定任一语法正确的表达式S，计算出与之对应的数值。</p><h2 id="4-1-表达式求值"><a href="#4-1-表达式求值" class="headerlink" title="4.1.表达式求值"></a>4.1.表达式求值</h2><p>回顾括号匹配算法：对于任何的一个表达式，在其中找到一对彼此紧邻也因此相互配对的括号，将这样一对括号删去，从而在剩余表达式与原先表达式在是否匹配上互为充要条件的前提下，使得问题的规模也就是括号的对数有所减少。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218183024.png" style="zoom:50%;"></p><p>对于表达式求值，我们依然要在表达式中寻找一个能够优先计算的子串，并且对它进行计算，然后将计算所得的数值重新放置在这个位置上，经过如此的转换之后，新的表达式的数值与原表达式的数值保持一致。如果将一个表达式的复杂度定义为其中包含的运算符的数目，那么这个过程依然是一个减而治之（decrease and conquer）的过程。因此这个算法具有单调性，最终将消除掉所有的运算符，从而得到最终的数值。下面是个具体的例子（计算次序由下到上）：</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218195657.png" style="zoom:67%;"></p><p>这样一个计算过程虽然在纸面上简便易行，但是如果面对比较长甚至非常长的表达式就将碰到很大的困难，这个困难就在于我们很难定位当前可以计算的那个运算符。如果以一种<strong>线性扫描</strong>的次序来处理表达式，每当扫到一个运算符的时候都未必能够确认它已经是可以计算的，也就是说<strong>计算次序未必与扫描的次序完全一致</strong>。</p><p>对于这样的一类问题，一种行之有效的办法就是借助<strong>栈结构</strong>，只需将所有已经扫描过的部分保存为一个栈，在所有已经扫描过的部分中有一些是能够及时处理的即在局部具有足够高的优先级，并且已经计算过的部分；而已经扫描过但是还不足以判断能够计算的部分将通过这个栈被缓冲起来，而我们的策略就是逐步地将尚未扫描的部分扫描并且处理掉。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218200405.png" style="zoom:80%;"></p><p><strong>求值算法 = 栈 + 线性扫描</strong>：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">自左向由扫描表达式，用栈记录已扫描的部分（含已执行运算的结果）</span><br><span class="line">   在每一字符处</span><br><span class="line">       <span class="keyword">while</span>(栈的顶部存在可优先计算的子表达式)</span><br><span class="line">         该子表式退栈；计算其数值；计算结果进栈</span><br><span class="line">   当前字符进栈，转入下一字符</span><br></pre></td></tr></table></figure><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218200316.png" style="zoom:70%;"></p><p>相对于此前那种纸面操作这样一个过程更加接近于机器能够自动实现的层次，然而离最终的目标还有差距，原因在于我们每次在栈顶检出这个可以计算的子表达式，无论是2乘3还是10除以5都不是那么自然，而诀窍在于将运算符和运算数分别对待，即将运算符和运算数分别存入两个栈中。</p><h2 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2.实现"></a>4.2.实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义优先级表</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> pri[<span class="number">9</span>][<span class="number">9</span>] = &#123;</span><br><span class="line"><span class="comment">//                当前运算符</span></span><br><span class="line"><span class="comment">//        +   -   *   /   ^   !   (   )  \0   </span></span><br><span class="line"><span class="comment">/* + */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* - */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* * */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* / */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* ^ */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* ! */</span>&#123; <span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span>,<span class="string">' '</span>,<span class="string">'&gt;'</span>,<span class="string">'&gt;'</span> &#125;,</span><br><span class="line"><span class="comment">/* ( */</span>&#123; <span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'='</span>,<span class="string">' '</span> &#125;,</span><br><span class="line"><span class="comment">/* ) */</span>&#123; <span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span> &#125;,</span><br><span class="line"><span class="comment">/* \0*/</span>&#123; <span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'&lt;'</span>,<span class="string">' '</span>,<span class="string">'='</span> &#125;</span><br><span class="line"><span class="comment">//(栈顶运算符)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readNumber</span><span class="params">(<span class="keyword">char</span>*&amp; p, Stack&lt;<span class="keyword">float</span>&gt;&amp; stk)</span> </span>&#123; <span class="comment">//将起始于p的子串解析为数值，并存入操作数栈</span></span><br><span class="line">stk.push((<span class="keyword">float</span>)(*p - <span class="string">'0'</span>)); <span class="comment">//当前数位对应的数值进栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(*(++p)))   <span class="comment">//只要后续还有紧邻的数字（即多位整数的情况），则</span></span><br><span class="line">stk.push(stk.pop() * <span class="number">10</span> + (*p - <span class="string">'0'</span>)); <span class="comment">//弹出原操作数并追加新数位后，新数值重新入栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'.'</span> != *p) </span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//此后非小数点，则意味着当前操作数解析完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> fraction = <span class="number">1</span>; <span class="comment">//否则，意味着还有小数部分</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(*(++p))) <span class="comment">//逐位加入</span></span><br><span class="line">stk.push(stk.pop() + (*p - <span class="string">'0'</span>) * (fraction /= <span class="number">10</span>)); <span class="comment">//小数部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由运算符得出编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">optr2rank</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'^'</span>:<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'!'</span>:<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:<span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:<span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\0'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较运算符的优先级</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">orderBetween</span><span class="params">(<span class="keyword">char</span> op1, <span class="keyword">char</span> op2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pri[optr2rank(op1)][optr2rank(op2)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行二元运算</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">calcu</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">char</span> op, <span class="keyword">float</span> b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> a + b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> a - b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> a * b;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">if</span> (<span class="number">0</span> == b) <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="keyword">return</span> a / b; <span class="comment">//注意：如此判浮点数为零可能不安全</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'^'</span>: <span class="keyword">return</span> <span class="built_in">pow</span>(a, b);</span><br><span class="line"><span class="keyword">default</span>: <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一元运算</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">calcu</span><span class="params">(<span class="keyword">float</span> b)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">1.01</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> b*(calcu(b<span class="number">-1</span>)); <span class="comment">//目前仅有阶乘，可照此方式添加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法主体部分，中缀表达式求值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S )</span> </span>&#123;</span><br><span class="line">Stack&lt;<span class="keyword">float</span>&gt; opnd;  <span class="comment">//运算数栈</span></span><br><span class="line">Stack&lt;<span class="keyword">float</span>&gt; optr;  <span class="comment">//运算符栈</span></span><br><span class="line">optr.push(<span class="string">'\0'</span>);    <span class="comment">//尾哨兵'\0'也作为头哨兵入栈</span></span><br><span class="line"><span class="keyword">while</span> (!optr.empty()) &#123;  <span class="comment">//逐个处理各字符，直至运算符栈空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(*S))     <span class="comment">//若当前字符为操作数，则</span></span><br><span class="line">readNumber(S, opnd);   <span class="comment">//读入（可能多位的）操作数</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//若当前字符为运算符，则视其余栈顶运算符之间优先级的高低</span></span><br><span class="line"><span class="keyword">switch</span>(orderBetween(optr.top(), *S))&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="comment">//栈顶运算符优先级更低时</span></span><br><span class="line">optr.push(*S); S++; <span class="comment">//计算推迟，当前运算符进栈</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'='</span>: <span class="comment">//优先级相等（当前运算符为右括号或者尾部哨兵'\0'）时</span></span><br><span class="line">optr.pop(); S++; <span class="comment">//脱括号并接收下一个字符</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123; <span class="comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span></span><br><span class="line"><span class="keyword">char</span> op = optr.pop();  <span class="comment">//栈顶运算符出栈并续接至RPN末尾</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'!'</span> == op) &#123; <span class="comment">//若属于一元运算符</span></span><br><span class="line">opnd.push( calcu( opnd.pop() )); <span class="comment">//实施一元计算，结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//对于其它（二元）运算符</span></span><br><span class="line"><span class="keyword">float</span> pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop(); <span class="comment">//取出后、前操作数 </span></span><br><span class="line">opnd.push( calcu( pOpnd1, op, pOpnd2 ) ); <span class="comment">//实施二元计算，结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> opnd.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-逆波兰表达式"><a href="#5-逆波兰表达式" class="headerlink" title="5.逆波兰表达式"></a>5.逆波兰表达式</h1><h2 id="5-1-RPN"><a href="#5-1-RPN" class="headerlink" title="5.1.RPN"></a>5.1.RPN</h2><p>逆波兰表达式（Reverse Polish notation，RPN），是一种由波兰数学家Jan Łukasiewicz在1920年引入的数学表达式，在逆波兰表达式中，所有操作符置于操作数的后面，不需要括号来标识操作符的优先级。在RPN中我们原先使用的运算符优先级和括号强制指定优先级都不存在了，因此RPN更适合机器来完成表达式的计算。</p><ul><li>在由运算符（operator）和操作数（operand）组成的表达式中不使用括号（parenthesis-free）即可表示带优先级的运算关系。</li></ul><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218223625.png" style="zoom: 50%;"></p><ul><li>相对于日常使用的中缀式（infix），RPN被称为后缀式（postfix）</li><li>作为补偿，须额外引入一个起分隔作用的元字符（比如空格）</li></ul><p>相比于上节的中缀表示式计算，RPN的计算显得十分简便，只需引入一个辅助栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rpnEvaluate(expr) &#123; <span class="comment">//假定RPN表达式epxr的语法正确</span></span><br><span class="line">    引入栈S，用于存放操作数；</span><br><span class="line">    <span class="keyword">while</span>(expr尚未扫描完毕)&#123;</span><br><span class="line">        读入expr的下一个元素x;</span><br><span class="line">        <span class="keyword">if</span>(x是操作数)</span><br><span class="line">            将X压入S;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//x是运算符</span></span><br><span class="line">            从栈中弹出运算符x所需数目的操作数;</span><br><span class="line">            对弹出的操作数实施x运算，并将运算结果重新压入S;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    返回栈顶; <span class="comment">//也是栈底</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218225206.png" style="zoom: 50%;"></p><h2 id="5-2-中缀表达式向RPN的转换"><a href="#5-2-中缀表达式向RPN的转换" class="headerlink" title="5.2.中缀表达式向RPN的转换"></a>5.2.中缀表达式向RPN的转换</h2><p>中缀表达式向逆波兰表达式的转换可以按以下过程实现：</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%88%E5%BA%94%E7%94%A8/QQ图片20200218224009.png" style="zoom: 50%;"></p><p>主要注意的是：在转换完成后，<strong>操作数的次序不会发生变换</strong>，<strong>而运算符的次序可能发生变换</strong>。</p><p>转换的具体算法实际上可以直接借助上节计算中缀表达式的算法，它在计算中缀表达式结果的同时，实际上也完成了向RPN的转换，重点关注下面代码的第6行和第12行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S <span class="built_in">string</span> *RPN)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*.................................*/</span></span><br><span class="line"><span class="keyword">while</span> (!optr.empty()) &#123;  <span class="comment">//逐个处理各字符，直至运算符栈空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(*S)) &#123;    <span class="comment">//若当前字符为操作数，则</span></span><br><span class="line">readNumber(S, opnd);</span><br><span class="line">            *(RPN++) = to_string(opnd.top());  <span class="comment">//将其压入RPN</span></span><br><span class="line"><span class="keyword">else</span>    <span class="comment">//若当前字符为运算符</span></span><br><span class="line"><span class="keyword">switch</span>(orderBetween(optr.top(), *S))&#123;</span><br><span class="line"><span class="comment">/*..............................*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123; <span class="comment">//栈顶运算符优先级更高时，可实施相应的计算，则</span></span><br><span class="line"><span class="keyword">char</span> op = optr.pop();</span><br><span class="line">                *(RPN++) = op;<span class="comment">//在执行相应的同时将其压入RPN</span></span><br><span class="line"><span class="comment">/*.............................*/</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> opnd.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本文结合几个具体的实际问题来介绍栈的实际应用，栈结构的经典应用场合大致可以分为：逆序输出，递归嵌套，延迟缓冲，栈式计算。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（7）栈与队列</title>
    <link href="http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://nekomoon404.github.io/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2020-02-17T09:49:20.000Z</published>
    <updated>2020-02-17T11:48:18.235Z</updated>
    
    <content type="html"><![CDATA[<p>栈和队列这对孪生兄弟都是线性序列的特例，它们在算法以及应用中都扮演着非常基本而重要的角色，本文主要介绍如何以ADT的形式来定义和规范它们的接口，以及如何借助此前学习过的序列结构（向量与列表）简洁高效地加以实现。</p><h1 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h1><h2 id="1-1操作与接口"><a href="#1-1操作与接口" class="headerlink" title="1.1操作与接口"></a>1.1操作与接口</h2><p><strong>栈结构</strong>（Stack）依然是由一组元素组成的线性序列，与一般的序列不同的是，在任何时候我们只能够访问栈中的一个特定元素——最末端那个元素，而其余的元素在当前都是禁止访问的。</p><p>通常习惯于将可以访问的开放的这一端，称作<strong>顶端top</strong>，而不开放的那个盲端称作<strong>底部bottom</strong>。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217181712.png" style="zoom:50%;"></p><p>一般意义下的栈以及它的操作可以由下面的一组图来表示，如果需要将某一个新的元素插入其中，那么只能将它作为最顶部的元素插入，这个动作我们也形象地称之为<code>push</code>。反过来如果需要从栈中取出某一个元素，那么也只能取出当前这个顶部的元素，这个元素被取出之后其余元素将依次向前递补，将会出现一个新的顶部元素，这样的一个过程称为<code>pop</code>。当然通常的栈还会提供另一个辅助的接口，查询顶部元素的数值而并不需要将它真正的弹出，那么这样一个动作称之为<code>top</code>。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217182209.png" style="zoom:50%;"></p><h2 id="1-2-操作实例"><a href="#1-2-操作实例" class="headerlink" title="1.2.操作实例"></a>1.2.操作实例</h2><p>接下来通过一个实例来了解栈结构各种接口的准确功能，以及它们组合之后所能达到的效果。</p><p>首先通过构造函数<code>Stack()</code>来创建一个空的栈，调用<code>empty()</code>来检查其是否为空，<code>push(5)</code>在栈中插入第一个元素，图中栈顶是在左侧，栈底是在右侧。<code>push(3)</code>即在栈顶也就是左侧插入元素3，<code>pop(3)</code>则将栈顶的元素删除，<code>size()</code>返回栈序列中元素的个数，<code>top()</code>返回栈顶元素的值。</p><p>需要留意的是，<strong>栈中元素入栈的出栈的次序</strong>，即相对而言后入栈的元素会更早出栈，这也是栈结构的一个非常独特的性质，即<strong>后进先出（LIFO）</strong>，正是因为栈的这种特性使得它在很多算法中都有重要作用。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217182320.png" style="zoom: 50%;"></p><h2 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3.实现"></a>1.3.实现</h2><p>实际上既然栈可以视作是序列的一种受限后的特例，那么自然可以通过此前学过的<strong>向量或列表结构直接派生而得</strong>，即我们完全可以利用向量或者列表来模拟栈以及它的接口行为。</p><p>以向量为例，栈中有多少元素，向量中也对应地有多少个元素，如果约定首元素是栈的底部盲端，那么<strong>末元素也就是可操作的栈顶</strong>，按照这样一个思路就可以简洁地写出栈模板类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> :</span> <span class="keyword">public</span> Vector&lt;T&gt; &#123;  <span class="comment">//由向量派生</span></span><br><span class="line"><span class="keyword">public</span>:   <span class="comment">//size()、empty()以及其它开放接口均可直接沿用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span> &amp; e)</span> </span>&#123; insert(<span class="built_in">size</span>(), e); &#125;  <span class="comment">//入栈</span></span><br><span class="line"><span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove</span>(<span class="built_in">size</span>() - <span class="number">1</span>); &#125;  <span class="comment">//出栈</span></span><br><span class="line"><span class="function">T &amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (*<span class="keyword">this</span>)[<span class="built_in">size</span>() - <span class="number">1</span>]; &#125;  <span class="comment">//取顶</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217184206.png" style="zoom:67%;"></p><p>对于向量结构而言无论是插入操作还是删除操作，所需要的时间都线性正比于插入和删除位置的后继的数目。对于栈结构，无论是插入操作还是删除操作都是在向量的末端进行，因此所有这些操作接口的时间复杂度都是常数的，即为$O(1)$。如果将向量的首元素作为栈顶，那么每次插入和删除操作的时间复杂度就会变成$O(n)$。</p><h1 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h1><p>队列（queue）也是一种特殊的线性序列，想想生活中机场安检窗口的队列或者超市等待付款的队列，用数据额结构的语言来说它们都构成一个线性的序列，与栈一样它也是一个受限的序列，不同的是队列的一端只能够出，另一端只能怪进。通常，允许插入的那一端被称作尾部，允许删除的一端被称为头部。</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217193113.png" style="zoom: 50%;"></p><ul><li><p>队列也是受限的序列：</p><ul><li><strong>只能在队尾插入</strong>（查询）：<code>enqueue()</code>  +  <code>rear()</code></li><li><strong>只能在队头删除</strong>（查询）：<code>dequeue()</code>  +  <code>front()</code></li></ul></li><li><p>队列中元素<strong>入队和出队的次序</strong>与栈相反：</p><ul><li><strong>先进先出</strong>（FIFO）</li><li><strong>后进后出</strong>（LILO）</li></ul></li></ul><p>下面是一个队列的操作具体事例：</p><p><img src="/2020/02/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/QQ图片20200217193714.png" style="zoom:50%;"></p><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2.实现"></a>2.2.实现</h2><p>与栈同理既然队列也是属于序列，自然可以利用此前已经实现的最基本的向量以及列表结构直接派生而得，这里选用列表来实现队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> :</span> <span class="keyword">public</span> List&lt;T&gt; &#123;  <span class="comment">//由列表派生</span></span><br><span class="line"><span class="keyword">public</span>:   <span class="comment">//size()与empty()以及其它开放接口均可直接沿用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T <span class="keyword">const</span> &amp; e)</span> </span>&#123; insertAsLast(e); &#125;  <span class="comment">//入队</span></span><br><span class="line"><span class="function">T <span class="title">dequeue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">remove</span>( first() ); &#125;   <span class="comment">//出队</span></span><br><span class="line"><span class="function">T &amp; <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first()-&gt;date; &#125;   <span class="comment">//查询队首元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于列表结构的特性，无论是<code>enqueue()</code> ，<code>dequeue()</code>还是<code>front()</code>这些接口都能够在常数的时间内完成，即$O(1)$的时间。</p><p>这种基于以前的工作来进一步完成新的任务的思路，不仅使得我们的工作可以快速推进，而且使得整个工作的系统性和安全性都能得到保障(ง •_•)ง</p><p>队列结构在此后的图算法以及其它的场合都有广泛的应用，所以这里只是首先简要地介绍它的接口定义，以及它在C++中的实现方式。</p>]]></content>
    
    <summary type="html">
    
      栈和队列是线性序列的特例，它们在算法应用中都扮演者非常基本而重要的角色，本文主要介绍栈和队列的接口与实现。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（10）继承和派生</title>
    <link href="http://nekomoon404.github.io/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/"/>
    <id>http://nekomoon404.github.io/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</id>
    <published>2020-02-17T03:57:42.000Z</published>
    <updated>2020-02-18T05:45:39.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-继承和派生"><a href="#1-继承和派生" class="headerlink" title="1.继承和派生"></a>1.继承和派生</h1><ul><li><p>继承的概念：在定义一个新的类B时，如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么就可以把A作为一个<strong>基类</strong>，而把B作为基类的一个<strong>派生类</strong>（也称为子类）。</p></li><li><p>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。</p></li><li>派生类一经定义后，可以独立使用，不依赖与基类。</li><li><p><strong>派生类拥有基类的全部成员变量和成员函数</strong>，包括<code>private</code>，<code>public</code>，<code>protected</code></p></li><li><p>派生类的写法：<code>class 派生类名: public 基类名 { };</code></p></li><li>派生类的<strong>内存空间</strong>：派生类对象的体积，等于基类对象的体积，再加上派生类对象自己的成员变量的体积。在派生类对象中，包含着基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span><span class="keyword">public</span> CBase&#123;</span><br><span class="line">    <span class="keyword">int</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200217121930.png" style="zoom:67%;"></p><p><strong>示例</strong>：写了一个学生的类<code>Student</code>，再写一个Student类的派生类<code>UndergraduateStudent</code>，补充和修改一些功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span>  <span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> id;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span>&lt;&lt;name&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: "</span> &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Age: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Gender: "</span> &lt;&lt; gender &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;_id, <span class="keyword">int</span> _age, <span class="keyword">char</span> _gender)</span> </span>&#123;</span><br><span class="line">name = _name;</span><br><span class="line">id = _id;</span><br><span class="line">age = _age;</span><br><span class="line">gender = _gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergraduateStudent</span> :</span><span class="keyword">public</span> Student &#123;  <span class="comment">//本科生类，继承了Student类的派生类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> department;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QualifiedForBaoyan</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"qualified for baoyan"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> </span>&#123;  <span class="comment">//派生类中修改基类中的PrintInfo</span></span><br><span class="line">Student::PrintInfo();  <span class="comment">//调用基类的PrintInfo</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Department:"</span> &lt;&lt; department &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;_id, <span class="keyword">int</span> _age, <span class="keyword">char</span> _gender, <span class="keyword">const</span> <span class="built_in">string</span> &amp;_department)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">Student::SetInfo(_name, _id, _age, _gender);</span><br><span class="line">department = _department;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UndergraduateStudent S;</span><br><span class="line">S.SetInfo(<span class="string">"Harry Potter"</span>, <span class="string">"20200217"</span>, <span class="number">19</span>, <span class="string">'M'</span>, <span class="string">"Machine Learning"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; S.GetName() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">S.QualifiedForBaoyan();</span><br><span class="line">S.PrintInfo();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200217131741.png" style="zoom:80%;"></p><h1 id="2-继承关系和复合关系"><a href="#2-继承关系和复合关系" class="headerlink" title="2.继承关系和复合关系"></a>2.继承关系和复合关系</h1><p>类与类之间有两种关系：</p><ul><li><strong>继承</strong>：“是”关系<ul><li>基类A，B是基类A的派生类</li><li>逻辑上要求：“一个B对象也是一个A对象”，比如上节中<code>Student</code>类和<code>UndergraduateStudent</code>类。</li></ul></li><li><strong>复合</strong>：“有”关系<ul><li>类C中“有”成员变量k，k是类D的对象，则C和D是复合关系</li><li>一般逻辑上要求：“D对象是C对象的固有属性或组成部分”。</li></ul></li></ul><p>举一个简单的例子：如果要写一个小区养狗管理程序，需要写一个“业主”类和“狗”类，狗的主人即是业主，规定狗只能有一个主人，而一个业主最多可以有5条狗。</p><p>正确的写法：为”狗“类设一个”业主“类的对象指针；为”业主“类设一个”狗“类的对象指针数组。</p><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200218111522.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    Master *m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>&#123;</span></span><br><span class="line">    Dog dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而以下的做法都是错误的或者不好的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>&#123;</span></span><br><span class="line">    Dog dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    Master m;</span><br><span class="line">&#125;;   <span class="comment">//会造成循环定义，不定确定Master和Dog所需的内存空间</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>&#123;</span></span><br><span class="line">    Dog *dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    Master m;</span><br><span class="line">&#125;;   <span class="comment">//如何维护不同的狗所属的相同的主人的信息的一致性？改了一条狗，其他狗也要更着改，十分麻烦</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>&#123;</span></span><br><span class="line">    Master *m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>&#123;</span></span><br><span class="line">    Dog dogs[<span class="number">10</span>];</span><br><span class="line">&#125;;   <span class="comment">//这样狗对象都包含在业主对象里面，只能通过修改业主信息来修改狗的信息</span></span><br></pre></td></tr></table></figure><h1 id="3-基类和派生类有同名成员的情况"><a href="#3-基类和派生类有同名成员的情况" class="headerlink" title="3.基类和派生类有同名成员的情况"></a>3.基类和派生类有同名成员的情况</h1><p> 基类和派生类有时会拥有相同名称的成员变量或者成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;         <span class="comment">//与基类相同的成员对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;   <span class="comment">//与基类相同的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> derived::access()&#123;</span><br><span class="line">    j = <span class="number">5</span>;  <span class="comment">//错误的，j是基类的私有成员</span></span><br><span class="line">    i = <span class="number">5</span>;        <span class="comment">//引用的是派生类的i </span></span><br><span class="line">    base::i = <span class="number">5</span>;  <span class="comment">//引用的是基类的i</span></span><br><span class="line">    func();       <span class="comment">//派生类的成员函数</span></span><br><span class="line">    base::func(); <span class="comment">//基类的成员函数 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    derived obj;</span><br><span class="line">    obj.i = <span class="number">3</span>;       <span class="comment">//对派生类的成员变量赋值</span></span><br><span class="line">    obj.base::i = <span class="number">3</span>; <span class="comment">//对派生类对应的基类部分的成员变量赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>obj</code>对象占用的存储空间：</p><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200218112413.png" style="zoom:80%;"></p><p>注意：<strong>一般来说，基类和派生类不定义同名成员变量</strong>。</p><h1 id="4-访问范围说明符"><a href="#4-访问范围说明符" class="headerlink" title="4.访问范围说明符"></a>4.访问范围说明符</h1><ul><li><p>基类的<code>private</code>成员，可以被下列函数访问：</p><ul><li>基类的成员函数</li><li>基类的友元函数</li></ul></li><li><p>基类的<code>public</code>成员，可以被下列函数访问：</p><ul><li>基类的成员函数</li><li>基类的友元函数</li><li>派生类的成员函数</li><li>派生类的友元函数</li><li>其他的函数</li></ul></li><li>基类的<code>protected</code>成员，可以被下列函数访问：<ul><li>基类的成员函数</li><li>基类的友元函数</li><li><strong>派生类的成员函数可以访问当前对象的基本的</strong><code>protected</code><strong>成员</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="keyword">int</span> nPrivate;</span><br><span class="line"><span class="keyword">public</span>:   <span class="keyword">int</span> nPublic;</span><br><span class="line"><span class="keyword">protected</span>:<span class="keyword">int</span> nProtected;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AccseeFather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">nPublic = <span class="number">1</span>;      <span class="comment">//Ok</span></span><br><span class="line">nPrivate = <span class="number">1</span>;     <span class="comment">//Wrong</span></span><br><span class="line">nProtected = <span class="number">1</span>;   <span class="comment">//Ok，访问从基类基础的protected成员</span></span><br><span class="line">Son f;</span><br><span class="line">f.nProtected = <span class="number">1</span>; <span class="comment">//Wrong,f不是AccseeFather作用的当前对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Father f;</span><br><span class="line">Son s;</span><br><span class="line">f.nPublic = <span class="number">1</span>;     <span class="comment">//Ok</span></span><br><span class="line">s.nPublic = <span class="number">1</span>;     <span class="comment">//Ok</span></span><br><span class="line">f.nProtected = <span class="number">1</span>;  <span class="comment">//Wrong</span></span><br><span class="line">f.nPublic = <span class="number">1</span>;     <span class="comment">//Wrong</span></span><br><span class="line">s.nProtected = <span class="number">1</span>;  <span class="comment">//Wrong</span></span><br><span class="line">s.nPublic = <span class="number">1</span>;     <span class="comment">//Wrong</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-派生类的构造函数"><a href="#5-派生类的构造函数" class="headerlink" title="5.派生类的构造函数"></a>5.派生类的构造函数</h1><ul><li>派生类对象包含基类对象</li><li>执行派生类构造函数之前，先执行基类的构造函数</li><li>派生类交代基类初始化，具体形式：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造函数名(形参表):基类名(基类构造函数实参表)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个具体的例子 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> nLegs;</span><br><span class="line"><span class="keyword">int</span> nColor;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> nType;</span><br><span class="line">Bug(<span class="keyword">int</span> _legs, <span class="keyword">int</span> _color);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintBug</span><span class="params">()</span> </span>&#123; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span> :</span><span class="keyword">public</span> Bug &#123;</span><br><span class="line"><span class="keyword">int</span> nWings;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FlyBug(<span class="keyword">int</span> _legs, <span class="keyword">int</span> _color, <span class="keyword">int</span> _wings);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bug::Bug(<span class="keyword">int</span> _legs, <span class="keyword">int</span> _color) &#123;</span><br><span class="line">nLegs = _legs;</span><br><span class="line">nColor = _color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的FlyBug构造函数</span></span><br><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> _legs, <span class="keyword">int</span> _color, <span class="keyword">int</span> _wings) &#123;</span><br><span class="line">nLegs = _legs;    <span class="comment">//Wrong，不能访问基类的私有成员</span></span><br><span class="line">nColor = _color;  <span class="comment">//Wrong，不能访问基类的私有成员</span></span><br><span class="line">nType = <span class="number">1</span>;        <span class="comment">//OK</span></span><br><span class="line">nWings = _wings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的FlyBug构造函数</span></span><br><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> _legs, <span class="keyword">int</span> _color, <span class="keyword">int</span> _wings) :Bug(_legs, _color) &#123;</span><br><span class="line">nWings = _wings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在<strong>创建派生类的对象时</strong>：</p><ul><li>需要调用基类的构造函数：初始化派生类对象中从基类继承的成员</li><li>在执行一个派生类的构造函数之前，总是先执行基类的构造函数</li></ul></li><li><p>调用基类构造函数的两种方式：</p><ul><li><p>显式方式：<strong>派生类的构造函数中 $\to$ 基类的构造函数提供参数</strong></p><p><code>FlyBug::FlyBug(int _legs, int _color, int _wings) :Bug(_legs, _color)</code></p></li><li><p>隐式方式：派生类的构造函数中，省略基类构造函数时，会自动调用基类的默认构造函数</p></li></ul></li><li><p>派生类的析构函数被执行时，<strong>执行完派生类的析构函数后，自动调用基类的析构函数</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Base(<span class="keyword">int</span> i):n(i)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; n &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; n &lt;&lt; <span class="string">" destructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> i) :Base(i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived  constructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Derived()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived  destructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">Obj</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果为：</p><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200218132030.png" style="zoom:80%;"></p><ul><li><p>对于<strong>包含成员对象的派生类</strong>的构造函数，创建派生类的对象时：</p><ul><li>调用基类的构造函数 $\to$ 初始化派生类对象中从基类继承的成员</li><li>调用成员对象类的构造函数 $\to$ 初始化派生类对象中成员对象</li><li>执行派生类的构造函数</li></ul></li><li><p>析构时：</p><ul><li>执行派生类的析构函数</li><li>调用成员对象类的析构函数</li><li>调用基类的析构函函数（仍然遵循<strong>先构造的后析构</strong>的规则）</li></ul></li></ul><h1 id="6-public继承的赋值兼容规则"><a href="#6-public继承的赋值兼容规则" class="headerlink" title="6.public继承的赋值兼容规则"></a>6.public继承的赋值兼容规则</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span><span class="keyword">public</span> base&#123; &#125;;</span><br><span class="line">base b;</span><br><span class="line">derived d;</span><br></pre></td></tr></table></figure><ul><li>派生类的对象可以赋值给基类对象：<code>b = d;</code></li><li>派生类的对象可以初始化基类引用：<code>base &amp; br = d;</code></li><li>派生类的对象的地址可以赋给基类指针：<code>base * bp = &amp; d;</code></li></ul><p>注意上述规则不能颠倒，且如果派生方式是<code>private</code>或者<code>protected</code>，上述三条都不可行</p><h1 id="7-直接基类与间接基类"><a href="#7-直接基类与间接基类" class="headerlink" title="7.直接基类与间接基类"></a>7.直接基类与间接基类</h1><p>C++中类的<strong>派生可以是很多层的</strong>。</p><p>如类A派生类B，类B派生类C，类C派生类D：</p><ul><li>类A是类B的直接基类；</li><li>类B是类C的直接基类，类A是类C的间接基类；</li><li>类C是类D的直接基类，类A、B是类D的间接基类；</li></ul><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200218133901.png" style="zoom:67%;"></p><p><strong>在声明派生类时，只需要列出它的直接基类</strong>；派生类沿用着类的层次自动向上继承它的间接基类。</p><p>派生类的成员包括：派生类自己定义的成员，直接基类中的所有成员，所有间接基类的全部成员</p><p><strong>当执行构造函数时，从顶层基类开始，依次往下执行基类的构造函数，最后执行自己的构造函数。</strong></p><p>下面看一个例子：<code>Base</code> $\to$ <code>Derived</code> $\to$ <code>MoreDerived</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Base(<span class="keyword">int</span> i) :n(i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; n &lt;&lt; <span class="string">" constructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; n &lt;&lt; <span class="string">" destructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Derived(<span class="keyword">int</span> i) :Base(i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived  constructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Derived() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived  destructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreDerived</span> :</span><span class="keyword">public</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MoreDerived(<span class="keyword">int</span> i) :Derived(i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MoreDerived  constructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~MoreDerived() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MoreDerived  destructed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MoreDerived <span class="title">Obj</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果为：</p><p><img src="/2020/02/17/Cpp%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/QQ图片20200218133052.png" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      本章学习了面向对象中一个很重要的概念：继承和派生，这种机制可以提高代码的重用性。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（9）运算符重载</title>
    <link href="http://nekomoon404.github.io/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://nekomoon404.github.io/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2020-02-16T01:55:33.000Z</published>
    <updated>2020-02-16T07:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><ul><li>运算符：C++预定义表示对数据的运算<ul><li>+, - , *, /, %, ^, &amp;, ~, !, |, =, &lt;&lt;, &gt;&gt;, != …….</li><li>只能用于基本的数据类型：整型，实型，字符型，逻辑型，……</li></ul></li><li>C++提供了数据抽象的手段：用户自己定义数据类型——类<ul><li>调用类的成员函数 $\to$  操作它的对象，有时会不方便</li><li>比如在数学上，两个复数可以直接进行+, -等运算；而在C++中，直接将+，-作用于复数（我们定义的类）是不允许的</li></ul></li><li><p>运算符重载：对抽象数据类型也能够直接使用C++提供的运算符</p><ul><li>程序更简洁</li><li>代码更容易理解</li></ul></li><li><p>运算符重对已有的运算符赋予多重的含义</p><ul><li>在使用同一运算符作用于不同类型的数据时 $\to$ 不同类型的行为</li><li>目的是扩展C++中提供的运算符的适用范围，以用于类所表示的抽象数据类型</li></ul></li><li>运算符重载的<strong>实质是函数重载</strong></li></ul><p>​        返回值类型 operator 运算符(形参表)  { …… }</p><ul><li>在程序编译时：<ul><li>把含运算符的表达式 $\to$ 对运算符函数的调用</li><li>把运算符的操作数 $\to$ 运算符函数的参数</li><li>运算符被多次重载时，根据<strong>实参的类型</strong>决定调用哪个运算符函数</li><li>运算符可以被<strong>重载为普通函数</strong>，也可以被<strong>重载为成员函数</strong></li></ul></li><li>运算符重载为普通函数时，参数个数为运算符目数（如+为2）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) &#123;</span><br><span class="line">real = r;</span><br><span class="line"><span class="built_in">imaginary</span> = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> real;</span><br><span class="line"><span class="keyword">double</span> <span class="built_in">imaginary</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;a, <span class="keyword">const</span> Complex &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(a.real+b.real,a.<span class="built_in">imaginary</span>+b.<span class="built_in">imaginary</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">Complex a(<span class="number">1</span>, <span class="number">2</span>), b(<span class="number">2</span>, <span class="number">3</span>), c;</span><br><span class="line">c = a + b;  <span class="comment">//相当于operator+(a,b)，会传递两个参数a,b</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运算符重载为成员函数时，参数个数为运算符目数减一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>):real(r),<span class="built_in">imaginary</span>(i) &#123; &#125; <span class="comment">//constructor</span></span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;);   <span class="comment">//addition</span></span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;);   <span class="comment">//subtraction</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> real;</span><br><span class="line"><span class="keyword">double</span> <span class="built_in">imaginary</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Overload addition operator</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;operand2) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real + operand2.real, <span class="built_in">imaginary</span> + operand2.<span class="built_in">imaginary</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Overload subtraction operator</span></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;operand2) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real - operand2.real, <span class="built_in">imaginary</span> - operand2.<span class="built_in">imaginary</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">Complex x(<span class="number">4.3</span>,<span class="number">8.2</span>),y(<span class="number">3.3</span>,<span class="number">1.1</span>),z;</span><br><span class="line">z = x + y;  <span class="comment">//相当于z = x.operator(y)，即只传入一个参数</span></span><br><span class="line">z = x - y;  <span class="comment">//相当于z = x.operator(y)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-赋值运算符’-’重载"><a href="#2-赋值运算符’-’重载" class="headerlink" title="2.赋值运算符’=’重载"></a>2.赋值运算符’=’重载</h1><h2 id="2-1-基本实现"><a href="#2-1-基本实现" class="headerlink" title="2.1.基本实现"></a>2.1.基本实现</h2><p>当类和对象这个新概念对引入的时候，原先一些传统的运算符并不能直接作用在我们自己定义的类型的对象上，但是唯有赋值运算符’=’是可以直接使用的，它会会按对象的数据成员一一完成赋值。当我们对’=’有更多的要求时，比如两边类型可以不匹配，或者除了完成普通的赋值外还要实现其他功能，就需要重载运算符’=’。</p><ul><li>赋值运算符’=’<strong>只能重载为成员函数</strong></li></ul><p>例子：编写一个长度可变的字符串类String，包含一个<code>char *</code>类型的成员变量 $\to$ 指向动态分配的存储空间，该存储空间用于存放<code>&#39;\0&#39;</code>结尾的字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">String</span>():str(<span class="literal">NULL</span>)&#123;&#125;   <span class="comment">//构造函数，初始化str为NULL</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">c_str</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> * s);</span><br><span class="line">~<span class="keyword">String</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line"><span class="keyword">if</span> (str) <span class="keyword">delete</span>[] str;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (str) <span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">String</span> s;</span><br><span class="line">s = <span class="string">"Good Luck"</span>;     <span class="comment">//相当于s.operator = "Good Luck";</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//String s2 = "hello!";   这条语句是错误的，我们并没有定义这样的构造函数</span></span><br><span class="line">s = <span class="string">"C++"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.c_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-重载赋值运算符的意义—浅复制和深复制"><a href="#2-2-重载赋值运算符的意义—浅复制和深复制" class="headerlink" title="2.2.重载赋值运算符的意义—浅复制和深复制"></a>2.2.重载赋值运算符的意义—浅复制和深复制</h2><ul><li><strong>浅复制/浅拷贝</strong>：执行逐个字节的复制工作</li></ul><p>比如利用我们上节定义的<code>String</code>类，它有两个对象<code>S1</code>和<code>S2</code>，利用我们已经重载的复制运算符可以实现直接将一个字符串赋值给一个<code>String</code>对象，如果想进一步将<code>S2</code>直接赋值给<code>S1</code>，在语法上也是没问题的，它会实现浅复制，即将<code>S2</code>对象中的内容逐字节地复制给<code>S1</code>，实际上就是<code>S1.str = S2.str</code>，<strong>两个指针就指向了同一块地址</strong>，但这会引发一些问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> S1, S2;</span><br><span class="line">S1 = <span class="string">"this"</span>;</span><br><span class="line">S2 = <span class="string">"that"</span>;</span><br><span class="line">S1 = S2;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/QQ图片20200216114530.png" style="zoom: 50%;"></p><p>当执行了<code>S1 = S2</code> 后，<code>S1.str</code>和<code>S2.str</code>两个指针指向了同一块地址，这引发了两个问题：第一个是存放”<code>this</code>“字符串的内存没有任何指针来对它进行控制，成为了一个内存垃圾；当<code>S1</code>和<code>S2</code>同时消亡的时候，存放”<code>that</code>“的内存会被释放两次，这会导致严重的内存错误。</p><ul><li>深复制/深拷贝：将一个对象中指针变量指向的内容 $\to$ 复制到另一个对象中指针成员对象指向的地方</li></ul><p><img src="/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/QQ图片20200216120842.png" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span> &amp;s) &#123;</span><br><span class="line"><span class="keyword">if</span> (str) <span class="keyword">delete</span>[] str;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;      <span class="comment">//注意这里返回的是this指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的赋值运算符深拷贝的实现，我们是否已经完全实现了String对象的赋值呢？仔细考虑一下，还会一点小疏漏，就是当执行<code>s = s</code>，即把当前对象赋值给其自身，那么在刚才的重载函数中就会出现一些小问题，当执行<code>strcpy(str, s.str)</code>时会发现我们已经把原来<code>s.str</code>所指的内存空间中的内容删掉了，所以我们要在原来代码基础上加一条if语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span> &amp;s) &#123;</span><br><span class="line"><span class="keyword">if</span> (str == s.str) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (str) <span class="keyword">delete</span>[] str;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面定义的<code>String</code>类还有其他问题嘛？</p><ul><li>需要注意的是：为<code>String</code>类编写<strong>复制构造函数</strong>时，会面临和’=’同样的问题，如果采用浅拷贝或者调用默认的复制构造函数，就会出现问题，为此我们也要采用深拷贝的方式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>(<span class="keyword">String</span> &amp;s) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.str) &#123;</span><br><span class="line">str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.str) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, s.str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-运算符重载为友元函数"><a href="#3-运算符重载为友元函数" class="headerlink" title="3.运算符重载为友元函数"></a>3.运算符重载为友元函数</h1><ul><li>通常，将运算符重载为类的成员函数</li><li>重载为友元函数的情况：<ul><li>成员函数不能满足要求</li><li>普通函数又不能访问类的私有成员</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">double</span> r) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real + r, imag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c = c + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，能实现<code>c = c + 5</code>，相当于<code>c = c.operator +(5)</code>，但不能实现<code>c = 5 + c</code>，如果要实现后者，就需要将’+’重载为普通函数，且要能访问<code>Complex</code>类的私有成员<code>real</code>，因此要将’+’重载为友元函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r);</span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r, <span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="keyword">double</span> r) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real + r, imag);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="keyword">double</span> r, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(c.real + r, c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-实例-长度可变的整型数组类"><a href="#4-实例-长度可变的整型数组类" class="headerlink" title="4.实例-长度可变的整型数组类"></a>4.实例-长度可变的整型数组类</h1><p>C++中的数组的大小（size）是固定的，不能按存放元素的多少自动调整容量，为此我们想自己定义一个长度可变的整型数组类，可以实现下面的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   <span class="comment">//要编写可变长度的整型数组类，使用如下功能</span></span><br><span class="line">CArray a;  <span class="comment">//开始里的数值是空的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">a.push_back(i);</span><br><span class="line">CArray a2, a3;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a2 = a3;  <span class="comment">//a2这时为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a2.length(); ++i)  <span class="comment">//a2.length()为0，所以没有输出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="function">CArray <span class="title">a4</span><span class="params">(a)</span></span>;  <span class="comment">//复制构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a4.length(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a4[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：</p><p><img src="/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/QQ图片20200216143357.png" style="zoom:80%;"></p><p>分析一下需要实现的功能：</p><ul><li>要用动态分配的内存来存放数组元素，需要一个指针成员变量</li><li>要重载’=’</li><li>要重载’[]’，即实现<code>a2[i]</code>，取下标</li><li>有复制构造函数</li></ul><p>这个长度可变的整型数组类可以有下面的代码实现，还是有一些需要注意的点的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CArray</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//数组元素的个数</span></span><br><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指向动态分配的数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CArray(<span class="keyword">int</span> s = <span class="number">0</span>); <span class="comment">//s代表数组元素的个数</span></span><br><span class="line">CArray(CArray &amp;a);</span><br><span class="line">~CArray();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> v)</span></span>;  <span class="comment">//用于在数组尾部添加一个元素v</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;   <span class="comment">//返回数组元素个数</span></span><br><span class="line">CArray &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CArray &amp; a);  <span class="comment">//用于数组对象间的赋值</span></span><br><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">     <span class="comment">//用于支持根据下标访问数组元素，如n = a[i] 和 a[i] = 4</span></span><br><span class="line"> <span class="comment">//若返回类型为int，则不能实现a[i] = 4，因为非引用的函数返回值不能作为左值</span></span><br><span class="line"><span class="keyword">return</span> ptr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CArray::CArray(<span class="keyword">int</span> s) :<span class="built_in">size</span>(s) &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span>[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CArray::CArray(CArray &amp;a) &#123;</span><br><span class="line"><span class="keyword">if</span> (!a.ptr) &#123;</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span>[a.<span class="built_in">size</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*a.<span class="built_in">size</span>);</span><br><span class="line"><span class="built_in">size</span> = a.<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CArray::~CArray() &#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) <span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CArray &amp; CArray::<span class="keyword">operator</span>=(<span class="keyword">const</span> CArray &amp;a) &#123;</span><br><span class="line"><span class="comment">//重载后的赋值号的作用是使'='左边对象里存放的数组，大小和内容都和右边的对象一样</span></span><br><span class="line"><span class="keyword">if</span> (ptr == a.ptr)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (a.ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) <span class="keyword">delete</span>[] ptr;</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> &lt; a.<span class="built_in">size</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span>[a.<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(ptr, a.ptr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*a.<span class="built_in">size</span>);</span><br><span class="line"><span class="built_in">size</span> = a.<span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CArray::push_back(<span class="keyword">int</span> v) &#123;</span><br><span class="line"><span class="keyword">if</span> (ptr) &#123;</span><br><span class="line"><span class="keyword">int</span> *tmpPtr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">size</span> + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmpPtr, ptr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">ptr = tmpPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">ptr[<span class="built_in">size</span>++] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-流插入和流提取运算符的重载"><a href="#5-流插入和流提取运算符的重载" class="headerlink" title="5.流插入和流提取运算符的重载"></a>5.流插入和流提取运算符的重载</h1><ul><li><code>cout</code>是在<code>iostream</code>中定义的，<code>ostream</code>类的对象。</li><li><p>“&lt;&lt;” 能用在<code>cout</code>上是因为在<code>iostream</code>里对”&lt;&lt;”进行了重载</p></li><li><p><code>cin</code>是在<code>iostream</code>中定义的，<code>istream</code>类的对象。</p></li><li>“&gt;&gt;” 能用在<code>cin</code>上是因为在<code>istream</code>里对”&gt;&gt;”进行了重载</li></ul><p>例子：假设c是<code>Complex</code>复数类的对象，实现<code>cout&lt;&lt;c;</code> 能输出”a+bi”形式，<code>cin&gt;&gt;c</code> 能从键盘接受”a+bi”形式的输入。</p><p>为此我们需要把&lt;&lt;和&gt;&gt;重载成全局函数，因为它们已经是<code>ostream</code>和<code>istream</code>的成员函数了；又因为它们需要访问<code>Complex</code>类的私有成员，因此要声明成<code>Complex</code>类的友元函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Complex(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) :real(r), imag(i) &#123; &#125;;</span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Complex &amp;c);</span><br><span class="line"><span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Complex &amp;c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Complex &amp;c) &#123;</span><br><span class="line">os &lt;&lt; c.real &lt;&lt; <span class="string">"+"</span> &lt;&lt; c.imag &lt;&lt; <span class="string">"i"</span>;  <span class="comment">//以“a+bi”的形式输出</span></span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, Complex &amp;c) &#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">is &gt;&gt; s;  <span class="comment">//将"a+bi"作为字符串读入，"a+bi"中间不能有空格</span></span><br><span class="line"><span class="keyword">int</span> pos = s.<span class="built_in">find</span>(<span class="string">"+"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">string</span> sTmp = s.substr(<span class="number">0</span>, pos);  <span class="comment">//分离出代表实部的字符串</span></span><br><span class="line">c.real = atof(sTmp.c_str());</span><br><span class="line"><span class="comment">//atof库函数能将const char* 指针指向的内容转换成float</span></span><br><span class="line">sTmp = s.substr(pos + <span class="number">1</span>, s.length() - pos - <span class="number">2</span>);  <span class="comment">//分离出代表虚部的字符串</span></span><br><span class="line">c.imag = atof(sTmp.c_str());</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Complex c;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">","</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果示例：</p><p><img src="/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/QQ图片20200217094938.png" style="zoom:80%;"></p><h1 id="6-自加-自减运算符的重载"><a href="#6-自加-自减运算符的重载" class="headerlink" title="6.自加/自减运算符的重载"></a>6.自加/自减运算符的重载</h1><ul><li>自加++/自减—运算符有前置/后置之分：<ul><li>前置++（++a）：先加1，再执行语句</li><li>后置++（a++）：先执行语句，再加1</li></ul></li><li><p>前置运算符作为一元运算符重载：</p><ul><li>重载为成员函数：<code>T operator++();</code>   ， <code>T operator--();</code></li><li>重载为全局函数：<code>T operator++(T);</code>   ， <code>T operator--(T);</code></li><li>如<code>++obj</code>，<code>obj.operator++()</code>，<code>operator++(obj)</code>都是调用上述前置运算符</li></ul></li><li><p>后置运算符作为二元运算符重载：（多写的参数只是标记重载的运算符为后置，并无具体意见）</p><ul><li>重载为成员函数：<code>T operator++(int);</code>   ， <code>T operator--(int);</code></li><li>重载为全局函数：<code>T operator++(T, int);</code>   ， <code>T operator--(T, int);</code></li><li>如<code>obj++</code>，<code>obj.operator++(0)</code>，<code>operator++(obj, 0)</code>都是调用上述前置运算符</li></ul></li></ul><p>例子：我们希望设计一个CDemo对象来实现下面的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">CDemo <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (d++) &lt;&lt; <span class="string">","</span>;   <span class="comment">//等价于d.operator++(0);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">","</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (++d) &lt;&lt; <span class="string">","</span>;   <span class="comment">//等价于d.operator++();</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (d--) &lt;&lt; <span class="string">","</span>;   <span class="comment">//等价于operator--(d,0);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">","</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (--d) &lt;&lt; <span class="string">","</span>;   <span class="comment">//等价于operator--(0);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="/2020/02/16/Cpp%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/QQ图片20200217105531.png" style="zoom:80%;"></p><p>我们首先需要设计<code>CDemo</code>对象的自加自减运算符，再注意<code>cout&lt;&lt;d</code>语句它会将<code>CDemo</code>对象直接输出为整型数，而<code>cout</code>并没有这样的功能，它不支持任意自定义类型的输出，因此要设计一个强制类型转换符的一个运算符重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CDemo(<span class="keyword">int</span> i=<span class="number">0</span>):n(i)&#123; &#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>++();     <span class="comment">//前置++，重载为成员函数</span></span><br><span class="line">CDemo <span class="keyword">operator</span>++(<span class="keyword">int</span>);  <span class="comment">//后置++</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> n; &#125;  </span><br><span class="line"><span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo &amp;);  <span class="comment">//前置--，重载为全局函数(仅做示例，重载为成员函数亦可）</span></span><br><span class="line"><span class="keyword">friend</span> CDemo <span class="keyword">operator</span>--(CDemo &amp;, <span class="keyword">int</span>);  <span class="comment">//后置--</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++() &#123;  <span class="comment">//前置++</span></span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span>++(<span class="keyword">int</span> k) &#123;  <span class="comment">//后置++</span></span><br><span class="line"><span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo &amp; d) &#123;  <span class="comment">//前置++</span></span><br><span class="line">d.n--;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">CDemo <span class="keyword">operator</span>--(CDemo &amp;d,<span class="keyword">int</span> k) &#123;  <span class="comment">//后置++</span></span><br><span class="line"><span class="function">CDemo <span class="title">tmp</span><span class="params">(d)</span></span>;</span><br><span class="line">d.n--;</span><br><span class="line"><span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意语句<code>operator int() { return n; }</code>  ：</p><ul><li>此时Int作为一个类型强制转换运算符被重载（而不是整型类型了）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CDemo s;</span><br><span class="line">(<span class="keyword">int</span>)s;  <span class="comment">//等效于s.int();</span></span><br></pre></td></tr></table></figure><ul><li>类型强制转换运算符重载时：<ul><li>不能写返回值类型</li><li>实际上返回值类型——类型强制转换运算符代表的类型</li></ul></li></ul><p><strong>运算符重载的注意事项</strong>：</p><ul><li>C++不允许定义新的运算符</li><li>重载后运算符的含义应该符合日常习惯</li><li>运算符重载不改变运算符的优先级</li><li>一下运算符不能被重载：’<code>.</code>‘，’<code>.*</code>‘，’<code>::</code>‘，’<code>?:</code>‘，<code>sizeof</code></li><li>重载运算符<code>()</code>，<code>[]</code>，<code>-&gt;</code>，<code>=</code>时，重载函数必须声明为类的成员函数</li></ul>]]></content>
    
    <summary type="html">
    
      运算符重载可以使抽象的数据类型也能够使用C++提供的传统运算符，从而使代码非常的简洁，也容易理解。
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（6）选择排序与插入排序</title>
    <link href="http://nekomoon404.github.io/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-15T11:22:47.000Z</published>
    <updated>2020-02-16T02:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h1><p>与向量那一章的做法一样列表这一章的接下来几节，也将针对列表这种结构的特点介绍几种典型的排序算法，这一节要介绍的是选择排序。</p><h2 id="1-1-构思"><a href="#1-1-构思" class="headerlink" title="1.1.构思"></a>1.1.构思</h2><p>选择排序在生活中其实很常见，举个例子，假设有一篮子苹果或大或小，如果你需要从小到大把它们排成一个序列，那你会怎么做呢？常用的一种方法应该是这样的：首先在其中挑选出最大的，接下来在剩下的中挑选出最大的，即整体中次大的，如此反复，直到篮子中只剩下最后那只苹果。</p><p>可以看出在这个过程中我们所采用的策略，原则非常的简单，就是每一次只需在篮子中找出当前最大的那只苹果，并且随即将它转移到桌子上。这里每一步所做的实质的关键动作就是所谓的选择select，而基于这样一种选择过程和策略的排序算法就叫作<strong>选择排序</strong>（selection sort）。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200215194320.png" style="zoom:50%;"></p><p>回顾一下此前所介绍过的起泡排序bubble sort，其实它也是selection sort。在起泡算法的过程中它的不变性可以表述为整个序列总是可以分成前后两个部分，其中后面的一个部分是由一系列已经就位的元素组成的，它们构成了一个有序的sorted的部分；而前半部分的元素数值的分布是随机的或大或小，但是就数值而言它们都绝对不会超过图中的黄线。这个算法是由一趟又一趟的扫描交换构成的，在接下来的一趟扫描交换中最实质的操作实际上是当前最大的那个元素和其后的元素不断地交换，直到它最终被移送到黄色区域的末尾。于是这个有序的S部分就可以向左侧拓展，这也就是起泡排序算法的单调性。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200215194329.png" style="zoom:50%;"></p><p>纵观这个过程并且与上面的选择排序做一对比，我们会发现二者之间的<strong>相似之处</strong>：也就是每一次扫描交换的作用其实实质上都等价于找到这个最大节点，并且随即将它转移至有序和无序子序列的分界点。从这个角度来看<br>起泡排序确实就是一个不折不扣的选择排序。</p><p>那反过来既然如此还有什么必要去专门讨论选择排序呢？原因在于起泡排序的效率太低，在最坏情况下它需要$O(n^2)$的时间，而借助列表结构这个效率是完全可以改进的。在起泡排序的过程中所执行的计算无非两类，一类就是相邻元素的比较，另一类才是元素位置的交换。然而很遗憾在这里将最大元素转移至合适的位置这样一个任务，是由一系列的短距离实际上是相邻元素之间的移动构成的，这种“小步慢跑式”的移动正是低效率的来源。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200215194333.png" style="zoom: 45%;"></p><p>所以既然我们最终无非就是要将这个最大的元素挪到最终的位置，为何不直接一次性地来完成这项工作呢？这正是我们改进的思路。</p><h2 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2.实现"></a>1.2.实现</h2><p>选择排序selection sort可以实现为下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表的选择排序算法：对起始于位置p的n个元素排序，valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="keyword">void</span> List&lt;T&gt;::selectionSort(Posi(T) p, <span class="keyword">int</span> n) &#123; </span><br><span class="line"> Posi(T) head = p-&gt;pred; ePosi(T) tail = p;  <span class="comment">//待排序区间为(head, tail)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tail = tail-&gt;succ;  <span class="comment">//head/tail可能是头/尾哨兵</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span> &lt; n) &#123; <span class="comment">//反复从（非平凡的）待排序区间内找出最大者，并将其移至无序区间末尾</span></span><br><span class="line">       insertBefore(tail, <span class="built_in">remove</span>(selectMax(head-&gt;succ, n))); </span><br><span class="line">       tail = tail-&gt;pred; n--;   <span class="comment">//待排序区间、有序区间的范围、均同步更新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下这个接口的语义，待排序的元素实际上是在列表中起始于位置<code>p</code>的连续<code>n</code>个元素，在下面的图示中，如果<code>L</code>是整个的列表那么待排序的区间，从节点p开始第n个节点是用虚线表示的，言下之意这里依然采用了此前<strong>左闭右开的区间定义习惯</strong>。相应地 这里引入了两个界桩<code>head</code>和<code>tail</code>。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200215194341.png" style="zoom: 50%;"></p><p>经过入口处预处理的两步，<code>head</code>和<code>tail</code>分别对应的位置就是在这个图中的<code>h</code>以及<code>p+n</code>，在接下来的循环中 <code>head</code>始终不变，而<code>tail</code>会每次向前移动一个节点。而从tail开始到最初的界桩之间的范围正是已经排序的区间，而尚未排序的的前缀U是从<code>p</code>一直到<code>T</code>左闭右开的区间，这也是这个算法的不变性。</p><p>从算法可以看出每次我们都调用<code>selectMax</code>的接口，从前缀U这个区间中找到当前的最大者，n会随着迭代地进行相应地下降，从记录前缀U的宽度。在这个图中被选取出来的最大节点以M来表示，我们将M节点摘出来<br>插入至S区间的首节点，<code>tail</code>的前端，相当于将M移动到此前的<code>T</code>的紧邻左侧，并且随即将<code>T</code>移动到新的这个节点处（M处），从而使有序的部分向左拓展一个单元。这个算法将持续地迭代下去，直到n最终缩减到平凡的情况，从而完成整个指定区域的排序。</p><h2 id="1-3-推敲"><a href="#1-3-推敲" class="headerlink" title="1.3.推敲"></a>1.3.推敲</h2><p>现在来重新审视一下这个算法并且对其中的几个细节来做一推敲，第一个问题是算法中套用了此前所实现的<code>remove</code>和<code>insert</code>这两个标准的操作接口，使整个代码实现更加简洁，但从效率而言还是值得推敲的。这其中的原因在于，这两个操作都要使用到动态空间分配，也就是<code>insert</code>的时候必须要用<code>new</code>，<code>remove</code>的时候需要<code>delete</code>。</p><p>虽然这两个操作都可以大致认为依然是常数的时间复杂度，但是从实际的时间消耗而言它大致是通常的基本操作的一百倍，也就是说要高出两个数量级，因此在实际中这一对操作应该尽可能少的使用。就这个意义而言，或许应该改用另外一种实现方式，比如可以只通过对M处和T处局部引用的修改，来实现同样的功能；另外一种可行的方式就是只需将M与T当前的前驱直接交换它们的数据域即可。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200215203558.png" style="zoom:67%;"></p><p>另一问题是有些情况下，对M的搬动操作其实是不必进行的，如果这个最大节点M恰好正是<code>tail</code>的直接前驱<br>那么它自然已经就位，当然也就无需搬动了。基于这个观察，或许你会倾向于去做这样一种优化：在搬运M前加一条if语句。这样一种改进的方式本身的确是可行的，但是我们并不认为这是一个优化，其中的原因在于，在通常的随机分布下这种情况出现的概率极低（$\ln n/n \to 0$），以致于我们这里所做的这种所谓的优化会得不偿失。</p><h2 id="1-4-实现：selectMax"><a href="#1-4-实现：selectMax" class="headerlink" title="1.4.实现：selectMax()"></a>1.4.实现：selectMax()</h2><p><code>selectMax()</code>接口的实现很朴实，从首节点出发逐一地进行比对，并且在这样的一个过程中记录下当前最大的元素，当我们抵达终点时，这个最终的记录就是我们所要找的最大节点。这个过程可以实现为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//从起始于位置p的n个元素中选出最大者</span></span><br><span class="line">Posi(T) List&lt;T&gt;::selectMax(Posi(T) p, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    Posi(T) <span class="built_in">max</span> = p; <span class="comment">//最大者暂定为首节点p</span></span><br><span class="line"><span class="keyword">for</span> (Posi(T) cur = p; <span class="number">1</span> &lt; n; n--) <span class="comment">//从首节点p出发，将后续节点逐一与max比较</span></span><br><span class="line"><span class="keyword">if</span> (!lt((cur = cur-&gt;succ)-&gt;data, <span class="built_in">max</span>-&gt;data)) <span class="comment">//若当前元素不小于max，则</span></span><br><span class="line">    <span class="built_in">max</span> = cur; <span class="comment">//更新最大元素位置记录</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>; <span class="comment">//返回最大节点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我们这里所采用的比较器是not less than ，也就是<strong>不小于</strong>（当前元素不小于max），只要当前的这个节点大于或等于目前的max，就需要做相应的更新。这是接口语义要求的，如果序列有最大的元素有多个的话，这样可以返回其中最靠后的那个（秩最大的那个），而这个元素也相应地会被优先地转移到sorted的那部分，就总体效果而言所有的这些重复元素都会依次地转移到相应的位置上去，从而保证算法的稳定性。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216164511.png" style="zoom:67%;"></p><h2 id="1-5性能"><a href="#1-5性能" class="headerlink" title="1.5性能"></a>1.5性能</h2><p>选择排序的性能如何呢？这个算法仍是由n次迭代完成的，在第k次迭代中：</p><ul><li><code>selectMax()</code>为$\Theta(n-k)$，算术级数</li><li><code>remove()</code>和<code>insertBefore()</code>均为$O(1)$</li></ul><p>故总体复杂度为$\Theta(n^2)$。（无论最大元素在哪都需要$n^2$，不分最好最坏情况，因此用$\Theta$）</p><p>选择排序居然和起泡排序的效果一样嘛？其实还是有区别的，就这里所涉及的两类操作：节点的移动以及比较大小而言，前者在实际效果也就是常系数的意义下要复杂的多得多，需要花费远远更多的时间，因此这里能够对移动次数做改进，使得每一趟扫描所需要的移动操作从原来的n降至1，实际上是一个非常了不起的改进。那么比较操作同样可以进一步地改进，等到后面的第十章优先级队列中，将会借助精巧的数据结构，使<code>selectMax()</code>可以$\log n$<br>而不是$n$的时间内完成。</p><h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h1><h2 id="2-1经验"><a href="#2-1经验" class="headerlink" title="2.1经验"></a>2.1经验</h2><p>插入排序也是一种生活中很常见的排序算法，比如在发牌时整理手上的牌[・_・?]，我们可能会这样做：将手牌先按大小整理好，接下来拿到新牌后再按照大小插入到手牌中相应的位置，这其实就是插入排序。</p><p>在每次这样的过程中，我们所做的工作无非两步：第一步就是由这条绿色的线所标明的去做一个定位，即寻找到要插入的位置；接下来的动作实际上是两个更小的步骤的组合，首先将更小的牌向左移动以腾出一个空余位置，然后将新牌插入到那个位置。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216171814.png" style="zoom: 50%;"></p><h2 id="2-2构思"><a href="#2-2构思" class="headerlink" title="2.2构思"></a>2.2构思</h2><p>在插入排序算法的整个过程中我们始终将输入序列视作两个部分：有序部分+无序部分</p><ul><li><p><strong>Sorted</strong> + <strong>Unsorted</strong></p><p><strong>L[0,  r)</strong>   +  <strong>L[r,  n)</strong></p></li></ul><p>接下来是迭代的过程，在每一次迭代中将当前秩为r的元素<code>e</code>插入到前面的Sorted部分的合适位置，使之保持有序，这样待解决问题的规模就减一，这也是这个算法的不变性。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216173432.png" style="zoom: 50%;"></p><ul><li><p>【初始化】置$S_0$为空序列（长度为0）     //空序列自然有序</p></li><li><p>【迭代】在有序的$S_r$ = S[0,  r)中确定适当位置       //有序序列的查找</p><p>​                插入S[r]，得到有序的$S_{r+1}$ = S[0,  r]        //有序序列的插入</p></li><li><p>如此，可逐步得到：$S_0,S_1,\dots,S_n$，最终，$S_n$ = S[0,  n)即排序序列</p></li><li><p>正确性基于以下不变性：$\forall$ 0&lt;= r &lt;= n，$S_r$ = 前r个元素组成的有序序列</p></li></ul><h2 id="2-3对比"><a href="#2-3对比" class="headerlink" title="2.3对比"></a>2.3对比</h2><p>介绍到这你可能会有疑问，排序排序和选择排序看起来是一回事啊？但其实它们是截然不同的两种算法，这里先来看一下两者在整体策略上的区别。</p><p>第一个区别：<strong>insertion sort</strong>有序部分和无序部分的次序左右颠倒，而在<strong>selection sort</strong>中 有序部分是后缀，无序的部分才是前缀，当然这不是很重要φ(&gt;ω&lt;*) 。</p><p>第二个区别：在选择排序中，无序的前缀部分始终保持着一个不变性，也就是无序部分的所有元素都不会超过有序部分的最小元素（第一个）；反观插入排序，并没有这样的规定，有序部分的k个元素仅仅是序列中的前k个元素，要插入的元素可能是任意大小。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216172318.png" style="zoom:50%;"></p><h2 id="2-4-实现"><a href="#2-4-实现" class="headerlink" title="2.4.实现"></a>2.4.实现</h2><p>将插入排序的过程实现为下面一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列表的插入排序算法：对起始于位置p的n个元素排序，valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="keyword">void</span> List&lt;T&gt;::insertionSort(Posi(T) p, <span class="keyword">int</span> n) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123; <span class="comment">//逐一为各节点</span></span><br><span class="line">insertAfter(search(p-&gt;data, r, p), p-&gt;data); <span class="comment">//查找适当的位置并插入</span></span><br><span class="line">    p = p-&gt;succ; <span class="built_in">remove</span>(p-&gt;pred); <span class="comment">//转向下一节点</span></span><br><span class="line">&#125;  <span class="comment">//n次迭代</span></span><br><span class="line">&#125;  <span class="comment">//仅使用O(1)辅助空间，属于就地算法</span></span><br></pre></td></tr></table></figure><p><code>p</code>一开始指向序列的起点，经过一次迭代p后移一位，它始终是有序部分和无序部分的界点。<code>search(p-&gt;data, r, p)</code>返回有序部分中不大于p的最大元素（最靠后），接着将值为<code>p-&gt;data</code>的节点插入其后（注意这里并不是将<code>p</code>直接插入到那位置），然后将<code>p</code>转向它的后继<code>p-&gt;succ</code>，并删除原来的<code>p</code>。</p><p>整个算法过程中，除了输入的列表自己本身以外，只需要$O(1)$的额外辅助空间，这种算法被称为<strong>就地算法</strong>（in-place algorithm ）。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216175658.png" style="zoom: 67%;"></p><h2 id="2-5-性能"><a href="#2-5-性能" class="headerlink" title="2.5.性能"></a>2.5.性能</h2><ul><li><p>最好情况：完全（或几乎）有序</p><p>每次迭代，只需1次比较，0次交换；累计$O(n)$时间 ！（而选择排序无论好坏都是$\Theta(n^2)$）</p></li></ul><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216182530.png" style="zoom: 33%;"></p><ul><li><p>最坏情况：完全（或几乎）逆序</p><p>第k次迭代，需要$O(k)$次比较，1次交换；累计$O(n^2)$时间</p></li></ul><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216182534.png" style="zoom:33%;"></p><p>你可能会想，既然是在一个有序部分中查找，那为什么不用二分查找呢[・_・?]，可以把比较次数降到$O(\log k)$。其实是不行的，因为列表不支持这种循秩访问的方式，而向量是可以的。</p><p>那为啥不用向量实现插入排序呢[・ヘ・?]。如果用向量的话，在插入操作时，我们必须将所插入元素之后的元素整体向后移一个单位，这样每次迭代仍然是需要$O(n)$时间，所以就最坏的情况而言，改用向量结构对于插入排序的改进于事无补。</p><h2 id="2-6-平均性能"><a href="#2-6-平均性能" class="headerlink" title="2.6.平均性能"></a>2.6.平均性能</h2><p>上节分析插入排序在最好和最坏情况下的时间复杂度，那么在一般情况下呢？</p><p>假定各元素的取值遵守均匀，独立分布，那么平均要做多少次比较呢？</p><p>为此需要采用一种方法：<strong>后向分析</strong>（backward analysis），我们把时间拉回到某个元素，比如第r个元素刚刚完成插入的那个时刻，在此之前有序前缀长度为r，现在长度为r+1。那么插入这个元素需要花费多少时间呢？由于插入元素的大小是不确定的，而且它插在不同位置上对应的成本也不同。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216195124.png" style="zoom:50%;"></p><p>但是由于我们采用的是均匀独立分布的假设，那么对于现在有序前缀中的r+1个元素中，<strong>每个元素都可能是刚刚插入的那个元素，其概率是相等的</strong>，为$1/(r+1)$。为了估算刚才那一步迭代的时间成本，我们将每一个元素作为刚插入元素完成插入所对应的成本累计起来，求期望：</p><script type="math/tex; mode=display">\left[ r+(r-1)+\dots+3+2+1+0\right]/(r+1)+1=r/2+1</script><p>于是，整个过程的总体期望是：</p><script type="math/tex; mode=display">\left[ 0+1+\dots+(n-1)\right]/2+1=O(n^2)</script><p>所以插入排序的平均复杂度依然是$O(n^2)$，与它在最坏情况下是同阶的，换而言之，虽然它有最好情况复杂度为$O(n)$，但这种情况发生的概率极低。</p><h2 id="2-7-逆序对"><a href="#2-7-逆序对" class="headerlink" title="2.7.逆序对"></a>2.7.逆序对</h2><p>最后来看一个与插入排序非常相关的一个概念：逆序对（inversion）。实际上在一个由n个元素构成的序列中，任何两个元素都有可能构成逆序对，其逆序对的总数接近$n^2$。逆序对涉及到两个元素，我们不妨把逆序对这个标记记到后边元素上，对应一个节点p，可以用$i(p)$来表示节点p对应的逆序对数的总和，那么整个序列的逆序对总数为：</p><script type="math/tex; mode=display">I=\sum_p i(p)</script><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216200259.png" style="zoom:50%;"></p><p>在插入排序中，当要把节点p插入到前面的有序序列S的适当位置时，p所对应的逆序对的个数就是p要经过的比较的次数，$i(p)$其实就是p所对应的查找长度。因此$I$就对应着整个插入排序算法所需要的比较次数的总和，这是算法所消耗时间的主要部分，再加上每n步插入所需要的时间一共是$n$，那么插入排序的复杂度就是$O(I+n)$。</p><p><img src="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/QQ图片20200216200305.png" style="zoom:50%;"></p><p>如果把整个序列的逆序对总数$I$作为序列无序程度的度量尺度，那么插入排序insertion sort就可以理解为是通过一次一次的努力去修复这种无序性。因此它的算法复杂度其实不光是取决于问题的规模，而更多的是取决于输入序列本身所具有的特性即它的无序程度，所以这样一种算法也称作<strong>输入敏感的</strong>（input-sensitive）。在排序算法家族中并非每一种算法都具有这样的一个特性，而插入排序也正因为它具有这样一个特性，而显得非常的独特。在之后要介绍的希尔排序（Shell sort）中，我们将会看到这种输入敏感的特性对于希尔排序整体的性能，乃至这个算法的有效性都是至关重要的。</p>]]></content>
    
    <summary type="html">
    
      本文针对列表这种结构的特点，介绍两种典型的排序算法：选择排序与插入排序。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（5）列表</title>
    <link href="http://nekomoon404.github.io/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/</id>
    <published>2020-02-14T12:33:23.000Z</published>
    <updated>2020-02-15T12:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本章的主题是列表，与向量一样列表也是典型的最基本的一类线性结构，但是列表结构与向量结构在几乎所有的方面都是对称的、互补的，因此它的特点也十分的鲜明。本文主要介绍列表的接口与实现，无序列表和有序列表。</p><h1 id="1-接口与实现"><a href="#1-接口与实现" class="headerlink" title="1.接口与实现"></a>1.接口与实现</h1><h2 id="1-1-从静态到动态"><a href="#1-1-从静态到动态" class="headerlink" title="1.1.从静态到动态"></a>1.1.从静态到动态</h2><ul><li><p>根据是否修改数据结构，所有操作大致分为两类方式：</p><ul><li>静态：仅读取，数据的内容及组成一般不变：get、search</li><li>动态：需写入，数据结构的局部或整体将改变：insert、remove</li></ul></li><li><p>与操作方式相对应地，数据元素的存储于组织方式也分为两种</p><ul><li><p>静态：数据空间整体创建或销毁</p><p>​            数据元素的物理存储次序与其逻辑次序严格一致</p><p>​            可支持高效的静态操作</p><p>比如向量，元素的物理地址与其逻辑次序线性对应</p></li><li><p>动态：为各数据元素动态地分配和回收的物理空间</p><p>​            逻辑上相邻的元素记录彼此的物理地址</p><p>​            形成一个整体可支持高效的动态操作</p><p>这里的代表就是我们这一章的主题：列表</p></li></ul></li></ul><h2 id="1-2-从向量到列表"><a href="#1-2-从向量到列表" class="headerlink" title="1.2.从向量到列表"></a>1.2.从向量到列表</h2><ul><li><p>列表（list）是采用动态存储策略的典型结构</p><ul><li>其中的元素称作<strong>节点</strong>（node）</li><li>各节点通过指针或引用彼此联接，构成一个逻辑上的线性序列：$L=\{a_0,a_1,\dots,a_{n-1}\}$</li></ul></li><li><p>相邻节点彼此互称<strong>前驱</strong>（predecessor）或<strong>后继</strong>（successor）</p><ul><li>前驱或后继若存在，则必然唯一</li></ul></li><li>一个序列中的第一个元素称为<strong>首节点</strong>（没有前驱），最后一个元素称为<strong>末节点</strong>（没有后继）</li></ul><p>以下图为例，对于任何一个列表而言，首先都有一个入口的位置，所有的元素确实可以从入口开始沿着它们之间的引用，依次地从相对的前驱转向后继以及后继的后继，直到最终的末节点。虽然在逻辑上它们是这样的一个排列的次序，但是在物理上却远远不是。但是这样不妨碍它们定义并且实现这样的一个次序，比如说从某一个位置出发，我们可以找到它的物理位置并且访问它，接下来可以顺着它的后继的引用找到它的后继，以及再顺着后继的引用找到后继的后继，诸如此类直到最终抵达末节点，从而退出这个列表。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214210536.png" style="zoom:67%;"></p><h2 id="1-3-从秩到位置"><a href="#1-3-从秩到位置" class="headerlink" title="1.3.从秩到位置"></a>1.3.从秩到位置</h2><ul><li><p>向量支持循秩访问（call-by-rank）的方式，根据数据元素的秩，可在$O(1)$时间内直接确定其物理地址，</p><p>V[i] 的物理地址 = V + i × s，s为单个单元占用的空间量</p></li><li><p>既然同属线性序列，列表固然也可通过秩找到对应的元素</p><p>为找到秩为<code>i</code>的元素，须从头（尾）端出发，沿引用前进（后退）<code>i</code>步</p></li><li><p>然而因为成本过高，此时的循秩访问已不合时宜</p><p>以平均分布为例，单次访问的期望复杂度为$(n+1)/2=O(n)$</p></li><li><p>因此，应改用循位置访问（call-by-position）的方式访问列表元素，也就是说，应转而利用结点之间的相互引用，找到特定的节点</p></li></ul><h2 id="1-4-实现"><a href="#1-4-实现" class="headerlink" title="1.4.实现"></a>1.4.实现</h2><h3 id="1-4-1列表节点：ADT接口"><a href="#1-4-1列表节点：ADT接口" class="headerlink" title="1.4.1列表节点：ADT接口"></a>1.4.1列表节点：ADT接口</h3><ul><li>作为列表的基本元素，列表节点首先需要独立地“封装”实现。为此，可设置并约定若干基本的操作接口</li></ul><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214123.png" style="zoom: 67%;"></p><h3 id="1-4-2-列表节点：ListNode模板类"><a href="#1-4-2-列表节点：ListNode模板类" class="headerlink" title="1.4.2.列表节点：ListNode模板类"></a>1.4.2.列表节点：ListNode模板类</h3><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214127.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Posi(T) ListNode<span class="meta-string">&lt;T&gt;* //列表节点位置（ISO C++.0x，template alias）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//简洁起见，完全开放而不再过度封装</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span> <span class="comment">//列表节点模板类（以双向链表形式实现）</span></span><br><span class="line">T data;  <span class="comment">//数值</span></span><br><span class="line">Posi(T) pred; <span class="comment">//前驱</span></span><br><span class="line">Posi(T) succ; <span class="comment">//后继</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ListNode() &#123;&#125;   <span class="comment">//针对header和trailer的构造</span></span><br><span class="line">ListNode(T e, Posi(T) p = <span class="literal">NULL</span>, Posi(T) s = <span class="literal">NULL</span>)</span><br><span class="line">: data(e), pred(p), succ(s) &#123;&#125; <span class="comment">//默认构造器</span></span><br><span class="line"> <span class="comment">// 操作接口</span></span><br><span class="line">Posi(T) insertAsPred(T <span class="keyword">const</span>&amp; e); <span class="comment">//紧靠当前节点之前插入新节点</span></span><br><span class="line">Posi(T) insertAsSucc(T <span class="keyword">const</span>&amp; e); <span class="comment">//紧随当前节点之后插入新节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-3列表：ADT接口"><a href="#1-4-3列表：ADT接口" class="headerlink" title="1.4.3列表：ADT接口"></a>1.4.3列表：ADT接口</h3><p>在给出列表结构的具体实现之前，首先定义一组它所应该提供的操作接口，仔细看会发现它的接口的形式以及对应的功能与第二章中所学过的向量Vector结构颇为类似，这里逐一再展开了，在后边相应的各节将对它们的功能和实现再做详细的介绍。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214131.png" style="zoom: 67%;"></p><h3 id="1-4-4-列表：List模板类"><a href="#1-4-4-列表：List模板类" class="headerlink" title="1.4.4.列表：List模板类"></a>1.4.4.列表：List模板类</h3><p>接下来介绍列表也就是List这种模板类的具体定义，首先要引入刚才所实现的列表节点类，可以看到<code>List</code>这种模板类也是分为三个层次，其中private 私有的层次与向量类似，记录的都是那些对外不可见的部分，具体包括规模、引入两个哨兵节点。另外也包括一些内部的功能函数，以及刚才我们所定义的那些对外开放的标准ADT接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"listNode.h"</span> <span class="comment">//引入列表节点类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span> <span class="comment">//列表模板类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _size; Posi(T) header; Posi(T) trailer; <span class="comment">//规模、头哨兵、尾哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">//列表创建时的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清除所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyNodes</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//复制列表中自位置p起的n项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Posi(T)&amp;, <span class="keyword">int</span>, List&lt;T&gt;&amp;, Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Posi(T)&amp;, <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(Posi(T), <span class="keyword">int</span>)</span></span>; <span class="comment">//对从p开始连续的n个节点插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    List() &#123; init(); &#125; <span class="comment">//默认</span></span><br><span class="line">List(List&lt;T&gt; <span class="keyword">const</span>&amp; L); <span class="comment">//整体复制列表L</span></span><br><span class="line">List(List&lt;T&gt; <span class="keyword">const</span>&amp; L, Rank r, <span class="keyword">int</span> n); <span class="comment">//复制列表L中自第r项起的n项</span></span><br><span class="line">List(Posi(T) p, <span class="keyword">int</span> n); <span class="comment">//复制列表中自位置p起的n项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">    ~List(); <span class="comment">//释放（包含头、尾哨兵在内的）所有节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读访问接口</span></span><br><span class="line"><span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size &lt;= <span class="number">0</span>; &#125; <span class="comment">//判空</span></span><br><span class="line">T&amp; <span class="keyword">operator</span>[] (Rank r) <span class="keyword">const</span>; <span class="comment">//重载，支持循秩访问（效率低）</span></span><br><span class="line">Posi(T) first() <span class="keyword">const</span> &#123; <span class="keyword">return</span> header-&gt;succ; &#125; <span class="comment">//首节点位置</span></span><br><span class="line">Posi(T) last() <span class="keyword">const</span> &#123; <span class="keyword">return</span> trailer-&gt;pred; &#125; <span class="comment">//末节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(Posi(T) p)</span> <span class="comment">//判断位置p是否对外合法</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> p &amp;&amp; (trailer != p) &amp;&amp; (header != p); &#125; <span class="comment">//将头、尾节点等同于NULL</span></span><br><span class="line">Posi(T) <span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e) <span class="keyword">const</span> <span class="comment">//无序列表查找</span></span><br><span class="line">      &#123; <span class="keyword">return</span> <span class="built_in">find</span>(e, _size, trailer); &#125;</span><br><span class="line">Posi(T) <span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span>; <span class="comment">//无序区间查找</span></span><br><span class="line">Posi(T) search(T <span class="keyword">const</span>&amp; e) <span class="keyword">const</span> <span class="comment">//有序列表查找</span></span><br><span class="line">  &#123; <span class="keyword">return</span> search(e, _size, trailer); &#125;</span><br><span class="line">Posi(T) search(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span>; <span class="comment">//有序区间查找</span></span><br><span class="line">Posi(T) selectMax(Posi(T) p, <span class="keyword">int</span> n); <span class="comment">//在p及其n-1个后继中选出最大者</span></span><br><span class="line">Posi(T) selectMax() &#123; <span class="keyword">return</span> selectMax(header-&gt;succ, _size); &#125; <span class="comment">//整体最大者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写访问接口</span></span><br><span class="line">Posi(T) insertAsFirst(T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作首节点插入</span></span><br><span class="line">Posi(T) insertAsLast(T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作末节点插入</span></span><br><span class="line">Posi(T) insertA(Posi(T) p, T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作p的后继插入（After）</span></span><br><span class="line">Posi(T) insertB(Posi(T) p, T <span class="keyword">const</span>&amp; e); <span class="comment">//将e当作p的前驱插入（Before）</span></span><br><span class="line"><span class="function">T <span class="title">remove</span><span class="params">(Posi(T) p)</span></span>; <span class="comment">//删除合法位置p处的节点,返回被删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(List&lt;T&gt;&amp; L)</span> </span>&#123;merge(first(), <span class="built_in">size</span>, L, L.first(), L._size);&#125;<span class="comment">//全列表归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Posi(T) p, <span class="keyword">int</span> n)</span></span>; <span class="comment">//列表区间排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort(first(), _size); &#125; <span class="comment">//列表整体排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>; <span class="comment">//无序去重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>; <span class="comment">//有序去重</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>; <span class="comment">//前后倒置（习题）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">void</span>(*) (T&amp;))</span></span>; <span class="comment">//遍历，依次实施visit操作（函数指针，只读或局部性修改）</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> VST&gt; <span class="comment">//操作器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(VST&amp;)</span></span>; <span class="comment">//遍历，依次实施visit操作（函数对象，可全局性修改）</span></span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">//List</span></span><br></pre></td></tr></table></figure><p>这样的一个宏观结构可以用下面的图来表示，任何一个<code>List</code>结构都会拥有一个叫作<code>header</code>，以及另一个叫作<code>trailer</code>的哨兵节点，<code>header</code>和<code>trailer</code>对外是不可见的，当然我们后面会看到它们的作用非常巨大。而对外可见的部分主要是介乎<code>header</code>和<code>trailer</code>之间的这样的一系列的元素，其中如果存在的话，第一个元素也就是<code>firstNode</code>，我们称作<strong>首元素</strong>，而最后一个<code>last</code>我们称作<strong>末元素</strong>。那么相应的也把名字规范一下，称<code>header</code>叫作<strong>头元素</strong>，称<code>trailer</code>是<strong>尾元素</strong>。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214135.png" style="zoom:67%;"></p><ul><li>等效地，头、首、末和尾这四个节点的“ 秩 ”可以分别理解为是等于-1、0、n-1以及n。</li></ul><p>那么它们之间的联系是：头节点和尾节点是与生俱来的，而且二者并不相同，<code>first</code>和<code>last</code>并不见得不相同，甚至不能保证它们存在，但是对外而言<code>first</code>、<code>last</code>是可见的，而<code>trailer</code>和<code>header</code>这两个哨兵都是invisible不可见的。当然从秩的角度来看一个长度为n的列表中，头、首、末和尾这四个节点的秩可以分别理解为是等于-1、0、n-1以及n。</p><h3 id="1-4-5-构造"><a href="#1-4-5-构造" class="headerlink" title="1.4.5.构造"></a>1.4.5.构造</h3><p>如此定义的一个列表结构可以按照这样的过程来创建：首先要为header和trailer分别地分配一个节点使它们真实的存在，接下来要将它们的后继以及前驱引用分别指向对方，从而实现这样一个互联的效果。当然逻辑上看<br>这个时候对外可见的那个列表实际上是没有任何元素的，对应的就是一个空列表。而在接下来的几节里会介绍如何实现在其中插入一些元素，以及再插入一些元素，也可能时不常地从中删除或者是修改某一个元素。总而言之这个列表将有可能会包含一些实在的、对外可见的节点，我们在后面几节再来看这些操作是如何具体实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> List&lt;T&gt;::init() &#123; <span class="comment">//列表初始化，在创建列表对象时统一调用</span></span><br><span class="line">header = <span class="keyword">new</span> ListNode&lt;T&gt;; <span class="comment">//创建头哨兵节点</span></span><br><span class="line">    trailer = <span class="keyword">new</span> ListNode&lt;T&gt;; <span class="comment">//创建尾哨兵节点</span></span><br><span class="line">    header-&gt;succ = trailer; header-&gt;pred = <span class="literal">NULL</span>;   <span class="comment">//互联</span></span><br><span class="line">trailer-&gt;pred = header; trailer-&gt;succ = <span class="literal">NULL</span>;  <span class="comment">//互联</span></span><br><span class="line">_size = <span class="number">0</span>; <span class="comment">//记录规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214214139.png" style="zoom:67%;"></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h1 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2.无序列表"></a>2.无序列表</h1><h2 id="2-1-秩到位置"><a href="#2-1-秩到位置" class="headerlink" title="2.1.秩到位置"></a>2.1.秩到位置</h2><p>这一节讨论无序列表的相关算法，首先关心的一个问题是既然列表和向量同属于线性的序列结构那么是否可以继续沿用向量那种，十分便捷也是我们十分习惯的循序秩访问的方式呢？具体说来，对于任何一个名字叫L的列表，每当我们指定其中一个合法的秩r，都可以以这样的一个形式来直接引用并且访问到对应的这个节点。</p><p>答案是可以的，因为我们可以<strong>仿照向量的做法对下标操作符进行适当的重载</strong>，具体的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//重载下标操作符，以通过秩直接访问列表节点（虽方便，效率低，需慎用）</span></span><br><span class="line">T List&lt;T&gt;::<span class="keyword">operator</span>[] (Rank r) <span class="keyword">const</span> &#123; <span class="comment">//assert: 0 &lt;= r &lt; size</span></span><br><span class="line"> Posi(T) p = first(); <span class="comment">//从首节点出发</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt; r--) p = p-&gt;succ; <span class="comment">//顺数第r个节点即是</span></span><br><span class="line"> <span class="keyword">return</span> p-&gt;data; <span class="comment">//目标节点，返回其中所存元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此也可以看出这个算法的复杂度是取决于所指定的那个秩r的，即$O(r)$，这个是十分低下的。实际上这种用法虽然很方便，但是我们只能偶尔为之而不能常用。估算它的平均性能为$O(n)$，需要线性的时间，这样一个性能，无论如何我们都是无法接受的。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214222433.png" style="zoom:50%;"></p><h2 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2.查找"></a>2.2.查找</h2><p>接下来考虑无序列表的查找算法，这里将这个算法的接口语义定义为在当前的列表L中以位置为<code>p</code>的某一个特定节点为基准，在它的<code>n</code>个<strong>真前驱</strong>中（不包括它自己在内的n个前驱中）找到某个可能存在的数值为特定值<code>e</code>的节点。</p><p>仿照向量的查找算法我们从p这个位置出发，从后向前将每个节点逐一取出并与目标元素进行比对，一旦发现相等也就是命中，即可停止。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214224316.png" style="zoom: 67%;"></p><p>这样一个过程可以准确地描述为下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//在无序列表内节点p（可能是trailer）的n个真前驱中，找到等于e的最后者</span></span><br><span class="line"> Posi(T) List&lt;T&gt;::<span class="built_in">find</span>(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt; n--) <span class="comment">//（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左</span></span><br><span class="line">   <span class="keyword">if</span> (e == (p = p-&gt;pred)-&gt;data) <span class="keyword">return</span> p; <span class="comment">//逐个比对，直至命中或范围越界</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//p越出左边界意味着区间内不含e，查找失败</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回NULL</span></span><br></pre></td></tr></table></figure><p>注意无论是成功的情况所返回的<code>p</code>，还是失败时返回的<code>NULL</code>，都是我们此前所定义的一个节点位置Position。还要注意一种特殊的情况，即目标节点e不仅存在而且可能有多个，那么在这时根据这个算法，它会首先停止于相对而言最靠后的那个节点，因为这正是我们的语义所要求的一个细节。</p><p>那么在最坏的情况下，当然这个算法必须一直迭代到最末尾这个位置，累计的宽度是n，所以相应的复杂度也就是最坏情况下$O(n)$。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200214224536.png" style="zoom:67%;"></p><p>还需要留意的是，我们这里的三个参数的次序<code>find(T const&amp; e, int n, Posi(T) p)</code>，为什么这里将<code>n</code>放在<code>p</code>的前端呢？实际上这是为了让我们更方便地了解这个算法的功能语义，当使用<code>find(e, n ,p)</code>这样一个方式来调用这个接口的时候，你就很容易理解它是在<code>p</code>的<code>n</code>个前驱中去进行查找。换而言之我们完全可以重载另一个接口<code>find(e, p, n)</code>，它的不同之处就在于<code>p</code>和<code>n</code>的位置恰好交换，这就意味着是在p的n个后继中去查找特定的某一个元素。</p><h2 id="2-3-插入"><a href="#2-3-插入" class="headerlink" title="2.3.插入"></a>2.3.插入</h2><p>本节以<code>insertBefore</code>（前插入）为例介绍列表插入功能的实现，所谓的<code>insert Before</code>就是在当前的列表中以某个位置p为基准，在它的前方也就是作为它的前驱插入一个新的节点，而且这个节点的数值应该是我们指定的<code>e</code>。可以看到实际上它是通过转而由<code>p</code>作为一个节点的对象所支持的一个叫作insert as predecessor这样一个接口来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; Posi(T) List&lt;T&gt;::insertBefore(Posi(t) p, T <span class="keyword">const</span>&amp; e)&#123;</span><br><span class="line"> _size++;</span><br><span class="line"> <span class="keyword">return</span> p-&gt;insertAsPred(e);   <span class="comment">//e当作p的前驱插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前插入算法（后插入算法完全对称）</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; Posi(T) ListNode&lt;T&gt;::insertAsPred(T <span class="keyword">const</span>&amp; e) &#123;</span><br><span class="line"> Posi(T) x = <span class="keyword">new</span> ListNode(e, pred, <span class="keyword">this</span>);  <span class="comment">//创建（耗时100倍）</span></span><br><span class="line"> pred-&gt;succ = x;</span><br><span class="line"> pred = x;</span><br><span class="line"> <span class="keyword">return</span> x;    <span class="comment">//建立链接，返回新节点的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insertAsPred</code>首先生成一个节点，它的数值为e，这个节点的前驱就是节点<code>this</code>的前驱，而这个新生成出来的节点的后继恰好就是<code>this</code>。所以<code>Posi(T) x = new ListNode(e, pred, this);</code>这样一句不仅创建了一个数值为<code>e</code>的节点，而且完成了这个节点到当前这个列表的正确的连接。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215134557.png" style="zoom:80%;"></p><p>接下来做进一步的调整，也就是既然新的这个节点已经以节点<code>this</code>作为后继，那么当前节点<code>this</code>也就应该以新的这个节点作为前驱。反之新的这个节点既然以原来的那个前驱为前驱，那么原来的这个前驱也就应该以新的这个节点为后继，至此完成了新节点的插入操作。（类似于Cpp基础6中的链表的创建过程）</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215134632.png" style="zoom:80%;"></p><p>需要注意的是这样一种操作只是在局部进行，只牵涉到局部的三个节点，与其它的节点没有关系，它的复杂度是常数的，而这一点与向量是迥然不同的（向量插入元素后，原位置其后的元素要整体后移）。</p><p>考虑一些特殊的情况，比如说如果当前这个节点<code>this</code>是首节点，以至于它的前驱根本就不存在，那么这个时候这种操作难道不会出问题吗？其实是不会出问题的，因为我们在此前设立过哨兵，即便当前这个节点是首节点，它的前驱在内部依然是存在的，也就是<code>header</code>，那么这个时候的这种操作依然是安全的。</p><h2 id="2-4-基于复制的构造"><a href="#2-4-基于复制的构造" class="headerlink" title="2.4.基于复制的构造"></a>2.4.基于复制的构造</h2><p>有的时候我们也需要以某个已有的列表为蓝本，通过复制来创建一个新的列表，这样的过程可以由下面的代码来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//列表内部方法：复制列表中自位置p起的n项</span></span><br><span class="line"> <span class="keyword">void</span> List&lt;T&gt;::copyNodes(ListNodePosi(T) p, <span class="keyword">int</span> n) &#123; <span class="comment">//p合法，且至少有n-1个真后继节点</span></span><br><span class="line">     init(); <span class="comment">//创建头、尾哨兵节点并做初始化</span></span><br><span class="line"> <span class="keyword">while</span> (n--) &#123; </span><br><span class="line"> insertAsLast(p-&gt;data);</span><br><span class="line"> p = p-&gt;succ;</span><br><span class="line"> &#125; <span class="comment">//将起自p的n项依次作为末节点插入</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; ListNodePosi(T) List&lt;T&gt;::insertAsLast ( T <span class="keyword">const</span>&amp; e )&#123; </span><br><span class="line">    _size++; </span><br><span class="line">    <span class="keyword">return</span> trailer-&gt;insertAsPred ( e );  </span><br><span class="line">&#125; <span class="comment">//e当作末节点插入</span></span><br></pre></td></tr></table></figure><p>解读下这个算法：可见这里被复制的节点范围是从某一个列表的位置<code>p</code>开始随后地连续<code>n</code>个节点，因此首先我们创建一个空的列表，它只包含内部的头尾哨兵节点，不包含任何实质的节点。接下来我们不断地将当前这个<code>p</code>处<br>所指的那个节点的元素取出来，把它作为当前列表的末节点插入其中，每做完这样一个新节点的引入，我们都会将注意力转向当前这个节点的后继，如此往复直到这个区间中的所有<code>n</code>个节点，都被复制过来。</p><p>那么其中的<code>insertAsLast</code>怎么来实现呢？回顾我们所有对外可见的最后那个节点叫作<code>last</code> 即末节点，但是我们还同样配备了一个哨兵节点叫作<code>trailer</code>。所以所谓的<code>insertAsLast</code>其实就是insertBefore  trailer。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215140315.png" style="zoom: 33%;"></p><h2 id="2-5-删除"><a href="#2-5-删除" class="headerlink" title="2.5.删除"></a>2.5.删除</h2><p>接下来介绍如何从列表中删除指定的节点。可以通过下面的代码来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T List&lt;T&gt;::<span class="built_in">remove</span>(ListNodePosi(T) p) &#123; <span class="comment">//删除合法节点p，返回其数值 O(1)</span></span><br><span class="line">     T e = p-&gt;data; <span class="comment">//备份待删除节点的数值（假定T类型可直接赋值）</span></span><br><span class="line"> p-&gt;pred-&gt;succ = p-&gt;succ;</span><br><span class="line"> p-&gt;succ-&gt;pred = p-&gt;pred; <span class="comment">//后继、前驱</span></span><br><span class="line"> <span class="keyword">delete</span> p; _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line"> <span class="keyword">return</span> e; <span class="comment">//返回备份的数值 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先我们需要将这个节点的数据域取出作一备份，以便在最终能够顺利地将它返回，而删除节点之后整个列表在这个局部的拓扑连接关系的调整则是由第4、5行来完成的，通过下面的图便于理解一下这个过程。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215142107.png" style="zoom: 80%;"></p><p><code>p-&gt;pred-&gt;succ = p-&gt;succ</code>的效果是将<code>p</code>现在的后继当作<code>p</code>现在的前驱的后继，这样等同于将后继的这个引用直接跳过了<code>p</code>。而<code>p-&gt;succ-&gt;pred = p-&gt;pred</code>的过程以及效果与前一句完全对称，具体来说就是将<code>p</code>现在的前驱作为<code>p</code>的现在后继的前驱。这样两句的实质的作用可以理解为是将这个局部的后继引用，以及前驱的引用都跳过节点<code>p</code>，也就是说 <code>p</code>可以认为与原来的列表已经在拓扑上隔离开了。所以当我们将<code>p</code>直接地通过<code>delete</code>操作删除并归还系统之后就实现了指定节点<code>p</code>的删除。</p><p>整个这个过程只牵涉到局部的三个节点其余的节点没有任何的影响，由此也可以确认删除算法的复杂度与插入算法一样，都是常数的。</p><h2 id="2-6-析构"><a href="#2-6-析构" class="headerlink" title="2.6.析构"></a>2.6.析构</h2><p>如何销毁一个已有的列表呢？整个过程分为两步，首先要将对外可见的所有节点逐一删除，当所有对外可见的节点都被删除之后，再将内部的两个哨兵也就是<code>header</code>以及<code>trailer</code>给释放了。</p><p>所以整个这个算法分为两级：析构方法首先调用一个名为<code>clear</code>的函数，将所有的可见节点删除，接下来再将<code>header</code>和<code>trailer</code>删除掉，那么clear的实质的工作也就是反复的删除<code>header</code>的后继。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; List&lt;T&gt;::~List() &#123;  <span class="comment">//列表析构</span></span><br><span class="line"> <span class="built_in">clear</span>();     <span class="comment">//清空列表  </span></span><br><span class="line"> <span class="keyword">delete</span> header;  <span class="keyword">delete</span> trailer;   <span class="comment">//释放头、尾哨兵节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; List&lt;T&gt;::clean() &#123;   <span class="comment">//清空列表</span></span><br><span class="line"> <span class="keyword">int</span> oldSize = _size;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt; _size)    <span class="comment">//反复删除首节点，直至列表变空</span></span><br><span class="line"> <span class="built_in">remove</span>(header-&gt;succ);</span><br><span class="line"> <span class="keyword">return</span> oldSize;</span><br><span class="line">&#125;  <span class="comment">//O(n)，线性正比于列表规模</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215145251.png" style="zoom: 67%;"></p><h2 id="2-7-唯一化"><a href="#2-7-唯一化" class="headerlink" title="2.7.唯一化"></a>2.7.唯一化</h2><p>本节介绍列表的唯一化问题，即如何将列表中可能存在的重复元素剔除掉。在接下来要介绍的这个算法中，我们始终将整个列表视作由三部分组成，这个前缀部分作为这个算法的一条不变性，已经能够保证不包含任何重复的节点，而我们当前所要考察的就是接下来的这个节点<code>p</code>，当然此时可能还存在一个非空后缀。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215151451.png" style="zoom:50%;"></p><p>这个算法的关键部分是如果当前那个节点的数值为e，就以e为目标在前缀中对它进行查找，无论查找成功与否<br>我们都可以将问题的规模，有效地降低至少一个单位，具体的算法可以实现为这样一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::deduplicate() &#123;  <span class="comment">//剔除无序列表中的重复节点</span></span><br><span class="line"> <span class="keyword">if</span> (_size &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//平凡列表自然无重复</span></span><br><span class="line">     <span class="keyword">int</span> oldSize = _size;       <span class="comment">//记录原规模</span></span><br><span class="line"> LPosi(T) p = first();  Rank r = <span class="number">1</span>;     <span class="comment">//p从首节点起</span></span><br><span class="line"> <span class="keyword">while</span> (trailer != (p = p-&gt;succ)) &#123;     <span class="comment">//依次直到末节点</span></span><br><span class="line"> Posi(T) q = <span class="built_in">find</span>(p-&gt;data, r, p);   <span class="comment">//在p的r个（真）前驱中，查找与之相同者</span></span><br><span class="line"> q ? <span class="built_in">remove</span>(q) : r++;    <span class="comment">//若的确存在，则删除之；否则秩递增</span></span><br><span class="line"> &#125;  <span class="comment">//assert: 循环过程中的任意时刻，p的所有前驱互不相同</span></span><br><span class="line">     <span class="keyword">return</span> oldSize - _size; <span class="comment">//返回列表规模的变化量，即被删除元素总数</span></span><br><span class="line"> &#125;   <span class="comment">//正确性及效率分析的方法与结论，与Vector::deduplicate()相同</span></span><br></pre></td></tr></table></figure><p>解读一下这段代码：首先是处理平凡情况，确保这个列表中至少包含两个节点，接下来这一步可以认为是初始化，可以看到p最初的时候是指向首节点，即这时的前缀实际上可以认为是空的，所以不变性自然也就满足。接下来算法的主体部分是这个循环，可以看到每一次我们都将<code>p</code>中所存的那个元素在以<code>p</code>为基准的<code>r</code>个真前驱中查找。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215151455.png" style="zoom:50%;"></p><p>在前缀中进行查找无非两种情况：一种就是<code>find</code>操作返回了一个非空的元素，它的数值当然就等于<code>e</code>，这是就把<code>q</code>删除掉了；否则如果<code>q</code>是一个<code>null</code>，那就意味着查找失败，即在这样的一个前缀中根本就不存在语义相同的元素，所以在这之后<code>p</code>这个节点可以归入到前缀中去，使得这个前缀拓展一个单位，在这种情况下就可以将<code>r</code>加1，即前缀的长度增加一个单位，同时<code>p</code>转入它的后继元素继续迭代，直到抵达哨兵<code>trailer</code>也就意味着整个列表全部扫描并且处理完毕。</p><h1 id="3-有序列表"><a href="#3-有序列表" class="headerlink" title="3.有序列表"></a>3.有序列表</h1><p>本节介绍有序列表，我们假设其中的元素不仅可以比较大小而且已经按照这种大小关系有序地排列。在这样的一个条件下很多问题都存在更加高效的解法。</p><h2 id="3-1-唯一化：原理"><a href="#3-1-唯一化：原理" class="headerlink" title="3.1.唯一化：原理"></a>3.1.唯一化：原理</h2><p>以唯一化问题为例，回顾有序向量的唯一化可以比无序向量的唯一化更快地完成，那么有序列表的唯一化是否也能够比无序列表的唯一化完成地更快呢？在介绍出具体的算法之前，我们先来分析一下算法的思路。</p><p>回顾在有序向量的去重算法中，曾经介绍过这样一个事实：在任何一个有序的序列中，如果存在重复元素，那么每一组重复元素必然会彼此紧邻地排列成一个又一个的分组，每一个分组都由彼此相同的一组元素构成。而唯一化的任务可以等效地理解成是从每一组中挑选出一个代表，而将其余的元素都剔除掉。于是仿照有序向量的唯一化算法也可以得到一个迭代式的算法。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215154302.png" style="zoom:67%;"></p><p>具体来讲每一次迭代我们都将注意力关注于当前以<code>p</code>指示的那个节点，同时还要考虑<code>p</code>的直接后继<code>q</code>，在经过一次比对之后如果发现<code>p</code>和<code>q</code>相等，就可以将后者剔除掉，这个可以通过列表所提供的<code>remove</code>标准接口来实现。此后<code>q</code>将指向新的后继节点。同样地在接下来的一步迭代中，依然会发现<code>q</code>与<code>p</code>相等，所以可以继续将它删除。</p><p>在某一步接下来的迭代中情况可能发生变化，即首次发现一个与<code>p</code>不同的节点，这时就预示着一个新的区段出现了，作为这个新的区段的首节点，我们将保留这个节点。而为了这个算法能够继续计算下去，不妨将<code>p</code>由原来的位置转向这个新发现的不同的节点（图中p由红色转向绿色）。可以看到经过这样一轮迭代之后，刚才相同的一组元素中，除了第一个其余的后继都被删除掉了。</p><h2 id="3-2-唯一化：实现"><a href="#3-2-唯一化：实现" class="headerlink" title="3.2.唯一化：实现"></a>3.2.唯一化：实现</h2><p>上小节的算法思路可以实现为下面一段具体的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::uniquify() &#123; <span class="comment">//成批剔除重复元素，效率更高</span></span><br><span class="line">     <span class="keyword">if</span> (_size &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//平凡列表自然无重复</span></span><br><span class="line"> <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line"> Posi(T) p = first(); Posi(T) q; <span class="comment">//p为各区段起点，q为其后继</span></span><br><span class="line"> <span class="keyword">while</span> (trailer != (q = p-&gt;succ)) <span class="comment">//反复考查紧邻的节点对(p, q)</span></span><br><span class="line">     <span class="keyword">if</span> (p-&gt;data != q-&gt;data) </span><br><span class="line"> p = q; <span class="comment">//若互异，则转向下一区段</span></span><br><span class="line">     <span class="keyword">else</span> <span class="built_in">remove</span>(q); <span class="comment">//否则（雷同），删除后者</span></span><br><span class="line"> <span class="keyword">return</span> oldSize - _size; <span class="comment">//列表规模变化量，即被删除元素总数</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>解读一下这段代码：首先是处理平凡的情况，即要确保这个列表至少包含两个元素。我们所关注的总是当前节点<code>p</code>，这个节点从首节点开始，同时还有另一个辅助的引用<code>q</code>指向p的后继。以下是一个循环，每一次我们都令<code>q</code>指向<code>p</code>的直接后继，随后将二者作一比对，如果相同就调用<code>remove</code>接口将<code>q</code>删除掉；反过来 一旦遇到一个与<code>p</code>不同的后继节点，那么就意味着抵达了下一个区段的首节点，这个时候我们就可以直接将注意力转向这个下一个区段的首节点也就是q。此后发生的情况将与刚才那样一轮迭代完全相同，迭代持续进行直到最终<code>q</code>试图越过边界，这时整个算法也就宣告结束。</p><p>整个算法过程主体的复杂度来源是<code>while</code>，可以看到每经过一步迭代<code>p</code>都会转入一个新的节点，所以整个迭代<br>至多经过线性步就会停止，所有这个算法的时间复杂度为$O(n)$，这相对于无序列表也是一个很大的改进。</p><h2 id="3-3-查找"><a href="#3-3-查找" class="headerlink" title="3.3.查找"></a>3.3.查找</h2><p>有序列表的去重操作相对于无序列表而言可以更快地进行，那么其它的操作呢？比如我们最最关心的查找呢？</p><p>有序的列表的查找操作可以由下面一段代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt; <span class="comment">//在有序列表内节点p的n个（真）前驱中，找到不大于e的最后者</span></span><br><span class="line">Posi(T) List&lt;T&gt;::search(T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, Posi(T) p) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">// assert: 0 &lt;= n &lt;= rank(p) &lt; _size</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">0</span> &lt;= n--)   <span class="comment">//对于p的最近的n个前驱，从右向左</span></span><br><span class="line"><span class="keyword">if</span> (((p = p-&gt;pred)-&gt;data) &lt;= e)   <span class="comment">//逐个命中</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">return</span> p; <span class="comment">//直至命中，数值越界或范围越界后，返回查找终止的位置</span></span><br><span class="line">&#125;  <span class="comment">//最好O(1)，最坏O(n)；等概率时平均O(n)，正比于区间宽度</span></span><br></pre></td></tr></table></figure><p>我们发现这个算法与无序列表居然没有太多的差异，同样它在最好情况下也是常数，比如在开始的位置就发现命中目标；反过来最坏也可能多达$O(n)$，即一直查找到最后才得出是否命中的结论。在整个查找范围也就是<code>p</code>之前的n个前驱中，每一个元素对应的查找成本将呈算数级数趋势变化，总体而言是线性的。</p><p>这样的结论多少会令人失望，因为尽管我们这里已经将列表中的元素按顺序进行了重新组织，但是查找的效率居然没有实质的改进。这并不是我们实现不当，而根本的原因在于列表的循位置访问这种方式。这种访问方式与向量的循秩访问有着本质的差异。</p><p>Vector这种结构在访问数据的时候，所依据的实际上是秩rank，而列表结构所依据的是位置position。在此前<br>所介绍过的计算模型，实际上对于<strong>RAM模型</strong>来说，它所对应的其实就是<strong>循秩访问</strong>的方式。对于RAM模型来说每给出一个编号<code>i</code>，都可以在$O(1)$的时间内找到对应的寄存器，读取其中的数值或者对其进行修改。</p><p>再来看图灵机模型，虽然“纸带”长度无限，但在任何时候我们所能够操纵的只是其中某一个特定的单元，而且更重要的是在接下来只可能向左或者向右移动一格。如果的确需要访问一个相距很远的单元，我们将不得不亦步亦趋地逐步地通过多步的迭代才能够抵达目标，这正是我<strong>call-by-position</strong>，而不是RAM那种<strong>call-by-rank</strong>。</p><p><img src="/2020/02/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E5%88%97%E8%A1%A8/QQ图片20200215160903.png" style="zoom: 50%;"></p>]]></content>
    
    <summary type="html">
    
      与向量一样列表也是典型的最基本的一类线性结构，但是列表结构与向量结构在几乎所有的方面都是对称的、互补的，因此它的特点也十分的鲜明。本文主要介绍列表的接口与实现，无序列表和有序列表。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（8）数据的共享与保护</title>
    <link href="http://nekomoon404.github.io/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/"/>
    <id>http://nekomoon404.github.io/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</id>
    <published>2020-02-13T12:58:24.000Z</published>
    <updated>2020-02-15T12:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符的作用域与可见性"><a href="#标识符的作用域与可见性" class="headerlink" title="标识符的作用域与可见性"></a>标识符的作用域与可见性</h1><p>作用域是一个标识符在程序正文中的有效区域。作用域可以分为以下几类：</p><ul><li>函数原型作用域：函数原型中的参数，其作用域始于”(“，结束语”)”，如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="keyword">double</span> radius)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>局部作用域：</p><ul><li>函数的形参、在块中声明的标识符</li><li>其作用域自声明处起，限于块中</li></ul></li><li><p>类作用域：</p><ul><li>类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。</li><li>如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）</li></ul></li><li>文件作用域：<ul><li>不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束语文件尾。</li></ul></li><li>可见性：<ul><li>可见性是从对标识符的引用的角度来谈的概念</li><li>可见性表示从内层作用域向外层作用域“看”时能看见什么</li><li>如果标识在某处可见，就可以在该处引用此标识符</li><li>如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见</li><li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i;  <span class="comment">//全局变量，文件作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i = <span class="number">5</span>;  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i; <span class="comment">//局部变量，局部作用域</span></span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出7</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h1><p><strong>静态生存期</strong>：</p><ul><li>静态生存期与程序的运行期间相同;</li><li>在文件作用于中声明的对象具有这种生存期</li><li>在函数内部声明静态生存期对象，要冠以关键字<code>static</code></li></ul><p><strong>动态生存期</strong>：</p><ul><li>开始于程序执行到声明点时，结束语命名该标识符的作用域结束处</li><li>块作用域中声明的，没有用static修饰的对象时动态生存期的对象（习惯称局部生存期对象）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;   <span class="comment">//i为全局变量，具有静态生存期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="comment">//a, b为静态局部变量，具有全局寿命，局部可见</span></span><br><span class="line"><span class="comment">//只第一次进入函数时被初始化</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;  <span class="comment">//C为局部变量，具有动态生存期，</span></span><br><span class="line">             <span class="comment">//每次进入函数时都初始化</span></span><br><span class="line">a += <span class="number">2</span>; i += <span class="number">32</span>; c += <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---OTHER---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">//静态局部变量，有全局寿命，局部可见（实际中尽量不使用重名的变量）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-10</span>;   <span class="comment">//b,c为局部变量，具有动态生存期</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">c += <span class="number">8</span>;   other();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"---MAIN---\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; <span class="string">" a; "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i += <span class="number">10</span>;  other();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/Cpp%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4/QQ图片20200214145239.png" style="zoom:80%;"></p><h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><p><strong>静态成员</strong>：在定义前面加了<code>static</code>关键字的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> w,h;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> nTotalNUmber;  <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       CRectangle(<span class="keyword">int</span> _w,<span class="keyword">int</span> _h);</span><br><span class="line">       ~CRectangle();</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;   <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享</li></ul><p>​       注意：<code>sizeof</code>运算符不会计算静态成员变量，如下例中<code>sizeof(Myclass)</code>等于4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。</li><li>因此静态成员不需要通过对象就能访问</li></ul><p>如何<strong>访问静态成员</strong>：</p><ol><li>类名::成员名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>对象名.成员名（并不意味着静态成员或静态成员函数只作用于该对象,，它们是被所有的CRentangle对象所共享的）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle r;  r.PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>指针-&gt;成员名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle *p = &amp;r;  p-&gt;PrintTotal();</span><br></pre></td></tr></table></figure><ol><li>引用.成员名</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRectangle &amp;<span class="built_in">ref</span> = r;  <span class="built_in">int</span> n = <span class="built_in">ref</span>.nTotalNumber;</span><br></pre></td></tr></table></figure><ul><li><strong>静态成员变量本质上是全局变量</strong>，哪怕一个对象都不存在，类的静态成员变量也存在。</li><li>静态成员函数本质上是全局函数</li><li>设置静态成员这种机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</li></ul><p><strong>示例</strong>：考虑一个需要随时知道矩阵总数和总面积的图像处理程序，可以用全局变量来记录总数和总面积，同静态成员将这两个变量封装进类中，就更容易理解和维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> w, h;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nTotalArea;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nTotalNUmber;  <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CRectangle(<span class="keyword">int</span> _w, <span class="keyword">int</span> _h);</span><br><span class="line">~CRectangle();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTotal</span><span class="params">()</span></span>;   <span class="comment">//静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> _w, <span class="keyword">int</span> _h)</span><br><span class="line">&#123;</span><br><span class="line">w = _w;</span><br><span class="line">h = _h;</span><br><span class="line">nTotalNUmber++;</span><br><span class="line">nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()</span><br><span class="line">&#123;</span><br><span class="line">nTotalNUmber--;</span><br><span class="line">nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nTotalNUmber &lt;&lt; <span class="string">", "</span>&lt;&lt;nTotalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalNUmber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> CRectangle::nTotalArea = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//必须在定义类的文件中对静态成员变量进行一次说明或初始化。</span></span><br><span class="line"><span class="comment">//否则编译能通过，链接不能通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRectangle r1(3, 3), r2(2, 2);</span><br><span class="line"><span class="comment">//cout&lt;&lt;CRectangle::nTotalNUmber;   //Wrong,私有成员不能在类外访问</span></span><br><span class="line">CRectangle::PrintTotal();</span><br><span class="line">r1.PrintTotal();  <span class="comment">//与上一句等价</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数（因为其可能访问非静态成员变量），例如下面的定义就是错误的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; w &lt;&lt;<span class="string">", "</span>&lt;&lt; nTotalNUmber &lt;&lt; <span class="string">", "</span>&lt;&lt;nTotalArea &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  <span class="comment">//Wrong，因为PrintTotal是静态成员函数，而w属于非静态成员变量</span></span><br></pre></td></tr></table></figure><p>我们回过头来再看之前的<code>CRectangle</code>类的写法，其实它是有严重<strong>缺陷</strong>的，那么这个缺陷是如何产生的呢？</p><p>问题就出在我们忽略了复制构造函数，在程序需要它时，会调用自动生成的复制构造函数，自然就不会对<code>nTotalNUmber</code>和<code>nTotalArea</code>作相应的增加。</p><ul><li><p>在使用<code>CRectangle</code>类时，有时会调用复制构造函数生成临时的隐藏的<code>CRectangle</code>对象</p><ul><li>调用一个以<code>CRectangle</code>类对象作为参数的函数时</li><li>调用一个以<code>CRectangle</code>类对象作为返回值的函数时    </li></ul></li><li><p>临时对象在消亡时会调用析构函数，减少<code>nTotalNUmber</code>和<code>nTotalArea</code>的值，可是这些临时对象在生成时却没有增加<code>nTotalNUmber</code>和<code>nTotalArea</code>的值。</p></li></ul><p><strong>解决办法</strong>：为<code>CRectangle</code>类写一个复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::CRectangle(CRectangle &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    w=r.w; h=r.h;</span><br><span class="line">    nTotalNUmber++;</span><br><span class="line">nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h1><ul><li>友元是C++提供的一种破坏数据封装和数据隐藏的机制</li><li>通过将一个模块声明为另一个模块的友元，一个模块能引用到另一个模块中很是被隐藏的信息</li><li>可以使用<strong>友元函数</strong>和<strong>友元类</strong></li><li>为了确保数据的完整性，及数据封装与隐藏的原则，<strong>建议尽量不使用或少使用友元</strong></li></ul><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul><li>友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体重能够通过对象名访问<code>private</code>和<code>protected</code>成员。</li><li>作用：增加灵活性，时程序员可以在封装和快速性方面做合理的选择。</li><li>访问对象中的成员必须通过对象名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostram&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>  <span class="comment">//提前声明CCar类，因为后面CDriver类要前向引用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar *pCar)</span></span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>; <span class="comment">//类外函数声明为友元函数</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar);  <span class="comment">//其他类的成员函数声明为友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar(CCar *pCar)  <span class="comment">//求最贵汽车的价格</span></span><br><span class="line">&#123;</span><br><span class="line">pCar-&gt;price += <span class="number">1000</span>;   <span class="comment">//汽车改装后价格增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span><br><span class="line"><span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">tmpMax = cars[i].price;</span><br><span class="line"><span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><ul><li>若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员</li><li>声明语法：将友元类名在另一个类中使用<code>friend</code>修饰说明</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span>  <span class="comment">//声明CDriver为CCar的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span></span>&#123;    <span class="comment">//改装汽车</span></span><br><span class="line">        myCar.price += <span class="number">1000</span>;  <span class="comment">//CDriver是CCar的友元类-&gt;可以访问其私有成price</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要注意的是：<strong>类的友元关系是单向的</strong>：</p><ul><li>如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数不能访问B类的私有、保护数据，即友元类的关系不能传递，不能继承。</li></ul><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>在C++刚推出的时候，编译器在编译C++程序课程时先把一段C++程序翻译成C程序，然后再用C的编译去编译。比如说我们把下面的<code>CCar</code>的类的C++程序翻译成C程序，<code>class</code>对应C中的<code>struct</code>结构体，而C中没有成员函数，因此需要借助<code>this</code>指针来实现<code>SetPrice</code>的功能。</p><p><strong>C++</strong>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CCar::SetPrice(<span class="keyword">int</span> p) &#123;</span><br><span class="line">price = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CCar car;</span><br><span class="line">car.SetPrice(<span class="number">20000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C</strong>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(struct CCar *<span class="keyword">this</span>, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;price = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CCar</span> <span class="title">car</span>;</span></span><br><span class="line">SetPrice( &amp;car, <span class="number">20000</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>this</code>指针作用：非静态成员函数中可以直接使用<code>this</code>来代表指向该函数作用的对象的指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> real, imag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; real &lt;&lt; <span class="string">"+"</span> &lt;&lt; imag &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line">Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line"><span class="function">Complex <span class="title">AddOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;real++;</span><br><span class="line"><span class="keyword">this</span>-&gt;Print();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Complex c1(1, 1), c2(0, 0);</span><br><span class="line">c2 = c1.AddOne();   <span class="comment">//输出 2+1i</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意静态成员函数不能使用this指针，因为静态成员函数并不具体作用于某个对象。</li></ul><h1 id="常量const"><a href="#常量const" class="headerlink" title="常量const"></a>常量const</h1><ul><li><p>常量对象：如果不希望某个对象的植被改变，则定义该对象时在其前面加<code>const</code>关键字。</p></li><li><p>常量成员函数：<strong>在类的成员函数说明后面</strong>加<code>const</code>关键字</p><ul><li>常量成员函数执行期间不应该修改其作用的对象。因此，在常量成员函数中不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（静态成员函数除外）。</li><li>若有两个成员函数，名字和参数表都一样，但是一个是<code>const</code>，一个不是，算重载，而不是冲突定义。</li></ul></li><li><p>常引用：引用前加const，不能通过常引用，修改其引用的变量；常引用经常作为函数的参数</p><ul><li>当传递一个对象的效率较低（因为需要调用复制构造函数生成一个新的对象），又要确保实际参数的值不能在函数内部被修改时，可以将参数的类型声明为常引用</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> w, h;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">(<span class="keyword">const</span> Rectangle &amp;<span class="built_in">rect</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//rect.w = rect.h + 2;   非法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rect</span>.w * <span class="built_in">rect</span>.h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      本章主要学习了标识符的作用域与可见性，对象的生存期，类的静态成员，类的友元
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>ML:Week2</title>
    <link href="http://nekomoon404.github.io/2020/02/13/ML-Week2/"/>
    <id>http://nekomoon404.github.io/2020/02/13/ML-Week2/</id>
    <published>2020-02-13T09:43:58.000Z</published>
    <updated>2020-02-15T09:43:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multivariate-Linear-Regression"><a href="#Multivariate-Linear-Regression" class="headerlink" title="Multivariate Linear Regression"></a>Multivariate Linear Regression</h1><h2 id="Multiple-Features"><a href="#Multiple-Features" class="headerlink" title="Multiple Features"></a>Multiple Features</h2><p>Linear regression with <strong>multiple variables</strong> is also known as “multivariate linear regression”. We now introduce notation for equations where we can have any number of input variables.</p><script type="math/tex; mode=display">\begin{align*}x_j^{(i)} &= \text{value of feature } j \text{ in the }i^{th}\text{ training example} \newline x^{(i)}& = \text{the input (features) of the }i^{th}\text{ training example} \newline m &= \text{the number of training examples} \newline n &= \text{the number of features} \end{align*}</script><p>The multivariable form of the hypothesis function accommodating these multiple features is as follows:</p><script type="math/tex; mode=display">h_θ(x)=θ_0+θ_1x_1+θ_2x_2+θ_3x_3+⋯+θ_nx_n</script><p>In order to develop intuition about this function, we can think about $\theta_0$ as the basic price of a house, $\theta_1$ as the price per square meter, $\theta_2$ as the price per floor, etc. $x_1$ will be the number of square meters in the house, $x_2$ the number of floors, etc.</p><p>Using the definition of matrix multiplication, our <strong>multivariable hypothesis function</strong> can be concisely represented as:</p><script type="math/tex; mode=display">\begin{align*}h_\theta(x) =\begin{bmatrix}\theta_0 \hspace{2em} \theta_1 \hspace{2em} ... \hspace{2em} \theta_n\end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x\end{align*}</script><p>This is a vectorization of our hypothesis function for one training example; see the lessons on vectorization to learn more.</p><p>Remark: Note that for convenience reasons in this course we assume $x^{(i)}_0=1 $ for $(i\in 1,\dots,m)$. This allows us to do matrix operations with theta and x. Hence making the two vectors $’\thetaθ’$ and $x^{(i)}$match each other element-wise (that is, have the same number of elements: n+1).]</p><h2 id="Gradient-Descent-for-Multiple-Variables"><a href="#Gradient-Descent-for-Multiple-Variables" class="headerlink" title="Gradient Descent for Multiple Variables"></a>Gradient Descent for Multiple Variables</h2><p>The gradient descent equation itself is generally the same form; we just have to repeat it for our ‘n’ features:</p><script type="math/tex; mode=display">\begin{align} & \text{repeat until convergence:} \; \lbrace \newline \; & \theta_0 := \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_0^{(i)}\newline \; & \theta_1 := \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_1^{(i)} \newline \; & \theta_2 := \theta_2 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_2^{(i)} \newline & \cdots \newline \rbrace \end{align}</script><p>In other words:</p><script type="math/tex; mode=display">\begin{align*}& \text{repeat until convergence:} \; \lbrace \newline \; & \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; & \text{for j := 0...n}\newline \rbrace\end{align*}</script><p>The following image compares gradient descent with one variable to gradient descent with multiple variables:</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213200014.png" style="zoom: 50%;"></p><p><strong>Python</strong>代码示例：</p><p>计算代价函数：$J\left( \theta  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{\left( h_{\theta}\left( x^{(i)} \right)-y^{(i)} \right)}^2$<br>其中：$h_{\theta}\left( x \right)=\theta^{T}X=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeCost</span><span class="params">(X, y, theta)</span>:</span></span><br><span class="line">    inner = np.power(((X * theta.T) - y), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sum(inner) / (<span class="number">2</span> * len(X))</span><br></pre></td></tr></table></figure><h2 id="Gradient-Descent-in-Practice-I-Feature-Scaling"><a href="#Gradient-Descent-in-Practice-I-Feature-Scaling" class="headerlink" title="Gradient Descent in Practice I -Feature Scaling"></a>Gradient Descent in Practice I -Feature Scaling</h2><p>We can <strong>speed up gradient descent</strong> by having each of our input values in roughly the same range. This is because <strong>θ will descend quickly on small ranges</strong> and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213201445.png" style="zoom: 50%;"></p><p>The way to prevent this is to modify the ranges of our input variables so that they are all roughly the same. Ideally:</p><p>−1 ≤ $x_{(i)}$≤ 1     or      −0.5 ≤ $x_{(i)}$ ≤ 0.5</p><p>Two techniques to help with this are <strong>feature scaling</strong>(特征缩放) and <strong>mean normalization</strong>(均值归一化). </p><p>Feature scaling involves dividing the input values by the range (maximum value  - minimum value) of the input variable, resulting in a new range of just 1. </p><p>Mean normalization involves subtracting the average value for an input variable from the values for that input variable resulting in a new average value for the input variable of just zero. To implement both of these techniques, adjust your input values as shown in this formula:</p><script type="math/tex; mode=display">x_i:=\frac{x_i-\mu_i}{s_i}</script><p>Where $\mu_i$ is the <strong>average</strong> of all the values for feature (i) and $s_i$ is the range of values (max - min), or $s_i$ is the <strong>standard deviation</strong>(标准差). （量化后的特征将分布在[-1, 1]，服从标准正态分布）</p><h2 id="Gradient-Descent-in-Practice-II-Learning-Rate"><a href="#Gradient-Descent-in-Practice-II-Learning-Rate" class="headerlink" title="Gradient Descent in Practice II - Learning Rate"></a>Gradient Descent in Practice II - Learning Rate</h2><p><strong>Debugging gradient descent</strong>(调试梯度下降):  Make a plot with <em>number of iterations</em> on the x-axis. Now plot the cost function, J(θ) over the number of iterations of gradient descent. If J(θ) ever increases, then you probably need to decrease α.</p><p><strong>Automatic convergence test</strong>(自动收敛测试):  Declare convergence if J(θ) decreases by less than E in one iteration, where E is some small value such as 10−3. However in practice it’s difficult to choose this threshold value</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213202754.png" style="zoom:50%;"></p><p>It has been proven that if learning rate α is sufficiently small, then J(θ) will decrease on every iteration.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213202813.png" style="zoom:50%;"></p><p>To summarize:</p><ul><li><p>If $\alpha$ is too small: slow convergence. </p></li><li><p>If $\alpha$ is too large: ￼may not decrease on every iteration and thus may not converge.</p></li></ul><h2 id="Features-and-Polynomial-Regression"><a href="#Features-and-Polynomial-Regression" class="headerlink" title="Features and Polynomial Regression"></a>Features and Polynomial Regression</h2><p>We can improve our features and the form of our hypothesis function in a couple different ways.</p><p>We can <strong>combine</strong> multiple features into one. For example, we can combine $x_1$ and $x_2$ into a new feature $x_3$ by taking $x_1⋅x_2$.</p><p>Our hypothesis function need not be linear (a straight line) if that does not fit the data well.</p><p>We can <strong>change the behavior or curve</strong> of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).</p><p>For example, if our hypothesis function is $h_\theta (x) = \theta_0 + \theta_1 x_1$ then we can create additional features based on $x_1$, to get the quadratic function $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_1^2$ or the cubic function $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_1^2 + \theta_3 x_1^3$</p><p>In the cubic version, we have created new features $x_2$ and $x_3$ where $x_2 = x_1^2$ and $x_3 = x_1^3$.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213204000.png" style="zoom:50%;"></p><p>To make it a square root function, we could do: $h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 \sqrt{x_1}$.</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200213203859.png" style="zoom:50%;"></p><p>One important thing to keep in mind is, if you choose your features this way then <strong>feature scaling becomes very important.</strong></p><p>eg. if $x_1$ has range 1 - 1000 then range of $x_1^2$ becomes 1 - 1000000 and that of $x_1^3$ becomes 1 - 1000000000</p><h1 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h1><p>Gradient descent gives one way of minimizing J. Let’s discuss a second way of doing so, this time performing the minimization explicitly and without resorting to an iterative algorithm. In the “<strong>Normal Equation</strong>“ (正规方程) method, we will minimize J by explicitly taking its derivatives with respect to the θj ’s, and setting them to zero: $\frac{\partial J\left( \theta  \right)}{\partial \theta }=0$.</p><p>This allows us to find the <strong>optimum theta</strong> <strong>without iteration</strong>. The normal equation formula is given below:</p><script type="math/tex; mode=display">\theta = (X^T X)^{-1}X^T y</script><p><img src="/2020/02/13/ML-Week2/QQ图片20200215105140.png" style="zoom: 50%;"></p><p>There is <strong>no need</strong> <strong>to do feature scaling with the normal equation</strong>.</p><p>The following is a comparison of gradient descent and the normal equation:</p><p><img src="/2020/02/13/ML-Week2/QQ图片20200215105310.png" style="zoom: 80%;"></p><p>总结一下，只要特征变量的数目并不大，标准方程是一个很好的计算参数$\theta $的替代方法。具体地说，只要特征变量数量小于一万，我通常使用标准方程法，而不使用梯度下降法。</p><p>随着学习算法越来越复杂，例如，分类算法，像逻辑回归算法，我们会看到，实际上对于那些算法，并不能使用标准方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及特征变量的数量，这两种算法都是值得学习的。</p><p>正规方程的python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">normalEqn</span><span class="params">(X, y)</span>:</span></span><br><span class="line">    </span><br><span class="line">   theta = np.linalg.inv(X.T@X)@X.T@y <span class="comment">#X.T@X等价于X.T.dot(X)</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure><h2 id="Noninvertibility-不可逆性"><a href="#Noninvertibility-不可逆性" class="headerlink" title="Noninvertibility(不可逆性)"></a>Noninvertibility(不可逆性)</h2><p>When implementing the normal equation in octave we want to use the <code>pinv</code> function rather than <code>inv</code>. The ‘<code>pinv</code>‘ function will give you a value of $\theta$ even if $X^TX$ is not invertible.</p><p>If $X^TX$ is <strong>noninvertible,</strong> the common causes might be having :</p><ul><li>Redundant features, where two features are very closely related (i.e. they are <strong>linearly dependent</strong>)</li><li>Too many features (e.g. m ≤ n). In this case, delete some features or use “<strong>regularization</strong>“（正则化） (to be explained in a later lesson).</li></ul><p>Solutions to the above problems include deleting a feature that is linearly dependent with another or deleting one or more features when there are too many features.</p><p><strong>补充</strong>：$\theta = (X^T X)^{-1}X^T y$的 证明：</p><p>代价函数：</p><script type="math/tex; mode=display">J\left( \theta  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{\left( h_{\theta}\left( x^{(i)} \right)-y^{(i)} \right)}^2</script><p>其中：$h_{\theta}\left( x \right)=\theta^{T}X=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+…+\theta_{n}x_{n}$</p><p>将向量表达形式转为矩阵表达形式，则有$J(\theta )=\frac{1}{2}{\left( X\theta -y\right)}^2$ ，其中$X$为$m$行$n$列的矩阵（$m$为样本个数，$n$为特征个数），$\theta$为$n$行1列的矩阵，$y$为$m$行1列的矩阵，对$J(\theta )$进行如下变换</p><script type="math/tex; mode=display">\begin{align}J(\theta )&=\frac{1}{2}{\left( X\theta -y\right)}^{T}\left( X\theta -y \right) \\ &=\frac{1}{2}\left( {\theta }^{T}{X^T}-{y}^{T} \right)\left(X\theta -y \right)\\&=\frac{1}{2}\left( {\theta }^T{X}^{T}X\theta -{\theta}^{T}{X}^{T}y-{y}^{T}X\theta -{y}^{T}y \right)\end{align}</script><p>接下来对$J(\theta )$偏导，需要用到以下几个矩阵的求导法则</p><script type="math/tex; mode=display">\begin{align}\frac{dAB}{dB}&={A^T}\\\frac{dX^TAX}{dX}&=2AX\end{align}</script><p>所以有:</p><script type="math/tex; mode=display">\begin{align}\frac{\partial J\left( \theta  \right)}{\partial \theta }&=\frac{1}{2}\left(2{X^T}X\theta -{X^T}y -({y^T}X )^{T}-0 \right)\\&=\frac{1}{2}\left(2{X^T}X\theta -{X^T}y -{X^T}y -0 \right)\\&={X^T}X\theta -{X^T}y\end{align}</script><p>令：$\frac{\partial J\left( \theta  \right)}{\partial \theta }=0$</p><p>则有：$\theta =\left( X^{T}X \right)^{-1}{X^T}y$。</p><p>————————————————————————————————————————————————</p><p>PS：Week2的第三部分是Octave语言教程，看了一遍视频发现Octave的语法和Matlab基本是一样的，有很方便的矩阵运算，而且Octave是完全开源的，但正版的Matlab确实很贵，这大概也是老师这门课用Octave的原因之一吧。（Andrew Ng 永远滴神！）</p>]]></content>
    
    <summary type="html">
    
      Week2的主要内容包括：Multivariate Linear Regression多变量线性回归，Normal Equation正规方程以及Octave语言的使用。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（4）气泡排序与归并排序</title>
    <link href="http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-12T12:45:52.000Z</published>
    <updated>2020-02-13T12:45:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过之前的两篇文章我们可以知道有序向量相对于无序向量有着更多的优势，比如它的去重操作以及查找操作都可以更快速地完成，然而我们遗留下一个问题，就是如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法，即起泡算法与归并算法。</p><h1 id="排序器：统一接口"><a href="#排序器：统一接口" class="headerlink" title="排序器：统一接口"></a>排序器：统一接口</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::sort ( Rank lo, Rank hi ) &#123; <span class="comment">//向量区间[lo, hi)排序</span></span><br><span class="line">  <span class="keyword">switch</span> ( rand() % <span class="number">6</span> ) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  bubbleSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//起泡排序</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:  selectionSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//选择排序（习题）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:  mergeSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:  heapSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//堆排序（第12章）</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:  quickSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//快速排序（第14章）</span></span><br><span class="line">    <span class="keyword">default</span>: shellSort ( lo, hi ); <span class="keyword">break</span>; <span class="comment">//希尔排序（第14章）</span></span><br><span class="line">  &#125; <span class="comment">//随机选择算法以充分测试。实用时可视具体问题的特点灵活确定或扩充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量的起泡排序（基本版）</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort( Rank lo, Rank hi ) &#123; <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">  <span class="keyword">while</span>( lo &lt; --hi ) <span class="comment">//反复起泡扫描</span></span><br><span class="line">    <span class="keyword">for</span>( Rank i = lo; i &lt; hi; i++ ) <span class="comment">//逐个检查相邻元素</span></span><br><span class="line">      <span class="keyword">if</span>( _elem[i] &gt; _elem[i + <span class="number">1</span>] ) <span class="comment">//若逆序，则</span></span><br><span class="line">        swap( _elem[i], _elem[i + <span class="number">1</span>] ); <span class="comment">//经交换使局部有序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一章曾以这个算法为例介绍过如何证明算法的正确性，这里按照刚才统一定义的形式将它整理为一个名为<code>bubbleSort</code>的算法接口。这个算法实际上可以认为是通过调用一个名为bubble的过程迭代地来进行，在每一迭代过程中都会考察当前介于<code>lo</code>和<code>hi</code>之间的所有相邻元素，只要有一对相邻元素是逆序的，就将它们交换，所以整个这样的一个过程也称作<strong>扫描交换</strong>。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200206133211.png" style="zoom: 50%;"></p><p>这个算法的不变法具体来说，如果最初的这个向量是一个无序向量的话，那么每经过这样一趟对bubble的调用都会有一个新的元素就位，比如对于第一次而言就是全局最大的那个元素，这里用红色来表示就位的元素，那么当然互补地其它的部分也就是接下来要考察的问题的范围，就会相应地缩小一个单元，这也是减而治之。再接下来有序的部分会继续地拓展，而无序的部分会继续地缩减，整个呈现为一个不断此消绿色的这部分，和彼涨红色的这部分<br>这样一个过程，直到无序的部分只剩下一个元素。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212210120.png" style="zoom:80%;"></p><p>不难看出每一趟对bubble的调用所需要的时间都线性正比于绿色无序部分的宽度，整体地呈现为一个算术级数的形式，所以它的总体量与它的末项成平方关系，即$O(n^2)$。然而我们并不满足于这样的结果，至少在很多情况下都是有可能改进的。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>可以看到这里的红色部分确实必然是有序的，但是绿色的部分未必都是无序的，事实上比如这个时候有可能其中会有一部分元素，甚至所有的元素都是有序的。那么如何尽早地判定出这种情况，从而提前结束这个算法呢？这里依赖的准则与算法最初的判定准则是一样的，也就是一个向量包括一个区间如果是完全有序的，当且仅当其中任何一对相邻的元素都是彼此顺序的，而实际上在刚刚进行完的前一次迭代中我们在某种意义上已经做过这种类似的检查了。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212211729.png" style="zoom: 67%;"></p><p>由此可以得出一个改进的策略：在每一次扫描交换的过程中不妨记录一下是否曾经真的存在逆序元素，如果存在的话它的充要条件是在此前做过一次交换，所以我们只要来记录一下在当下这趟扫描交换过程中是否曾经做过至少一次扫描交换，如果没有做过那么后续的各趟其实都可以省略掉，从而在实际的运行时间上有可能会有所减少，甚至大大减少。这是一个很好的策略，我们不妨把这个策略整理为下面的一段代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123;</span><br><span class="line"><span class="keyword">while</span> (!bubble(lo, hi--));</span><br><span class="line">&#125;  <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123;</span><br><span class="line"><span class="keyword">bool</span> sorted = ture;  <span class="comment">//整体有序标志</span></span><br><span class="line"><span class="keyword">while</span>(++lo &lt; hi)&#123;    <span class="comment">//自左向右，逐一检查各相邻元素</span></span><br><span class="line"><span class="keyword">if</span> (_elem[lo - <span class="number">1</span>] &gt; _elem[lo]) &#123;    <span class="comment">//若逆序，则</span></span><br><span class="line">sorted = <span class="literal">false</span>;                 <span class="comment">//意味着尚未整体有序，并需要</span></span><br><span class="line">swap(_elem[lo - <span class="number">1</span>], _elem[lo]); <span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sorted;  <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原算法整体运行时间确实可以度量为一个三角形的面积，那么对于新的改进的这个算法，它固然要做第一趟扫描交换也许还需进行若干次扫描交换，但是在某些情况下它有可能会发现不光此后的部分已经有序了，而且这个前缀也已经完全有序了，所以这时它就会及时地跳转到最后，聪明地绕过这些完全可以绕过的计算量。因此与刚才那样对比新的这个算法所执行的计算量可以度量为这样一个梯形，而不是原来的三角形，也就是说很多情况下都可以节省一定的甚至是相当多的时间。不过我们对这个算法的改进并不满足于此因为我们发现在一些其它或者说在更多的情况下，这个算法依然存在继续改进的空间。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212212729.png" style="zoom:50%;"></p><h2 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h2><p>考察这样一个向量，假设它可以分为长度相差悬殊的一个前缀以及后缀，而且后缀中的元素都已按顺序排列并严格地就位，当然相应地所有的乱序元素都集中分布于这样一个相对更短的前缀中。对于这样的一个实例，上节中已经做过优化的起泡排序算法会如何表现呢？</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212214445.png" style="zoom: 67%;"></p><p>首先它需要做第一趟完整地扫描交换，并且确认在最后这个位置有一个元素就位，虽然它原本就是就位的。请注意虽然这个时候在这个后缀中，存在着大量的就位元素，但因为在前缀中刚才存在交换，<code>bubble</code>算法会返回false，那么算法接下来还会继续下去。尽管能够判定的就位元素数目会继续增加，但是与刚才同理，我们依然不能确认可以提前退出，接下来还需要进行若干次的扫描交换。那么对于这样的一个例子，总体而言需要的扫描交换的趟数不会超过这个前缀的长度<code>r</code>。</p><p>因为此前所做的各趟扫描交换，与其说是在对绿色的范围做处理，不如说实际影响的是这个前缀中的倒数第一个<br>倒数第二个 以及倒数第三个，即是在这个前缀中后面的那些元素。每一趟扫描交换所起的实质作用无非是在这样一个前缀中，令其中的一个一个的后缀元素依次就位，直到整个这个前缀中的元素完全就位。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212215502.png" style="zoom:67%;"></p><p>因此这个算法总体消耗的时间应该是n乘以r，如果r取作根号n，相应地也就是n的1.5次方，即$O(n^{1.5})$。但如果能及时地检测出这样一种情况，也就是实质需要排序的元素集中在一个宽度仅为$\sqrt{n}$的区间中，而不是整个向量。那么即使套用最原始的起泡排序算法，所需要的时间也无非是$O((\sqrt{n})^2)=O(n)$。问题是如何才能够完成从1.5次方到一次方的优化转换呢？</p><p>重新审视上面的例子，所多余出来的时间消耗无非是在后缀中，对这些已就位元素的反复扫描交换，不难理解这些元素都是不必扫描交换的，可惜此前的算法版本未能及时地将它们分解出来，但它们实际上是可以分解出来的。</p><p>比如说如果我们通过某一种方法记录在上一趟扫描交换过程中所进行的最后一次交换，就很容易确定在上一趟扫描的区间中有一个多长的后缀实际上没有做过任何交换，也就是说它们中的元素都是已经就位了的。如果能这样只需要将原先的右侧标志<code>hi</code>直接地指向这个新的位置，而不是像刚才那样亦步亦趋地、逐个地收缩。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212215732.png" style="zoom:50%;"></p><p>基于以上的分析不难得到下面的新的改进的方法，从结构上看跟刚才大体类似，依然是逐个地检查所有的相邻对，如果是逆序的就做交换，不同之处在于这里我们所记录的不再只是一个逻辑性变量，而是一个名为<code>last</code>的整型或者说是秩，它的初值是取作lo，而每当需要交换就将这个<code>last</code>更新为新的位置。在整个算法的过程中<code>lo</code>这个变量是持续递增的，所以当它在返回的时候，<code>last</code>确实名副其实地记录了最右侧也就是最后一对逆序对的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort(Rank lo,Rank hi)&#123;</span><br><span class="line"><span class="keyword">while</span> (!bubble(lo, hi--));</span><br><span class="line">&#125;  <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::bubble(Rank lo, Rank hi) &#123;</span><br><span class="line">Rank last = lo;  <span class="comment">//最右侧的逆序对初始化为[lo-1, lo]</span></span><br><span class="line"><span class="keyword">while</span>(++lo &lt; hi)&#123;    <span class="comment">//自左向右，逐一检查各相邻元素</span></span><br><span class="line"><span class="keyword">if</span> (_elem[lo - <span class="number">1</span>] &gt; _elem[lo]) &#123;    <span class="comment">//若逆序，则</span></span><br><span class="line">last = lo;                 <span class="comment">//更新最右侧逆序对位置记录，并</span></span><br><span class="line">swap(_elem[lo - <span class="number">1</span>], _elem[lo]); <span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;  <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;  <span class="comment">//前一版本中的逻辑型标志sorted，改为秩last</span></span><br></pre></td></tr></table></figure><p>这样我们就可以有效地来处理刚才那种情况，回到刚才那个实例，我们构造了一个足够短的乱序前缀再加一个非常长但是已经就绪了的后缀。新的算法首先也会做一趟扫描交换，当然为此花费的时间是$O(n)$。但是与刚才那个版本的不同，在这个时候它会检测出发生的最后一次扫描交换绝对不会超过绿色末尾的位置，将扫描交换的右侧界桩<code>hi</code>一次性地挪到那里，这等效于判断出了此后的这些元素包括最后那个元素都是已经就位的。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212222027.png" style="zoom: 50%;"></p><p>从算法的流程来说我们的下一趟扫描交换的区间，就不再是原先整个那个绿色的区间，而是相对要短很多的一个区间。接下来等效于只是对这样一段区间做扫描交换，因此需要花费的时间除了刚才的$O(n)$以外，主要是对应于这样的一个更小的三角形，如果边长是$\sqrt{n}$，累计也不过是再加上一个$O(n)$，与刚才的$O(n)$合并，总体不过是$O(n)$，更有意思的是这种情况在整个排序过程中有可能会多次出现。</p><p>我们也可以通过图形的方式，形象地将新的这个算法版本与之前的原始版本在时间效率上做一个对比。这个三角形 代表的是原始的起泡排序算法所需要的时间。新版本的算法所需要执行的扫描交换将会呈现为连续的一段。然后再间或地跳跃到下面一段以及再间或地有可能会跳跃到下面一段（深色部分）。换而言之这个算法的时间成本将取决于这样一个一个若干个梯形的面积总和，相对于此前那个梯形来说这种梯形的划分更加的精细，所以它节省下来的时间也会在通常的情况下相对更多。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212220355.png" style="zoom:50%;"></p><p>当然在最坏的情况下这个算法依然是于事无补的，起泡排序依然注定需要$O(n^2)$的时间。</p><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><ul><li><p>三种起泡排序在最好和最坏情况下的效率相同：最好$O(n)$，最坏$O(n^2)$</p></li><li><p>输入含重复元素时，算法的稳定性（stability）是更为细致的要求</p><p>重复元素在输入，输出序列中的相对次序，是否保持不变？（在某些问题中很敏感）</p><p>​        输入：$6,7_a,3,2,7_b,1,5,8,7_c,4$</p><p>​        输出：$1,2,3,4,5,6,7_a,7_b,7_c,8$      //stable</p><p>​                    $1,2,3,4,5,6,7_a,7_c,7_b,8$     //unstable</p></li><li><p>三种起<strong>泡排序算法都是稳定</strong>的，因为在起泡排序中，元素$7_a$和$7_b$的相对位置发生变化，只有一种可能：</p><p>​        经分别与其他元素的交换，二者相互接近直至相邻</p><p>​        在接下来一轮扫描交换中，二者因逆序而交换位置</p><p>而起泡排序中交换，即if的判断条件是<code>_elem[lo - 1] &gt; _elem[lo])</code>，严格大于，因此不会出现上面的情况</p></li></ul><p>虽然起泡排序可以做大量的改进，但从最坏情况而言它依然是注定也需要$O(n^2)$的时间，所以我们非常希望能够得到一个即便在最坏情况下也能够效率更高的排序算法，这也就是下一节所要介绍的内容。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>采用包括Bubble sort在内的常规的基于比较式的算法（Comparison Based Algorithm），求解排序问题都存在一个下界$nlogn$。那么在$n^2$的上界到$nlogn$的下界之间是否存在一些其它的，相对于$n^2$而言更好的算法,甚至于是否有一个算法即使在最坏的情况下也只需要$nlogn$的时间就能完成排序呢？答案就蕴含在这一节的主题里<br>也就是归并排序（Merge Sort）。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212224219.png" style="zoom: 50%;"></p><p>归并排序算法是<strong>分治策略</strong>在算法设计中应用的又一个典型，这个算法最初是由冯·诺依曼编码实现的，所谓的分治策略在这里就是说将待排序的那个序列（向量或者列表）一分为二，这种分法很快捷只需要$O(1)$的时间，接下来 对于划分出的两个子序列分别去做递归地求解，也就是递归地排序。而当两个子序列已经分别有序之后，我们接下来要解决的一个问题就是将它们合并准确地讲是归并merge，从而构成一个完整的有序序列。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212225508.png" style="zoom: 80%;"></p><p>对于上面这样一个由8个元素组成的向量，首先是分沿左右划分为左和右两个子序列，这两个子序列递归地求解的过程中依然还是相对比较大，所以它们会继续递归地、各自地进行划分继续分为左左、左右以及右左和右右四个子序列。同样 它们还是不够平凡所以我们最后还要对这四个子序列继续地一分为二，最终八个元素各自成为一个独立的序列，这个时候从递归地角度讲就抵达了递归基，所有这些元素都已经不需要再继续划分下去了，因为它们各自有序了。</p><p>所以如果说前面半层是做无序向量的递归分解，接下来就要通过逐层的合并使之逐渐地变成一个大一点的，更大一点的，直到最后那个有序的序列。我们可以看到每一次都是将两个已经是有序的子序列合并为一个有序的子序列，然后再继续相邻的子序列逐对地合并构成再更大的序列，最后左右这两个各自有序的子序列再逐对地合并最终得到整体的序列。</p><p>那么如果果真能像这里所说的那样，我们就应该能够得到一个总体是$nlogn$的算法，可由下面的递推式证明，其中$O(n)$是分与并累计的时间。</p><script type="math/tex; mode=display">T(n)=2\cdot T(n/2)+O(n)</script><p>可以得到：$T(n)=O(nlogn)$。</p><p>接下来的技术细节就是如何来兑现这一点呢？可以看到从这里的划分的过程是非常简单，递归也可以交给递归的机制去做，所以这里核心的任务是在怎么进行合并，或者准确地讲是怎么将两个已经有序的序列归并成一个更大的序列，这也是这个算法最关键的细节和技巧。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212224639.png" style="zoom: 50%;"></p><h2 id="主算法"><a href="#主算法" class="headerlink" title="主算法"></a>主算法</h2><p>把刚才的思路实现为这样一段具体的代码，和所有的递归程序一样首先要处理递归基，接下来开始实质的分也就是除二取到中点，这样的话我们可以将整体的一个序列分成左和右两部分，分别由<code>lo</code>和<code>mi</code>，以及<code>mi</code>和<code>hi</code>来界定。对于这两个序列，分别是递归调用自己，<code>mergeSort</code>前一个序列，<code>mergeSort</code>后一个序列。接下来最重要的实质的工作是在<code>merge</code>，下面不妨来通过一个实例来理解merge算法的原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">  <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">  <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">  mergeSort ( lo, mi ); </span><br><span class="line">  mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">  merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>2-way merge：将两个有序序列合并为一个有序序列 S[lo, hi) = S[lo, mi) + S[mi, hi)</li></ul><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212233054.png" style="zoom:80%;"></p><p>首先（a）图给出了两个各自有序的子序列，二路归并算法的要诀就是我们只需要把注意力关注在这两个序列的首元素上，这样一个虚线的方框是我们的关注焦点，其余的元素可以暂时不用顾及。那么我们取出这两个序列各自的首元素的时候，都要从中挑选出更小的那个元素，如果是两者相等的话，可以任意取一个。<br>比如 就这个例子而言</p><p>就这个例子而言首先取出的是这个2，我们将它择出来，相应地在摘除了首元素以后，后续的元素将逐次递补，也就是关注到新顶替上来的这个首元素上。同样在接下来的一轮比对中，我们考察这两个首元素的大小，并且同样地取出其中的更小的那个，4依然比5小所以4被取出，同样它的后继们会顶替上来对这个例子而言就是10。就这样逐步进行到图（h），直到最终一旦有一个向量已经变成空的，那么另一个向量所剩余的元素无论多少都直接串接在后边（因为剩余那部分必然是有序的）。</p><p>按照这样的原理，我们确实可以得到一个更大的单调序列，这种二路归并的算法实际上是非常通用的一个版本，但在这里针对于归并排序而言的，我们实际上用到的是其中的一种特例，在这个时候参与归并的两个序列实际上是来自于同一个更大的向量，只不过是由其中的三个界桩也就是<code>lo</code>、<code>mi</code>和<code>hi</code>来联合定义的。如果左侧的这个向量称作B，右侧的称作C的话，那么合并起来的整体的这个向量就是A。那下一小节介绍针对这样一种特殊情况，二路归并算法应该如何实现。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200212234305.png" style="zoom:50%;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序向量（区间）的归并</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge ( Rank lo, Rank mi, Rank hi )&#123;<span class="comment">//各自有序的子向量[lo, mi)和[mi, hi)</span></span><br><span class="line">  T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br><span class="line">  <span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line">  <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="comment">//复制前子向量</span></span><br><span class="line">  <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br><span class="line">  <span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb) || (k &lt; lc); ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt;  B[j]))) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;  <span class="comment">//该循环实现紧凑；但就效率而言，不如拆分处理</span></span><br><span class="line">  <span class="keyword">delete</span> [] B; <span class="comment">//释放临时空间B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读一下上面的代码：首先需要将定义两个向量的三个界桩也就是<code>lo</code>、<code>mi</code>和<code>hi</code>作为参数传入，接下来要定义清楚ABC三个向量：首先A向量在这里将继续地保存在它输入的位置，准确地讲就是在<code>_elem</code>整个数据区中起自于最左侧的界桩<code>lo</code>的一段区间，可以直接令A指向这个区间的起点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br></pre></td></tr></table></figure><p>接下来是左侧的子向量B，我们需要为这个子向量申请一段空间，它的宽度应该是<code>mi</code>到<code>lo</code>之间的距离，当然还需要将A中对应的那些元素，也就是左半部分的那些元素，逐一地取出来并且复制到新开辟的这段空间中去，从而完成整体的这个子向量B的一个缓冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line"><span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; i++ ) B[i] = A[i]; <span class="comment">//复制前子向量</span></span><br></pre></td></tr></table></figure><p>最后是C，C非常的简单，实际上定义的就是在<code>_elem</code>数据区中，起始于<code>mi</code>的这段数据，那么不同的在于右侧的子向量C并不需要另辟空间进行缓存，尽管在这里为了说明的方便，还是将它画在了上边作为一个单独的子向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213000033.png" style="zoom:80%;"></p><p>接下来就是最主要的这个循环，这也就是上节实例子所给的过程，具体来讲就是每一次我们都比较两个子向量当前的首元素取出其中更小的那个，比如说在for循环体中上面一句的情况下B更小，而在下面一句的情况下C更小，无论谁更小都把它转入到A中去。B和C首元素是由j和k这两个秩来标定的，在最初始的情况下它们都是0，分别指向B和C的第一个元素，在随后 每当有一个元素转移到A中，它们各自都会自加，从而指向下一个替补的新的首元素。而A每次纳入新元素由<code>i</code>指示，其初值也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; (j &lt; lb) || (k &lt; lc); ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((j &lt; lb) &amp;&amp; (lc &lt;= k || (B[j] &lt;= C[k]))) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (lb &lt;= j || (C[k] &lt;  B[j]))) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当B更小的情况：严格来讲是由一系列的逻辑判断构成的，首先是一个and，我们要确定<code>j &lt; lb</code>，即B中的首元素的秩应该至少没有越过它的右侧的边界，它还是合法的，也就是<code>B[j]</code>指向的还是一个实在的而不是虚拟的元素，接下来地有两种情况，要么C中的<code>k</code>已经越界，要么就是<code>k</code>没有越界，但是<code>B[j]</code>更小<code>B[j] &lt;= C[k]</code>，这里我们运用了C++语言里头的“<strong>短路求值”</strong>的语法特性，否则在不满足的情况下还去进行比较求值，实际上这个<code>k</code>因为已经越界就会造成程序运行过程中的错误。当C更小的情况也是同理。</p><p>当然整个这个循环的退出条件也值得揣摩的，这里的条件<code>(j &lt; lb) || (k &lt; lc)</code>可以理解为是这两个位置<code>j</code>和<code>k</code>同时越界之后算法才会退出，而在这个时候无论是B还是C中的元素都已经完整地归入到了A中，成为了一个整体的序列。</p><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>为了更好地理解算法的过程，我们不妨分几种情况来给出具体的图示作进一步解释。</p><p>首先来考虑第一种情况（a)，<code>i</code>还是介于<code>lo</code>和<code>mi</code>之间没有越过<code>mi</code>这个界线，还没有进入到C这个子向量的范围，这种情况显然<code>i</code>不可能居于<code>j</code>的左侧，顶多是平齐，所以每次迭代中如果需要发生数据转移的话，无论是<code>B[j]</code>转移到<code>A[i]</code>，还是<code>C[k]</code>转移到<code>A[i]</code>，整个数据从内容来讲都不会发生覆盖，是安全的，功能上讲也是正确的。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093008.png" style="zoom:67%;"></p><p>再来看相对复杂一点的情况(b)，也就是当<code>i</code>在持续增加之后，终会越过<code>mi</code>，进入C的区域。表面看这样会侵犯到C的区域，但实际上不要紧，因为在这个时候<code>k</code>绝对不会位于<code>i</code>的左侧，所以介于<code>mi</code>和<code>i</code>之间的这些元素，其实作为C中原来的元素必然已经归入到A中，当然是它的左侧在<code>i</code>之前的这部分中的某一个适当的位置。所以这种情况依然是安全的，无论是<code>C[k]</code>、还是<code>B[j]</code>转移到<code>A[i]</code>中去，都不会导致C中已有的元素被无意中覆盖掉，从而导致错误。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093113.png" style="zoom:67%;"></p><p>再来看最后两种更为复杂的情况，如图（c），B这个子向量已经提前耗尽，它其中的元素已经完全地归入到A中<br>当然也是就位了，而在C中还残存有部分的元素没有转移和就位。这种情况下我们的逻辑其实相当于等效地是在B的最右侧，就是<code>lb</code>这个位置上增加了一个哨兵节点，而且它的数值就是正无穷。因此即便C的右侧还残存有若干个元素它们也会在接下来的各次迭代中，因为是与这样一个正无穷相比而被认为是更小，从而顺利地转移到A中适当的位置，直到两个子向量都同时耗尽。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093158.png" style="zoom:67%;"></p><p>反过来另一种对称的情况（d）就是C也可能会提前耗尽，也相当于等效地 在C的最右侧增加了一个数值为正无穷的哨兵，它的秩是<code>lc</code>，所以即便在B的尾部 还残存有部分的元素也不要紧，它们也等效于和这样一个数值为正无穷的哨兵相比，总是会被认为是更小，所以按照算法的逻辑会等效地转移到A中剩余的对应区域中去，整个这个过程也是会顺利地进行，不会出现我们所说的数据遗漏或者数据被无意中覆盖。</p><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213093242.png" style="zoom:67%;"></p><p>需要注意的是（c）和（d）这两种情况其实并不对等，因为按照这里的设计，其实向量C和B地位本来就是不等的。B是完全复制出来的一个缓冲部分，而C虽然是独立的绘制出来但实际上它就在A中，占据右端，换而言之如果是C提前耗尽，我们确实需要把B尾部的这些元素悉数转移到A的尾部，但如果是B提前耗尽那么对C尾部这些元素的转移其实都是多余的，因为它们原来就在那，完全没有必要。注意到这样一个现象的话，我们就不难对刚才表面上很规范的逻辑进一步的精简：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; j &lt; lb; ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( lc &lt;= k || (B[j] &lt;= C[k]) ) </span><br><span class="line">          A[i++] = B[j++];                          <span class="comment">//B更小，C[k]已无或不小</span></span><br><span class="line">  <span class="keyword">if</span> ((k &lt; lc) &amp;&amp; (C[k] &lt;  B[j]) ) </span><br><span class="line">          A[i++] = C[k++];                          <span class="comment">//C更小，或B[j]已无或更大</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E6%B0%94%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/QQ图片20200213095412.png" style="zoom:67%;"></p><p>这里最重要的改进就是并不需要考虑C提前耗尽的那种情况，我们只需要考虑B提前耗尽的情况，一旦B提前耗尽<br>我们就可以直接终止这个循环包括这个算法，这样可以使这个算法效率进一步的提高，尽管不是从渐进角度而言的一种实质的提高。</p><p>那么这个算法在原来以及包括这样精简之后，从渐进意义上讲 复杂度是多少呢？是否能像我们最初所预期的那样能够有大幅度的提高呢？</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>算法的运行时间主要消耗于for循环，共有两个控制变量 </p><p>​    初始：j = 0, k = 0</p><p>​    最终：j = lb, k = lc</p><p>​    亦即：j + k = lb + lc =hi - lo = n</p></li><li><p>观察：每经过一次迭代，j和k中至少有一个会加一（j + k 也至少加一）</p></li><li><p>故知：merge()总体迭代不过$O(n)$次，累计只需线性时间</p><p>这一结论与排序算法的$\Omega(nlogn)$下界并不矛盾——毕竟这里的B和C均已各自有序</p></li><li><p>归并算法在最坏情况下的复杂度：$T(n)=2\cdot T(n/2)+O(n)$ ——&gt;$T(n)=O(nlogn)$</p></li><li><p>注意：待归并子序列不必等长</p><p>亦即：允许lb $\ne$ lc，mi $\ne$ (lo + hi) / 2</p></li><li><p>实际上，这一算法及结论也适用于另一类序列——列表</p></li></ul>]]></content>
    
    <summary type="html">
    
      如何将一个无序的向量转化为有序的向量，这就需要用到排序算法，本文针对向量介绍两种典型的排序算法：起泡算法与归并算法。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ML:Week1</title>
    <link href="http://nekomoon404.github.io/2020/02/11/ML-Week1/"/>
    <id>http://nekomoon404.github.io/2020/02/11/ML-Week1/</id>
    <published>2020-02-11T02:15:57.000Z</published>
    <updated>2020-02-13T02:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="What-is-Machine-Learning"><a href="#What-is-Machine-Learning" class="headerlink" title="What is Machine Learning"></a>What is Machine Learning</h2><p>Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition.</p><p>Tom Mitchell provides a more <strong>modern definition</strong>: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”</p><p>Example: playing checkers.</p><p>E = the experience of playing many games of checkers</p><p>T = the task of playing checkers.</p><p>P = the probability that the program will win the next game.</p><p>In general, any machine learning problem can be assigned to one of two broad classifications:</p><p>Supervised learning and Unsupervised learning.</p><h2 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h2><p>In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.</p><p>Supervised learning problems are categorized into “<strong>regression</strong>“ and “<strong>classification</strong>“ problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103343.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103351.png" style="zoom:50%;"></p><p><strong>Example 1:</strong></p><p>Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.</p><p>We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories.</p><p><strong>Example 2</strong>:</p><p>(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture</p><p>(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.</p><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>Unsupervised learning allows us to <strong>approach problems with little or no idea what our results should look like</strong>. We can derive structure from data where we don’t necessarily know the effect of the variables.</p><p>We can derive this structure by clustering the data based on relationships among the variables in the data.</p><p>With unsupervised learning there is no feedback based on the prediction results.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103654.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211103533.png" style="zoom:50%;"></p><p><strong>Example:</strong></p><p><strong>Clustering</strong>: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.</p><p><strong>Non-clustering</strong>: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party).</p><h1 id="Model-and-Cost-Function"><a href="#Model-and-Cost-Function" class="headerlink" title="Model and Cost Function"></a>Model and Cost Function</h1><h2 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h2><p>To establish notation for future use, we’ll use $x^{(i)}$to denote the “input” variables (living area in this example), also called input features, and $y^{(i)}$ to denote the “output” or target variable that we are trying to predict (price). A pair $(x^{(i)} , y^{(i)} )$ is called a training example, and the dataset that we’ll be using to learn—a list of m training examples $(x^{(i)},y^{(i)});i=1,…, m$—is called a <strong>training set</strong>. </p><p>Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ.</p><p>To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a <strong>hypothesis</strong>. Seen pictorially, the process is therefore like this:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211104346.png" style="zoom: 80%;"></p><p>When <strong>the target variable that we’re trying to predict is continuous</strong>, such as in our housing example, we call the learning problem a <strong>regression problem</strong>. When <strong>y can take on only a small number of discrete values</strong> (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a <strong>classification problem</strong>.</p><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>We can measure the accuracy of our hypothesis function by using a <strong>cost function</strong>. This takes an average difference (actually a fancier version of an average) of all the results of the hypothesis with inputs from x’s and the actual output y’s.</p><script type="math/tex; mode=display">J(\theta_0, \theta_1) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>To break it apart, it is $\frac{1}{2} <script type="math/tex">\bar{x}$， where</script>\bar{x}$$ is the mean of the squares of $h_\theta (x_{i}) - y_{i}$, or the difference between the predicted value and the actual value.</p><p>This function is otherwise called the “<strong>Squared error function</strong>“, or “<strong>Mean squared error</strong>“. The mean is halved $\left(\frac{1}{2}\right) $as a convenience for the computation of the gradient descent, as the derivative term of the square function will cancel out the$ \frac{1}{2}$ term. The following image summarizes what the cost function does:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211110416.png" style="zoom: 50%;"></p><h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition 1"></a>Intuition 1</h3><p>If we try to think of it in visual terms, our training data set is scattered on the x-y plane. We are trying to make a straight line (defined by $h_\theta(x)$) which passes through these scattered data points.</p><p>Our objective is to get the best possible line. The best possible line will be such so that the average squared vertical distances of the scattered points from the line will be the least. Ideally, the line should pass through all the points of our training data set. In such a case, the value of $J(\theta_0, \theta_1)$will be 0. The following example shows the ideal situation where we have a cost function of 0.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111045.png" style="zoom:50%;"></p><p>When $\theta_1 = 1$, we get a slope of 1 which goes through every single data point in our model. Conversely, when $\theta_1 = 0.5$, we see the vertical distance from our fit to the data points increase.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111208.png" style="zoom:50%;"></p><p>This increases our cost function to 0.58. Plotting several other points yields to the following graph:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111212.png" style="zoom:50%;"></p><p>Thus as a goal, we should try to minimize the cost function. In this case, $\theta_1 = 1$=1 is our <strong>global minimum</strong>.</p><h3 id="Intuition-2"><a href="#Intuition-2" class="headerlink" title="Intuition 2"></a>Intuition 2</h3><p>A <strong>contour plot</strong>（等高线，轮廓线） is a graph that contains many contour lines. A contour line of a two variable function has a constant value at all points of the same line. An example of such a graph is the one to the right below.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111928.png" style="zoom:50%;"></p><p>Taking any color and going along the ‘circle’, one would expect to get the same value of the cost function. For example, the three green points found on the green line above have the same value for $J(\theta_0,\theta_1)$ and as a result, they are found along the same line. The circled x displays the value of the cost function for the graph on the left when $\theta_0$ = 800 and $\theta_1$= -0.15. Taking another h(x) and plotting its contour plot, one gets the following graphs:</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111932.png" style="zoom:50%;"></p><p>When $\theta_0$ = 360 and $\theta_1$ = 0, the value of $J(\theta_0,\theta_1)$ in the contour plot gets closer to the center thus reducing the cost function error. Now giving our hypothesis function a slightly positive slope results in a better fit of the data.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211111935.png" style="zoom:50%;"></p><p>The graph above minimizes the cost function as much as possible and consequently, the result of $\theta_1$ and $\theta_0$ tend to be around 0.12 and 250 respectively. Plotting those values on our graph to the right seems to put our point in the center of the inner most ‘circle’.</p><h1 id="Parameter-Learning"><a href="#Parameter-Learning" class="headerlink" title="Parameter Learning"></a>Parameter Learning</h1><h2 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h2><p>So we have our hypothesis function and we have a way of measuring how well it fits into the data. Now we need to estimate the parameters in the hypothesis function. That’s where <strong>gradient descent</strong> comes in.</p><p>Imagine that we graph our hypothesis function based on its fields $\theta_0$ and $\theta_1$ (actually we are graphing the cost function as a function of the parameter estimates). We are not graphing x and y itself, but the parameter range of our hypothesis function and the cost resulting from selecting a particular set of parameters.</p><p>We put $\theta_0$ on the x axis and $\theta_1$ on the y axis, with the cost function on the vertical z axis. The points on our graph will be the result of the cost function using our hypothesis with those specific theta parameters. The graph below depicts such a setup.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211112658.png" style="zoom:50%;"></p><p>We will know that we have succeeded when our cost function is at the very bottom of the pits in our graph, i.e. <strong>when its value is the minimum</strong>. The red arrows show the minimum points in the graph.</p><p>The way we do this is by taking the <strong>derivative</strong> (the tangential line to a function) of our cost function. The slope of the tangent is the derivative at that point and it will give us a direction to move towards. We make <strong>steps down the cost function in the direction with the steepest descent</strong>. The size of each step is determined by the parameter α, which is called the learning rate.</p><p>For example, the distance between each ‘star’ in the graph above represents a step determined by our parameter α. A smaller α would result in a smaller step and a larger α results in a larger step. The direction in which the step is taken is determined by the partial derivative of J(\theta_0,\theta_1)<em>J</em>(<em>θ</em>0,<em>θ</em>1). Depending on where one starts on the graph, one could end up at different points. The image above shows us two different starting points that end up in two different places.</p><p>The gradient descent algorithm is:</p><p>repeat until convergence:</p><script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j} J(\theta_0, \theta_1)</script><p>where $j=0,1$ represents the feature index number.</p><p>At each iteration j, one should simultaneously update the parameters $\theta_1, \theta_2,…,\theta_n$. Updating a specific parameter prior to calculating another one on the $j^{(th)}$ iteration would yield to a wrong implementation.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211112718.png" style="zoom:50%;"></p><h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>In this part we explored the scenario where we used one parameter $\theta_1$ and plotted its cost function to implement a gradient descent. Our formula for a single parameter was :</p><p>Repeat until convergence:</p><script type="math/tex; mode=display">\theta_1 := \theta_1 - \alpha \frac{\partial}{\partial \theta_1} J(\theta_1)</script><p>Regardless of the slope’s sign for $\frac{d}{d\theta_1} J(\theta_1)$, $\theta_1$ eventually converges to its minimum value. The following graph shows that when the slope is negative, the value of $\theta_1$ increases and when it is positive, the value of $\theta_1$ decreases.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113613.png" style="zoom:50%;"></p><p>On a side note, we should <strong>adjust our parameter $\alpha$ to ensure that the gradient descent algorithm converges in a reasonable time</strong>. Failure to converge or too much time to obtain the minimum value imply that our step size is wrong.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113618.png" style="zoom:50%;"></p><p>How does gradient descent converge with a fixed step size $\alpha$?</p><p>The intuition behind the convergence is that $\frac{d}{d\theta_1} J(\theta_1)$ approaches 0 as we approach the bottom of our convex function. At the minimum, the derivative will always be 0 and thus we get:</p><script type="math/tex; mode=display">\theta_1 := \theta_1 - \alpha*0</script><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113622.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211113625.png" style="zoom:50%;"></p><h2 id="Gradient-Descent-For-Linear-Regression"><a href="#Gradient-Descent-For-Linear-Regression" class="headerlink" title="Gradient Descent For Linear Regression"></a>Gradient Descent For Linear Regression</h2><p>When specifically applied to the case of linear regression, a new form of the gradient descent equation can be derived. We can substitute our actual cost function and our actual hypothesis function and modify the equation to :</p><p>Repeat until convergence:</p><script type="math/tex; mode=display">\begin{align*}   & \newline \theta_0 := & \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}(h_\theta(x_{i}) - y_{i}) \newline \theta_1 := & \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}\left((h_\theta(x_{i}) - y_{i}) x_{i}\right) \newline & \end{align*}</script><p>where m is the size of the training set, $\theta_0$ a constant that will be changing simultaneously with $\theta_1$ and $x_i$, $y_i$ are values of the given training set (data).</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114831.png" style="zoom:50%;"></p><p>The point of all this is that if we start with a guess for our hypothesis and then repeatedly apply these gradient descent equations, our hypothesis will become more and more accurate.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114835.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114839.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114850.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114854.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114859.png" style="zoom:50%;"></p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114902.png" style="zoom:50%;"></p><p>So, this is simply gradient descent on the original cost function J. This method looks at every example in the entire training set on every step, and is called <strong>batch gradient descent</strong>. Note that, while gradient descent can be susceptible to local minima in general, the optimization problem we have posed here for linear regression has only one global, and no other local, optima; thus gradient descent always converges (assuming the learning rate α is not too large) to the global minimum. Indeed, J is a convex quadratic function. Here is an example of gradient descent as it is run to minimize a quadratic function.</p><p><img src="/2020/02/11/ML-Week1/QQ图片20200211114941.png" style="zoom: 67%;"></p><p>The ellipses shown above are the contours of a quadratic function. Also shown is the trajectory taken by gradient descent, which was initialized at (48,30). The x’s in the figure (joined by straight lines) mark the successive values of θ that gradient descent went through as it converged to its minimum.</p>]]></content>
    
    <summary type="html">
    
      这几天开始看coursera网站上Andrew Ng教授的Machine Learning课程，看评论说这门课讲的比较浅显，适合入门学习，课程是按周排的，那我也按周记录下学习的内容_φ_(．．)。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（3）有序向量</title>
    <link href="http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/</id>
    <published>2020-02-10T02:58:38.000Z</published>
    <updated>2020-02-12T02:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h1><p>有序向量是相对于无序向量而言，无序向量要求元素之间至少应该能比较是否相等，我们称作比对操作；而有序向量更为复杂，它需要能够判定任何一对元素孰大孰小，这叫作比较操作。元素之间可以相互比较只是有序向量的一个必要条件，如果要成为一个真正的有序向量，还必须要求其中的元素确实是按照顺序排列的，因此就存在一个如何甄别一个向量是否有序的问题。</p><h2 id="有序性及其甄别"><a href="#有序性及其甄别" class="headerlink" title="有序性及其甄别"></a>有序性及其甄别</h2><ul><li>与起泡排序算法的理解相同：</li></ul><p>​        有序序列中，任意一对相邻元素顺序；无序序列中，总有一对相邻元素逆序。</p><ul><li>因此，逆序相邻元素的数目，可用以度量向量的逆序程度。</li><li>无序向量经预处理转换为有序向量之后，相关算法多可优化。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//返回逆序相邻元素对的总数</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;    <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _sizei++)        <span class="comment">//逐一检查各对相邻元素</span></span><br><span class="line">n += (_elem[i - <span class="number">1</span>] &gt; _elem[i]);  <span class="comment">//逆序则计数</span></span><br><span class="line"><span class="keyword">return</span> n;   <span class="comment">//向量有序当且仅当 n = 0</span></span><br><span class="line">&#125;  <span class="comment">//若只需判断是否有序，则首次遇到逆序对之后，即可立即终止</span></span><br></pre></td></tr></table></figure><p>根据上面的分析可以知道，一个向量是有序的，当且仅当经过disordered()判断以后返回的值是零。实际上只要向量中的元素本身是支持大小比较的，就有一定的办法将它转化为有序向量。其中的原因在于经过这样的一个转换以后虽然我们花费了一定的成本，但此后涉及到的很多操作也就是相关算法，大多都可以优化，相应地所得要远远比转换时所花费的成本大的多。</p><h2 id="低效算法"><a href="#低效算法" class="headerlink" title="低效算法"></a>低效算法</h2><p>上一篇文章介绍了无序向量的去重操作，现在我们希望把这种去重操作推广到有序向量，即将一个有序向量中的重复元素（如果存在）全部剔除掉，同样地每一组重复元素只保留一个副本。有序向量其实相对于无序向量而言，具有更好的规范性。这种规范性是指在有序向量中，彼此重复的元素必然会依次相互紧邻地构成一个一个的区间，比如就下图中的例子而言，这些元素相互重复，它们彼此紧邻，会紧密地排列成一个区间，其它元素也有这种规律。所以既然我们需要从每一组元素中保留一个副本，等价于从其中找出一个代表并且保留下来。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210132545.png" style="zoom: 67%;"></p><p>具体到一个算法，可以大致用一个线性扫描过程来描述：每次都观察并比对一对相邻的元素，如果二者相等就将后者删除掉，并且继续比较，如果后者还相等就把它继续删除掉，直到遇到一个不相重复的元素，这个时候我们才把注意力后移，再去考虑下一对紧邻的元素，如果依然出现这种情况再删除，直到又转到下一对。这样确实可以顺利地把所有重复的元素都剔除掉，但是不倾向与使用，因为其效率低。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line"><span class="keyword">int</span> oldSize = _size;  <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//从首元素开始</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; _size - <span class="number">1</span>)  <span class="comment">//从前向后，逐一比对各相邻元素</span></span><br><span class="line"><span class="comment">//若雷同，则删除后者；否则，转至后一个元素</span></span><br><span class="line">(_elem[i] == _elem[i + <span class="number">1</span>]) ? <span class="built_in">remove</span>(i + <span class="number">1</span>) : i++;</span><br><span class="line"><span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：其中_size的减小，由remove()内隐式地完成</span></span><br></pre></td></tr></table></figure><h3 id="低效算法的复杂度"><a href="#低效算法的复杂度" class="headerlink" title="低效算法的复杂度"></a>低效算法的复杂度</h3><ul><li>算法的运行时间主要取决去<code>while</code>循环，次数共计: _size - 1 = n -1</li><li>最坏情况下：每次都需调用<code>remove()</code>，耗时$O(n-1)\sim O(1)$，累计$O(n^2)$</li></ul><p>​       尽管省去<code>fine()</code>，总体竟与无序向量的<code>deduplicate()</code>相同。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113255.png" style="zoom: 80%;"></p><h2 id="高效算法"><a href="#高效算法" class="headerlink" title="高效算法"></a>高效算法</h2><p>需要首先对原有的算法进行反思，我们发现造成低效率的根源在于：其中的同一个元素有可能会作为被删除元素的后继，而多次地参与前移操作，对于这样的一个元素来说虽然它每次都是向前移动，但是很可惜它的每一次移动只会移动一个单元，而不是一次性地一步到达它最终的位置。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113558.png" style="zoom:50%;"></p><p>反过来这就启示我们，如果能够将每一个<strong>重复的区间作为一个整体</strong>来考虑，成批地删除雷同的元素而不是像刚才那样逐个地去删除，并且逐个地移动，就有可能实现这种一步到位式的移动，从而使得整体的性能大大地改进。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210113800.png" style="zoom: 80%;"></p><p>这个新算法的思路可以由上面的图来表示，在任何时刻我们关注的都是<code>i</code>和<code>j</code>两个元素，而且这里有一个不变性，也就是在<code>i</code>之后 <code>j</code>之前的所有这些元素都与<code>i</code>重复，这个算法一直扫描直到发现第一个与i不同的元素。如果它确实是不同的话我们就只需将<code>j</code>向前移到与<code>i</code>紧邻于右侧的这个位置，这是一个很高明的删除算法，因为在这样的一个过程中虽然没有显式地去做这些重复元素的删除，但是实际上已经无形中将它们忽略掉了，等效于做删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123;</span><br><span class="line">Rank i = <span class="number">0</span>, j = <span class="number">0</span>;     <span class="comment">//各对互异“相邻”元素的秩</span></span><br><span class="line"><span class="keyword">while</span> (++j &lt; _size)    <span class="comment">//逐一扫描，直至末元素</span></span><br><span class="line"><span class="comment">//跳过雷同者；发现不同元素时，向前移至紧邻于前者右侧</span></span><br><span class="line"><span class="keyword">if</span> (_elem[i] != _elem[j])  </span><br><span class="line">_elem[++i] = _elem[j];</span><br><span class="line">_size = ++i;  </span><br><span class="line">shrink();      <span class="comment">//直接截除尾部多余元素</span></span><br><span class="line"><span class="keyword">return</span> j - i;  <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;   <span class="comment">//注意：通过remove(lo,hi)批量删除，依然不能达到高效率</span></span><br></pre></td></tr></table></figure><h3 id="高效算法的复杂度"><a href="#高效算法的复杂度" class="headerlink" title="高效算法的复杂度"></a>高效算法的复杂度</h3><p>下面通过一个例子来分析新算法的复杂度：</p><ul><li>共计n-1次迭代，每次常数时间，累计$O(n)$时间。</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210114155.png" style="zoom:80%;"></p><p>算法首先考虑的<code>i</code>和<code>j</code>元素，其实就是0和1号元素，对这个例子而言它们是彼此重复的元素，所以在那个循环中将会通过那个隐藏着看不见的<code>else</code>直接将它忽略掉，并且使得<code>j</code>进而转向下一个单元，以及在接下来的一个循环中再下一个单元，以及再下一个单元。执行到3和5出现了第一次的不同，按照刚才算法的逻辑会把<code>i++</code>到1号位置，然后把第<code>j</code>号元素取出来复制到对应的1号位置上，这就是为什么变成了3和5相邻。注意，在这个过程中我们并<strong>没有做显式的删除操作</strong>。</p><p>接下来的操作与之类似，直到<code>j</code>第一次越过右侧的边界的时候循环退出，算法也就终止。这个时候我们已经无形中将后边的这些元素统一地给删除掉了，这种删除非常的高明，因为我们没有做任何的一次显式的删除操作，而只是通过合理的计算得知了最终的向量规模之后，对<code>_size</code>这个量重新进行了一次设置。</p><p>通过这个例子可以得出，算法过程中只是经过了<code>i+1</code>次的迭代，每次移动j必然总是会往后移动一位。而且在每一次过程中，所做的操作无非就是一次比对，只有在比对不同的情况下才会做一次复制，即便是最坏的情况下既比对而且也复制的话，累计起来也不过是常数的时间。所以换而言之，整个这个新的算法只需要$O(n)$线性的时间。</p><h1 id="二分查找（版本A）"><a href="#二分查找（版本A）" class="headerlink" title="二分查找（版本A）"></a>二分查找（版本A）</h1><p>在上一篇文章中介绍了无序向量的查找算法，它的格式为<code>Vector::find(e, lo, hi)</code>，第一个参数指明查找的对象，第二和第三个参数<code>lo</code>和<code>hi</code>指示查找的区间范围。这种算法从思路上来说大体是从一端出发不断地逐个比对，直到发现某一个特定的元素就是<code>e</code>，或者一直到<code>lo-1</code>这个位置在左侧越界，即是查找失败。所以最好情况它只需$O(1)$的时间，但是从最坏的情况以及从一般<code>e</code>的概率分布的平均情况而言，都不得不需要线性的时间。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210141315.png" style="zoom:67%;"></p><p>那么在进入有序向量之后，我们应该可以得到更快的一种解决方案，不妨重新起一个名字叫<code>search()</code>，以示与无序向量的那个<code>find()</code>的区别。当然从操作的参数以及接口的语义来说都是类似的，即我们同样要在<code>lo</code>到<code>hi</code>这样一个左闭右开的区间里找到一个特定的元素。</p><h2 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//查找算法统一接口，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::search(T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi) <span class="keyword">const</span>&#123;   </span><br><span class="line"><span class="keyword">return</span>(rand() % <span class="number">2</span>) ?   <span class="comment">//按各50%的概率随机选用</span></span><br><span class="line">binSearch(_elem, e, lo, hi)   <span class="comment">//二分查找算法，或者</span></span><br><span class="line">  : fibSearch(_elem, e, lo, hi);  <span class="comment">//Fibonacci查找算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所提供的<code>search()</code>接口从形式上看是统一的，即ADT。从内部讲，它的具体实现算法却不见得完全一样，后面的的各节将会分别介绍二分查找算法以及Fibonacci查找算法，而且对每一种算法都有不同的版本。</p><p>为了做测试这里采用了一个随机的方法，也就是在0和1之间随机地取一个数，从而随机地调用这两个算法。在实际应用中可以针对不同的情况在这几种算法中选择其一。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210142201.png" style="zoom: 67%;"></p><p><code>seach()</code>的简要的操作语义就是在<code>lo</code>和<code>hi</code>所确定的这个区间找出目标元素<code>e</code>（如果它确实存在的话）。这里需要处理很多特殊的情况，比如，目标元素并不存在与规定的区间中，这就叫失败。在此前学习的无序向量的<code>find</code>的接口中我们只是简单地返回了一个标志-1，但严格地说这样做是不够的。反过来有可能目标元素存在多个，既然作为有序向量，一旦有多个e的话，那么它肯定会连续地分布构成一个区间。在这种情况下，到底是返回最前边的一个，最后的一个？还是中间的某一个？这些都是我们需要进一步地从语义上予以约定的。</p><h2 id="语义约定"><a href="#语义约定" class="headerlink" title="语义约定"></a>语义约定</h2><p>在语义上的细致约定是非常有必要的，否则<code>search()</code>接口将只能作为一个孤立的功能，而不能有效地、便捷地为其它的算法，作为一个基本的部件而利用。<code>search()</code>接口至少应该<strong>使得有序向量自身的动态维护变得非常便利</strong>，比如在有序向量不断插入元素过程中，我们希望往往能够采用这样一种形式：当插入某一个元素时，首先要通过<code>search()</code>来确定一个适当的位置，例如查找返回的那个值再加1，然后再将<code>e</code>插入于这个秩所对应位置，并且同时使得这个有序向量继续是一个有序向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V.insert(<span class="number">1</span> + V.search(e), e);</span><br></pre></td></tr></table></figure><p>幸运的是前人已经帮我们设计出了这样的<strong>语义约定</strong>，比如下面就是其中的一种约定：</p><ul><li>在有序向量区间V[lo, hi)中，确定不大于e的最后一个元素</li><li>-∞ &lt; e &lt; V[lo] 时，返回 lo-1 （左侧哨兵）</li><li>V[hi-1] &lt; e &lt; +∞ 时，返回hi-1（右侧哨兵的前一个）</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210171952.png" style="zoom:67%;"></p><p>按照这个约定，对于要查找的元素有重复元素的情况，即有多个元素是与目标的元素是重复的，应该返回的所谓的不大于<code>e</code>的最后一个元素，也就是这个区段的右端点。如果我们要做一个插入，把新的元素插入这个位置同加1后的位置，即重复元素区间右端点的后面，正是再合适不过的。</p><p>这里的合适是指：第一，它继续保持了整体的有序性；第二，它以及与它雷同的那些元素会保持它们插入到这个向量中的先后的次序。所以这种语义约定是非常好的，它涵盖了我们几乎所有的情况包括特殊情况。所以接下来我们在实现这些具体的算法的时候，必须最终落实到能够符合这种语义的要求。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个版本只是为了说明原理，从严格的意义上讲，它还不能完全地符合刚才的语义要求，在后面的小节就会对它进行改进。</p><ul><li><p>减而治之：以任一元素x = S[mi] 为界，都可将待查找的区间分为三部分</p><p>S[lo, mi) &lt;= S[mi] &lt;= S(mi, hi)                 // S[mi] 称作轴点</p></li><li><p>只需将目标元素e与x做比较，即可分三种情况进一步处理：</p><ul><li>e &lt; x：则e若存在，必属于左侧子区间S[lo, mi)，故可递归深入</li><li>x &gt; e：则e若存在，必属于右侧子区间S(mi, hi)，亦可递归深入</li><li>x = e：已在此处命中，可随即返回       //若有多个，返回哪个？后面会介绍</li></ul></li><li><p>二分（折半）策略：轴点mi总是取作中点（至少能保证不是最坏情况）</p><p>于是每经过至多两次比较，或者能够命中，或者将问题规模减一半</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210174237.png" style="zoom: 67%;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//在有序向量区间[lo, hi)内查找元素e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span><span class="params">(T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;  </span><br><span class="line">Rank mi = (lo + hi) &gt;&gt; <span class="number">1</span>;     <span class="comment">//每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line"><span class="keyword">if</span>      (e &lt; A[mi])  hi = mi;      <span class="comment">//深入前半段[lo, hi)继续查找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[mi] &lt; e)  lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)</span></span><br><span class="line"><span class="keyword">else</span>                 <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong>：这里有编写程序的一个小的习惯，可以帮助我们更好地思考问题并且写出算法，更重要的是可以让代码更加好理解，同时也减少一些不必要的失误。我们这里<strong>统一地都用了小于号</strong>，因为小于号的左右的次序和我们通常所画的这样从小到大的次序是吻合的，所以这里<code>e &lt; A[mi]</code>的解读既可以认为是<code>e</code>小于<code>mi</code>，也可以认为是<code>e</code>存在于当前这个分界点<code>mi</code>的左侧。当这样顺着读下来时，当然我们就应该深入到前半段也就是左半段去，相应地呢，我们应该修改右侧的界桩<code>hi = mi</code>。同样接下来<code>A[mi] &lt; e</code>解读也是这样与其说是<code>mi</code>小于<code>e</code>，不如更直观地说是我们的目标<code>e</code>是处于<code>mi</code>这个分界点的右侧，所以我们应该深入到右半段也就是后半段去继续搜索，相应的操作也就是去修改左侧的界桩<code>lo = mi +1</code>。</p><h2 id="实例与复杂度"><a href="#实例与复杂度" class="headerlink" title="实例与复杂度"></a>实例与复杂度</h2><ul><li><code>S.search(8, 0, 7)</code>：共经$2+1+2=5$次比较，在<code>S[4]</code>处命中</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182501.png" style="zoom:67%;"></p><ul><li><code>S.search(3, 0, 7)</code>：共经$1+1+2=4$次比较，在<code>S[1]</code>处失败</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210182505.png" style="zoom:67%;"></p><ul><li><p>线性递归：$T(n)=T(n/2)+O(1)=O(logn)$，大大优于顺序查找</p><p>递归跟踪：轴点总取重点，递归深度$O(logn)$；各递归实例均耗时$O(1)$。</p></li></ul><h2 id="查找长度"><a href="#查找长度" class="headerlink" title="查找长度"></a>查找长度</h2><p>有序向量的查找是一种非常基本的算法，而且它存在多个版本，因此除了上面利用渐近的复杂度能够从总体上把握它的大体性能以外，我们还需要对不同版本算法的性能做更加细微的评定。具体来说就是考察渐近复杂度$logn$前面的那个常系数，而具体地在统计和分析的时候，更多的是考量关键码的比较操作次数，也就是在其中所执行的if语句的次数，我们将此称作是不同的算法在不同的情况下所对应的查找长度。</p><ul><li><p>如何更为精确地评估查找算法的性能？</p><p>考查关键码的比价次数，即查找长度（search length）</p></li><li><p>通常，需分别针对成功与失败查找，从最好，最坏，平均等角度评估</p></li><li><p>例如，成功、失败时的平均查找长度均大致为$O(1.50\cdot logn)$。</p></li></ul><p>下面是一个一个具体的实例，这是一个由七个元素构成的有序向量，其实它的数值是具体是多少我们并不在意，只要它是非降排列的就可以。如果把算法改写成递归的形式，那么整个的不同情况的递归跟踪将构成下面的递归跟踪图，每条虚线旁边的数字代表由上一步执行到下一步所增加的比较操作的次数，具体位置的方框中的数字代表查找到它所需要总的比较操作次数，即查找长度。需要注意的是，每次递归到左子区间，比较操作次数增加1，而递归到右区间，比较操作次数增加2。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210193029.png" style="zoom:80%;"></p><ul><li>n = 7时，各元素对应的成功查找长度为$\{4,3,5,2,5,4,6\}$</li></ul><p>​       在等概率情况下，平均成功查找长度$=29/7=4.14$；</p><ul><li><p>共有8中失败情况，查找长度分别为$\{3,4,4,5,4,5,5,6\}$</p><p>在等概率情况下，平均失败查找长度$=36/8=4.50$；</p></li><li><p>可见，成功和失败的平均查找长度大致是$1.50\cdot log_28$</p></li></ul><h1 id="Fibonacci查找"><a href="#Fibonacci查找" class="headerlink" title="Fibonacci查找"></a>Fibonacci查找</h1><h2 id="改进思路及原理"><a href="#改进思路及原理" class="headerlink" title="改进思路及原理"></a>改进思路及原理</h2><p>在上一节引入了二分查找（Binary search）这样的一个概念，并且给出了一个基本的算法的版本，这个版本的复杂度从渐近意义而言应该是logn量级的，但如果进一步地细微地来考察前面的系数大致是1.5，我们也指出这个1.5是可以改进的。我们现在就来看看，如何通过一种新的算法：fibonacci查找（fibonaccian search）来对此进行改进。</p><p>上一节的末尾以一个长度为7的有序向量为例，具体地给出了在成功和失败情况下平均查找长度的估算的过程。实际上通过那个实例的推而广之，如果考虑更一般的情况，不难发现此前所介绍的版本A，确实还有很大地改进余地。这样一个判断是来自于这样一个观察事实，也就是说版本A这个算法实际上从用意上讲，它是试图通过使各种情况的搜索<strong>在迭代次数上的平衡</strong>来尽可能地回避掉最坏的情况。</p><p>具体讲比如所有的失败情况大部分都会失败在同样深度的，也就是最深的这个位置，所以它表面上看是平衡的，但这其中却蕴涵着很大的不平衡。因为在整个这个查找的过程中我们在任何一个位置上，如果要决定是向左或者是向右深入的话，所花费的成本，也就是比较的次数是不等的。准确地说按照版本A，向左侧只需要一次比较，而向右侧却需要两次比较，所以这样一个表面上看是非常公平的一个平衡，实际上在内部却蕴涵着极大的不平衡，所以我们确实有理由怀疑算法的效率是否已经达到最优。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201438.png" style="zoom: 50%;"></p><p>反过来我们也可以得到改进的一个思路，具体讲就是既然我们已经看到目前的机制中，向左侧确实会成本更低，而向右侧更高。那么为什么不把这个搜索的各种情况画成类似下面的这样一个树状图，做成左侧是更深的，而右侧是相对更浅的。这样一个表面上看的不平衡，却因为它恰好和这种成本互相之间能做一个合适的补偿，反过来有可能从整体上会得到更优，也就是说使得整体的查找平均长度反而会缩短。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210201558.png" style="zoom:50%;"></p><p>具体来讲，越是成本低的转向我们就越希望更多地做，越是成本更高的越是希望它能更少地来做，所以这样的话我们就得到了新的算法的改进的思路。那么具体这个思路怎么来兑现呢？非常有意思的是需要用到<strong>fibonacci数</strong>。不失一般性，假设有序向量的长度N，就是某个fibonacci数减1的形式。</p><p>如下图所示有序向量的长度<code>n = fib(k) - 1</code>，那我们就在其中选择这么样一个特定的切分点<code>mi</code>，<code>mi = fib(k-1) - 1</code>，如果以这个点为切分，那么左边子向量的长度就恰好是<code>fib(k-1) - 1</code>，而右边子向量的长度恰巧是<br><code>fib(k-2) - 1</code>。可见这样一种切分的好处就是，在任何时候只要按照这样来切分，无论是向左还是向右它都会从长度上保持某个fibonacci数再减1的形式，而这种形式实际上恰好是最优的。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210203236.png" style="zoom:67%;"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>首先定义一个<code>Fib</code>类，让其提供一些接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span> &#123;</span> <span class="comment">//Fibonacci数列类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> f, g; <span class="comment">//f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Fib ( <span class="keyword">int</span> n ) <span class="comment">//初始化为不小于n的最小Fibonacci项</span></span><br><span class="line">  &#123; f = <span class="number">1</span>; g = <span class="number">0</span>; <span class="keyword">while</span> ( g &lt; n ) next(); &#125; <span class="comment">//fib(-1), fib(0)，O(log_phi(n))时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> g; &#125; <span class="comment">//获取当前Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; g += f; f = g - f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至下一Fibonacci项，O(1)时间</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123; f = g - f; g -= f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至上一Fibonacci项，O(1)时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Fibonacci查找可以实现为下面的一段代码，可以注意到它的接口还是完全一样的，而且在其中的这个循环，大致来说也是与版本A类似的，即每次都要来判断以保证当前的<code>lo</code>和<code>hi</code>构成一个合法的区间，如果这个区间能够收缩到非法(lo == hi)，那也就意味着查找是失败的，这跟此前的版本A是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fibonacci/Fib.h"</span> <span class="comment">//引入Fib数列类</span></span></span><br><span class="line"><span class="comment">// Fibonacci查找算法（版本A）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt;= hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function">Fib <span class="title">fib</span><span class="params">(hi - lo)</span></span>;   <span class="comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">   <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( hi - lo &lt; fib.<span class="built_in">get</span>() ) fib.prev();   <span class="comment">//自后向前顺序查找（分摊O(1)）</span></span><br><span class="line">      Rank mi = lo + fib.<span class="built_in">get</span>() - <span class="number">1</span>;       <span class="comment">//确定形如Fib(k) - 1的轴点</span></span><br><span class="line">      <span class="keyword">if</span>      ( e &lt; S[mi] ) hi = mi;      <span class="comment">//深入前半段[lo, mi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( S[mi] &lt; e ) lo = mi + <span class="number">1</span>;  <span class="comment">//深入后半段(mi, hi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span>                  <span class="keyword">return</span> mi;    <span class="comment">//在mi处命中</span></span><br><span class="line">   &#125; <span class="comment">//成功查找可以提前终止</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure><h2 id="查找长度-1"><a href="#查找长度-1" class="headerlink" title="查找长度"></a>查找长度</h2><ul><li>fibonacci查找算法的平均查找长度为$O(1.44 \cdot logn)$，略优于二分查找</li><li>仍以n = fib(6) -1 = 7 为例，在等概率情况下：<ul><li>平均成功查找长度$=(2+3+4+4+5+5+5)/7=28/7=4.00&lt;4.14$</li><li>平均失败查找长度$=(4+5+4+4+5+4+5+4)/7=35/7=4.38&lt;4.50$</li></ul></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210205204.png" style="zoom: 80%;"></p><h2 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h2><ul><li><p>通用策略：对于任何的A[0, n)，总是选取A[λn]作为轴点，$0\le \lambda &lt;1$:</p><p>比如二分查找对应于$\lambda=0.5$，Fibonacci查找对应于$\lambda=\phi=(\sqrt{5}-1)/2=0.6180339\dots$（黄金分割比）</p></li><li><p>在[0, 1)内，$\lambda$如何取值才能达到最优？设平均查找长度为$\alpha(\lambda)\cdot log_2n$，何时$\alpha(\lambda)$最小？</p></li><li><p>递推式：$\alpha(\lambda)\cdot log_2 n=\lambda\cdot [1+\alpha(\lambda)\cdot log_2 (\lambda n)]+(1-\lambda)\cdot [2+\alpha(\lambda)\cdot log_2 \left((1-\lambda) n \right)]$</p></li><li><p>整理后：$\frac{-ln2}{\alpha(\lambda)}=\frac{\lambda\cdot ln\lambda+(1-\lambda)\cdot ln(1-\lambda)}{2-\lambda}$，当$\lambda=\phi$时，$\alpha(\lambda)=1.440420\dots$达到最小。</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210212554.png" style="zoom: 80%;"></p><p>相对于我们上一节的二分查找$\alpha(\lambda)=1.50$，Fabonacci查找又有了一定的改进，而且从本节的分析可以看出这种改进已经达到了极限，如果我们不再改变这个算法的总体模式和框架的话。</p><h1 id="二分查找（改进）"><a href="#二分查找（改进）" class="headerlink" title="二分查找（改进）"></a>二分查找（改进）</h1><p>这一节将介绍另一种思路的改进，这是一种直截了当的改进思路，既然我们已经注意到了此前的版本A中造成效率略低的原因是因为左右分支的转向代价不平衡，那么可以考虑是否能将二者做成是平衡的。</p><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><ul><li><p>二分查找中左、右分支转向代价不平衡的问题，也可直接解决</p></li><li><p>比如，每次迭代（或每个递归实例）仅做1次关键码比较，如此，所有分支只有2个方向，而不再是3个</p></li><li><p>同样地，轴点mi取作中点，则查找每深入一层，问题规模也缩减一半</p><p>1）e &lt; x：  则e若存在，必属于左侧子空间S[lo, mi)，故可递归深入</p><p>2）x &lt;= e：则e若存在，必属于右侧子空间S[mi, hi)，亦可递归深入</p></li><li><p>只有当元素数目hi - lo = 1时，才判断该元素是否命中，这是该算法做出的牺牲</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210215936.png" style="zoom:67%;"></p><h2 id="版本B：实现"><a href="#版本B：实现" class="headerlink" title="版本B：实现"></a>版本B：实现</h2><p>主要注意代码中与版本A不同的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找算法（改进）：在有序向量的区间[lo, hi)内查找元素e，0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo ) &#123;         <span class="comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;   <span class="comment">//以中点为轴点（区间宽度的折半，等效于宽度之数值表示的右移）</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi;     <span class="comment">//经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">  &#125;    <span class="comment">//出口时hi = lo + 1，查找区间仅含一个元素A[lo]</span></span><br><span class="line">  <span class="keyword">return</span> (e == A[lo]) ? lo : <span class="number">-1</span>; <span class="comment">//返回命中元素的秩或者-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法是封闭的，可以运转，而且可以完全实现此前一样的功能。与此前的版本A对比，它在最好情况下反而有所倒退，原因是在与即使是成功的情况它也一直要推迟到最终，只有在经过最终的这次比对之后才会确定是否成功。此前的版本A它的最好情况是非常好的，最最好的情况莫过于在第一次试图做减而治之的时候，所采用的那个切分点就成功命中，只需要$O(1)$的时间。</p><p>本节改进的二分查找无论如何都一直要切分到最后，所以最好的情况的时间复杂度是$O(logn)$。但是反过来最坏的情况又会更好，因为我们这里最坏的情况不会出现每一次都是向右，即每次都要花费两次比较的情况，所以最坏的情况会得到抑制。所以从总体而言此前的那个版本A如果说它在性能上好坏情况相差非常大的话，那么本节中改进的版本在整体性能上，它就会趋于更加的稳定，即差异化不是那么大，当然这还不是它的最大的优势所在。</p><h2 id="语义约定-1"><a href="#语义约定-1" class="headerlink" title="语义约定"></a>语义约定</h2><ul><li><p>以上的二分查找及Fibonacci查找算法，均未严格地兑现<code>search()</code>接口的语义约定：</p><p><strong>返回不大于e的最后一个元素</strong></p></li><li><p>只有兑现这一约定，才可以有效支持相关算法，比如：<code>V.insert(1 + V.search(e), e)</code></p><p>1）当有多个命中元素时，必须返回最靠右（秩最大）者</p><p>2）失败时，应返回小于e的最大者（含哨兵<code>lo-1</code>）</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210222959.png" style="zoom:67%;"></p><h2 id="版本C：实现"><a href="#版本C：实现" class="headerlink" title="版本C：实现"></a>版本C：实现</h2><p>在刚才代码的基础上，我们做进一步的调整，得到一个最终的版本，它可以严格地实现上面定义的语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* S, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) </span><br><span class="line">  &#123;   <span class="comment">//不变性：A[0,lo) &lt;= e &lt; A[hi,n)</span></span><br><span class="line">    Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>;    <span class="comment">//以中点为轴点</span></span><br><span class="line">    ( e &lt; S[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>;    <span class="comment">//经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">  &#125; <span class="comment">//出口时，A[lo = hi]为大于e的最小元素</span></span><br><span class="line">  <span class="keyword">return</span> --lo;   <span class="comment">//故循环结束时lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125;   <span class="comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span></span><br></pre></td></tr></table></figure><p>就算法的结构而言，这个新的算法版本C和此前的版本A，尤其是版本B，似乎没有什么太大的区别。解读一下：当这个区间还是合法之前我们就不断地迭代，每一次也照样是取出它的中点作为轴点，并且经过一次比较从而决定到底是向左侧还是向右侧深入，那么直到区间宽度缩小到足够小的时候，才返回最终的值。</p><p>需要注意的是版本C和版本B，虽然在功能上是等效的，但是在很多细节上却有着本质的<strong>区别</strong>：</p><ul><li>待<strong>查找区间宽度缩短至0</strong>而非1时，算法才结束</li><li>转入右侧子向量时，<strong>左边界取作mi+1</strong>，而非mi                 //A[mi]会被遗漏？下一小节证明</li><li>无论成功与否，返回的秩严格<strong>符合接口的语义约定</strong></li></ul><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p>首先通过下面的图例来具体地了解一下版本C的工作过程，其实最主要的是它的每次迭代的过程都是类似的。如图(a)，在整个向量的区间内，我们关注的是某一个特定的从<code>lo</code>到<code>hi</code>的一个查找区间，每次在这个区间里都要考虑middle point，即图中的x。</p><p>我们以它为界，经过一次比较以后有可能会发现目标元素更小所以就深入到如图b所示的左侧的这个子区间；或者对称地，因为目标元素更大而深入到右侧的这个区间，如图(c)。版本C的算法中左侧子区间和右侧的子区间都没有覆盖这个middle point，而且对middle point也没有做显式地判断，所以这也是为什么有理由怀疑它有可能是这个算法的一个疏忽。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210230255.png" style="zoom:67%;"></p><p>接下来我们来证明这样一个模式实际上是安全的，为此同样用我们的两种技巧：第一就是给出这个算法的不变性<br>其次要给出它的一个单调性，而单调性是一目了然，就不再说明了，主要是证明它的不变性：</p><ul><li>不变性：A[0, lo) &lt;= e &lt; A[hi, n)            //A[hi] 总是大于e的最小者</li><li>初始时，lo = 0且 hi = n，A[0, lo) = A[hi, n) = $\varnothing$，自然成立</li><li>数学归纳法：假设不变性一直保持至图(a)的状态，下一步无非两种情况：</li></ul><p>第一种情况，也就是深入左侧这个分支的情况，即图(b)。那么此前的判断<code>e &lt; A[mi]</code>返回的是True，之后执行   <code>hi = mi</code>，从而使得右侧的这段区间向左拓展是安全的，因为确实可以断定这个整个区间内的这些元素都是严格地大于e的，因为它们其中最小的那个元素也就是<code>A[mi]</code>都大于<code>e</code>。而A[0, lo)保持不变,所以这种情况是没有问题的。</p><p>第二种情况，也就是深入右侧这个分支的情况，即图(c)。那么此前的判断<code>e &lt; A[mi]</code>返回的是False，之后执行 <code>lo = mi</code>，此时<code>e</code>是不小于<code>A[mi]</code>的，而<code>A[mi]</code>元素是左段区间中最大的，所以左段区间都是都是不大于e的。这样一个左侧区间向右拓展的动作在刚才不变性的意义上讲，依然是安全的，它使得不变性得到了延续。所以经过一次迭代以后无论是向左还是向右的深入，不变性都是成立的。</p><ul><li>单调性：显而易见，直到最后会出现一个情况，就是整个区间的宽度变成零，可以表示为下图。</li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200210234026.png" style="zoom:67%;"></p><p>从整个的原始的搜索空间开始，经过不断地压缩、压缩、压缩之后，将搜索的范围缩小到一个宽度为零的一个区间，其实它就只是一个分界。它严格地将整个区间分为了左右两部分，由不变性左侧这部分依然是不大于e，而右侧这部分是严格地&gt;e。如果查找的结果是命中的，我们只需要返回左侧这个区间的最右端的那个元素就可以了，而这个元素正是A[lo-1]。这也就是为什么我们在算法的最终返回之前要做一次<code>--lo</code>的操作。</p><p>这样的话我们就得到了一个从<strong>功能</strong>上、从<strong>语义</strong>上、从<strong>性能</strong>上都近乎完美的算法！</p><h1 id="插值插值"><a href="#插值插值" class="headerlink" title="插值插值"></a>插值插值</h1><p>插值查找（Interpolation Search）有序向量查找算法的一个另类的变种，此前所介绍的Fibonacci search或binary search包括它们的各种版本对向量只做了一个假定，即其中的元素是单调有序的，对于其中元素的分布情况并没有做任何的假设，也就是可以是完全理想任意随机的。但是在某些情况下也许不是这样，比如我们可能不仅知道向量是有序的，而且<strong>其中的元素是按照某种先验规律随机分布的</strong>。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194037.png" style="zoom: 50%;"></p><p>在这里我们考虑一种最常见的随机分布：<strong>均匀独立的随机分布</strong>，比如在从<code>lo</code>一直到<code>hi</code>的秩的范围之内，所有的元素都是互相不影响，各自独立的，然后从取值来看是均匀的取自于某一个区间范围。如果我们确实知道诸如此类的规律的话，就有可能实现优于此前那些算法$O(logn)$的更高的查找效率，以$o(logn)$的效率来完成一次查找。</p><h2 id="原理与算法"><a href="#原理与算法" class="headerlink" title="原理与算法"></a>原理与算法</h2><p>在均匀且独立的随机分布下，所有的元素在排序之后，即组织成一个有序向量之后，必然大体上是按线性增长的趋势分布的，从最小值<code>lo</code>开始大致是<strong>线性增长</strong>到最高值<code>hi</code>。这就意味着对于其中的任何一个潜在元素<code>mi</code>，都可以写出这样一个近似的线性等式，它们的秩的比与它们的数值比，二者是近似接近的。</p><script type="math/tex; mode=display">\frac{mi-lo}{hi-lo}\approx \frac{e-A[lo]}{A[hi]-A[lo]}</script><p>实际上这给了我们一个启示，即在每次确定mi的时候，既不需要固定的用1/2，也不需要固定的用小写的φ（黄金分割比），甚至不需要用某一个一般的λ，而是可以动态的来猜测这样一个轴点，就是根据上面的等式。将这个等式稍微整理一下把<code>mi</code>提到左侧，我们就可以知道根据<code>lo</code>、<code>hi</code>以及它们对应的这两个元素的数值，以及每次动态要查找的那个元素的数值<code>e</code>，就可以大致的估算出<code>mi</code>，这样的话如果整个的减而治之的搜索过程可以认为是一个不断收缩包围圈逐步收敛的一个过程，那么它将会使得收敛的速度极大的加快，从而更快速的完成我们整个的查找。</p><script type="math/tex; mode=display">mi\approx lo+(hi-lo)\cdot \frac{e-A[lo]}{A[hi]-A[lo]}</script><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212190744.png" style="zoom: 80%;"></p><p>正如这个图所画的是一本英文词典中abcd一直到z开头的单词各自起始的页码,它大致是1300多页，换而言之如果它确实是一个大致平均分布的话，每一个字母大概占50页，所以我们可以大致估算出来从1到50页大概是a，50页到100页大概是b，100页到150页大概是c，诸如此类。比如说去查binary (b)，那么因为它是第二个字母所以它大概会在整书从2/26这个位置开始，而search,s是第19个元素 所以大概它会位于19/26的位置。正因为这种算法在确定切分点也就是轴点的时候，采用的是近似的插值估算的方法，所以我们也称之为Interpolation Search插值查找，下面是一个实例。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212194041.png" style="zoom: 67%;"></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>从刚才的例子我们可以看出，对于这样一个长度为19的有序向量，只用了3次比较就给出了答案，而在通常的二分查找中这是做不到的，所以我们已经看到它在某些情况下确实很快，但是它总是能很快吗？包括这种很快到底定性是多大呢？</p><p>我们需要做一个严格的界定，首先一个不好的消息是插值查找<strong>在某些情况下效率会很低</strong>，比如说 可能退化为与平凡的顺序查找没有什么区别，我们此前所做的那种假设也就是均匀独立的分布不满足，或者至少在某些部分不满足以致在全局或某些局部出现一些所谓的病态分布。</p><ul><li>最坏情况：$O(hi- lo)=O(n)$</li></ul><p>当然 插值查找的最好情况也是不言而喻的，和其他的查找差不多，也就是说有可能我们在某次，甚至在第一次猜测的时候就直接命中，那么这种我们也不再考虑。我们转而再考虑一般的情况，也就是平均而言会怎么样。</p><p>这里我们需要用到一个非常基础类似引理的结论这个结论：在插值查找算法中每经过一次迭代，或者说每经过一次比较，都可以将查找的范围也就是减而治之之后剩余的部分由原先的规模n缩减为$\sqrt{n}$。</p><ul><li>平均情况：每经过一次比较，$n$缩减至$\sqrt{n}$。</li><li>于是，待查找区间宽度将按一下趋势缩减：</li></ul><p>​       $n,\quad\sqrt{n},\quad \sqrt{\sqrt{n}},\quad \sqrt{\sqrt{\sqrt{n}}},\dots,\quad2$</p><p>​       $n,\quad n^{(1/2)},\quad n^{(1/2)^2},\dots,\quad n^{(1/2)^k},\dots,\quad2$</p><ul><li><p>经多少次比较之后，有$n^{(1/2)^k}&lt;2$？</p><p>$k&gt;loglogn$</p></li><li><p>插值查找的时间复杂度为：$O(loglogn)$</p></li></ul><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212201351.png" style="zoom: 67%;"></p><p>我们同样可以来估算：如果向量的长度或者这个区间的宽度是n的话，考虑这个n按照二进制打印出来以后的位宽就是以的2为底 logn，那么每一次将它变为根号n从二进制的打印宽度来看其实就是变成了1/2的原来那么多宽度，换而言之每一次开方其实同步的是使宽度变成了原来的1/2，这样的过程 从n的数位宽度来说是一个不断折半的过程。</p><p>回顾此前的二分查找，如果是对的n的数值每次折半的话，那么这里的<strong>插值查找实际上就是对n的二进制位宽度来做二分查找</strong>。二分查找所需要的迭代次数是与它的初始值呈一个对数关系的，即$O(logn)$，而插值查找的位宽的初值相当于是logn，所以其需要的迭代次数就是$O(loglogn)$。</p><p><img src="/2020/02/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8F/QQ图片20200212204350.png" style="zoom: 50%;"></p><p>从今以后也许我们应该学会忘掉这些复杂的，虽然是精确的数学，而改用这种宏观的大趋势的把握本质的习惯。</p><h2 id="综合对比"><a href="#综合对比" class="headerlink" title="综合对比"></a>综合对比</h2><p>现在将插值查找和其他的算法综合起来进行比对和考量，刚才插值查找所实现的这种改进也就是从logn到loglogn<br>虽然从数学上是一个比较大的改进，但从实际效率来看却值得商榷。</p><ul><li><p>从$O(logn)$到$O(loglogn)$，是否值得？</p></li><li><p>通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高。</p><p>比如，n = 2^(2 ^ 5) = 2 ^ 32 = 4G时，$log_2(n)=32,\quad log_2(log_2(n))=5$</p></li><li><p>易受小扰动的干扰和“蒙骗”，可能在局部花费非常多的时间</p></li><li>须引入乘法、除法运算，相对而言成本更高（二分查找只需加法，Fibonacci查找只需加法和减法）</li></ul><p>所以可行的查找算法也许应该将插值查找以及此前的那些查找算法各自的优势综合结合起来，比如说插值查找更善于在比较大的一个宏观的范围内，将问题的关注点尽可能快的缩小到一定的范围，即它比较擅长于处理那种极大的情况，然后一旦到了比较小的情况，这种容易受到干扰包括蒙骗尤其是乘法除法这样的一些overhead额外计算占得比重就会更大成为不可忽略的因素，而在这个时候二分查找的优势就体现出来了。</p><ul><li><p>实际可行的方法：</p><p>首先通过插值查找，将插值范围缩小到一定的范围，然后再进行二分查找，或者顺序查找，即：</p><ul><li>大规模：插值查找</li><li>中规模：折半查找</li><li>小规模：顺序查找</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      向量这一章的内容比较多，决定分开写，本文主要介绍有序向量。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（2）向量</title>
    <link href="http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/</id>
    <published>2020-02-08T02:04:27.000Z</published>
    <updated>2020-02-09T02:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-接口与实现"><a href="#1-接口与实现" class="headerlink" title="1.接口与实现"></a>1.接口与实现</h1><p>我们首先需要辨析一组非常相关但是又非常容易弄混的概念，也就是<strong>抽象数据类型</strong>以及<strong>数据结构</strong>。那么什么是<strong>Abstract Data Type</strong>呢？以及什么是<strong>Data Structure</strong>呢？可以从字面上给出定义，抽象数据类型就是在一组数据的模型上定义的一组操作。数据结构则是基于某种特定的语言真正实现的一套完整的算法。</p><p>Data Type数据类型，比如在高级程序设计语言中<code>int</code>也就是整型，这就是一个数据类型，而<code>floa</code>t也是，还有<code>char</code>，诸如此类地。这种数据类型能够让我们能定义其中的一个成员，比如<code>n</code>是一个整数，从此以后我们就可以使用它了，我们也可以定义<code>x</code>是一个浮点数，<code>c</code>是一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">char</span> c;</span><br></pre></td></tr></table></figure><p>凡是这样指定了某一个元素是来自于某一个数据类型，或者说属于某一个数据类型，那么它就自然地具有了这种数据类型的特点，包括支持相应地处理方法，比如说运算。那么这里那些操作的运算具体是如何实现的，我们并不知道，我们也并不需要知道，这是最重要的。</p><p>把这样的一个概念抽象出来施加到我们所将要实现的数据结构上，比如这一章要介绍的<code>vector</code>。我们希望在使用的时候能够参照数据类型的这种形式，把它等同地当作是一个数据类型，比如可以用类似的方法来定义一个<code>vector</code>结构，包括下一章将要介绍的<code>List</code>。</p><p>这种使用方法使得我们可以将数据结构与数据类型等同起来，我们只需要知道它所提供的那些操作，比如说向量的查找、排序，而不需要去关心它其中的细节，比如说这些操作是如何实现的。那么从这个意义上讲，它就是一个经过了抽象以后的数据类型，所以称之为<strong>Abstract Data Type</strong>。</p><p>举个例子：可以将数据结构比喻成某种产品，比如说汽车，相关的有两类人，首先是用户，我们笼统地称之为应用Application，另一类人是汽车这种产品的设计和制造者，称之为实现Implementation。这两类人所关心的以及他们的职责是不同的，作为用户而言，他只关心这种产品的外在特性，能够提供的功能；而实现者则需要对这些功能以及特性具体如何落实负责。在这二者之间实际上是有某种形式的一个协议，也就是使用说明书，产品手册。而这种手册或者说明在数据结构的使用者与数据结构内部算法的设计者之间，达成了这么样一个协议，两类人可能互不见面，互不相识，但是他们通过这样一个规范，可以很好地彼此沟通，并且有效地合作。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208102916.png" style="zoom:67%;"></p><h2 id="1-1-向量ADT"><a href="#1-1-向量ADT" class="headerlink" title="1.1.向量ADT"></a>1.1.向量ADT</h2><h3 id="1-1-1-从数组到向量"><a href="#1-1-1-从数组到向量" class="headerlink" title="1.1.1.从数组到向量"></a>1.1.1.从数组到向量</h3><p><strong>向量实际上是C++等高级编程语言中数组这种数据组织形式的一个推广和泛化</strong>。实际上在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都与0到n之间的某一个整数编号相互彼此对应。这里我们也同样延用此前已经约定的习惯，虽然最后这个第n个元素，实际上未必存在，我们还是把它虚拟地放在这儿作为哨兵，以帮助我们对很多问题的思考，并且使得我们很多算法的实现能够得以简化。</p><ul><li>C/C++语言中，<strong>数组A[ ]中的元素与[0,n)内的编号一一对应</strong>。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208105846.png" style="zoom:67%;"></p><p>既然每一个这样的元素都与这些编号是一一对应的，所以反过来我们通过合法区间内的编号都可以唯一地来指代并且访问对应的那个元素。一旦知道这个元素的下标<code>i</code>，就可以从<code>A</code>也就是这段存储区域的首地址出发，再向后以s作为间隔去数出<code>i</code>步，就可以得到某一个特定的单元。正因为所有这些元素的物理地址可以按照这样一个线性的方程来确定。所以我们也称之为<strong>线性数组</strong>（linear array）。</p><ul><li><p>反之每个元素均由（非负）编号唯一指代，并可直接访问。<strong>A[i]</strong>的物理地址 = A + i×s，s为单个元素占用的空间量。</p></li><li><p>向量是数组的抽象与泛化，由一组元素按线性次序封装而成：</p><ul><li>各元素与[0, n)内的<strong>秩</strong>（rank）一一对应</li><li>元素的类型不限于基本类型</li><li>操作、管理维护更加简化、统一于安全</li><li>可更为便捷地参与复杂数据结构的定制与实现</li></ul></li></ul><h3 id="1-1-2-向量ADT接口"><a href="#1-1-2-向量ADT接口" class="headerlink" title="1.1.2.向量ADT接口"></a>1.1.2.向量ADT接口</h3><p>按照抽象数据类型的规范，向量结构必须提供一系列的操作接口，可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作，这里的接口功能非常的丰富。</p><p>比如说与其它的数据结构一样向量也可以看作是一组元素的集合，所以<code>size( )</code>实际上返回的是其中元素的总数，称之为这个数据结构的规模。也可以从中取特定的元素<code>get(r)</code>，也可以修改其中特定的元素<code>put(r, e)</code>，甚至插入<code>insert(r, e)</code>或者是删除某个元素<code>remove(r)</code>。我们也可以判定一下其中的元素是否已经有序排列<code>disordered( )</code>，如果没有有序排列，可以调用相应的接口使之有序排列<code>sort( )</code>。</p><p>我们也可以在它尚未有序排列的时候，按某种算法找到其中特定的元素<code>find(e)</code>，也可以在已经有序的前提下按照某种方式，来找到其中的元素<code>search(e)</code>。当然为了展示一些算法的实现我们也附加了一些其它的功能，比如说能够在无序和有序的情况下分别剔除这个数据集中的重复元素：<code>deduplicate( )</code>和<code>uniquify( )</code> 。最后也是非常重要的一个接口就是如何对这个数据集中的元素逐一地进行枚举，并且访问一遍<code>traverse( )</code>，称之为遍历。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208110149.png" style="zoom:80%;"></p><h3 id="1-1-3-ADT接口操作实例"><a href="#1-1-3-ADT接口操作实例" class="headerlink" title="1.1.3.ADT接口操作实例"></a>1.1.3.ADT接口操作实例</h3><p>下面举例说明ADT接口的实现。</p><p>最开始向量与任何一个数据结构一样，初始化的时候都是不包含任何实质的内容的，我们称它是一个空的向量。接下来调用插入操作<code>insert</code>，它在rank为0的这个位置上插入一个元素9，所以向量的组成将由空变成包含一个元素9。接下来继续调用<code>insert</code>接口，在0号这个位置上rank为0的这个位置上插入一个元素4，原来的元素9将会后移一位。同样地，我们也可以调用插入接口在rank为1的位置上插入5，在这个位置上出现了5，而它的后继统一地向后后移了一位。我们也可以调用<code>put</code>接口，这个接口的意思是修改，它会把当前rank为1的那个位置上的元素数值，由原来的5修改为2。我们也可以通过<code>get</code>这个接口获取秩为某一特定值的元素，比如说秩为2的那个元素，实际上就是2这个位置上的9，因此会返回<code>9</code>。</p><p><code>remove</code>接口的参数是2，这说明它希望在原来这个向量中将rank为2的这个元素，把它剔除掉，剔除之后，会把这个被剔除的元素的值作为输出返回，即返回<code>2</code>，同时它的所有的后继与插入时候的操作的现象相反，会向前平移一个单元。当这个时候我们调用<code>size</code>的时候，因为这里所包含的元素总共是6个，所以它会返回<code>6</code>。</p><p>我们可以看到在整个这个操作的过程中向量都确实具有这么样一个特点，就是它在逻辑上，甚至在物理上必然是彼此紧邻的排列的，所有的元素之间没有任何的缝隙。需要注意的是无论是此前所介绍的这些接口，还是后面所要介绍的接口，就目前而言，我们并不关心它的具体实现方法，我们关心的只是它的操作语义。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208125724.png" style="zoom:80%;"></p><p>接下来我们可以通过<code>disordered()</code>这个接口来检测向量的有序性，或者更准确地讲它的<strong>无序性</strong>。在此前介绍bubble sort算法的原理的时候，曾经指出包括向量在内的序列是否有序，当且仅当其中是否存在紧邻的逆序对。那么这里总共有6个元素，共定义了5组紧邻对，其中有3组，也就是4和3、7和4、和9和6是逆序的，<code>disordered</code>会<strong>返回逆序对的个数</strong>，即是<code>3</code>，只要这个数值不是0，就说明它尚未构成有序的序列。</p><p>对于这样的一个<strong>无序向量</strong>我们已经可以通过<code>find</code>接口，来查找其中特定的某个元素，比如说9。可以看到9号元素是位于rank为4的位置，因此find会返回<code>4</code>。同样地，也可以查找比如说5，我们发现5并不存在，这个时候我们统一地约定返回一个数值是<code>-1</code>，这个-1肯定不是一个合法的rank，表示查找失败。接着我们可以通过sort这个接口对整个向量排序，接下来再调用<code>disordered()</code>这个接口，它已经没有任何逆序的紧邻对了，所以返回<code>0</code>。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208130026.png" style="zoom:80%;"></p><p>对于<strong>有序向量</strong>，我们可以通过另一套接口，也就是<code>search</code>来进行查找。比如说可以首先通过<code>search</code>，然后引用9来查找数值为9的元素，这个元素的rank为5，因此返回的是<code>5</code>。那么如果查找8会怎么样呢？向量中并没有8，这里我们采用了另一种约定：如果<strong>没有找到</strong>这个元素，我们要找的是<strong>不超过这个元素的最大的那个元素的值</strong>。对这个例子而言不超过8的最大的元素实际上就是7，而7的秩是4，所以<code>search(8)</code>会返回<code>4</code>。同样 我们如果要去查找10的话会返回不超过10的最大的那个元素也就是9的秩5，因此<code>search(10)</code>会返回<code>5</code>。</p><p>另一种特殊情况：查找一个全局都没有而且小于全局的最小的那个元素的数比如说1，我们会假设在-1的rank这个位置上有一个假想的哨兵，它的数值是负无穷，所以<code>search(1)</code>返回的是<code>-1</code>。这样一套约定可以使得我们在语义上更加的明确，使得我们在后续的操作过程中可以便利地来搭建不同的算法。还有一点要注意的是：在有些时候，我们要查找的元素尽管有，但是它却有<strong>多次出现</strong>，比如说这个4 出现了两次，那这个时候会返回什么呢？同样跟这里的语义所定义吻合的是，我们要<strong>返回其中不超过4这个目标元素的最后边那个元素</strong>，所以如果有两个甚至多个4的话，我们会取其中rank最大的那个元素把它的rank返回，对这个例子而言也就是2号元素，因此<code>search(4)</code>会返回<code>2</code>。</p><p>最后，<code>uniquify()</code>对于一个有序的向量把所有的重复的元素，比如说4都剔出掉，只保留一个拷贝。</p><h2 id="1-2-vector模板类"><a href="#1-2-vector模板类" class="headerlink" title="1.2.vector模板类"></a>1.2.vector模板类</h2><p>有上述接口规范之后，我们就可以遵照这种规范来学习如任何具体地在C++语言平台上实现这样一种向量模板类<code>vector</code>结构。首先约定用int来定义这里所说的秩这种概念，接下来会首先采用一种基本的扩容方式，它的初始容量需要设定，这里不妨取它的DEFAULT_CAPACITY取作3，在实际应用中完全可以取更大的一个数。</p><p>下面通过<code>template</code>这种方式给一个模板参数T，它的意思可以认为是定义了一个<code>vector</code>这样的模板类。其中的元素类型是什么可以是将来指定的任何名字现在叫作T的类型。所以与其说它写的是一个类，不如说这个模板类给的是一系列的类，我们可以根据实际需要直接地生成相应的<code>vector</code>类。在模板类里面有一些私有的，也就是封装和隐藏起来的变量，比如说其内部会记忆它到底有多少个元素有一个<code>_size</code> ，以及它目前的容量<code>_capacity</code>，还有<br>包括真正存放元素的一个空间<code>_elem</code>。其它的内部函数以及公开的接口函数会在后边陆续学到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank; <span class="comment">//秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_CAPACITY  3 <span class="comment">//默认的初始容量（实际应用中可设置为更大）</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span> <span class="comment">//向量模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity;  T* _elem; <span class="comment">//规模、容量、数据区</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="keyword">const</span>* A, Rank lo, Rank hi )</span></span>; <span class="comment">//复制数组区间A[lo, hi)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">bubble</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//扫描交换</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//起泡排序算法</span></span><br><span class="line">  <span class="function">Rank <span class="title">max</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选取最大元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选择排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">( Rank lo, Rank mi, Rank hi )</span></span>; <span class="comment">//归并算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//归并排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//堆排序（稍后结合完全堆讲解）</span></span><br><span class="line">  <span class="function">Rank <span class="title">partition</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//轴点构造算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//快速排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//希尔排序算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  Vector ( <span class="keyword">int</span> c = DEFAULT_CAPACITY, <span class="keyword">int</span> s = <span class="number">0</span>, T v = <span class="number">0</span> ) <span class="comment">//容量为c、规模为s、所有元素初始为v</span></span><br><span class="line">  &#123; _elem = <span class="keyword">new</span> T[_capacity = c]; <span class="keyword">for</span> ( _size = <span class="number">0</span>; _size &lt; s; _elem[_size++] = v ); &#125; <span class="comment">//s&lt;=c</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank n ) &#123; copyFrom ( A, <span class="number">0</span>, n ); &#125; <span class="comment">//数组整体复制</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V ) &#123; copyFrom ( V._elem, <span class="number">0</span>, V._size ); &#125; <span class="comment">//向量整体复制</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">  ~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125; <span class="comment">//释放内部空间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只读访问接口</span></span><br><span class="line">  <span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_size; &#125; <span class="comment">//判空</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span> ( e, <span class="number">0</span>, _size ); &#125; <span class="comment">//无序向量整体查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//无序向量区间查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> <span class="comment">//有序向量整体查找</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &gt;= _size ) ? <span class="number">-1</span> : search ( e, <span class="number">0</span>, _size ); &#125;</span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//有序向量区间查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写访问接口</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] ( Rank r ); <span class="comment">//重载下标操作符，可以类似于数组形式引用各元素</span></span><br><span class="line">  <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] ( Rank r ) <span class="keyword">const</span>; <span class="comment">//仅限于做右值的重载版本</span></span><br><span class="line">  Vector&lt;T&gt; &amp; <span class="keyword">operator</span>= ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; ); <span class="comment">//重载赋值操作符，以便直接克隆向量</span></span><br><span class="line">  <span class="function">T <span class="title">remove</span> <span class="params">( Rank r )</span></span>; <span class="comment">//删除秩为r的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//删除秩在区间[lo, hi)之内的元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( Rank r, T <span class="keyword">const</span>&amp; e )</span></span>; <span class="comment">//插入元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> </span>&#123; <span class="keyword">return</span> insert ( _size, e ); &#125; <span class="comment">//默认作为末元素插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">()</span> </span>&#123; unsort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>; <span class="comment">//无序去重</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>; <span class="comment">//有序去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( <span class="keyword">void</span> (* ) ( T&amp; ) )</span></span>; <span class="comment">//遍历（使用函数指针，只读或局部性修改）</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( VST&amp; )</span></span>; <span class="comment">//遍历（使用函数对象，可全局性修改）</span></span><br><span class="line">&#125;; <span class="comment">//Vector</span></span><br></pre></td></tr></table></figure><p>vector模板类的原理：整个vector结构是被封装起来，能供来自各种应用的用户使用的操作接口就是interface框中vector，~vector，insert，remove等等，它们就相当于vector结构的使用说明书，它告诉我们这里提供了哪些操作渠道、途径，通过这种接口规范直接使用。经过了这样地一个剥离之后，使得我们的应用和实现相互之间可以很好的分工，又同时很好的协作。<br>那么具体内部怎么实现的呢？可以看出其实是开辟了一个名字叫作<code>_elem</code>的数据区，它的容量至少要足以容纳所存放的有效数据，对外而言的每一个元素都通过某种形式转译为内部这段数据区中的，实际上是这个有效的数据区（<code>_size</code>）中的某一个元素，由此实现了对内部数据项的封装。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208143153.png" style="zoom: 50%;"></p><h3 id="1-2-1构造与析构"><a href="#1-2-1构造与析构" class="headerlink" title="1.2.1构造与析构"></a>1.2.1构造与析构</h3><p>作为一种数据结构与所有的类一样，<code>vector</code>也首先需要解决<strong>构造和析构</strong>的问题。向量的默认的构造实际上只需指始初始的容量就可以了，如果没有指定会按照默认的容量，指定一个数值。在内部的操作其实就是通过<code>new</code>申请一个长度为<code>c</code>，基本类型就是模板参数<code>T</code>的一段连续的数据空间。在创建了这样一个空间之后，我们把这个空间的首地址交给内部的<code>_elem</code>记下来。这个时候虽然它有一定的空间，但是其中有效的数据是没有的，所以这就是为什么<code>_size</code>初始化是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector(<span class="keyword">int</span> c = DEFAULT_CAPACITY)</span><br><span class="line">&#123;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = c]; </span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">//默认</span></span><br></pre></td></tr></table></figure><p>当然还有其它的一些构造的方法，比如如果已经有一组以数组的形式存放的数据，我们也可以将其中从<code>lo</code>到<code>hi</code>的这段区间中的元素取出来作为初始向量，可以看到它是通过调用一个叫作<code>copyFrom()</code>的内部接口实现的。同样地 它还<strong>重载</strong>了其它的一些形式，比如被复制的元素可能是来自于一个数组，而是来自于一个本身已经被封装了的向量，我们可以从这个向量的<code>_elem</code>区域中去读取出来，并且同样调用<code>copyFrom()</code>来做这件事。所以这里有区间的复制，也可以有对整个向量的一个克隆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector(T <span class="keyword">const</span> *A, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(A, lo, hi);&#125;           <span class="comment">//数组区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(V._elem, lo, hi);&#125;     <span class="comment">//向量区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V)</span><br><span class="line">  &#123; copyForm(V._elem, <span class="number">0</span>, V._size);&#125; <span class="comment">//向量整体复制</span></span><br></pre></td></tr></table></figure><p>内部操作接口<code>copyForm( )</code>的工作原理以及过程可以通过下图示意，工作原理以及过程，可以通过这个图来示意。一般地我们需要从一个数组<code>A</code>中将介于<code>lo</code>到<code>hi</code>之间的元素整体复制到当前仍然为空的一个向量中，具体的操作大概分为两步，首先在向量内部开辟出足够的空间，接下来再将区间内的元素逐一地复制过来。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208145159.png" style="zoom:50%;"></p><p>这个过程可以描述并且实现为下面的C++代码：首先申请足够多的空间，这里需要再强调一下这个区间的宽度可以直接通过<code>lo</code>和<code>hi</code>之间的一个减法得到，这是因为当我们在描述一个区间的时候往往是用<strong>左闭右开</strong>的形式，所以换而言之这个<code>lo</code>是在这个区间中最靠左的那个元素，而hi是在右侧第一个不属于这个区间的那个元素，尽管<code>hi</code>这个元素有可能压根就不存在。但是我们不妨把它统一地理解成是一个哨兵，这样的话我们就可以通过，<code>hi</code>减<code>lo</code>直接得到区间的宽度。</p><p>这里给计算出的宽度再乘个2，也就是说我们实际开辟的空间是我们需要复制的空间的两倍，而不是恰好那么多。这样做的主要的目的在于预留了一些空间之后，就可以使得我们在接下来足够长的时间之内，不会因为有必要扩容而打断我们的计算过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//元素类型</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom (T <span class="keyword">const</span>* A, Rank lo, Rank hi)<span class="comment">//以数组区间A[lo, hi)为蓝本复制向量</span></span><br><span class="line">&#123; </span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span> * ( hi - lo ) ]; _size = <span class="number">0</span>; <span class="comment">//分配空间，规模清零</span></span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) <span class="comment">//A[lo, hi)内的元素逐一</span></span><br><span class="line">  _elem[_size++] = A[lo++]; <span class="comment">//复制至_elem[0, hi - lo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还需要对这个向量的有效规模进行初始化 把它清为0。</p><p>再接下来 就是复制过程也就是说我们对于<code>lo</code>和<code>hi</code>中间的每一个<code>Rank</code>，都要从<code>A</code>这个数组中取出对应的元素，并将它们顺次的存入到<code>_elem</code>，对应的区间里面去。整体循环构成了这个操作的最重要的部分，所以我们也可以看出算法的复杂度主要是来自于这样一个循环。这样一个主体的复杂度是取决于被复制元素的个数，或者说这个复制区间的宽度，也可以认为是这个向量通过复制被创建之后的初始规模。</p><p><strong>析构函数</strong>只需要把这个曾经动态分配获得的数据区域释放掉，归还给操作系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125;     <span class="comment">//释放内部空间</span></span><br></pre></td></tr></table></figure><p>这样的话我们就完成了向量这种最基本的结构作为一种模板类它的最基本的一些接口，接下来会学习功能更为复杂的其它的接口。</p><h1 id="2-可扩充向量"><a href="#2-可扩充向量" class="headerlink" title="2.可扩充向量"></a>2.可扩充向量</h1><p>与所有的数据结构一样，向量也可以认为是一组数据项的集合，换而言之，它首先必须能够自适应地在规模上适应其中所包含的元素个数的变化，这一节集中讨论它的可扩充性能。向量本身并不具有这种性能，我们需要采取一些策略。就目前的设计方案而言，我们的向量并不具备可扩充的性能，究其原因在于它采用的 实际上是所谓的静态空间管理的策略。</p><h2 id="2-1-静态空间管理"><a href="#2-1-静态空间管理" class="headerlink" title="2.1.静态空间管理"></a>2.1.静态空间管理</h2><p>具体来说，它实际上在内部只不过是设置了一个私有的数组，这个数组所占有的那段连续的地址空间会被用来存放若干个对外界而言可见的，或者是有效的元素。这些元素的总数，或者说它们所占用的逻辑空间的数，用<code>_size</code>来表示，而整个物理空间的大小是由<code>_capacity</code>来确定的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208163714.png" style="zoom: 80%;"></p><p>这里的问题是<code>_capacity</code>一旦确定,按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：第一 是有可能会出现所谓的<strong>上溢overflow</strong>，也就是说随着有效元素（个数）的增加，总会出现这样的可能，使得整个<code>_elem</code>所占用的物理空间已经不足以存放需要存放的元素组。尽管这个时候在系统的其它的部分仍然有足够多的空间可以用于存放这些元素，但是限于<code>_capacity</code>是固定的，我们不能直接做到这一点。</p><p>另一种情况虽然不是很严重，但是也是会造成一定的空间的效率低下，我们称之为<strong>下溢underflow</strong>。具体来说就是有可能我们开辟了一个比较大的空间，但是在整个这个数据结构的生命期内真正存放于其中的数据却寥寥无几，从而使得<strong>装填因子</strong>指标会非常非常的小，这个装填因子其实就是有效元素个数，也就是<code>_size</code> ，去除以可用于存放元素的空间总数<code>_capacity</code>，也可以理解成是空间的利用率有可能不到一半，甚至远远地低于一半，那么在这种时候空间效率非常低下。</p><p>很遗憾如果我们坚持采用这样一种固定容量的策略，我们在实际的一般应用环境中，很难在事先就预测到我们需要用多少空间，也就是说这种空间不足以及空间浪费的情况，都有可能发生甚至经常发生。</p><p>那么如何使得向量可以自适应地根据实际需要来动态地调整自己的容量呢？而且这种调整的过程既能保证足够同时又不致使得因为开辟的空间过多而导致空间效率的低下。</p><h2 id="2-2-动态空间管理"><a href="#2-2-动态空间管理" class="headerlink" title="2.2.动态空间管理"></a>2.2.动态空间管理</h2><p>为了解决上述的问题，我们需要把刚才所采用的静态空间管理策略改变为所谓的<strong>动态空间管理策略</strong>，就是如果在某个时刻，某一个向量即将发生上溢，那么我们就适当地扩大内部数组的容量，使之足以容纳新的元素。按照这样一种策略向量的生命期可以大致由下面一组图来表示。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208164212.png" style="zoom:80%;"></p><p>最开始的时候向量所存放的有效元素还不是很多，还不致于出现上溢的情况，这时候可以从容应对。但是剩余的空间有可能会逐步地被占用，直到某一个关键时刻，内部数组有可能已经饱和，这时就存在一个风险也就是说再插入一个元素的话，就会导致上溢。为此我们可以动态的申请另一段存放空间，当然它的大小应该比原来的有所增长。接下来我们要把原先已经存放好的那些有效元素，逐一地按次序地复制过来，从而使得它们对外界而言依然保持原貌。新多出来的这些空间就足够用以存放新需要插入的元素，而原来所占用的空间将在此之后被释放并且归还给系统。上述这样一个完整的调整过程可以描述并且实现为下面的c++的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123;    <span class="comment">//向量空间不足时扩容</span></span><br><span class="line"><span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;   <span class="comment">//尚未满员时，不必扩容</span></span><br><span class="line">_capacity = <span class="built_in">max</span>(_capacity, DEFAULT_CAPACITY);   <span class="comment">//不低于最小容量</span></span><br><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];  <span class="comment">//容量加倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)  <span class="comment">//复制原向量内容</span></span><br><span class="line">_elem[i] = oldElem[i];       <span class="comment">//T为基本类型，或已重载复制操作符'='</span></span><br><span class="line"><span class="keyword">delete</span>[] oldElem;   <span class="comment">//释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要判断现在是否处于即将发生上溢的临界状态，它的标志就是<code>_size</code>是否还继续严格地小于<code>_capacity</code>。如果是还不存在上溢的风险，可以直接返回，所以这里隐含着有一个else，即接下来<code>_size</code>虽然不一定大于<code>_capacity</code>，但是至少会出现等于<code>_capacity</code>的情况。</p><p>这时我们要做的是将原来的那个数据域做一个备份，接下来以原先的容量（注意这里是左移一位，相当于加倍）加倍的一个新的容量来申请一段动态空间，并且将这段空间交由原来的<code>_elem</code>来指示。接下来是复制，对从原先的那个数据域中逐一地取出各项，并且将其转移至新的这个数据域中对应的位置。在整体赋值完之后，原先的这个空间已经没有任何存在的意义了，所以通过<code>delete</code>操作将它释放。</p><p>其实对于尚未封装的数组同样可以采用上述的这样的一个策略，而对于向量而言，这里调整的优势体现在向量整体的封装性上。因为对于一般的数组，如果它经过了动态的重新分配地址，那么原先指向它内部的某些元素的一些指针就有可能会出现无效，即虽然它能指向一个地址但其中并没有存放所需要的数值。但是对于向量而言经过了这样的封装以后就安全了，因为无论是此前此后我们在访问某一个具体的元素的时候，在内部都是通过<code>_elem</code>这个统一的指示器来标识空间的起点。从这一点也可以看出进行封装以后的一个好处。</p><p>那么为什么要采用一个容量加倍的策略呢？采用其他策略，比如适当增加背部数组的容量，是否也可行呢？</p><h3 id="2-2-1-容量递增策略"><a href="#2-2-1-容量递增策略" class="headerlink" title="2.2.1.容量递增策略"></a>2.2.1.容量递增策略</h3><p>实际上情况并不那么简单，我们不妨以其中的一种典型的策略，即容量递增策略，来做一个对比。就是每当发现<br>当前的内部数组即将发生上溢我们并不是对它进行容量的加倍，而只是在原来的容量的基础上追加一个固定的数额，这样看起来并没有什么问题。在代码上只需将原来的<code>_capacity*2</code>变成<code>_capacity</code>追加一个固定的数额，记为<code>INCREMENT</code>，简记作$I$。下面来考虑这个策略的效率。</p><ul><li>在即将上溢之前，追加固定大小的容量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity += INCREMENT];</span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量0的空向量中，连续插入$n = m * I$个元素（远大于2）</li><li>于是，在第$1, I+1, 2I+1, 3I+1,……$次插入时都需要扩容</li><li>即便不计申请空间操作，各次过程中复制原向量的时间成本依次为：$0,I,2I,\dots,(m-1)I$（算术级数）</li><li>总体耗时 = $I\times(m-1)\times m/2=O(n^2)$，每次扩容的<strong>分摊成本为</strong>$O(n)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208172649.png" style="zoom: 50%;"></p><h3 id="2-2-2-容量加倍策略"><a href="#2-2-2-容量加倍策略" class="headerlink" title="2.2.2.容量加倍策略"></a>2.2.2.容量加倍策略</h3><ul><li>在即将上溢之前，使容量加倍</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];   <span class="comment">//容量加倍</span></span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量1的的满向量中，连续插入$n=2^m$个元素</li><li>于是，在第$1，2,4,8,16,32，\dots$次插入时都需要扩容</li><li>各次扩容过程中复制原向量的时间成本依次为：$1,2,4,8,\dots,2^m$  （几何级数）</li><li>总耗时 = $O(n)$，每次扩容的分摊成本为$O(1)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208174131.png" style="zoom:50%;"></p><p>造成两种方法每次扩容分摊成本的时间复杂度出现很大差别的原因，可以用下图说明。实际上在向量规模不断递增<br>达到某一固定的数值之前，如果采用的是递增式的增容策略，那么所需增容的操作必然是按当时的规模呈算数级数的形式分布。反过来如果是以倍增式的策略来进行的扩容，那么只需要进行其中的少数几次扩容就够了，具体来说就是这些以紫色标明的，可以看到要远远小于原先的数目，而且随着数组规模的增加，这种差异会更加的明显。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208171602.png" style="zoom:80%;"></p><p>我们不妨将这两种策略所对应的性能列成如上面的一张表。在时间方面，在达到一个固定的规模n之前，累计所用的扩容时间：递增策略要多达$O(n^2)$，而倍增策略只需要$O(n)$，如果从分摊的意义上讲分摊到每一次扩容所需要的时间：前者是$O(n)$， 而后者是$O(1)$。可以看到就时间而言，容量加倍策略具有巨大的优势。而在空间方面，前一种策略似乎要非常好，因为它总是每次增加一个固定的数额，所以随着向量规模的增加，整个空间的利用率会越来越接近于百分之百。而加倍策略未必能做到百分之百，但是它至少有个底线，至少是50%，只有在它即将发生上溢，而因此刚刚通过加倍扩容的那个瞬间时才会是50%。所以相对而言，可以理解为倍增策略是通过在空间的效率上做了一个适当的牺牲，来换取在时间方面的巨大的收益，显然收益要远远大于损失。</p><h2 id="2-3-平均分析-vs-分摊分析"><a href="#2-3-平均分析-vs-分摊分析" class="headerlink" title="2.3.平均分析 vs. 分摊分析"></a>2.3.平均分析 vs. 分摊分析</h2><p><strong>平均复杂度或期望复杂度（average/expected complexity）</strong></p><p>根据数据结构各种操作出现概率的分布，将对应的成本加权平均。</p><ul><li>各种可能得操作，作为独立事件分别考查；</li><li>割裂了操作之间的相关性和连贯性；</li><li>往往不能准确地评判数据结构和算法的真实性能。</li></ul><p><strong>分摊复杂度（amortized complexity）</strong></p><p>对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作。</p><ul><li>从实际可行的角度，对一系列操作做整体的考量；</li><li>更加忠实地刻画了可能出现的操作序列；</li><li>可以更为精确地评判数据结构和算法的真实性能</li></ul><h1 id="3-无序向量"><a href="#3-无序向量" class="headerlink" title="3.无序向量"></a>3.无序向量</h1><p>回顾前两节，我们以向量为例给出了数据结构定义的一种通用方法，即模板，大致格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Vector &#123; ...... &#125;;</span><br></pre></td></tr></table></figure><p>这种方法实际上定义了 一系列的<code>Vector</code>，在使用的时候可以灵活指定它的类型。如果尖括号里是<code>int</code>的，那这个<code>Vector</code>实际上是a Vector of integers，即由一系列的整数组成的向量。更重要的是 在以后我们将利用这种方式来构造更为复杂的数据结构，比如可以把某些数据结构作为基本的组成元素来构成向量，举个例子在后面的学习中会定义二叉树Binary Tree这样一种数据结构，如果把<code>BinTree</code>作为基本的元素来构成<code>Vector</code>，那我们就可以构成一个由一系列的二叉树构成的一个线性序列，也就是A Vector of Binary Trees，取个形象的名字可以叫它<code>forest</code> 森林。在后面介绍霍夫曼编码的时候也会用到这种技巧，通过采用统一的模板式的方法，可以使得数据结构的定义非常的规范，而且更重要的是它们可以互相的融合组合，便捷地搭建更为复杂的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="keyword">int</span>&gt; myVector1;</span><br><span class="line">Vector&lt;<span class="keyword">float</span>&gt; myVector2;</span><br><span class="line">Vector&lt;<span class="keyword">char</span>&gt; myVector3;</span><br><span class="line"></span><br><span class="line">Vector&lt;BinTree&gt; forest;</span><br></pre></td></tr></table></figure><p>这一节我们将围绕向量的最基本的形式，即无序向量来展开。无序向量不一定是说其中的元素没有顺序，甚至有时候其中的元素是根本就不可能排成顺序。在这样的一个前提下我们将研究如何来定义并且实现相应的操作接口。</p><h2 id="3-1-循秩访问"><a href="#3-1-循秩访问" class="headerlink" title="3.1.循秩访问"></a>3.1.循秩访问</h2><p>通过<code>V.get(r)</code>和<code>V.put(r, e)</code>接口，固然可以读，写向量元素，但便捷性远不如数组元素的下标式访问方式A[r]。通过<strong>重载下标操作符</strong>“ [ ] “，便可沿用数组的下标方式访问向量元素。对于任何一个指定的Rank r，只需在内部数据区中取出对应的第r号元素，此后凡是需要引用向量中的某个特定的比如说Rank为r的这个元素，就可以直接以这样一种类似于数组下标的形式进行引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span>  <span class="comment">//0 &lt;= r &lt; _size</span></span><br><span class="line">   &#123; <span class="keyword">return</span> _elem[r]; &#125;</span><br></pre></td></tr></table></figure><p>此后，对外的V[r]即对应于与内部的V._elem[r]。这种引用可以作为右值，以这种类似数组形式进行运算并且将运算的结果，向左侧赋值给某一变量；而反过来计算的结果也可以赋值给向量中某一个元素，也就是作为左值，因为这个接口返回值是一个引用。</p><ul><li><p>右值：<code>T x = V[r] + U[s] * W[t]</code></p></li><li><p>左值：<code>V[r] = （T) (2*x + 3)</code></p></li></ul><p>需要注意的是这里我们对入口参数r并没有做过多的检查，而是简易地在入口处增设了一个断言，用以提醒使用者保证入口参数r能够在合理的范围之内，但在真正的实际应用中，要做更为严格的处理。</p><h2 id="3-2-插入"><a href="#3-2-插入" class="headerlink" title="3.2.插入"></a>3.2.插入</h2><p> 向量的插入算法具体来说就是如何将某一个特定的元素插入到向量的特定位置，在原来向量中因为所有的元素都必须是紧邻排列的，所以为了能够插入新的元素我们需要做一个调整，也就是将对应这个位置之后的所有的那些元素，称作它的后继，整体的构成一个后缀，进行一个整体的右移操作。这个right shift操作效果就是所有的后缀元素都向右移动一个单元，从而空出一个单，此时才可以将指定的那个元素纳入其中，从而完成插入。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208211730.png" style="zoom: 50%;"></p><p>整个算法可以描述并且实现如下的C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//e作为秩为r的元素插入，0 &lt;= r &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert(Rank r, T <span class="keyword">const</span>&amp; e) &#123;</span><br><span class="line">expand();  <span class="comment">//若有必要，扩容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">//自后向前</span></span><br><span class="line">_elem[i] = _elem[i - <span class="number">1</span>];     <span class="comment">//后继元素顺次后移一个单元</span></span><br><span class="line">_elem[r] = e;  <span class="comment">//置入新元素</span></span><br><span class="line">_size++;       <span class="comment">//更新容量</span></span><br><span class="line"><span class="keyword">return</span> r;      <span class="comment">//返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移操作可以通过for循环完成，每个元素确实都是后移一位，当所有的后移完成之后，再将新的那个元素纳入到rank所指的位置上，当然同时还要更新整个向量的规模。</p><p>有两个需要注意的地方：第一，在for循环的方向是从最后一直向前不断地递减，也就是说整个的移动的方向虽然是向右，但是<strong>所有元素移动的先后次序却是后优先的</strong>，用图来表示也就是最后这个元素先移动，接下来是次后这个元素，再往前一直直到最前面的那个元素。这是必要的，如果把这个次序颠倒过来会有危险，会出现数据在无意中被覆盖的问题。</p><p>第二个主要注意的是<code>expand()</code>，即扩容操作，这是有必要的。因为确实在某些时候这个向量可能已经是满载的，所以为了插入新元素，在后移的过程中必然会出现上溢的情况，在这种时候就需要对向量进行扩容处理，比如上节的容量加倍策略，这样一件事情完全由<code>expand()</code>完成。</p><h2 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3.删除"></a>3.3.删除</h2><h3 id="3-3-1-区间删除"><a href="#3-3-1-区间删除" class="headerlink" title="3.3.1.区间删除"></a>3.3.1.区间删除</h3><p>我们先考虑一个通用的一个版本，即区间删除，具体来说就是在某个向量中，我们要将介于<code>lo</code>和<code>hi</code>之间的一系列的元素成批地从中剔除掉。因为向量要求所有的元素始终都是彼此紧邻排列的，所以不应该在删除之后留下这个缝隙，换而言之，我们需要将它后继的那些元素（如果有的话）统一地向前或者说向左移动来填补这段空白。其实可以反过来看到如果能够完成这样的一个左移的话，那么实际上也就相当于把这些元素给剔除或者叫覆盖掉了，所以关键的任务在于如何实现这个左移。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208212314.png" style="zoom:50%;"></p><p>这样的一个过程可以实现为下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除区间[lo, hi)，0&lt;=lo&lt;=hi&lt;=_size</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank lo, Rank hi) &#123;  <span class="comment">//O(n-hi)</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//处于效率考虑，单独处理退化情况</span></span><br><span class="line"><span class="keyword">while</span> (hi &lt; _size)</span><br><span class="line">_elem[lo++] = _elem[hi++];  <span class="comment">//[hi, _size)顺次前移hi-lo个单元</span></span><br><span class="line">_size = lo; shrink();   <span class="comment">//更新闺蜜，若有必要则缩容</span></span><br><span class="line"><span class="keyword">return</span> hi - lo;   <span class="comment">//返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中最关键的是<code>while</code>循环，它会遍历整个后缀，并且将其中的每一个元素逐一地取出，向前转移到合适的位置。比如第一个转移的是<code>hi</code>这个位置上的这个元素，它将被转移到<code>lo</code>这个位置，紧接着是<code>hi+1</code>转移到<code>lo+1</code>，<code>hi+2</code>转移到<code>lo+2</code>，直到最后。</p><p>同样有两个问题需要强调说明：第一个问题，在整个移动的过程中，所有这些元素参与移动的先后次序，同样也是很敏感的，或者说不能更改的，与插入算法完全颠倒，插入算法是自后向前，而区间删除算法是越往前的元素越优先参与移动，所以我们也可以认为它是一个<strong>自前向后的前移操作</strong>。如果把这个次序颠倒过来是有风险的，比如两者，即前缀的原来的那个位置和后来的那个位置中间有相互重叠的部分，如果优先移动后面的那个元素，那么就有可能会造成重叠区间的元素在无意中被覆盖掉。</p><p>第二点是<code>shrink()</code>这个历程的调用，它是某种意义上讲的缩容，这种操作在实际应用中并不是必须的，我们往往可以忽略它。</p><h3 id="3-3-2-单元素删除"><a href="#3-3-2-单元素删除" class="headerlink" title="3.3.2.单元素删除"></a>3.3.2.单元素删除</h3><p>上一小节中实现了区间的批量删除的接口，所以我们不妨把单元素的删除视作是整个区间操作的特例。具体来说<br>，就是要将任何一个由单个元素构成的区间视作是由 <code>r</code> 到 <code>r+1</code>所定义的左闭右开的那段区间。这样就可以很简明地调用用此前重载的那个<code>remove</code>接口，只不过这里的参数改变为 <code>r</code> 和 <code>r+1</code>，与我们刚才的那种转换相对应。同理算法所进行的操作就是所有的后缀向前移动一个单位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除向量中秩为r的元素，0 &lt;=r &lt; _size</span></span><br><span class="line">T Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank r) &#123;  <span class="comment">//O(n - r)</span></span><br><span class="line">T e = _elem[r];     <span class="comment">//备份被删除的元素</span></span><br><span class="line"><span class="built_in">remove</span>(r, r + <span class="number">1</span>);   <span class="comment">//调用区间删除算法</span></span><br><span class="line"><span class="keyword">return</span> e;           <span class="comment">//返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反过来，基于remove(r)接口，通过反复的调用，实现remove(lo, hi)是否可行呢。理论上是可行的，对于一个特定的一段从 lo 到 hi的区间，我们可以对其中的每一个元素分别去调用一次单元素删除接口，从而完成整体的删除操作。但是正如我们一直强调的，数据结构更多关注的是效率，而从效率上看这样做是非常差的。</p><p>首先考虑单元素删除本身的效率，最重要的实际上是这段区间也就是被删除元素的那些后继们，统一地要向前移动一次，这也是它的复杂度的来源。因此它的时间复杂度是取决于它的后继的个数，即为n-hi，最坏情况下是$O(n)$。如果按这种方式反复调用，有可能会导致$O(n^2)$的复杂度，在效率上是不能接受的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208225132.png" style="zoom: 67%;"></p><h2 id="3-4-查找"><a href="#3-4-查找" class="headerlink" title="3.4.查找"></a>3.4.查找</h2><p>查找即是按照某种特定的条件，从向量中找出特定的元素。首先我们要明确两个概念：<strong>判等</strong>与<strong>比较</strong>，对于任何的两个元素，我们来判断它们是否是相等，或者是比较它们之间谁大谁小，这两个操作并不是所有的类型都天然支持的。所以这里我们做一个<strong>假设</strong>：向量中元素的类型是基本类型，或者向量元素这个类已经重载了对应的判等的操作符或者是比较的操作符。无序向量可以一般性地认为它只支持判等操作，而对于有序向量，要求要更高一点，它还需要支持其中的元素能够相互比较大小。</p><ul><li>无序向量：<code>T</code>为可判等的基本类型，或已重载操作符<code>=</code>或<code>!=</code></li><li>有序向量：<code>T</code>为可比较的基本类型，或已重载操作符<code>&lt;</code>或<code>&gt;</code></li></ul><p>无序向量的查找过程可以描述为下图，如果查找的区间范围是 <code>lo</code> 到 <code>hi</code> 的话，就<strong>从 <code>hi</code> 出发</strong>逆向地、逐一地取出<br>向量中的各个元素与目标元素进行比对，如果不相等就忽略它，进而考察它的前驱，所以整个的工作会亦步亦趋地逐个地遍历向量中的所有的元素。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208222707.png" style="zoom:50%;"></p><p>经过这样一个逆向地扫描的过程，我们很有可能在中间的某一步找到所需要的那个目标，即查找成功；如果一直持续到最后，在试图越过<code>lo</code>也就是合法的最左侧的边界的时候，就可以断定整个查找是失败的。这个算法可以通过下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">find</span>(T <span class="keyword">const</span> &amp;e, Rank lo, Rank hi) cosnt</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//O(hi - lo) = O(n)，在命中多个元素时可返回秩最大者</span></span><br><span class="line"><span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (e != _elem[hi]));  <span class="comment">//逆向查找</span></span><br><span class="line"><span class="keyword">return</span> hi;   <span class="comment">// hi &lt; lo 意味着失败，否则hi即命中元素的秩</span></span><br><span class="line">&#125;   <span class="comment">// Excel::match(e, range, type)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>find</code>函数<strong>返回的都是最终停止的那个位置</strong>，有可能是合法的一个位置。也可能是刚刚越过左边界的那个非法的位置。而具体判别是否成功可以交给上层的调用者，因为他通过这个秩是否是合法就可以判断查找是否成功，如果是成功的话这样一个秩将可以被高层的算法进一步地利用。</p><p>我们也可以看出这个算法的复杂度有很大的变化空间，在最好的情况下，可能在第一个元素位置上就顺利地命中<br>所以这时复杂度是常数$O(1)$；但是在最坏的情况下，比如一直持续到比较后才发现这个元素，甚至一直持续到最终也没有发现我们的目标元素，为此在这个过程中我们需要扫描的元素可能会与向量的规模相当，复杂度就会是$O(n)$。</p><p>这样一种在最好和最坏情况下相差极其悬殊的算法，叫作<strong>输入敏感</strong>算法（input-sensitive），即它的复杂度具体是多少与输入时候数据的配置紧密相关。</p><ul><li>输入敏感（input-sensitive）：最好$O(1)$，最差$O(n)$。（对本例而言）</li></ul><h2 id="3-5-唯一化问题"><a href="#3-5-唯一化问题" class="headerlink" title="3.5.唯一化问题"></a>3.5.唯一化问题</h2><p>无序向量的唯一化问题，即是<strong>把其中重复的元素都剔除掉</strong>，使得每一组重复的元素只保留一个拷贝。在很多实际的应用中都能够找到唯一化的影子，比如在网络搜索的环境中有很多个不同的结点所分工完成的局部的搜索结果，可能会含有大量的重复的元素，我们需要将其中重复的元素剔除掉，从而得到一份记忆完整同时又不冗余的搜索报告。这样一个算法大致可以通过这样的一个图示来表示它的原理：</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208232314.png" style="zoom:80%;"></p><p>对于一个向量，我们总是把它<strong>分为三个部分</strong>，以当前的这个元素为界，当前这个元素自己是一部分，它的前驱所构成的前缀是一部分，以及对称地，所有的后继是一部分。每一次我们遇到一个新的元素，都在它的前缀中去进行查找，这可以通过find操作来完成的，如果能够找到雷同的元素，比如在某个位置上出现了一个x，就可以把这个元素剔除掉。反之，经过查找以后，如果这个元素没有出现，那么我们就可以把它保留下来，同时再去考察它的下一个元素。这个算法可以由下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//删除重复元素，返回被删除元素数目</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class="line"><span class="keyword">int</span> oldSize = _size;  <span class="comment">//记录原规模</span></span><br><span class="line">Rank i = <span class="number">1</span>;      <span class="comment">//从_elem[1]开始</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; _size)   <span class="comment">//自前向后逐一考查各元素_elem[i]</span></span><br><span class="line">(<span class="built_in">find</span>(_elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>) ?   <span class="comment">//在前缀中寻找雷同者</span></span><br><span class="line">i++   <span class="comment">//若无雷同者则继续考查其后继</span></span><br><span class="line">: <span class="built_in">remove</span>(i);    <span class="comment">//否则删除雷同者（可以是多个）</span></span><br><span class="line"><span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-1-正确性"><a href="#3-5-1-正确性" class="headerlink" title="3.5.1.正确性"></a>3.5.1.正确性</h3><p>那么我们如何给出这个算法正确性的严格证明呢？同样根据第一章学到的知识，我们通过挖掘算法所具有的<strong>不变性</strong>和<strong>单调性</strong>，来证明一个算法最终的正确性。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208234943.png" style="zoom:50%;"></p><p>首先来证明不变性，我们发现在这个算法运行的任何一个时刻，如果当前所对应的是第<code>i</code>个元素<code>V[i]</code>的话，那么在它所对应的那个前缀中所有的元素必然是彼此互异，即不包含重复元素。当算法开始时<code>i=1</code>，它的前缀只有<code>V[0]</code>。</p><p>其余的一般情况下可以用数学归纳法来予以证明：假设当时的状态是第<code>i</code>个元素<code>e</code>，它的前缀是从<code>0</code>到<code>i</code>的区间。按照数学归纳法我们假设在此前不变性是成立的话，那么接下来，无非两种情况，即当前的这次对应的查找成功或者失败。</p><p>如果是失败，即在它的前缀中不含元素e，算法给出的处理方法是直接令<code>i++</code>，也就是我们已经指向了它的下一个元素，而将刚才那个元素<code>e</code>归入了新的这个前缀中。既然<code>e</code>和此前的那些前缀是互不重复的，所以将<code>e</code>归入这样的一个区间以后，这个区间必然是不含重复元素的。</p><p>反之如果如果查找成功，<code>e</code>出现在它的前缀中，按照算法流程会将它剔除掉，也就是通过删除操作使得后继的元素整体地向前移动，从而使得原先它的直接后继变为当前的这个元素，并且算法继续地运转下去。经过了这样一次迭代之后当前的这个元素虽然换了，但是它的前缀并没有换，这个前缀所具有的元素互异的性质也依然会保持下来。</p><p>算法运行到最终是覆盖整个向量，到那时我们所说的当前的元素其实就是最末尾的那个哨兵元素，而它的前缀其实就是整个向量，那么它的前缀中不包含重复的元素其实也就相当于整体的向量中不包含重复的元素，这正是我们这个算法的功能唯一化所要求的，所以在最终这个不变性必然会转化为我们所需要的正确性</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209000113.png" style="zoom:50%;"></p><p>接着我们证明单调性，这个算法的主体是由一个<code>while</code>循环构成的，随着反复的while迭代:</p><ul><li>当前元素前缀的长度单调非降，且迟早增至_size</li><li>当前元素后缀的长度严格单调下降，且迟早减至0</li></ul><p>所以算法待处理元素的个数会严格单调减少，算法必然终止，且至多迭代$O(n)$轮。</p><h3 id="3-5-2-复杂度"><a href="#3-5-2-复杂度" class="headerlink" title="3.5.2.复杂度"></a>3.5.2.复杂度</h3><p>这个算法的主体是while循环，而在while循环中真正能够造成有效复杂度的是<code>find</code>操作和<code>remove</code>操作，其中<code>find</code>操作是对于当前的元素的整个前缀而言的，而<code>remove</code>操作恰好对称是相对于当前这个元素的后继而言的。所以每一次<code>while</code>循环所需要的成本也就是<code>find</code>和<code>remove</code>两类操作的成本，累计起来也不会超过整个向量的长度，即$O(n)$线性步。而<code>while</code>循环最多会迭代$O(n)$轮，所以这个算法累计起来最多不超过$O(n^2)$的时间复杂度，这也是最坏情况。</p><p>这个算法也可以进一步的优化。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209001549.png" style="zoom:50%;"></p><h2 id="3-6-遍历"><a href="#3-6-遍历" class="headerlink" title="3.6.遍历"></a>3.6.遍历</h2><p>遍历就是按照某种事先约定的操作（称之为<code>visit</code>），对向量中的每一个元素逐一地、统一地执行一次。所以这里涉及到两个问题：第一，如何来指定或者来描述这样一个visit操作；第二，如何将它传递到向量内部的每一个具体的元素。</p><p>通常有两种方法：第一种是使用函数指针，也就是说可以对于<code>vector</code>这样一个类定义一个<code>traverse</code>接口，作为它的参数<code>visit</code>本身就是一个函数的指针。所以为了兑现这样的一个遍历操作我们只需要逐一地取出向量中由这个<code>i</code>确定的每一个元素通过这个函数指针找到这个函数，并且对这个元素实施这个函数所指定的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span>(*visit)(T&amp;))&#123;   <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是使用函数对象，也就是说我们指定的这个参数visit，本身就是一个对象，它的作用就是用来模拟一个操作一个函数的一个行为方式。所以同样地，我们也可以对这个向量中的每一个元素都逐一地取出，并且转交给这样一个函数对象，通过它来实施具体地、统一地操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST&amp; visit) &#123;       <span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法其实是非常接近，但是也有一些重要的区别，相对而言，后一种方式的通用性更强。</p><p>下面通过一个实例来了解如何通过函数对象，实现刚才所说的具体地遍历。比如说，我们可以考虑将向量中的所有的元素统一地各自+1。为此我们只需要实现一个对应功能的函数对象，它本身也是以一个类的形式给出来的。这里为了简化起见使用了<code>struct</code>，而没有进行过多的封装。这个对象最重要的一个作用或者说唯一的作用就是重载了它的圆括号操作符<code>()</code>，从而使得它在行为上与一个函数非常的类似，而具体的功能就是把每一个参数<code>e</code>做一个+1操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//假设T可直接递增或已重载操作符“++”</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inciease</span> &#123;</span>       <span class="comment">//函数对象：通过重载操作符"()"实现</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp; e)</span> </span>&#123; e++; &#125;   <span class="comment">//加一</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现了这样一个对应的类之后，就可以通过调用vector统一遍历接口traverse，将我们刚刚编写的这个函数对象以参数的形式传入就可以实现相应的功能，也就是把向量中的每一个元素统一地加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class="line">V.traverse(Increase&lt;T&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      向量属于最基本的数据结构，这一章围绕向量讨论两个方面的问题：如何根据统一的接口规范来定制并且实现一个数据结构，如何通过更加有效的算法使得我们对外的接口更加高效率地工作。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（1）</title>
    <link href="http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-05T02:32:06.000Z</published>
    <updated>2020-02-07T02:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>对象：规律，技巧</p><p>目标：高效，低耗</p><p>Computer science should be called called computing science, for the same reason why surgery is not called knife science.</p><p>-E.Dijkstra</p><ul><li>计算 = 信息处理</li></ul><p>​       借助某种工具，遵照一定规则，以明确而机械的形式进行</p><ul><li>计算模型 = 计算机 = 信息处理工具</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>所谓算法，即特定计算模型下，旨在解决特定问题的指令序列</p><p>​        输入：待处理的信息（问题）</p><p>​        输出：待处理的信息（答案）</p><p>​    正确性：的确可以解决指定的问题</p><p>​    确定性：任一算法都可以描述为一个由基本操作组成的序列</p><p>​    可行性：每一基本操作都可以实现，且在常数时间内完成</p><p>​    有穷性：任一算法在执行有限次基本操作之后终止并给出输出</p><ul><li>列子：Hailstone序列</li></ul><script type="math/tex; mode=display">\begin{align*}& 序列Hailstone(n)=\begin{cases}\{1\}     &n\le1\\\{n\}\cup Hailstone(n/2) &n为偶数\\\{n\}\cup Hailstone(3n+1) &n为奇数\end{cases}\\\\&Hailstone(42)=\{ 42,21,64,32,\dots,1\}\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hailstone</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//计算序列Hailstone(n)的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>; <span class="comment">//从1开始递推</span></span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">1</span>) &#123; (n % <span class="number">2</span>) ? n = <span class="number">3</span> * n + <span class="number">1</span> : n / = <span class="number">2</span>; lenth++; &#125;</span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回hailstone(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：对于任意的n，总有|Hailstone(n)| &lt;  ∞ ？</p><p>目前还不能证明</p><ul><li>程序不一定是算法</li></ul><h2 id="好算法"><a href="#好算法" class="headerlink" title="好算法"></a>好算法</h2><p>正确：符合语法，能够编译，链接</p><p>​           能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入</p><p>健壮：能辨别不合法的输入并做适当处理，而不致非正常退出</p><p>可读性：结构化  + 准确命名 + 注释 + …</p><p><strong>效率</strong>：<strong>速度尽可能快 ；存储空间尽可能少</strong>   （最重要的）</p><p>​           Algorithms + Data Structures = Programs         -N. Wirth, 1976</p><p>​          (Algorithms + Data Structures) × Efficiency = Computation</p><h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>好的数据结构和算法才能有高效的计算，从而有好的应用。         </p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>两个主要方面：</p><p>​        正确性：算法功能与问题要求一致？</p><p>​                        数学证明？并不简单</p><p>​        <strong>成本</strong>：    <strong>运行时间</strong>+所需存储空间</p><p>​                        如何度量？如何比较？</p><p>考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。</p><p>​           意义不大，因为可能出现的问题实例太多。那么如何归纳概括？</p><p>观察：问题实例的<strong>规模</strong>，往往是决定计算成本的主要因素。</p><p><strong>特定算法 + 不同实例</strong></p><ul><li>令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。</li></ul><p>​         讨论特定算法A（及其对应的问题）时，简记作$T(n)$。</p><ul><li><p>然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。</p></li><li><p>稳妥起见，取$T(n) = max\{ T(P)| |P| = n \}$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。</p></li></ul><p><strong>特定问题 + 不同算法</strong></p><ul><li>同一问题通常有多种算法，如何评判其优劣？</li><li>实验统计是最直接的方法，但足以准确反映算法的真正效率？</li><li>但实验统计还是不足够的，还要考虑：<ul><li>不同的算法，可能更适应于不同规模的输入</li><li>不同的算法，可能更适应 与不同类型的输入</li><li>同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现</li><li>同一算法，可能实现并运行与不同的体系结构、操作系统</li></ul></li><li>为给出客观的评判，需要抽象出一个理想的平台或模型<ul><li>不再依赖于上述种种具体的因素</li><li>从而直接而准确地描述，测量并评价算法</li></ul></li></ul><h2 id="图灵机-Turing-Machine"><a href="#图灵机-Turing-Machine" class="headerlink" title="图灵机 Turing Machine"></a>图灵机 Turing Machine</h2><ul><li>Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’</li><li>Alphabet：字符的种类有限</li><li>Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格</li><li>State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态</li><li>Transition Function ：（q,  c;  d,  L/R,  P)</li></ul><p>​        若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；</p><p>​        转入p状态，一旦转入特定的状   态’h’，则停机。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205112701.png" alt="QQ图片20200205112701" style="zoom:67%;"></p><h2 id="RAM-Random-Access-Machine"><a href="#RAM-Random-Access-Machine" class="headerlink" title="RAM:  Random Access Machine"></a>RAM:  Random Access Machine</h2><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114006.png" alt="QQ图片20200205114006" style="zoom:67%;"></p><p>与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。</p><p>在这些模型中：</p><ul><li>算法的运行时间   转化为   算法需要执行的基本操作次数</li><li>$T(n)$  =  算法为求解规模为n的问题，所需执行的基本操作次数</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114827.png" style="zoom:67%;"></p><h1 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h1><h2 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h2><ul><li>回到原先的问题：随着问题规模的增长，计算成本如何增长？</li></ul><p>​        注意：这里更关心足够大的问题，注重考察成本的增长趋势</p><ul><li>渐进分析：在问题规模足够大后，计算成本如何增长？</li></ul><p>​       Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法</p><p>​               需执行的基本操作次数：T(n) = ?</p><p>​               需占用的存储单元数：S(n) = ?         //通常可不考虑</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205124613.png" style="zoom:50%;"></p><h2 id="大-O-记号（big-O-notation）"><a href="#大-O-记号（big-O-notation）" class="headerlink" title="大$O$记号（big-$O$ notation）"></a>大$O$记号（big-$O$ notation）</h2><script type="math/tex; mode=display">\begin{align*}&T(n)=O(\,f(n)\,)\quad if \quad \exists c>0, 当n>>2后，有T(n)<c\cdot f(n)\\\\&例如：\sqrt{5n\cdot[3n\cdot(n+2)+4]+6}<\sqrt{5n\cdot[6n^2+4]+6}<\sqrt{35n^3+6}<6\cdot n^{1.5}=O(n^{1.5})\end{align*}</script><p>与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势</p><ul><li>常系数可忽略：$O(\,f(n)\,)=O(c\times \,f(n)\,)$</li><li>低次数可忽略：$O(n^a+n^b)=O(n^2),\,a&gt;b&gt;0$</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205130742.png" alt="QQ图片20200205130742" style="zoom: 50%;"></p><p><strong>其它记号</strong>：</p><ul><li>$T(n)=\Omega(\,f(n)\,)$：</li></ul><p>​       $ \exists c&gt;0, 当n&gt;&gt;2后，有T(n)&lt;c\cdot f(n)$</p><ul><li>$T(n)=\Theta(\,f(n)\,)$：</li></ul><p>​       $ \exists c_1&gt;c_2&gt;0, 当n&gt;&gt;2后，有c_1\cdot f(n)&gt;T(n)&gt;c_2\cdot f(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205131613.png" style="zoom:50%;"></p><h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>下面讨论大$O$记号的几种”刻度“：</p><p><strong>$O(1)$</strong></p><ul><li><p>常数（constant function）</p><p>$2=2013=2013\times 2013=O(1)$，甚至$2013^2013=O(1)$</p></li><li><p>这类算法的效率最高</p></li><li><p>什么样的代码对应于常数执行时间？</p><p>一般地，不含循环；不含分支转向；不能有（递归）调用，应具体问题具体分析</p></li></ul><p><strong>$O(log^c n)$</strong></p><ul><li>对数$O(log^c n)$</li><li>常底数无所谓</li></ul><p>​       $\forall a,b&gt;0,\,log_an=log_ab\cdot log_bn=\Theta(logn)$</p><ul><li>常数次幂无所谓</li></ul><p>​       $\forall c&gt;0,\,logn^c=c\cdot logn=\Theta(logn)$</p><ul><li><p>对数多项式（ploy-log function）</p><p>$123\cdot log^{321}n+log^{105}(n^2-n+1)=\Theta(log^{321}n)$</p></li><li><p>这类算法非常有效，复杂度无限接近于常数</p><p>$\forall c&gt;0,\,logn=\Theta(n^c)$</p></li></ul><p><strong>$O(n^c)$</strong></p><ul><li><p>多项式（polynomial function）</p><p>$(100n-500)(20n^2-300n+2013)=O(n\times n^2)=O(n^3)$</p><p>一般地，$a_kh^k+a_{k-1}n^{k-1}+\dots+a_1n+a_0=O(n^k),\,a_k&gt;0$</p></li><li><p>线性（linear function）：所有$O(n)$函数</p></li><li><p>这门课主要覆盖的范围：从$O(n)$到$O(n^2)$</p></li><li><p>这类算法的效率通常认为已可令人满意</p></li></ul><p><strong>$O(2^n)$</strong></p><ul><li>指数（exponential function）：$T(n)=a^n$</li><li>$\forall c&gt;1,\,n^c=O(2^n);\,n^{1000}=O(1.00001^n)=O(2^n);\,1.00001^n=\Omega(n^{1000})$</li><li>这类算法的计算成本增长极快，通常被认为不可忍受</li><li>从$O(n^c)$到$O(2^n)$，是从有效算法到无效算法的分水岭</li><li>很多问题的$O(2^n)$算法往往显而易见，然而设计出$O(n^c)$算法却极为不易，甚至有时注定只能是徒劳无功。</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100203.png" style="zoom:50%;"></p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100207.png" style="zoom:50%;"></p><p><strong>例子</strong>：2-Subset</p><p>S包含n个正整数，$\sum S=2m$，S是否有子集T，满足$\sum T=m$？</p><ul><li>直觉算法：逐一枚举S的每一个子集，并统计其元素的总和</li><li>定理：$|2^s|=2^{|s|}=2^n$，亦即直觉算法需要迭代$2^n$轮，并（在最坏情况下）至少需要花费这么多时的间</li><li>但实际上上述的直觉算法已属最优解，就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法。</li><li>2-Subset is NP-complete</li></ul><h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>两个主要任务 = 正确性（不变形 × 单调性） + 复杂度</p><p>那么为了确定复杂度，真地需要将算法描述为RAM的基本指令，再统计累计的执行次数嘛？答案是不必的。</p><p>C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当：</p><ul><li>分支转向：goto   //算法的灵魂，出于结构化考虑，被隐藏了</li><li>迭代循环：for( )、while( )……  //本质上就是 if + goto</li><li>调用 + 递归（自我调用）  //本质上也是goto</li></ul><p>复杂度分析的主要方法：</p><ul><li>迭代：级数求和</li><li>递归：递归跟踪 + 递推方程</li><li>猜测 + 验证</li></ul><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><ul><li>算数级数：与末项平方同阶</li></ul><p>​       $T(n)=1+2+\dots +n=n(n+1)/2=O(n^2)$</p><ul><li>幂方级数：比幂次高出一阶</li></ul><p>​       $\sum_{k=0}^nk^d\approx \int_0^n x^{d+1}dx=\frac{1}{d+1}x^{d+1}\mid_0^n=\frac{1}{d+1}n^{d+1}=O(n^{d+1})$</p><p>​       $T_2(n)=1^2+2^2+3^2+\dots+n^2=n(n+1)(2n+1)/6=O(n^3)$</p><p>​       $T_3(n)=1^3+2^3+3^3+\dots+n^3=n^2(n+1)^2/4=O(n^4)$</p><ul><li>几何级数（a&gt;1）：与末项同阶</li></ul><p>​       $T_a(n)=a^0+a^1+\dots+a^n=(a^{n+1}-1)/(a-1)=O(a^n)$</p><p>​       $1+2+4+\dots+2^n=2^{n+1}-1=O(2^{n+1})=O(2^n)$</p><ul><li>收敛级数</li></ul><p>​       $1/2/2+1/2/3+1/3/4+\dots+1/(n-1)/n=1-1/n=O(1)$</p><p>​       $1+1/2^2+\dots+1/n^2&lt;1+1/2^2+\dots=\pi^2/6=O(1)$</p><p>​       $1/3+1/7+1/8+1/15+/24+1/26+1/31+1/35+\dots=1=O(1)$</p><p>​       实际上讨论这类分数级数是有必要的，因为在某种意义上，基本操作次数，存储单元数可以看作是分数，例如将某个循环条件执行的概率设为$\lambda$，则其数学期望为：</p><p>​        $(1-\lambda)\cdot[1+2\lambda+3\lambda^2+4\lambda^3+\dots]=1/(1-\lambda)=O(1)，0&lt;\lambda&lt;1$</p><ul><li>某些不收敛但长度有限的级数</li></ul><p>​       $h(n)=1+1/2+1/3+\dots+1/n=\Theta(logn)$                     调和级数</p><p>​       $log1+log2+log3+\dots+logn=log(n!)=\Theta(nlogn)$      对数级数</p><h2 id="循环与级数"><a href="#循环与级数" class="headerlink" title="循环与级数"></a>循环与级数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=n+n+\dots+n=n\cdot n=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131334.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=0+1+\dots+(n-1)=\frac{n(n-1)}{2}=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131338.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j+=<span class="number">2013</span>)</span><br></pre></td></tr></table></figure><p>算术级数：$O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131342.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i&lt;&lt;=<span class="number">1</span>)  <span class="comment">// i&lt;&lt;=1 左移一位，相当于乘2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>几何级数：$1+2+4+\dots+2^{[log_2(n-1)]}={\sum}_{k=0}^{[log_2(n-1)]}2^k=2^{[log_2(n-1)]}-1=n-1=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131345.png" style="zoom:67%;"></p><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>问题：给定整数子集S，|S| = n &gt;=3，找出元素$a\in S,a\ne max(S)，且 a\ne min(S)  $</p><p>算法：从S中任取三个元素{x, y, z}  //若S以数组形式给出，不妨取前三个；由于S是集合，这三个元素必互异</p><p>​            确定并排除其中的最小者，最大者  //不妨设 x = max{x, y, z},  y = min{x, y, z}</p><p>​            输出剩下的元素z</p><p>无论输入规模n多大，上述算法需要的执行时间不变</p><p>​            $T(n)=常数=O(1)=\Omega(1)=\Theta(1)$</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p><strong>问题</strong>：给定n个整数，将它们按非降序排列</p><p><strong>观察</strong>：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</p><p><strong>扫描交换</strong>：依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；否则，再做一趟交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           <span class="keyword">if</span>(A[i<span class="number">-1</span>] &gt; A[i])&#123;</span><br><span class="line">               swap(A[i<span class="number">-1</span>],A[i]);</span><br><span class="line">               sorted = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑算法的正确性</p><p>问题：该算法必然会结束？至多需迭代多少趟？</p><p><strong>不变性</strong>：经k轮扫描交换后，最大的k个元素必然就位</p><p><strong>单调性</strong>：经k轮扫描交换后，问题规模缩减至n-k</p><p><strong>正确性</strong>：经至多n趟扫描后，算法必然终止，且能给出正确答案</p><p><strong>通过挖掘并且综合算法的不变性和单调性，进而证明算法正确性</strong>的方法是算法分析中的一个基本且重要的方法。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206133211.png" style="zoom: 67%;"></p><h2 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h2><p>除了大$O$记号这种定性的方法，我们在很多时候也需要定量的估算，一种常用的方法是封底估算（Back-of-the-Envelope Calculation）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206134004.png" style="zoom:67%;"></p><h1 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h1><p>To iterate is human, to recurse, divine.</p><p><strong>例子</strong>：<strong>数组求和（迭代）</strong></p><p>问题：计算任意n个整数之和</p><p>实现：逐一取出每个元素，累加之</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumI</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论A[ ]内容如何，都有时间复杂度为：</p><p>​        $T(n)=1+n*1+1=n+2=O(n)=\Omega(n)+\Theta(n)$</p><p>如果把输入参数中的n看作是这个问题的规模，其中最重要的循环部分，每经过一次迭代，有一个数已经统计完毕，而相应的尚未参与统计的元素，即尚未解决的问题的规模就会递减一个元素，这种通过不断削减问题的有效规模的方法就是减而治之。</p><h2 id="减而治之（Decrease-and-conquer）"><a href="#减而治之（Decrease-and-conquer）" class="headerlink" title="减而治之（Decrease-and-conquer）"></a>减而治之（Decrease-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡易解，另一规模缩减；分别求解子问题；由子问题的解，得到原问题的解。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206174923.png" style="zoom:67%;"></p><h3 id="数组求和：线性递归"><a href="#数组求和：线性递归" class="headerlink" title="数组求和：线性递归"></a>数组求和：线性递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>) ? <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归跟踪</strong>（recursion trace）分析：</li></ul><p>​       检查每个递归实例；累计所需时间（调用语句本身，计入对应的子实例）；其总和即算法执行时间</p><ul><li>本例中，单个递归实例自身只需$O(1)$时间</li></ul><p>​        $T(n)=O(1)*(n+1)=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206181824.png" style="zoom:67%;"></p><ul><li>从<strong>递推</strong>的角度看，为求解<code>sum(A, n)</code>，需要</li></ul><p>​                递归求解规模为n-1的问题<code>sum(A,n-1)</code>           //T(n-1)</p><p>​                再累加上A[n-1]                                                   //$O(1)$</p><p>​                递归基：<code>sum(A, 0)</code>                                          //$O(1)$</p><ul><li>递推方程：$T(n)=T(n-1)+O(1)$                     //recurrence</li></ul><p>​                          $T(0)=O(1)$                                            //base</p><ul><li>求解：       $T(n)-n=T(n-1)-(n-1)=\dots=T(2)-2=T(1)-1=T(0)$</li></ul><p>​                          $T(n)=O(1)+n=O(n)$</p><h3 id="数组倒置"><a href="#数组倒置" class="headerlink" title="数组倒置"></a>数组倒置</h3><p>任给数组A[n]，将其前后颠倒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">&#123;</span><br><span class="line">swap(A[lo], A[hi]);</span><br><span class="line">reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由递推方程：$T(n)=T(n-2)+O(1)$可得其时间复杂度为：$O(n)$。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206184350.png" style="zoom:67%;"></p><h2 id="分而治之（Divide-and-conquer）"><a href="#分而治之（Divide-and-conquer）" class="headerlink" title="分而治之（Divide-and-conquer）"></a>分而治之（Divide-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为若干个（通常两个）子问题，规模大体相当；分别求解子问题；由子问题的解，得到原问题的解</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201250.png" style="zoom:67%;"></p><h3 id="数组求和：二分递归"><a href="#数组求和：二分递归" class="headerlink" title="数组求和：二分递归"></a>数组求和：二分递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(A,lo,mi) + sum(A,mi+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201640.png" style="zoom:67%;"></p><p>该算法的正确性毋庸置疑，接下来分析其时间复杂度：</p><ul><li>从<strong>递归跟踪</strong>的角度：</li></ul><p>​       $T(n)=各层递归实例所需时间之和=O(1)\times(2^0+2^1+2^2+\dots+2^{logn})=O(n)$</p><p>​     （几何级数的时间复杂度与末项同阶）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206202116.png" style="zoom: 67%;"></p><ul><li><p>从<strong>递推</strong>的角度：为求解<code>sum(A, lo, hi)</code>，需要</p><p>​        递归求解<code>sum(A, lo, mi)</code>和<code>sum(A, mi+1, hi)</code> ；进而将子问题的解累加</p></li></ul><p>​               递归基：<code>sum(A, lo, lo)</code></p><p>​        递推关系：$T(n)=2*T(n/2)+O(1)$</p><p>​                           $T(1)=O(1)$</p><p>​        求解：        $T(n)=O(n)$</p><h2 id="Max2"><a href="#Max2" class="headerlink" title="Max2"></a>Max2</h2><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]，元素比较的次数，要求尽可能地少.</p><h3 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206204203.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x1 = lo; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[i]) x1 = i;                  <span class="comment">//hi-lo-1 = n-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x2 = lo; i &lt; x1; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//x1-lo-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x1 + <span class="number">1</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//hi-x1-1次比较      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何，该算法的比较次数总是$\Theta(2n-3)$</p><h3 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206205752.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])  swap(x1, x2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = i])</span><br><span class="line">swap(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：$1+(n-2)\times1=n-1$</p><p>最坏情况：$1+(n-2)\times2=2n-3$；就最坏的情况而言，这种算法并没有改进</p><h3 id="递归-分治"><a href="#递归-分治" class="headerlink" title="递归+分治"></a>递归+分治</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206210400.png" style="zoom:67%;"></p><p>将数组二分为左侧和右侧两部分，分别找出最大值和次大值，再进行比较；每一侧又可以继续二分，实现递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">2</span> == hi)&#123;                          <span class="comment">//T(2) = 1</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">3</span> == hi)&#123;                          <span class="comment">//T(3) &lt;= 3</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[lo + <span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = lo + <span class="number">2</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;                                </span><br><span class="line"><span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;    <span class="comment">//divide</span></span><br><span class="line"><span class="keyword">int</span> x1L, x2L;  max2(A, lo, mi, x1L, x2L);</span><br><span class="line"><span class="keyword">int</span> x1R, x2R;  max2(A, mi, hi, x1R, x2R);</span><br><span class="line"><span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">x1 = x1L;</span><br><span class="line">x2 = (A[x2L] &gt; A[x1R]) ? x2L : x1R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = x1R;</span><br><span class="line">x2 = (A[x1L] &gt; A[x2R]) ? x1L : x2R;</span><br><span class="line">&#125;     <span class="comment">//1 + 1 = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度：$T(n)=2*T(n/2)+2\le5n/3-2$</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work, make it right, make it fast.</p><p>前两步work和right可以通过递归解决，而最后一步fast可以通过迭代解决。</p><h2 id="斐波那契数列fib"><a href="#斐波那契数列fib" class="headerlink" title="斐波那契数列fib( )"></a>斐波那契数列fib( )</h2><p>$fib(n)  = fib(n-1) + fib(n-2) : \{0, 1, 1, 2, 3, 5, 8, ……\}$</p><h3 id="fib-：递归"><a href="#fib-：递归" class="headerlink" title="fib( )：递归"></a>fib( )：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>&gt;n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当n较大时，这个递归算法的计算是很慢的，其<strong>时间复杂度</strong>为：</p><p>$T(0)=T(1)=1;\,T(n)=T(n-1)+T(n-2)+1,\,n&gt;1$</p><p>令：$S(n)=[T(n)+1]/2$</p><p>则：$S(0)=1=fib(1),\,S(1)=1=fib(2)$</p><p>故：$S(n)=S(n-1)+S(n-2)=fib(n+1)$</p><p>​        $T(n)=2*S(n)-1=2\times fib(n+1)-1=O(fib(n+1))=O(\Phi^n)=O(2^n)$  ，</p><p>其中：$\Phi=\frac{1+\sqrt{5}}{2}=1.61803…$，即黄金分割数</p><p>可见该算法的时间复杂度和fib数列的n+1项的值是一个量级的。</p><p>接着对这个$O(\Phi^n)$进行较准确的估算，用<strong>封底估算</strong>的方法有：</p><p>$\Phi^{36}=2^{25},\,\Phi^{43}=2^{30}=10^9flo=1sec$</p><p>$\Phi^{5}=10,\,\Phi^{67}=10^14flo=10^5sec$</p><p>$\Phi^{92}=10^{19}flo=10^{10}sec=10^5day=3century$</p><p>可见这并不是一个好方法。</p><p>从<strong>递归跟踪</strong>的角度来分析：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206221339.png" style="zoom:67%;"></p><p>递归版<code>fib( )</code>低效的根源在于，各地鬼实例均被大量重复地调用</p><p>那么可以使每个实例只能调用一次嘛？答案是可以的。先后出现的递归实例，供给$O(\Phi^n)$个，而去除重复之后，总共不过$O(n)$种。</p><h3 id="fib-：迭代"><a href="#fib-：迭代" class="headerlink" title="fib( )：迭代"></a>fib( )：迭代</h3><p>解决方法A（<strong>记忆</strong>：memoization）：</p><p>​        将已计算过实例的结果指标备查。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206222400.png" style="zoom: 50%;"></p><p>解决方法B（动态规划：dynamic programming）：</p><p>​        颠倒计算方向，由自顶而下递归，改为自底而上迭代。不妨用两个变量f和g，分别来记忆当前我所处的相邻的两个数。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206223053.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;   <span class="comment">//fib(0), fib(1)</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了一个循环，没有其他增加时间复杂度的操作，而且只需要f和g两个存储单元。</p><p>$T(n)=O(n)$，而且仅需要$O(1)$空间！</p><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p><strong>子序列（Subsequence）</strong>：由序列中若干字符，按原相对次序构成（线不能有交叉）。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224303.png" style="zoom:67%;"></p><p><strong>最长公共子序列（Longest Common Subsequence）</strong>：两个序列公共子序列中的最长者。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224308.png" style="zoom:67%;"></p><p>现在考虑一个较简单的问题：如何计算出任意给出的两个序列的最长公共子序列的长度？</p><h3 id="LCS：递归"><a href="#LCS：递归" class="headerlink" title="LCS：递归"></a>LCS：递归</h3><p>对于序列A[0, n]和B[0, m]，LCS(A, B)无非三种情况</p><p>0）若n = -1 或 m = -1，则取空序列（“ ”）                                      //递归基</p><p>1）若A[n] = ‘X’ = B[m]，则取作LCS( A[0, n),  B[0, m) ) + ‘X’          // 减而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230441.png" style="zoom: 67%;"></p><p>2）若A[n] $\ne$ B[m]，则分别计算LCS( A[0, n],  B[0, m) )，与LCS( A[0, n),  B[0, m] )，取更长者。 //分而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230523.png" style="zoom:67%;"></p><p>我们把上述算法中生成的所有递归实例绘制成一个表，每一个横纵坐标所确定的3×3的小方格所组成的一个大方格分别对应于一个子任务或者说是递归实例，可以看到如果是减而治之的情况，对应大方格中的一条对角线；如果是分而治之的情况，则会考虑左侧和上方的子问题，然后取更长者，保留其对应的一条边。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206231904.png" style="zoom:67%;"></p><p>这样的形式可以帮助我们理解整个计算的过程，在这样一张表中我们最终求解的问题必然是右下角的方格对应的子问题，它分别会递归地引发一些更小的子问题，最终收缩到平凡的长度为0的子问题；我们也可以认为，每一个LCS问题的解都是从左上角(0,0)的单元开始一直沿着可行的深色的线通往右下角单元的路径，每一条路径就对应着一个解，这样就能很好地理解多解的情况。</p><p>接下来分析该算法的正确性和时间复杂度：</p><ul><li><p><strong>单调性</strong>：无论如何，每经过一次比对，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位。</p></li><li><p><strong>最好情况</strong>（不出现情况2））下，只需$O(n+m)$时间（线性规模）</p></li><li>但问题在于，在情况2）下原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能<strong>雷同</strong>，与<code>fib( )</code>的递归出现的问题类似，这种重复度往往是超出我们直观想象的。</li></ul><p>​       我们将上面的图表进行局部放大：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206233230.png" style="zoom:67%;"></p><p>为了进行更好的估算，我们不妨从更宏观的角度来重新审视上面的表格，不妨把其中所有的递归实例分别按坐标的形式表示为(n, m)，那么为了计算出最终的递归实例即(n, m)对应的解，我们需要唤醒某一个特定的递归实例(a. b)多少次呢？</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206234248.png" style="zoom:67%;"></p><p>根据图表中路线行进的方向，在最坏的情况下所唤醒的次数应该等于介于这两点之间的通路的条数，每一条通路对应于(a, b)被唤醒一次，即为两点之间所有合法的通路的总长n+m-a-b中挑选出n-a条水平路径的方案数，或挑选出m-b条垂直路径的方案数。</p><p>那么在最坏情况下，LCS( A[0, a],  B[0, b] )出现的次数为：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m-a-b\\n-a\end{pmatrix}=\begin{pmatrix}n+m-a-b\\m-b\end{pmatrix}</script><p>特别地，LCS( A[0],  B[0] )出现的次数多达：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m\\n\end{pmatrix}=\begin{pmatrix}n+m\\m\end{pmatrix}</script><p>当$n=m$时，该算法的时间复杂度为：$O(2^n)$。</p><h3 id="LCS：迭代"><a href="#LCS：迭代" class="headerlink" title="LCS：迭代"></a>LCS：迭代</h3><ul><li><p>与<code>fib( )</code>类似，这里也有大量重复的递归实例（子问题），（最坏情况下）先后共计出现$O(2^n)$个</p></li><li><p>各子问题，分别对应于A和B的某个前缀组合，因此总共不过$O(n*m)$种</p></li><li><p>采用动态规划的策略，只需$O(n*m)$时间即可计算出所有子问题</p></li><li><p>为此，我们只需将所有子问题列成一张表，颠倒计算方向，<strong>从LCS( A[0],  B[0] )出发</strong>，依次计算出所有项。</p><p>填表的规则是：首先初始化，行列都设为0，若遇到减而治之，即字母相同，则对应位置元素为其左上对角线元素+1；若遇到分而治之，即字母不相同，则对应位置元素取其上方和左侧元素中的最大值。</p></li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206235750.png" style="zoom:67%;"></p><p>这样对于每一个子问题，只会出现一次，因此算法的时间复杂度为$O(n*m)$。</p>]]></content>
    
    <summary type="html">
    
      开个新坑
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（7）类和对象</title>
    <link href="http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-04T08:09:38.000Z</published>
    <updated>2020-02-14T08:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计的基本特点"><a href="#面向对象程序设计的基本特点" class="headerlink" title="面向对象程序设计的基本特点"></a>面向对象程序设计的基本特点</h1><p><strong>抽象</strong>：对同一类对象的共同属性和行为进行概括，形成类。</p><ul><li>首先注意问题的本质及描述，其次是实现过程或细节。</li><li>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</li><li>代码抽象：描述某类对象的共有的行为特征或具有的功能。</li><li>抽象的实现：类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装</strong>：将抽象出的数据，代码封装在一起，形成类。</p><ul><li>目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</li><li>实现封装：类声明中的{ }</li></ul><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174646.png" alt="QQ图片20200204174646" style="zoom: 50%;"></p><p><strong>继承</strong>：在已有类的基础上，进行扩展形成新的类。</p><p><strong>多态</strong>：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。</p><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。</p><p>设计类就是设计类型，需要<strong>关注哪些问题</strong>：</p><ul><li>此类型的“合法值”是什么？</li><li>此类型应该有什么样的函数和操作符？</li><li>新类型的对象该如何被创建和销毁？</li><li>如何进行对象的初始化和赋值？</li><li>对象作为函数的参数如何以值传递？</li><li>谁将使用此类型的对象成员？</li></ul><h3 id="类定义的语法形式"><a href="#类定义的语法形式" class="headerlink" title="类定义的语法形式"></a>类定义的语法形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">           公有成员（外部接口）</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">           私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">           保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour = <span class="number">0</span>, minute = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p><strong>公有类型成员</strong>：在关键字<code>public</code>后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</p><p><strong>私有类型成员</strong>：在关键字<code>private</code>后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字<code>private</code>可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p><p><strong>保护类型成员</strong>：与private类似，其差别表现在继承与派生时对派生类的影响不同。</p><p>类中成员之间直接使用成员名互相访问。</p><p>从类外访问成员使用“ <code>对象名.成员</code>”，来访问公有成员。</p><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类中声明函数原型：</p><ul><li>可以直接在类中给出函数体，形成内联成员函数；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以在类外给出函数体实现，并在函数名前用类名加以限定；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::getArea() &#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line"><span class="keyword">int</span> Rectangle::getPerimeter() &#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br></pre></td></tr></table></figure><ul><li>允许声明重载函数和带默认参数值的函数。</li></ul><p><strong>例子</strong>：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setM</span><span class="params">(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y)</span> </span>&#123; x = _x; y = _y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> _r)</span> </span>&#123; r = _r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * r * r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> *r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Circle myCircle;</span><br><span class="line">myCircle.setM(<span class="number">1.7</span>, <span class="number">3.2</span>);</span><br><span class="line">myCircle.setR(<span class="number">4.2</span>);</span><br><span class="line"><span class="keyword">double</span> myArea = myCircle.getArea();</span><br><span class="line"><span class="keyword">double</span> myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">myCircle.setR(<span class="number">8.4</span>);</span><br><span class="line">myArea = myCircle.getArea();</span><br><span class="line">myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174231.png" alt="QQ图片20200204174231" style="zoom:80%;"></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>当我们定义对象时，如何对对象进行初始化？在定义基本类型的变量时，是可以直接给定初始值的，但是在定义对象时却不是这么简单，因为一个类是我们自己定义的，对类的对象按照什么规则进行初始化，编译器是不会自动知道的，必须由程序员写程序来规定。为此C++中提供了一种特殊的机制：<strong>构造函数</strong>，在构造函数中我们可以描述如何对类的对象进行初始化。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><ul><li>在对象被创建时使用特点的值构造对象，将对象初始化为一个特定的初始状态</li></ul><p>例如：希望在构造一个Clock类对象时，将初始时间设为0:0:0，就可以通过构造函数来设置</p><h3 id="构造函数的形式"><a href="#构造函数的形式" class="headerlink" title="构造函数的形式"></a>构造函数的形式</h3><ul><li>函数名与类名相同；</li><li>不能定义返回值类型，也不能在函数体有return语句；</li><li>可以有形式参数，也可以没有形式参数；</li><li>可以是内联函数；</li><li>可以是重载；</li><li>可以带默认参数值。</li></ul><h3 id="构造函数的调用时机"><a href="#构造函数的调用时机" class="headerlink" title="构造函数的调用时机"></a>构造函数的调用时机</h3><ul><li>在对象创建时被自动调用，但如果没有定义构造函数就进行初始化，那么编译器就会报错。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Clockk <span class="title">myClock</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>调用时可以不需要实参的构造函数：</p><ul><li>参数表为空的构造函数</li><li>全部参数都有默认值的构造函数</li></ul><p>下面两个都是默认构造函数，如在类中同时出现，将产生编译错误，不是合法的函数重载形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock();</span><br><span class="line">Clock(<span class="keyword">int</span> newH=<span class="number">0</span>, <span class="keyword">int</span> newM=<span class="number">0</span>, <span class="keyword">int</span> newS=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="隐含生成的构造函数"><a href="#隐含生成的构造函数" class="headerlink" title="隐含生成的构造函数"></a>隐含生成的构造函数</h3><p>如果在程序中未定义构造函数，编译器将在需要时自动生成一个<strong>默认的构造函数</strong>：</p><ul><li>参数列表为空，不为数据成员设置初始值；</li><li>如果类内定义了成员的初始值，则使用内类定义的初始值；</li><li>如果没有定义类内的初始值，则以默认方式初始化；</li><li>基本类型的数据默认初始化的值是不确定的。</li></ul><p>如果定义的类的成员不是基本类型的成员，而是其他类的对象，这个就是类组合的情况，其默认的初始化方式由它所属的类决定。</p><h4 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h4><p>如果程序中已定义构造函数，默认情况下编译器就不会再隐含生成默认构造函数。如果此时依然希望编译器隐含生成的默认构造函数，可以使用<code>=default</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Clock() = <span class="keyword">default</span>;</span><br><span class="line">       Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">c.showTime();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);   <span class="comment">//构造函数</span></span><br><span class="line">    Clock();  <span class="comment">//默认构造函数，如果类要重复使用，一般要提供一个默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;  <span class="comment">//调用有参数的构造函数</span></span><br><span class="line">    Clock c2;          <span class="comment">//调用无参数的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>当我们在一个类中重载多个构造函数的时候，往往发现这些构造函数它们只是形参表不同，初始化列表不同，而其他都是一样的，初始化算法都是相同的，函数体都是相同的。那么在这种情况下，如果我们写多个函数体来重载，往往就显得重复了，为了避免这种重复，C++11新标准提供了一种新的机制：<strong>委托构造函数</strong>，也就是让一个构造函数可以去委托另一个构造函数去帮它完成初始化功能。</p><p>回顾<code>Clock</code>类的两个构造函数，第一个构造函数是有三个参数的，第二个构造函数是默认构造函数，没有参数。实际上，这两个构造函数进行初始化的方式是完全一样的，只不过第一个构造函数是用参数表里的参数进行初始化，第二个构造函数用默认状态全部用0进行初始化。那么我们其实没有必要写两个类似的重复的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br></pre></td></tr></table></figure><p>委托构造函数使用类的其他构造函数执行初始化过程，我们用委托构造函数的方法重写上面的代码，这里第二个构造函数调用了另外一个有参数的构造函数，将默认的三个初始化参数传给有参数表的Clock构造函数，这样就不用把同样的初始化方法再写一遍了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125;</span><br><span class="line">Clock::Clock():Clock(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>用委托构造函数不仅可以减少重复的工作，其最大的好处是可以<strong>保持代码实现的一致性</strong>，如果想要修改构造函数的初始化算法时，就只需在一处修改，其他的委托这个构造函数来进行初始化的构造函数的算法也就同步修改了。</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>当我们在定义一个基本类型的变量时，经常会用一个已经存在的已经有值的变量去初始化这个变量；我们在定义对象时可会有这样的需求，即用一个存在的对象去初始化一个新的对象，这时要如何实现这种初始化呢？C++中提供了一种特殊的构造函数，叫<strong>复制构造函数</strong>。</p><p>在复制构造函数中我们可以规定如何用一个已经存在的对象去初始化一个新对象，可以用这个已经存在的对象的引用作为构造函数的参数。如果在定义类的时候没有定义复制构造函数，编译器也生成一个默认的复制构造函数，它会实现类的两个对象的数据成员之间一一对应复制，这些功能在很多时候已经能满足需求，那么我们就不需要再写复制构造函数了。</p><h3 id="复制构造函数定义"><a href="#复制构造函数定义" class="headerlink" title="复制构造函数定义"></a>复制构造函数定义</h3><ul><li>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</li></ul><p>由于复制构造函数的目的不会是将原有的那个形参对象给修改了，所以最好是在形参引用前加上<code>const</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       类名(形参)； <span class="comment">//构造函数</span></span><br><span class="line">       类名(<span class="keyword">const</span> 类名 &amp;对象名);   <span class="comment">//复制构造函数</span></span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类(<span class="keyword">const</span> 类名 &amp;对象名)      <span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><h3 id="复制构造函数的调用"><a href="#复制构造函数的调用" class="headerlink" title="复制构造函数的调用"></a>复制构造函数的调用</h3><p>除了在定义新对象时，用已有的对象作为参数去初始化它这种情况以外，共有三种情况是典型的要调用复制构造函数的情况：</p><ul><li>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</li><li>如果<strong>函数的**</strong>形参是类的对象**，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</li><li>如果<strong>函数的返回值是类的对象</strong>，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。</li></ul><h3 id="隐含的复制构造函数"><a href="#隐含的复制构造函数" class="headerlink" title="隐含的复制构造函数"></a>隐含的复制构造函数</h3><ul><li>如果程序员没有为类拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数；</li><li>这个构造函数的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</li></ul><p>如果类的成员中有指针的时候，很多情况下，默认的复制构造函数其浅层的复制功能就不够用了，这是我们就需定义深层的复制构造。</p><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>如果我们不希望对象被复制构造，那么可以采用下面的方法:</p><ul><li>C++98做法：将复制构造函数声明为<code>private</code>，并且不提供函数的实现。</li><li>C++11做法：用<code>=delete</code>指示编译器不生成默认复制构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx=<span class="number">0</span>, <span class="keyword">int</span> yy=<span class="number">0</span>) &#123;x=xx; y=yy&#125;  <span class="comment">//构造函数，内联</span></span><br><span class="line">       Point(<span class="keyword">const</span> Point &amp;p) = <span class="keyword">delete</span>;         <span class="comment">//指示编译器不生成默认复制构造函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当一个对象在存续期间会占用系统资源，当这个对象的生存期结束时，需要进行善后工作将其删除清理掉，C++中提供了这样一种机制：析构函数。当对象被构造时，构造函数会自动调用；当对象要消亡时，其析构函数也会自动调用。</p><ul><li>完成对象被删除前的一些清理工作；</li><li>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间；</li><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空；</li><li>析构函数的原型：<code>~类名( );</code></li><li>析构函数没有参数，没有返回类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)   <span class="comment">//构造函数</span></span><br><span class="line">       ~Point();               <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line">Point::Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    x=xx; y=yy;</span><br><span class="line">&#125;</span><br><span class="line">Point::~Point()&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h1><p>在制造业多年来都一直使用部件组装的生产方式，与一切手工从头做起相比，部件组装的生产效率肯定是要高，产品的标准化  它的可靠性也都更好。在程序中我们也可以借用这种部件组装的思想，用已经存在的这些类去组装新的类，C++语言支持类的组合。我们在定义一个新类的时候，可以让它的类成员是已有类的对象，也就是说一些类的对象可以作为另外一个类的部件，这就是类的组合。</p><p><strong>类组合的基本概念</strong>：</p><ul><li>类中的成员是另外其他类的对象；</li><li>可以在已有抽象的基础上实现更复杂的抽象。</li></ul><p><strong>成员对象</strong>：一个类的成员变量是另一个类的对象</p><p>包含成员对象的类叫<strong>封闭类</strong>（Enclosing）</p><h2 id="类组合的构造函数设计"><a href="#类组合的构造函数设计" class="headerlink" title="类组合的构造函数设计"></a>类组合的构造函数设计</h2><p>那么组合类的构造函数如何设计呢？每个类的构造函数都是负责自己本类成员初始化的，如果用另外类的对象作为新定义类的成员，那么这个组合类是没有权利去访问部件对象内部的私有成员。因为一个类的私有成员只有这个类内部的函数可以访问，类外任何地方是不可以访问的，而且部件类的设计者、开发者，跟组合类的设计者  开发者可能不是一个人，甚至不是一个团队。因此在写组合类的构造函数时要考虑，由组合类的构造函数负责将部件对象初始化所需要的初始化参数传递给它，然后编译器会自动去调用部件类的构造函数，来初始化这些部件对象。其语法形式如下：</p><ul><li>原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。</li><li>声明形式：<strong>初始化列表</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(对象成员所需的形参，本类成员形参):</span><br><span class="line">    对象<span class="number">1</span>(参数), 对象<span class="number">2</span>(参数),......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//函数体其他语句</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="构造组合类对象时的初始化次序"><a href="#构造组合类对象时的初始化次序" class="headerlink" title="构造组合类对象时的初始化次序"></a>构造组合类对象时的初始化次序</h3><ul><li>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。<ul><li>成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造</li><li>初始化列表中未出现的成员对象，调用默认构造函数（即无形餐的）初始化</li></ul></li><li>处理完初始化化列表之后，再执行构造函数的函数体</li></ul><p>也可以这样理解，<strong>构造函数和析构函数的调用顺序</strong>：</p><ul><li>当封闭类对象生成时：<ul><li>S1：执行所有成员对象的构造函数</li><li>S2：执行封闭类的构造函数</li></ul></li><li>成员对象的构造函数调用顺序<ul><li>和成员对象在类中的说明顺序一致</li><li>与在成员初始化列表中出现的顺序无关</li></ul></li><li>当封闭类的对象消亡时<ul><li>S1：先执行封闭类的析构函数</li><li>S2：再执行成员对象的析构函数</li></ul></li><li>析构函数顺序和构造函数的调用顺序相反（先构造的后析构，后构造的先析构）</li></ul><p>需要注意的是，我们在写类的构造函数时，<strong>最好再写一个无参数的默认构造函数</strong>。当这个类的对象被用作其他类的部件成员时，可能组合类中没有写构造函数只使用默认构造函数，这个时候我们上面的操作就显得很必要了。</p><p><strong>例子</strong>：构造一个<code>Point</code>类，再用<code>Point</code>类构造组合类<code>Line</code>类，通过构造函数和复制构造函数中的“调试信息”（<code>cout&lt;&lt;</code>……）可以更好地理解构造函数和复制构造函数的调用过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span>    <span class="comment">//Point类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">x = xx;</span><br><span class="line">y = yy;</span><br><span class="line">&#125;</span><br><span class="line">Point(Point &amp;p);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::Point(Point &amp;p) &#123;   <span class="comment">//复制构造函数的实现</span></span><br><span class="line">x = p.x;</span><br><span class="line">y = p.y;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling the copy constructor of Point"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span>   <span class="comment">//Line类的定义</span></span><br><span class="line"><span class="keyword">public</span>:        <span class="comment">//外部接口</span></span><br><span class="line">Line(Point xp1, Point xp2);</span><br><span class="line">Line(Line &amp;l);</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> len; &#125;</span><br><span class="line"><span class="keyword">private</span>:      <span class="comment">//私有数据成员</span></span><br><span class="line">Point p1, p2;   <span class="comment">//Point类的对象p1,p2</span></span><br><span class="line"><span class="keyword">double</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合类的构造函数</span></span><br><span class="line">Line::Line(Point xp1, Point xp2) :p1(xp1), p2(xp2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling constructor of Line"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">double</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p1.getX() - p2.getX());</span><br><span class="line"><span class="keyword">double</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p1.getY() - p2.getY());</span><br><span class="line">len = <span class="built_in">sqrt</span>(x*x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合类的复制构造函数</span></span><br><span class="line">Line::Line(Line &amp;l) :p1(l.p1), p2(l.p2) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling the copy constructor of Line"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">len = l.len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Point myp1(1, 1), myp2(4, 5);</span><br><span class="line"><span class="function">Line <span class="title">line</span><span class="params">(myp1, myp2)</span></span>;</span><br><span class="line"><span class="function">Line <span class="title">line2</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the line is: "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span>.getLen() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the line2 is: "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line2.getLen() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200209205450.png" style="zoom:80%;"></p><h1 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h1><p>类应该先声明，后使用，如果<strong>需要在某个类的声明之前引用该类</strong>，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其他地方。前向引用声明某个类之后，可在之后的其他类的成员函数中将该类作为参数类型使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>使用前向引用声明虽然可以解决一些问题，但它并不是万能的。</li><li>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。</li><li>当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>;</span>  <span class="comment">//前向引用声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Barney</span>&#123;</span></span><br><span class="line">    Fred x;  <span class="comment">//错误：类Fred的声明尚不完整，不能声明该类的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fred</span>&#123;</span></span><br><span class="line">    Barney y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol><li>声明一个<code>CPU</code>类，包含等级（rank）、频率（frequency）、电压（voltage）等属性，有两个公有成员函数run、stop。其中，rank为枚举类型CPU_Rank，声明为<code>enum CPU_Rank {P1=1,P2,P3,P4,P5,P6,P7}</code>，frequency为单位是MHz的整型数，voltage为浮点型的电压值。类似地声明一个<code>RAM</code>类。</li><li>声明一个简单的Computer类，有数据成员芯片（cpu）、内存（ram），有两个公有成员函数run、stop。cpu为CPU类的一个对象，ram为RAM类的一个对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> CPU_Rank &#123; P1 = <span class="number">1</span>, P2, P3, P4, P5, P6, P7 &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU_Rank rank;</span><br><span class="line"><span class="keyword">int</span> frequency;</span><br><span class="line"><span class="keyword">float</span> voltage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CPU(CPU_Rank r, <span class="keyword">int</span> f, <span class="keyword">float</span> v)  <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">rank = r;</span><br><span class="line">frequency = f;</span><br><span class="line">voltage = v;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个CPU!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CPU(CPU &amp;c)  <span class="comment">//复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">rank = c.rank;</span><br><span class="line">frequency = c.frequency;</span><br><span class="line">voltage = c.voltage;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造了一个CPU！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~CPU() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个CPU!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">CPU_Rank <span class="title">GetRank</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rank; &#125;       <span class="comment">//外部接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFrequency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> frequency; &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetVoltage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> voltage; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRank</span><span class="params">(CPU_Rank r)</span> </span>&#123; rank = r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFrequency</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123; frequency = f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVoltage</span><span class="params">(<span class="keyword">float</span> v)</span> </span>&#123; voltage = v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CPU开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CPU停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RAM_TYPE &#123; DDR2 = <span class="number">2</span>, DDR3, DDR4 &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> RAM_TYPE type;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> frequency;  <span class="comment">//MHz</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>;       <span class="comment">//GB</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RAM(RAM_TYPE t, <span class="keyword">unsigned</span> <span class="keyword">int</span> f, <span class="keyword">unsigned</span> <span class="keyword">int</span> s)  <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">type = t;</span><br><span class="line">frequency = f;</span><br><span class="line"><span class="built_in">size</span> = s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RAM(RAM &amp;c)    <span class="comment">//复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">type = c.type;</span><br><span class="line">frequency = c.frequency;</span><br><span class="line"><span class="built_in">size</span> = c.<span class="built_in">size</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~RAM() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个RAM！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;   <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">RAM_TYPE <span class="title">GetType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetFrequency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> frequency; &#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetType</span><span class="params">(RAM_TYPE t)</span> </span>&#123; type = t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFrequency</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> f)</span> </span>&#123; frequency = f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> s)</span> </span>&#123; <span class="built_in">size</span> = s; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RAM开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RAM停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//COMPUTER类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COMPUTER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU my_cpu;</span><br><span class="line">RAM my_ram;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> storage_size; <span class="comment">//GB</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bandwidth;    <span class="comment">//MB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">COMPUTER(CPU c, RAM r,<span class="keyword">unsigned</span> <span class="keyword">int</span> s, <span class="keyword">unsigned</span> b);     <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">~COMPUTER() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构了一个COMPUTER！"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;  <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">my_cpu.Run();</span><br><span class="line">my_ram.Run();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPUTER开始运行!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">my_cpu.Stop();</span><br><span class="line">my_ram.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"COMPUTER停止运行!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//COMPUTER类的构造函数，内嵌对象采用初始化列表初始化</span></span><br><span class="line"><span class="comment">//一共会调用两次复制构造函数，形实结合调用依次，初始化列表调用依次</span></span><br><span class="line"><span class="comment">//当COMPUTER构造函数结束以后，形实结合那个形参的生命周期就结束，于是执行析构函数</span></span><br><span class="line">COMPUTER::COMPUTER(CPU c, RAM r, <span class="keyword">unsigned</span> <span class="keyword">int</span> s, <span class="keyword">unsigned</span> <span class="keyword">int</span> b) :my_cpu(c), my_ram(r)</span><br><span class="line">&#123;</span><br><span class="line">storage_size = s;</span><br><span class="line">bandwidth = b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"构造了一个COMPUTER！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">CPU <span class="title">a</span><span class="params">(P6, <span class="number">300</span>, <span class="number">2.8</span>)</span></span>;</span><br><span class="line">a.Run();</span><br><span class="line">a.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">RAM <span class="title">b</span><span class="params">(DDR3, <span class="number">1600</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">b.Run();</span><br><span class="line">b.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">COMPUTER <span class="title">my_computer</span><span class="params">(a, b, <span class="number">128</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line">my_computer.Run();</span><br><span class="line">my_computer.Stop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"***********************\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return之前会执行析构函数，先析构my_computer，和它的两个内嵌成员，然后析构CPU a和RAM b</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200209232217.png" style="zoom:80%;"></p><p>PS：结构体，联合体，枚举类的内容在上一篇文章Cpp基础（6）中。</p>]]></content>
    
    <summary type="html">
    
      设计程序的过程，就是设计类的过程
    
    </summary>
    
    
      <category term="C++基础" scheme="http://nekomoon404.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
