<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-02-08T16:59:39.805Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法（2）向量</title>
    <link href="http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/"/>
    <id>http://nekomoon404.github.io/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/</id>
    <published>2020-02-08T02:04:27.000Z</published>
    <updated>2020-02-08T16:59:39.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><p>我们首先需要辨析一组非常相关但是又非常容易弄混的概念，也就是<strong>抽象数据类型</strong>以及<strong>数据结构</strong>。那么什么是<strong>Abstract Data Type</strong>呢？以及什么是<strong>Data Structure</strong>呢？可以从字面上给出定义，所谓的抽象数据类型，其实就是在一组数据的模型上定义的一组操作。那么什么叫作数据结构呢？是基于某种特定的语言真正实现的一套完整的算法。</p><p>我们此前比较熟悉的程序语言，先不要考虑什么抽象数据类型，先来看看什么叫作Data Type数据类型。比如在高级程序设计语言中<code>int</code>也就是整型，这就是一个数据类型，而<code>floa</code>t也是，还有<code>char</code>，诸如此类地。这种数据类型能够让我们能定义其中的一个成员，比如<code>n</code>是一个整数，从此以后我们就可以使用它了，我们也可以定义<code>x</code>是一个浮点数，<code>c</code>是一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">char</span> c;</span><br></pre></td></tr></table></figure><p>凡是这样指定了某一个元素是来自于某一个数据类型，或者说属于某一个数据类型，那么它就自然地具有了这种数据类型的特点，包括支持相应地处理方法，比如说运算。那么这里那些操作的运算具体是如何实现的，我们并不知道，我们也并不需要知道，这是最重要的。</p><p>把这样的一个概念抽象出来施加到我们所将要实现的数据结构上，比如这一章要介绍的<code>vector</code>。我们希望在使用的时候能够参照数据类型的这种形式，把它等同地当作是一个数据类型，比如可以用类似的方法来定义一个<code>vector</code>结构，包括下一章将要介绍的<code>List</code>。</p><p>这种使用方法使得我们可以将数据结构与数据类型等同起来，我们只需要知道它所提供的那些操作，比如说向量的查找、排序，而不需要去关心它其中的细节，比如说这些操作是如何实现的。那么从这个意义上讲，它就是一个经过了抽象以后的数据类型，所以称之为<strong>Abstract Data Type</strong>。</p><p>举个例子：我们可以将数据结构比喻成某种产品，比如说汽车，相关的有两类人，首先是用户，我们笼统地称之为应用Application，另一类人是汽车这种产品的设计和制造者，称之为实现Implementation。这两类人所关心的以及他们的职责是不同的，作为用户而言，他只关心这种产品的外在特性，能够提供的功能；而实现者则需要对这些功能以及特性具体如何落实负责。在这二者之间实际上是有某种形式的一个协议，也就是使用说明书，产品手册。而这种手册或者说明在数据结构的使用者与数据结构内部算法的设计者之间，达成了这么样一个协议，两类人可能互不见面，互不相识，但是他们通过这样一个规范，可以很好地彼此沟通，并且有效地合作。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208102916.png" style="zoom:67%;"></p><h2 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h2><h3 id="从数组到向量"><a href="#从数组到向量" class="headerlink" title="从数组到向量"></a>从数组到向量</h3><p><strong>向量实际上是C++等高级编程语言中数组这种数据组织形式的一个推广和泛化</strong>。实际上在这些高级程序设计语言中所谓的数组实际上就是一段连续的内存空间，它被均匀地划分为若干个单元，而每一个单元都与0到n之间的某一个整数编号相互彼此对应，我们称之为第0号单元或者元素，或者第1号元素、第2号元素以及到最后的实质第n-1个元素。这里我们也同样延用此前已经约定的习惯，虽然最后这个第n个元素，实际上未必存在，我们还是把它虚拟地放在这儿作为哨兵，以帮助我们对很多问题的思考，并且使得我们很多算法的实现能够得以简化。</p><ul><li>C/C++语言中，<strong>数组A[ ]中的元素与[0,n)内的编号一一对应</strong>。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208105846.png" style="zoom:67%;"></p><p>既然每一个这样的元素都与这些编号是一一对应的，所以反过来我们通过合法区间内的编号都可以唯一地来指代并且访问对应的那个元素。一旦知道这个元素的下标<code>i</code>，就可以从<code>A</code>也就是这段存储区域的首地址出发，再向后以s作为间隔去数出<code>i</code>步，就可以得到某一个特定的单元。正因为所有这些元素的物理地址可以按照这样一个线性的方程来确定。所以我们也称之为<strong>线性数组</strong>（linear array）。</p><ul><li><p>反之每个元素均由（非负）编号唯一指代，并可直接访问。<strong>A[i]</strong>的物理地址 = A + i×s，s为单个元素占用的空间量。</p></li><li><p>向量是数组的抽象与泛化，由一组元素按线性次序封装而成：</p><ul><li>各元素与[0, n)内的秩（rank）一一对应</li><li>元素的类型不限于基本类型</li><li>操作、管理维护更加简化、统一于安全</li><li>可更为便捷地参与复杂数据结构的定制与实现</li></ul></li></ul><h3 id="向量ADT接口"><a href="#向量ADT接口" class="headerlink" title="向量ADT接口"></a>向量ADT接口</h3><p>按照抽象数据类型的规范，向量结构必须提供一系列的操作接口，可以通过这些操作接口对向量做各种操作，同时也只能通过这些操作接口对向量进行操作，这里的接口功能非常的丰富。</p><p>比如说 与其它的数据结构一样向量也可以看作是一组元素的集合，所以<code>size( )</code>实际上返回的是其中元素的总数，称之为这个数据结构的规模。也可以从中取特定的元素<code>get(r)</code>，也可以修改其中特定的元素<code>put(r, e)</code>，甚至插入<code>insert(r, e)</code>或者是删除某个元素<code>remove(r)</code>。我们也可以判定一下其中的元素是否已经有序排列<code>disordered( )</code>，如果没有有序排列，可以调用相应的接口使之有序排列<code>sort( )</code>。</p><p>我们也可以在它尚未有序排列的时候，按某种算法找到其中特定的元素<code>find(e)</code>，也可以在已经有序的前提下按照某种方式，来找到其中的元素<code>search(e)</code>。当然为了展示一些算法的实现我们也附加了一些其它的功能，比如说能够在无序和有序的情况下分别剔除这个数据集中的重复元素：<code>deduplicate( )</code>和<code>uniquify( )</code> 。最后也是非常重要的一个接口就是如何对这个数据集中的元素逐一地进行枚举，并且访问一遍<code>traverse( )</code>，称之为遍历。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208110149.png" style="zoom:80%;"></p><h3 id="ADT接口操作实例"><a href="#ADT接口操作实例" class="headerlink" title="ADT接口操作实例"></a>ADT接口操作实例</h3><p>下面举例说明ADT接口的实现。</p><p>最开始向量与任何一个数据结构一样，初始化的时候都是不包含任何实质的内容的，我们称它是一个空的向量。接下来调用插入操作<code>insert</code>，它在rank为0的这个位置上插入一个元素9，所以向量的组成将由空变成包含一个元素9。接下来继续调用<code>insert</code>接口，在0号这个位置上rank为0的这个位置上插入一个元素4，原来的元素9将会后移一位。同样地，我们也可以调用插入接口在rank为1的位置上插入5，在这个位置上出现了5，而它的后继统一地向后后移了一位。我们也可以调用<code>put</code>接口，这个接口的意思是修改，它会把当前rank为1的那个位置上的元素数值，由原来的5修改为2。我们也可以通过<code>get</code>这个接口获取秩为某一特定值的元素，比如说秩为2的那个元素，实际上就是2这个位置上的9，因此会返回<code>9</code>。</p><p><code>remove</code>接口的参数是2，这说明它希望在原来这个向量中将rank为2的这个元素，把它剔除掉，剔除之后，会把这个被剔除的元素的值作为输出返回，即返回<code>2</code>，同时它的所有的后继与插入时候的操作的现象相反，会向前平移一个单元。当这个时候我们调用<code>size</code>的时候，因为这里所包含的元素总共是6个，所以它会返回<code>6</code>。</p><p>我们可以看到在整个这个操作的过程中向量都确实具有这么样一个特点，就是它在逻辑上，甚至在物理上必然是彼此紧邻的排列的，所有的元素之间没有任何的缝隙。需要注意的是无论是此前所介绍的这些接口，还是后面所要介绍的接口，就目前而言，我们并不关心它的具体实现方法，我们关心的只是它的操作语义。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208125724.png" style="zoom:80%;"></p><p>接下来我们可以通过<code>disordered()</code>这个接口来检测向量的有序性，或者更准确地讲它的<strong>无序性</strong>。在此前介绍bubble sort算法的原理的时候，曾经指出包括向量在内的序列是否有序，当且仅当其中是否存在紧邻的逆序对。那么这里总共有6个元素，共定义了5组紧邻对，其中有3组，也就是4和3、7和4、和9和6是逆序的，<code>disordered</code>会<strong>返回逆序对的个数</strong>，即是<code>3</code>，只要这个数值不是0，就说明它尚未构成有序的序列。</p><p>对于这样的一个<strong>无序向量</strong>我们已经可以通过<code>find</code>接口，来查找其中特定的某个元素，比如说9。可以看到9号元素是位于rank为4的位置，因此find会返回<code>4</code>。同样地，也可以查找比如说5，我们发现5并不存在，这个时候我们统一地约定返回一个数值是<code>-1</code>，这个-1肯定不是一个合法的rank，表示查找失败。接着我们可以通过sort这个接口对整个向量排序，接下来再调用<code>disordered()</code>这个接口，它已经没有任何逆序的紧邻对了，所以返回<code>0</code>。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208130026.png" style="zoom:80%;"></p><p>对于<strong>有序向量</strong>，我们可以通过另一套接口，也就是<code>search</code>来进行查找。比如说可以首先通过<code>search</code>，然后引用9来查找数值为9的元素，这个元素的rank为5，因此返回的是<code>5</code>。那么如果查找8会怎么样呢？向量中并没有8，这里我们采用了另一种约定：如果<strong>没有找到</strong>这个元素，我们要找的是<strong>不超过这个元素的最大的那个元素的值</strong>。对这个例子而言不超过8的最大的元素实际上就是7，而7的秩是4，所以<code>search(8)</code>会返回<code>4</code>。同样 我们如果要去查找10的话会返回不超过10的最大的那个元素也就是9的秩5，因此<code>search(10)</code>会返回<code>5</code>。</p><p>另一种特殊情况：查找一个全局都没有而且小于全局的最小的那个元素的数比如说1，我们会假设在-1的rank这个位置上有一个假想的哨兵，它的数值是负无穷，所以<code>search(1)</code>返回的是<code>-1</code>。这样一套约定可以使得我们在语义上更加的明确，使得我们在后续的操作过程中可以便利地来搭建不同的算法。还有一点要注意的是：在有些时候，我们要查找的元素尽管有，但是它却有<strong>多次出现</strong>，比如说这个4 出现了两次，那这个时候会返回什么呢？同样跟这里的语义所定义吻合的是，我们要<strong>返回其中不超过4这个目标元素的最后边那个元素</strong>，所以如果有两个甚至多个4的话，我们会取其中rank最大的那个元素把它的rank返回，对这个例子而言也就是2号元素，因此<code>search(4)</code>会返回<code>2</code>。</p><p>最后，<code>uniquify()</code>对于一个有序的向量把所有的重复的元素，比如说4都剔出掉，只保留一个拷贝。</p><h2 id="vector模板类"><a href="#vector模板类" class="headerlink" title="vector模板类"></a>vector模板类</h2><p>有上述接口规范之后，我们就可以遵照这种规范来学习如任何具体地在C++语言平台上实现这样一种向量模板类<code>vector</code>结构。首先约定用int来定义这里所说的秩这种概念，接下来会首先采用一种基本的扩容方式，它的初始容量需要设定，这里不妨取它的DEFAULT_CAPACITY取作3，在实际应用中完全可以取更大的一个数。</p><p>下面通过<code>template</code>这种方式给一个模板参数T，它的意思可以认为是定义了一个<code>vector</code>这样的模板类。其中的元素类型是什么可以是将来指定的任何名字现在叫作T的类型。所以与其说它写的是一个类，不如说这个模板类给的是一系列的类，我们可以根据实际需要直接地生成相应的<code>vector</code>类。在模板类里面有一些私有的，也就是封装和隐藏起来的变量，比如说其内部会记忆它到底有多少个元素有一个<code>_size</code> ，以及它目前的容量<code>_capacity</code>，还有<br>包括真正存放元素的一个空间<code>_elem</code>。其它的内部函数以及公开的接口函数会在后边陆续学到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Rank; <span class="comment">//秩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_CAPACITY  3 <span class="comment">//默认的初始容量（实际应用中可设置为更大）</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span> <span class="comment">//向量模板类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Rank _size; <span class="keyword">int</span> _capacity;  T* _elem; <span class="comment">//规模、容量、数据区</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copyFrom</span> <span class="params">( T <span class="keyword">const</span>* A, Rank lo, Rank hi )</span></span>; <span class="comment">//复制数组区间A[lo, hi)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>; <span class="comment">//空间不足时扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>; <span class="comment">//装填因子过小时压缩</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">bubble</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//扫描交换</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//起泡排序算法</span></span><br><span class="line">  <span class="function">Rank <span class="title">max</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选取最大元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//选择排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">( Rank lo, Rank mi, Rank hi )</span></span>; <span class="comment">//归并算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//归并排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//堆排序（稍后结合完全堆讲解）</span></span><br><span class="line">  <span class="function">Rank <span class="title">partition</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//轴点构造算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//快速排序算法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//希尔排序算法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  Vector ( <span class="keyword">int</span> c = DEFAULT_CAPACITY, <span class="keyword">int</span> s = <span class="number">0</span>, T v = <span class="number">0</span> ) <span class="comment">//容量为c、规模为s、所有元素初始为v</span></span><br><span class="line">  &#123; _elem = <span class="keyword">new</span> T[_capacity = c]; <span class="keyword">for</span> ( _size = <span class="number">0</span>; _size &lt; s; _elem[_size++] = v ); &#125; <span class="comment">//s&lt;=c</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank n ) &#123; copyFrom ( A, <span class="number">0</span>, n ); &#125; <span class="comment">//数组整体复制</span></span><br><span class="line">  Vector ( T <span class="keyword">const</span>* A, Rank lo, Rank hi ) &#123; copyFrom ( A, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V ) &#123; copyFrom ( V._elem, <span class="number">0</span>, V._size ); &#125; <span class="comment">//向量整体复制</span></span><br><span class="line">  Vector ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; V, Rank lo, Rank hi ) &#123; copyFrom ( V._elem, lo, hi ); &#125; <span class="comment">//区间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">  ~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125; <span class="comment">//释放内部空间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只读访问接口</span></span><br><span class="line">  <span class="function">Rank <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125; <span class="comment">//规模</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !_size; &#125; <span class="comment">//判空</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span> ( e, <span class="number">0</span>, _size ); &#125; <span class="comment">//无序向量整体查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//无序向量区间查找</span></span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> <span class="comment">//有序向量整体查找</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &gt;= _size ) ? <span class="number">-1</span> : search ( e, <span class="number">0</span>, _size ); &#125;</span><br><span class="line">  <span class="function">Rank <span class="title">search</span> <span class="params">( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> <span class="keyword">const</span></span>; <span class="comment">//有序向量区间查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写访问接口</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>[] ( Rank r ); <span class="comment">//重载下标操作符，可以类似于数组形式引用各元素</span></span><br><span class="line">  <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] ( Rank r ) <span class="keyword">const</span>; <span class="comment">//仅限于做右值的重载版本</span></span><br><span class="line">  Vector&lt;T&gt; &amp; <span class="keyword">operator</span>= ( Vector&lt;T&gt; <span class="keyword">const</span>&amp; ); <span class="comment">//重载赋值操作符，以便直接克隆向量</span></span><br><span class="line">  <span class="function">T <span class="title">remove</span> <span class="params">( Rank r )</span></span>; <span class="comment">//删除秩为r的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">remove</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//删除秩在区间[lo, hi)之内的元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( Rank r, T <span class="keyword">const</span>&amp; e )</span></span>; <span class="comment">//插入元素</span></span><br><span class="line">  <span class="function">Rank <span class="title">insert</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> </span>&#123; <span class="keyword">return</span> insert ( _size, e ); &#125; <span class="comment">//默认作为末元素插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123; sort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体排序</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span> <span class="params">( Rank lo, Rank hi )</span></span>; <span class="comment">//对[lo, hi)置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsort</span><span class="params">()</span> </span>&#123; unsort ( <span class="number">0</span>, _size ); &#125; <span class="comment">//整体置乱</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">deduplicate</span><span class="params">()</span></span>; <span class="comment">//无序去重</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">uniquify</span><span class="params">()</span></span>; <span class="comment">//有序去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( <span class="keyword">void</span> (* ) ( T&amp; ) )</span></span>; <span class="comment">//遍历（使用函数指针，只读或局部性修改）</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="function"><span class="keyword">void</span> <span class="title">traverse</span> <span class="params">( VST&amp; )</span></span>; <span class="comment">//遍历（使用函数对象，可全局性修改）</span></span><br><span class="line">&#125;; <span class="comment">//Vector</span></span><br></pre></td></tr></table></figure><p>vector模板类的原理：整个vector结构是被封装起来，能供来自各种应用的用户使用的操作接口就是interface框中vector，~vector，insert，remove等等，它们就相当于vector结构的使用说明书，它告诉我们这里提供了哪些操作渠道、途径，通过这种接口规范直接使用。经过了这样地一个剥离之后，使得我们的应用和实现相互之间可以很好的分工，又同时很好的协作。<br>那么具体内部怎么实现的呢？可以看出其实是开辟了一个名字叫作<code>_elem</code>的数据区，它的容量至少要足以容纳所存放的有效数据，对外而言的每一个元素都通过某种形式转译为内部这段数据区中的，实际上是这个有效的数据区（<code>_size</code>）中的某一个元素，由此实现了对内部数据项的封装。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208143153.png" style="zoom: 50%;"></p><h3 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h3><p>作为一种数据结构与所有的类一样，<code>vector</code>也首先需要解决<strong>构造和析构</strong>的问题。向量的默认的构造实际上只需指始初始的容量就可以了，如果没有指定会按照默认的容量，指定一个数值。在内部的操作其实就是通过<code>new</code>申请一个长度为<code>c</code>，基本类型就是模板参数<code>T</code>的一段连续的数据空间。在创建了这样一个空间之后，我们把这个空间的首地址交给内部的<code>_elem</code>记下来。这个时候虽然它有一定的空间，但是其中有效的数据是没有的，所以这就是为什么<code>_size</code>初始化是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector(<span class="keyword">int</span> c = DEFAULT_CAPACITY)</span><br><span class="line">&#123;</span><br><span class="line">    _elem = <span class="keyword">new</span> T[_capacity = c]; </span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;  <span class="comment">//默认</span></span><br></pre></td></tr></table></figure><p>当然还有其它的一些构造的方法，比如如果已经有一组以数组的形式存放的数据，我们也可以将其中从<code>lo</code>到<code>hi</code>的这段区间中的元素取出来作为初始向量，可以看到它是通过调用一个叫作<code>copyFrom()</code>的内部接口实现的。同样地 它还<strong>重载</strong>了其它的一些形式，比如被复制的元素可能是来自于一个数组，而是来自于一个本身已经被封装了的向量，我们可以从这个向量的<code>_elem</code>区域中去读取出来，并且同样调用<code>copyFrom()</code>来做这件事。所以这里有区间的复制，也可以有对整个向量的一个克隆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector(T <span class="keyword">const</span> *A, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(A, lo, hi);&#125;           <span class="comment">//数组区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V, Rank lo, Rank hi)</span><br><span class="line">  &#123; copyForm(V._elem, lo, hi);&#125;     <span class="comment">//向量区间复制</span></span><br><span class="line">Vector(Vector&lt;T&gt; <span class="keyword">const</span> &amp;V)</span><br><span class="line">  &#123; copyForm(V._elem, <span class="number">0</span>, V._size);&#125; <span class="comment">//向量整体复制</span></span><br></pre></td></tr></table></figure><p>内部操作接口<code>copyForm( )</code>的工作原理以及过程可以通过下图示意，工作原理以及过程，可以通过这个图来示意。一般地我们需要从一个数组<code>A</code>中将介于<code>lo</code>到<code>hi</code>之间的元素整体复制到当前仍然为空的一个向量中，具体的操作大概分为两步，首先在向量内部开辟出足够的空间，接下来再将区间内的元素逐一地复制过来。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208145159.png" style="zoom:50%;"></p><p>这个过程可以描述并且实现为下面的C++代码：首先申请足够多的空间，这里需要再强调一下这个区间的宽度可以直接通过<code>lo</code>和<code>hi</code>之间的一个减法得到，这是因为当我们在描述一个区间的时候往往是用<strong>左闭右开</strong>的形式，所以换而言之这个<code>lo</code>是在这个区间中最靠左的那个元素，而hi是在右侧第一个不属于这个区间的那个元素，尽管<code>hi</code>这个元素有可能压根就不存在。但是我们不妨把它统一地理解成是一个哨兵，这样的话我们就可以通过，<code>hi</code>减<code>lo</code>直接得到区间的宽度。</p><p>这里给计算出的宽度再乘个2，也就是说我们实际开辟的空间是我们需要复制的空间的两倍，而不是恰好那么多。这样做的主要的目的在于预留了一些空间之后，就可以使得我们在接下来足够长的时间之内，不会因为有必要扩容而打断我们的计算过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//元素类型</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::copyFrom (T <span class="keyword">const</span>* A, Rank lo, Rank hi)<span class="comment">//以数组区间A[lo, hi)为蓝本复制向量</span></span><br><span class="line">&#123; </span><br><span class="line">  _elem = <span class="keyword">new</span> T[_capacity = <span class="number">2</span> * ( hi - lo ) ]; _size = <span class="number">0</span>; <span class="comment">//分配空间，规模清零</span></span><br><span class="line">  <span class="keyword">while</span> ( lo &lt; hi ) <span class="comment">//A[lo, hi)内的元素逐一</span></span><br><span class="line">  _elem[_size++] = A[lo++]; <span class="comment">//复制至_elem[0, hi - lo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还需要对这个向量的有效规模进行初始化 把它清为0。</p><p>再接下来 就是复制过程也就是说我们对于<code>lo</code>和<code>hi</code>中间的每一个<code>Rank</code>，都要从<code>A</code>这个数组中取出对应的元素，并将它们顺次的存入到<code>_elem</code>，对应的区间里面去。整体循环构成了这个操作的最重要的部分，所以我们也可以看出算法的复杂度主要是来自于这样一个循环。这样一个主体的复杂度是取决于被复制元素的个数，或者说这个复制区间的宽度，也可以认为是这个向量通过复制被创建之后的初始规模。</p><p><strong>析构函数</strong>只需要把这个曾经动态分配获得的数据区域释放掉，归还给操作系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Vector() &#123; <span class="keyword">delete</span> [] _elem; &#125;     <span class="comment">//释放内部空间</span></span><br></pre></td></tr></table></figure><p>这样的话我们就完成了向量这种最基本的结构作为一种模板类它的最基本的一些接口，接下来会学习功能更为复杂的其它的接口。</p><h1 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h1><p>与所有的数据结构一样，向量也可以认为是一组数据项的集合，换而言之，它首先必须能够自适应地在规模上适应其中所包含的元素个数的变化，这一节集中讨论它的可扩充性能。向量本身并不具有这种性能，我们需要采取一些策略。就目前的设计方案而言，我们的向量并不具备可扩充的性能，究其原因在于它采用的 实际上是所谓的静态空间管理的策略。</p><h2 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h2><p>具体来说，它实际上在内部只不过是设置了一个私有的数组，这个数组所占有的那段连续的地址空间会被用来存放若干个对外界而言可见的，或者是有效的元素。这些元素的总数，或者说它们所占用的逻辑空间的数，用<code>_size</code>来表示，而整个物理空间的大小是由<code>_capacity</code>来确定的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208163714.png" style="zoom: 80%;"></p><p>这里的问题是<code>_capacity</code>一旦确定,按照目前的方案它就将一成不变，而这样一种策略显然存在明显的不足。这种不足体现在两个方面：第一 是有可能会出现所谓的<strong>上溢overflow</strong>，也就是说随着有效元素（个数）的增加，总会出现这样的可能，使得整个<code>_elem</code>所占用的物理空间已经不足以存放需要存放的元素组。尽管这个时候在系统的其它的部分仍然有足够多的空间可以用于存放这些元素，但是限于<code>_capacity</code>是固定的，我们不能直接做到这一点。</p><p>另一种情况虽然不是很严重，但是也是会造成一定的空间的效率低下，我们称之为<strong>下溢underflow</strong>。具体来说就是有可能我们开辟了一个比较大的空间，但是在整个这个数据结构的生命期内真正存放于其中的数据却寥寥无几，从而使得<strong>装填因子</strong>指标会非常非常的小，这个装填因子其实就是有效元素个数，也就是<code>_size</code> ，去除以可用于存放元素的空间总数<code>_capacity</code>，也可以理解成是空间的利用率有可能不到一半，甚至远远地低于一半，那么在这种时候空间效率非常低下。</p><p>很遗憾如果我们坚持采用这样一种固定容量的策略，我们在实际的一般应用环境中，很难在事先就预测到我们需要用多少空间，也就是说这种空间不足以及空间浪费的情况，都有可能发生甚至经常发生。</p><p>那么如何使得向量可以自适应地根据实际需要来动态地调整自己的容量呢？而且这种调整的过程既能保证足够同时又不致使得因为开辟的空间过多而导致空间效率的低下。</p><h2 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h2><p>为了解决上述的问题，我们需要把刚才所采用的静态空间管理策略改变为所谓的<strong>动态空间管理策略</strong>，就是如果在某个时刻，某一个向量即将发生上溢，那么我们就适当地扩大内部数组的容量，使之足以容纳新的元素。按照这样一种策略向量的生命期可以大致由下面一组图来表示。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208164212.png" style="zoom:80%;"></p><p>最开始的时候向量所存放的有效元素还不是很多，还不致于出现上溢的情况，这时候可以从容应对。但是剩余的空间有可能会逐步地被占用，直到某一个关键时刻，内部数组有可能已经饱和，这时就存在一个风险也就是说再插入一个元素的话，就会导致上溢。为此我们可以动态的申请另一段存放空间，当然它的大小应该比原来的有所增长。接下来我们要把原先已经存放好的那些有效元素，逐一地按次序地复制过来，从而使得它们对外界而言依然保持原貌。新多出来的这些空间就足够用以存放新需要插入的元素，而原来所占用的空间将在此之后被释放并且归还给系统。上述这样一个完整的调整过程可以描述并且实现为下面的c++的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123;    <span class="comment">//向量空间不足时扩容</span></span><br><span class="line"><span class="keyword">if</span> (_size &lt; _capacity) <span class="keyword">return</span>;   <span class="comment">//尚未满员时，不必扩容</span></span><br><span class="line">_capacity = <span class="built_in">max</span>(_capacity, DEFAULT_CAPACITY);   <span class="comment">//不低于最小容量</span></span><br><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];  <span class="comment">//容量加倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)  <span class="comment">//复制原向量内容</span></span><br><span class="line">_elem[i] = oldElem[i];       <span class="comment">//T为基本类型，或已重载复制操作符'='</span></span><br><span class="line"><span class="keyword">delete</span>[] oldElem;   <span class="comment">//释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要判断现在是否处于即将发生上溢的临界状态，它的标志就是<code>_size</code>是否还继续严格地小于<code>_capacity</code>。如果是还不存在上溢的风险，可以直接返回，所以这里隐含着有一个else，即接下来<code>_size</code>虽然不一定大于<code>_capacity</code>，但是至少会出现等于<code>_capacity</code>的情况。</p><p>这时我们要做的是将原来的那个数据域做一个备份，接下来以原先的容量（注意这里是左移一位，相当于加倍）加倍的一个新的容量来申请一段动态空间，并且将这段空间交由原来的<code>_elem</code>来指示。接下来是复制，对从原先的那个数据域中逐一地取出各项，并且将其转移至新的这个数据域中对应的位置。在整体赋值完之后，原先的这个空间已经没有任何存在的意义了，所以通过<code>delete</code>操作将它释放。</p><p>其实对于尚未封装的数组同样可以采用上述的这样的一个策略，而对于向量而言，这里调整的优势体现在向量整体的封装性上。因为对于一般的数组，如果它经过了动态的重新分配地址，那么原先指向它内部的某些元素的一些指针就有可能会出现无效，即虽然它能指向一个地址但其中并没有存放所需要的数值。但是对于向量而言经过了这样的封装以后就安全了，因为无论是此前此后我们在访问某一个具体的元素的时候，在内部都是通过<code>_elem</code>这个统一的指示器来标识空间的起点。从这一点也可以看出进行封装以后的一个好处。</p><p>那么为什么要采用一个容量加倍的策略呢？采用其他策略，比如适当增加背部数组的容量，是否也可行呢？</p><h3 id="容量递增策略"><a href="#容量递增策略" class="headerlink" title="容量递增策略"></a>容量递增策略</h3><p>实际上情况并不那么简单，我们不妨以其中的一种典型的策略，即容量递增策略，来做一个对比。就是每当发现<br>当前的内部数组即将发生上溢我们并不是对它进行容量的加倍，而只是在原来的容量的基础上追加一个固定的数额，这样看起来并没有什么问题。在代码上只需将原来的<code>_capacity*2</code>变成<code>_capacity</code>追加一个固定的数额，记为<code>INCREMENT</code>，简记作$I$。下面来考虑这个策略的效率。</p><ul><li>在即将上溢之前，追加固定大小的容量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity += INCREMENT];</span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量0的空向量中，连续插入$n = m * I$个元素（远大于2）</li><li>于是，在第$1, I+1, 2I+1, 3I+1,……$次插入时都需要扩容</li><li>即便不计申请空间操作，各次过程中复制原向量的时间成本依次为：$0,I,2I,\dots,(m-1)I$（算术级数）</li><li>总体耗时 = $I\times(m-1)\times m/2=O(n^2)$，每次扩容的<strong>分摊成本为</strong>$O(n)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208172649.png" style="zoom: 50%;"></p><h3 id="容量加倍策略"><a href="#容量加倍策略" class="headerlink" title="容量加倍策略"></a>容量加倍策略</h3><ul><li>在即将上溢之前，使容量加倍</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;</span><br><span class="line">_elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>];   <span class="comment">//容量加倍</span></span><br></pre></td></tr></table></figure><ul><li>最坏情况：在初始容量1的的满向量中，连续插入$n=2^m$个元素</li><li>于是，在第$1，2,4,8,16,32，\dots$次插入时都需要扩容</li><li>各次扩容过程中复制原向量的时间成本依次为：$1,2,4,8,\dots,2^m$  （几何级数）</li><li>总耗时 = $O(n)$，每次扩容的分摊成本为$O(1)$。</li></ul><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208174131.png" style="zoom:50%;"></p><p>造成两种方法每次扩容分摊成本的时间复杂度出现很大差别的原因，可以用下图说明。实际上在向量规模不断递增<br>达到某一固定的数值之前，如果采用的是递增式的增容策略，那么所需增容的操作必然是按当时的规模呈算数级数的形式分布。反过来如果是以倍增式的策略来进行的扩容，那么只需要进行其中的少数几次扩容就够了，具体来说就是这些以紫色标明的，可以看到要远远小于原先的数目，而且随着数组规模的增加，这种差异会更加的明显。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208171602.png" style="zoom:80%;"></p><p>我们不妨将这两种策略所对应的性能列成如上面的一张表。在时间方面，在达到一个固定的规模n之前，累计所用的扩容时间：递增策略要多达$O(n^2)$，而倍增策略只需要$O(n)$，如果从分摊的意义上讲分摊到每一次扩容所需要的时间：前者是$O(n)$， 而后者是$O(1)$。可以看到就时间而言，容量加倍策略具有巨大的优势。而在空间方面，前一种策略似乎要非常好，因为它总是每次增加一个固定的数额，所以随着向量规模的增加，整个空间的利用率会越来越接近于百分之百。而加倍策略未必能做到百分之百，但是它至少有个底线，至少是50%，只有在它即将发生上溢，而因此刚刚通过加倍扩容的那个瞬间时才会是50%。所以相对而言，可以理解为倍增策略是通过在空间的效率上做了一个适当的牺牲，来换取在时间方面的巨大的收益，显然收益要远远大于损失。</p><h2 id="平均分析-vs-分摊分析"><a href="#平均分析-vs-分摊分析" class="headerlink" title="平均分析 vs. 分摊分析"></a>平均分析 vs. 分摊分析</h2><p><strong>平均复杂度或期望复杂度（average/expected complexity）</strong></p><p>根据数据结构各种操作出现概率的分布，将对应的成本加权平均。</p><ul><li>各种可能得操作，作为独立事件分别考查；</li><li>割裂了操作之间的相关性和连贯性；</li><li>往往不能准确地评判数据结构和算法的真实性能。</li></ul><p><strong>分摊复杂度（amortized complexity）</strong></p><p>对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作。</p><ul><li>从实际可行的角度，对一系列操作做整体的考量；</li><li>更加忠实地刻画了可能出现的操作序列；</li><li>可以更为精确地评判数据结构和算法的真实性能</li></ul><h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><p>回顾前两节，我们以向量为例给出了数据结构定义的一种通用方法，即模板，大致格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Vector &#123; ...... &#125;;</span><br></pre></td></tr></table></figure><p>这种方法实际上定义了 一系列的<code>Vector</code>，在使用的时候可以灵活指定它的类型。如果尖括号里是<code>int</code>的，那这个<code>Vector</code>实际上是a Vector of integers，即由一系列的整数组成的向量。更重要的是 在以后我们将利用这种方式来构造更为复杂的数据结构，比如可以把某些数据结构作为基本的组成元素来构成向量，举个例子在后面的学习中会定义二叉树Binary Tree这样一种数据结构，如果把<code>BinTree</code>作为基本的元素来构成<code>Vector</code>，那我们就可以构成一个由一系列的二叉树构成的一个线性序列，也就是A Vector of Binary Trees，取个形象的名字的名字可以叫它<code>forest</code> 森林。在后面介绍霍夫曼编码的时候也会用到这种技巧，通过采用统一的模板式的方法，可以使得数据结构的定义非常的规范，而且更重要的是它们可以互相的融合组合，便捷地搭建更为复杂的数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="keyword">int</span>&gt; myVector1;</span><br><span class="line">Vector&lt;<span class="keyword">float</span>&gt; myVector2;</span><br><span class="line">Vector&lt;<span class="keyword">char</span>&gt; myVector3;</span><br><span class="line"></span><br><span class="line">Vector&lt;BinTree&gt; forest;</span><br></pre></td></tr></table></figure><p>这一节我们将围绕向量的最基本的形式，即无序向量来展开。无序向量不一定是说其中的元素没有顺序，甚至有时候其中的元素是根本就不可能排成顺序。在这样的一个前提下我们将研究如何来定义并且实现相应的操作接口。</p><h2 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h2><p>通过<code>V.get(r)</code>和<code>V.put(r, e)</code>接口，固然可以读，写向量元素，但便捷性远不如数组元素的下标式访问方式A[r]。通过<strong>重载下标操作符</strong>“ [ ] “，便可沿用数组的下标方式访问向量元素。对于任何一个指定的Rank r，只需在内部数据区中取出对应的第r号元素，此后凡是需要引用向量中的某个特定的比如说Rank为r的这个元素，就可以直接以这样一种类似于数组下标的形式进行引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](Rank r) <span class="keyword">const</span>  <span class="comment">//0 &lt;= r &lt; _size</span></span><br><span class="line">   &#123; <span class="keyword">return</span> _elem[r]; &#125;</span><br></pre></td></tr></table></figure><p>此后，对外的V[r]即对应于与内部的V._elem[r]。这种引用可以作为右值，以这种类似数组形式进行运算并且将运算的结果，向左侧赋值给某一变量；而反过来计算的结果也可以赋值给向量中某一个元素，也就是作为左值，因为这个接口返回值是一个引用。</p><ul><li><p>右值：<code>T x = V[r] + U[s] * W[t]</code></p></li><li><p>左值：<code>V[r] = （T) (2*x + 3)</code></p></li></ul><p>需要注意的是这里我们对入口参数r并没有做过多的检查，而是简易地在入口处增设了一个断言，用以提醒使用者保证入口参数r能够在合理的范围之内，但在真正的实际应用中，要做更为严格的处理。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p> 向量的插入算法具体来说就是如何将某一个特定的元素插入到向量的特定位置，在原来向量中因为所有的元素都必须是紧邻排列的，所以为了能够插入新的元素我们需要做一个调整，也就是将对应这个位置之后的所有的那些元素，称作它的后继，整体的构成一个后缀，进行一个整体的右移操作。这个right shift操作效果就是所有的后缀元素都向右移动一个单元，从而空出一个单，此时才可以将指定的那个元素纳入其中，从而完成插入。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208211730.png" style="zoom: 50%;"></p><p>整个算法可以描述并且实现如下的C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//e作为秩为r的元素插入，0 &lt;= r &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert(Rank r, T <span class="keyword">const</span>&amp; e) &#123;</span><br><span class="line">expand();  <span class="comment">//若有必要，扩容</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; r; i--)  <span class="comment">//自后向前</span></span><br><span class="line">_elem[i] = _elem[i - <span class="number">1</span>];     <span class="comment">//后继元素顺次后移一个单元</span></span><br><span class="line">_elem[r] = e;  <span class="comment">//置入新元素</span></span><br><span class="line">_size++;       <span class="comment">//更新容量</span></span><br><span class="line"><span class="keyword">return</span> r;      <span class="comment">//返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移操作可以通过for循环完成，每个元素确实都是后移一位，当所有的后移完成之后，再将新的那个元素纳入到rank所指的位置上，当然同时还要更新整个向量的规模。</p><p>有两个需要注意的地方：第一，在for循环的方向是从最后一直向前不断地递减，也就是说整个的移动的方向虽然是向右，但是<strong>所有元素移动的先后次序却是后优先的</strong>，用图来表示也就是最后这个元素先移动，接下来是次后这个元素，再往前一直直到最前面的那个元素。这是必要的，如果把这个次序颠倒过来会有危险，会出现数据在无意中被覆盖的问题。</p><p>第二个主要注意的是<code>expand()</code>，即扩容操作，这是有必要的。因为确实在某些时候这个向量可能已经是满载的，所以为了插入新元素，在后移的过程中必然会出现上溢的情况，在这种时候就需要对向量进行扩容处理，比如上节的容量加倍策略，这样一件事情完全由<code>expand()</code>完成。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="区间删除"><a href="#区间删除" class="headerlink" title="区间删除"></a>区间删除</h3><p>我们先考虑一个通用的一个版本，即区间删除，具体来说就是在某个向量中，我们要将介于<code>lo</code>和<code>hi</code>之间的一系列的元素成批地从中剔除掉。因为向量要求所有的元素始终都是彼此紧邻排列的，所以不应该在删除之后留下这个缝隙，换而言之，我们需要将它后继的那些元素（如果有的话）统一地向前或者说向左移动来填补这段空白。其实可以反过来看到如果能够完成这样的一个左移的话，那么实际上也就相当于把这些元素给剔除或者叫覆盖掉了，所以关键的任务在于如何实现这个左移。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208212314.png" style="zoom:50%;"></p><p>这样的一个过程可以实现为下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除区间[lo, hi)，0&lt;=lo&lt;=hi&lt;=_size</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank lo, Rank hi) &#123;  <span class="comment">//O(n-hi)</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//处于效率考虑，单独处理退化情况</span></span><br><span class="line"><span class="keyword">while</span> (hi &lt; _size)</span><br><span class="line">_elem[lo++] = _elem[hi++];  <span class="comment">//[hi, _size)顺次前移hi-lo个单元</span></span><br><span class="line">_size = lo; shrink();   <span class="comment">//更新闺蜜，若有必要则缩容</span></span><br><span class="line"><span class="keyword">return</span> hi - lo;   <span class="comment">//返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中最关键的是<code>while</code>循环，它会遍历整个后缀，并且将其中的每一个元素逐一地取出，向前转移到合适的位置。比如第一个转移的是<code>hi</code>这个位置上的这个元素，它将被转移到<code>lo</code>这个位置，紧接着是<code>hi+1</code>转移到<code>lo+1</code>，<code>hi+2</code>转移到<code>lo+2</code>，直到最后。</p><p>同样有两个问题需要强调说明：第一个问题，在整个移动的过程中，所有这些元素参与移动的先后次序，同样也是很敏感的，或者说不能更改的，与插入算法完全颠倒，插入算法是自后向前，而区间删除算法是越往前的元素越优先参与移动，所以我们也可以认为它是一个<strong>自前向后的前移操作</strong>。如果把这个次序颠倒过来是有风险的，比如两者，即前缀的原来的那个位置和后来的那个位置中间有相互重叠的部分，如果优先移动后面的那个元素，那么就有可能会造成重叠区间的元素在无意中被覆盖掉。</p><p>第二点是<code>shrink()</code>这个历程的调用，它是某种意义上讲的缩容，这种操作在实际应用中并不是必须的，我们往往可以忽略它。</p><h3 id="单元素删除"><a href="#单元素删除" class="headerlink" title="单元素删除"></a>单元素删除</h3><p>上一小节中实现了区间的批量删除的接口，所以我们不妨把单元素的删除视作是整个区间操作的特例。具体来说<br>，就是要将任何一个由单个元素构成的区间视作是由 <code>r</code> 到 <code>r+1</code>所定义的左闭右开的那段区间。这样就可以很简明地调用用此前重载的那个<code>remove</code>接口，只不过这里的参数改变为 <code>r</code> 和 <code>r+1</code>，与我们刚才的那种转换相对应。同理算法所进行的操作就是所有的后缀向前移动一个单位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//删除向量中秩为r的元素，0 &lt;=r &lt; _size</span></span><br><span class="line">T Vector&lt;T&gt;::<span class="built_in">remove</span>(Rank r) &#123;  <span class="comment">//O(n - r)</span></span><br><span class="line">T e = _elem[r];     <span class="comment">//备份被删除的元素</span></span><br><span class="line"><span class="built_in">remove</span>(r, r + <span class="number">1</span>);   <span class="comment">//调用区间删除算法</span></span><br><span class="line"><span class="keyword">return</span> e;           <span class="comment">//返回被删除的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反过来，基于remove(r)接口，通过反复的调用，实现remove(lo, hi)是否可行呢。理论上是可行的，对于一个特定的一段从 lo 到 hi的区间，我们可以对其中的每一个元素分别去调用一次单元素删除接口，从而完成整体的删除操作。但是正如我们一直强调的，数据结构更多关注的是效率，而从效率上看这样做是非常差的。</p><p>首先考虑单元素删除本身的效率，最重要的实际上是这段区间也就是被删除元素的那些后继们，统一地要向前移动一次，这也是它的复杂度的来源。因此它的时间复杂度是取决于它的后继的个数，即为n-hi，最坏情况下是$O(n)$。如果按这种方式反复调用，有可能会导致$O(n^2)$的复杂度，在效率上是不能接受的。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208225132.png" style="zoom: 67%;"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找即是按照某种特定的条件，从向量中找出特定的元素。首先我们要明确两个概念：<strong>判等</strong>与<strong>比较</strong>，对于任何的两个元素，我们来判断它们是否是相等，或者是比较它们之间谁大谁小，这两个操作并不是所有的类型都天然支持的。所以这里我们做一个<strong>假设</strong>：向量中元素的类型是基本类型，或者向量元素这个类已经重载了对应的判等的操作符或者是比较的操作符。无序向量可以一般性地认为它只支持判等操作，而对于有序向量，要求要更高一点，它还需要支持其中的元素能够相互比较大小。</p><ul><li>无序向量：<code>T</code>为可判等的基本类型，或已重载操作符<code>=</code>或<code>!=</code></li><li>有序向量：<code>T</code>为可比较的基本类型，或已重载操作符<code>&lt;</code>或<code>&gt;</code></li></ul><p>无序向量的查找过程可以描述为下图，如果查找的区间范围是 <code>lo</code> 到 <code>hi</code> 的话，就<strong>从 <code>hi</code> 出发</strong>逆向地、逐一地取出<br>向量中的各个元素与目标元素进行比对，如果不相等就忽略它，进而考察它的前驱，所以整个的工作会亦步亦趋地逐个地遍历向量中的所有的元素。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208222707.png" style="zoom:50%;"></p><p>经过这样一个逆向地扫描的过程，我们很有可能在中间的某一步找到所需要的那个目标，即查找成功；如果一直持续到最后，在试图越过<code>lo</code>也就是合法的最左侧的边界的时候，就可以断定整个查找是失败的。这个算法可以通过下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">Rank Vector&lt;T&gt;::<span class="built_in">find</span>(T <span class="keyword">const</span> &amp;e, Rank lo, Rank hi) cosnt</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//O(hi - lo) = O(n)，在命中多个元素时可返回秩最大者</span></span><br><span class="line"><span class="keyword">while</span> ((lo &lt; hi--) &amp;&amp; (e != _elem[hi]));  <span class="comment">//逆向查找</span></span><br><span class="line"><span class="keyword">return</span> hi;   <span class="comment">// hi &lt; lo 意味着失败，否则hi即命中元素的秩</span></span><br><span class="line">&#125;   <span class="comment">// Excel::match(e, range, type)</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>find</code>函数<strong>返回的都是最终停止的那个位置</strong>，有可能是合法的一个位置。也可能是刚刚越过左边界的那个非法的位置。而具体判别是否成功可以交给上层的调用者，因为他通过这个秩是否是合法就可以判断查找是否成功，如果是成功的话这样一个秩将可以被高层的算法进一步地利用。</p><p>我们也可以看出这个算法的复杂度有很大的变化空间，在最好的情况下，可能在第一个元素位置上就顺利地命中<br>所以这时复杂度是常数$O(1)$；但是在最坏的情况下，比如一直持续到比较后才发现这个元素，甚至一直持续到最终也没有发现我们的目标元素，为此在这个过程中我们需要扫描的元素可能会与向量的规模相当，复杂度就会是$O(n)$。</p><p>这样一种在最好和最坏情况下相差极其悬殊的算法，叫作<strong>输入敏感</strong>算法（input-sensitive），即它的复杂度具体是多少与输入时候数据的配置紧密相关。</p><ul><li>输入敏感（input-sensitive）：最好$O(1)$，最差$O(n)$。（对本例而言）</li></ul><h2 id="唯一化问题"><a href="#唯一化问题" class="headerlink" title="唯一化问题"></a>唯一化问题</h2><p>无序向量的唯一化问题，即是<strong>把其中重复的元素都剔除掉</strong>，使得每一组重复的元素只保留一个拷贝。在很多实际的应用中都能够找到唯一化的影子，比如在网络搜索的环境中有很多个不同的结点所分工完成的局部的搜索结果，可能会含有大量的重复的元素，我们需要将其中重复的元素剔除掉，从而得到一份记忆完整同时又不冗余的搜索报告。这样一个算法大致可以通过这样的一个图示来表示它的原理：</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208232314.png" style="zoom:80%;"></p><p>对于一个向量，我们总是把它<strong>分为三个部分</strong>，以当前的这个元素为界，当前这个元素自己是一部分，它的前驱所构成的前缀是一部分，以及对称地，所有的后继是一部分。每一次我们遇到一个新的元素，都在它的前缀中去进行查找，这可以通过find操作来完成的，如果能够找到雷同的元素，比如在某个位置上出现了一个x，就可以把这个元素剔除掉。反之，经过查找以后，如果这个元素没有出现，那么我们就可以把它保留下来，同时再去考察它的下一个元素。这个算法可以由下面的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//删除重复元素，返回被删除元素数目</span></span><br><span class="line"><span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123;</span><br><span class="line"><span class="keyword">int</span> oldSize = _size;  <span class="comment">//记录原规模</span></span><br><span class="line">Rank i = <span class="number">1</span>;      <span class="comment">//从_elem[1]开始</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; _size)   <span class="comment">//自前向后逐一考查各元素_elem[i]</span></span><br><span class="line">(<span class="built_in">find</span>(_elem[i], <span class="number">0</span>, i) &lt; <span class="number">0</span>) ?   <span class="comment">//在前缀中寻找雷同者</span></span><br><span class="line">i++   <span class="comment">//若无雷同者则继续考查其后继</span></span><br><span class="line">: <span class="built_in">remove</span>(i);    <span class="comment">//否则删除雷同者（可以是多个）</span></span><br><span class="line"><span class="keyword">return</span> oldSize - _size;  <span class="comment">//返回向量规模变化量，即删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>那么我们如何给出这个算法正确性的严格证明呢？同样根据第一章学到的知识，我们通过挖掘算法所具有的<strong>不变性</strong>和<strong>单调性</strong>，来证明一个算法最终的正确性。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200208234943.png" style="zoom:50%;"></p><p>首先来证明不变性，我们发现在这个算法运行的任何一个时刻，如果当前所对应的是第<code>i</code>个元素<code>V[i]</code>的话，那么在它所对应的那个前缀中所有的元素必然是彼此互异，即不包含重复元素。当算法开始时<code>i=1</code>，它的前缀只有<code>V[0]</code>。</p><p>其余的一般情况下可以用数学归纳法来予以证明：假设当时的状态是第<code>i</code>个元素<code>e</code>，它的前缀是从<code>0</code>到<code>i</code>的区间。按照数学归纳法我们假设在此前不变性是成立的话，那么接下来，无非两种情况，即当前的这次对应的查找成功或者失败。</p><p>如果是失败，即在它的前缀中不含元素e，算法给出的处理方法是直接令<code>i++</code>，也就是我们已经指向了它的下一个元素，而将刚才那个元素<code>e</code>归入了新的这个前缀中。既然<code>e</code>和此前的那些前缀是互不重复的，所以将<code>e</code>归入这样的一个区间以后，这个区间必然是不含重复元素的。</p><p>反之如果如果查找成功，<code>e</code>出现在它的前缀中，按照算法流程会将它剔除掉，也就是通过删除操作使得后继的元素整体地向前移动，从而使得原先它的直接后继变为当前的这个元素，并且算法继续地运转下去。经过了这样一次迭代之后当前的这个元素虽然换了，但是它的前缀并没有换，这个前缀所具有的元素互异的性质也依然会保持下来。</p><p>算法运行到最终是覆盖整个向量，到那时我们所说的当前的元素其实就是最末尾的那个哨兵元素，而它的前缀其实就是整个向量，那么它的前缀中不包含重复的元素其实也就相当于整体的向量中不包含重复的元素，这正是我们这个算法的功能唯一化所要求的，所以在最终这个不变性必然会转化为我们所需要的正确性</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209000113.png" style="zoom:50%;"></p><p>接着我们证明单调性，这个算法的主体是由一个<code>while</code>循环构成的，随着反复的while迭代:</p><ul><li>当前元素前缀的长度单调非降，且迟早增至_size</li><li>当前元素后缀的长度严格单调下降，且迟早减至0</li></ul><p>所以算法待处理元素的个数会严格单调减少，算法必然终止，且至多迭代$O(n)$轮。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>这个算法的主体是while循环，而在while循环中真正能够造成有效复杂度的是<code>find</code>操作和<code>remove</code>操作，其中<code>find</code>操作是对于当前的元素的整个前缀而言的，而<code>remove</code>操作恰好对称是相对于当前这个元素的后继而言的。所以每一次<code>while</code>循环所需要的成本也就是<code>find</code>和<code>remove</code>两类操作的成本，累计起来也不会超过整个向量的长度，即$O(n)$线性步。而<code>while</code>循环最多会迭代$O(n)$轮，所以这个算法累计起来最多不超过$O(n^2)$的时间复杂度，这也是最坏情况。</p><p>这个算法也可以进一步的优化。</p><p><img src="/2020/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%90%91%E9%87%8F/QQ图片20200209001549.png" style="zoom:50%;"></p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历就是按照某种事先约定的操作（称之为<code>visit</code>），对向量中的每一个元素逐一地、统一地执行一次。所以这里涉及到两个问题：第一，如何来指定或者来描述这样一个visit操作；第二，如何将它传递到向量内部的每一个具体的元素。</p><p>通常有两种方法：第一种是使用函数指针，也就是说可以对于<code>vector</code>这样一个类定义一个<code>traverse</code>接口，作为它的参数<code>visit</code>本身就是一个函数的指针。所以为了兑现这样的一个遍历操作我们只需要逐一地取出向量中由这个<code>i</code>确定的每一个元素通过这个函数指针找到这个函数，并且对这个元素实施这个函数所指定的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(<span class="keyword">void</span>(*visit)(T&amp;))&#123;   <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是使用函数对象，也就是说我们指定的这个参数visit，本身就是一个对象，它的作用就是用来模拟一个操作一个函数的一个行为方式。所以同样地，我们也可以对这个向量中的每一个元素都逐一地取出，并且转交给这样一个函数对象，通过它来实施具体地、统一地操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::traverse(VST&amp; visit) &#123;       <span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">vist(_elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法其实是非常接近，但是也有一些重要的区别，相对而言，后一种方式的通用性更强。</p><p>下面通过一个实例来了解如何通过函数对象，实现刚才所说的具体地遍历。比如说，我们可以考虑将向量中的所有的元素统一地各自+1。为此我们只需要实现一个对应功能的函数对象，它本身也是以一个类的形式给出来的。这里为了简化起见使用了<code>struct</code>，而没有进行过多的封装。这个对象最重要的一个作用或者说唯一的作用就是重载了它的圆括号操作符<code>()</code>，从而使得它在行为上与一个函数非常的类似，而具体的功能就是把每一个参数<code>e</code>做一个+1操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//假设T可直接递增或已重载操作符“++”</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inciease</span> &#123;</span>       <span class="comment">//函数对象：通过重载操作符"()"实现</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp; e)</span> </span>&#123; e++; &#125;   <span class="comment">//加一</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实现了这样一个对应的类之后，就可以通过调用vector统一遍历接口traverse，将我们刚刚编写的这个函数对象以参数的形式传入就可以实现相应的功能，也就是把向量中的每一个元素统一地加一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(Vector&lt;T&gt; &amp; V)</span> </span>&#123;</span><br><span class="line">V.traverse(Increase&lt;T&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      向量属于最基本的数据结构，这一章围绕向量讨论两个方面的问题：如何根据统一的接口规范来定制并且实现一个数据结构，如何通过更加有效的算法使得我们对外的接口更加高效率地工作。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法（1）</title>
    <link href="http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-05T02:32:06.000Z</published>
    <updated>2020-02-06T16:31:08.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>对象：规律，技巧</p><p>目标：高效，低耗</p><p>Computer science should be called called computing science, for the same reason why surgery is not called knife science.</p><p>-E.Dijkstra</p><ul><li>计算 = 信息处理</li></ul><p>​       借助某种工具，遵照一定规则，以明确而机械的形式进行</p><ul><li>计算模型 = 计算机 = 信息处理工具</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>所谓算法，即特定计算模型下，旨在解决特定问题的指令序列</p><p>​        输入：待处理的信息（问题）</p><p>​        输出：待处理的信息（答案）</p><p>​    正确性：的确可以解决指定的问题</p><p>​    确定性：任一算法都可以描述为一个由基本操作组成的序列</p><p>​    可行性：每一基本操作都可以实现，且在常数时间内完成</p><p>​    有穷性：任一算法在执行有限次基本操作之后终止并给出输出</p><ul><li>列子：Hailstone序列</li></ul><script type="math/tex; mode=display">\begin{align*}& 序列Hailstone(n)=\begin{cases}\{1\}     &n\le1\\\{n\}\cup Hailstone(n/2) &n为偶数\\\{n\}\cup Hailstone(3n+1) &n为奇数\end{cases}\\\\&Hailstone(42)=\{ 42,21,64,32,\dots,1\}\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hailstone</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//计算序列Hailstone(n)的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>; <span class="comment">//从1开始递推</span></span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">1</span>) &#123; (n % <span class="number">2</span>) ? n = <span class="number">3</span> * n + <span class="number">1</span> : n / = <span class="number">2</span>; lenth++; &#125;</span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回hailstone(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：对于任意的n，总有|Hailstone(n)| &lt;  ∞ ？</p><p>目前还不能证明</p><ul><li>程序不一定是算法</li></ul><h2 id="好算法"><a href="#好算法" class="headerlink" title="好算法"></a>好算法</h2><p>正确：符合语法，能够编译，链接</p><p>​           能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入</p><p>健壮：能辨别不合法的输入并做适当处理，而不致非正常退出</p><p>可读性：结构化  + 准确命名 + 注释 + …</p><p><strong>效率</strong>：<strong>速度尽可能快 ；存储空间尽可能少</strong>   （最重要的）</p><p>​           Algorithms + Data Structures = Programs         -N. Wirth, 1976</p><p>​          (Algorithms + Data Structures) × Efficiency = Computation</p><h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>好的数据结构和算法才能有高效的计算，从而有好的应用。         </p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>两个主要方面：</p><p>​        正确性：算法功能与问题要求一致？</p><p>​                        数学证明？并不简单</p><p>​        <strong>成本</strong>：    <strong>运行时间</strong>+所需存储空间</p><p>​                        如何度量？如何比较？</p><p>考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。</p><p>​           意义不大，因为可能出现的问题实例太多。那么如何归纳概括？</p><p>观察：问题实例的<strong>规模</strong>，往往是决定计算成本的主要因素。</p><p><strong>特定算法 + 不同实例</strong></p><ul><li>令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。</li></ul><p>​         讨论特定算法A（及其对应的问题）时，简记作$T(n)$。</p><ul><li><p>然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。</p></li><li><p>稳妥起见，取$T(n) = max{ T(P)| |P| = n }$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。</p></li></ul><p><strong>特定问题 + 不同算法</strong></p><ul><li>同一问题通常有多种算法，如何评判其优劣？</li><li>实验统计是最直接的方法，但足以准确反映算法的真正效率？</li><li>但实验统计还是不足够的，还要考虑：<ul><li>不同的算法，可能更适应于不同规模的输入</li><li>不同的算法，可能更适应 与不同类型的输入</li><li>同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现</li><li>同一算法，可能实现并运行与不同的体系结构、操作系统</li></ul></li><li>为给出客观的评判，需要抽象出一个理想的平台或模型<ul><li>不再依赖于上述种种具体的因素</li><li>从而直接而准确地描述，测量并评价算法</li></ul></li></ul><h2 id="图灵机-Turing-Machine"><a href="#图灵机-Turing-Machine" class="headerlink" title="图灵机 Turing Machine"></a>图灵机 Turing Machine</h2><ul><li>Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’</li><li>Alphabet：字符的种类有限</li><li>Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格</li><li>State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态</li><li>Transition Function ：（q,  c;  d,  L/R,  P)</li></ul><p>​        若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；</p><p>​        转入p状态，一旦转入特定的状   态’h’，则停机。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205112701.png" alt="QQ图片20200205112701" style="zoom:67%;"></p><h2 id="RAM-Random-Access-Machine"><a href="#RAM-Random-Access-Machine" class="headerlink" title="RAM:  Random Access Machine"></a>RAM:  Random Access Machine</h2><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114006.png" alt="QQ图片20200205114006" style="zoom:67%;"></p><p>与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。</p><p>在这些模型中：</p><ul><li>算法的运行时间   转化为   算法需要执行的基本操作次数</li><li>$T(n)$  =  算法为求解规模为n的问题，所需执行的基本操作次数</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114827.png" style="zoom:67%;"></p><h1 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h1><h2 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h2><ul><li>回到原先的问题：随着问题规模的增长，计算成本如何增长？</li></ul><p>​        注意：这里更关心足够大的问题，注重考察成本的增长趋势</p><ul><li>渐进分析：在问题规模足够大后，计算成本如何增长？</li></ul><p>​       Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法</p><p>​               需执行的基本操作次数：T(n) = ?</p><p>​               需占用的存储单元数：S(n) = ?         //通常可不考虑</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205124613.png" style="zoom:50%;"></p><h2 id="大-O-记号（big-O-notation）"><a href="#大-O-记号（big-O-notation）" class="headerlink" title="大$O$记号（big-$O$ notation）"></a>大$O$记号（big-$O$ notation）</h2><script type="math/tex; mode=display">\begin{align*}&T(n)=O(\,f(n)\,)\quad if \quad \exists c>0, 当n>>2后，有T(n)<c\cdot f(n)\\\\&例如：\sqrt{5n\cdot[3n\cdot(n+2)+4]+6}<\sqrt{5n\cdot[6n^2+4]+6}<\sqrt{35n^3+6}<6\cdot n^{1.5}=O(n^{1.5})\end{align*}</script><p>与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势</p><ul><li>常系数可忽略：$O(\,f(n)\,)=O(c\times \,f(n)\,)$</li><li>低次数可忽略：$O(n^a+n^b)=O(n^2),\,a&gt;b&gt;0$</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205130742.png" alt="QQ图片20200205130742" style="zoom: 50%;"></p><p><strong>其它记号</strong>：</p><ul><li>$T(n)=\Omega(\,f(n)\,)$：</li></ul><p>​       $ \exists c&gt;0, 当n&gt;&gt;2后，有T(n)&lt;c\cdot f(n)$</p><ul><li>$T(n)=\Theta(\,f(n)\,)$：</li></ul><p>​       $ \exists c_1&gt;c_2&gt;0, 当n&gt;&gt;2后，有c_1\cdot f(n)&gt;T(n)&gt;c_2\cdot f(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205131613.png" style="zoom:50%;"></p><h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>下面讨论大$O$记号的几种”刻度“：</p><p><strong>$O(1)$</strong></p><ul><li><p>常数（constant function）</p><p>$2=2013=2013\times 2013=O(1)$，甚至$2013^2013=O(1)$</p></li><li><p>这类算法的效率最高</p></li><li><p>什么样的代码对应于常数执行时间？</p><p>一般地，不含循环；不含分支转向；不能有（递归）调用，应具体问题具体分析</p></li></ul><p><strong>$O(log^c n)$</strong></p><ul><li>对数$O(log^c n)$</li><li>常底数无所谓</li></ul><p>​       $\forall a,b&gt;0,\,log_an=log_ab\cdot log_bn=\Theta(logn)$</p><ul><li>常数次幂无所谓</li></ul><p>​       $\forall c&gt;0,\,logn^c=c\cdot logn=\Theta(logn)$</p><ul><li><p>对数多项式（ploy-log function）</p><p>$123\cdot log^{321}n+log^{105}(n^2-n+1)=\Theta(log^{321}n)$</p></li><li><p>这类算法非常有效，复杂度无限接近于常数</p><p>$\forall c&gt;0,\,logn=\Theta(n^c)$</p></li></ul><p><strong>$O(n^c)$</strong></p><ul><li><p>多项式（polynomial function）</p><p>$(100n-500)(20n^2-300n+2013)=O(n\times n^2)=O(n^3)$</p><p>一般地，$a<em>kh^k+a</em>{k-1}n^{k-1}+\dots+a_1n+a_0=O(n^k),\,a_k&gt;0$</p></li><li><p>线性（linear function）：所有$O(n)$函数</p></li><li><p>这门课主要覆盖的范围：从$O(n)$到$O(n^2)$</p></li><li><p>这类算法的效率通常认为已可令人满意</p></li></ul><p><strong>$O(2^n)$</strong></p><ul><li>指数（exponential function）：$T(n)=a^n$</li><li>$\forall c&gt;1,\,n^c=O(2^n);\,n^{1000}=O(1.00001^n)=O(2^n);\,1.00001^n=\Omega(n^{1000})$</li><li>这类算法的计算成本增长极快，通常被认为不可忍受</li><li>从$O(n^c)$到$O(2^n)$，是从有效算法到无效算法的分水岭</li><li>很多问题的$O(2^n)$算法往往显而易见，然而设计出$O(n^c)$算法却极为不易，甚至有时注定只能是徒劳无功。</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100203.png" style="zoom:50%;"></p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100207.png" style="zoom:50%;"></p><p><strong>例子</strong>：2-Subset</p><p>S包含n个正整数，$\sum S=2m$，S是否有子集T，满足$\sum T=m$？</p><ul><li>直觉算法：逐一枚举S的每一个子集，并统计其元素的总和</li><li>定理：$|2^s|=2^{|s|}=2^n$，亦即直觉算法需要迭代$2^n$轮，并（在最坏情况下）至少需要花费这么多时的间</li><li>但实际上上述的直觉算法已属最优解，就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法。</li><li>2-Subset is NP-complete</li></ul><h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>两个主要任务 = 正确性（不变形 × 单调性） + 复杂度</p><p>那么为了确定复杂度，真地需要将算法描述为RAM的基本指令，再统计累计的执行次数嘛？答案是不必的。</p><p>C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当：</p><ul><li>分支转向：goto   //算法的灵魂，出于结构化考虑，被隐藏了</li><li>迭代循环：for( )、while( )……  //本质上就是 if + goto</li><li>调用 + 递归（自我调用）  //本质上也是goto</li></ul><p>复杂度分析的主要方法：</p><ul><li>迭代：级数求和</li><li>递归：递归跟踪 + 递推方程</li><li>猜测 + 验证</li></ul><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><ul><li>算数级数：与末项平方同阶</li></ul><p>​       $T(n)=1+2+\dots +n=n(n+1)/2=O(n^2)$</p><ul><li>幂方级数：比幂次高出一阶</li></ul><p>​       $\sum_{k=0}^nk^d\approx \int_0^n x^{d+1}dx=\frac{1}{d+1}x^{d+1}\mid_0^n=\frac{1}{d+1}n^{d+1}=O(n^{d+1})$</p><p>​       $T_2(n)=1^2+2^2+3^2+\dots+n^2=n(n+1)(2n+1)/6=O(n^3)$</p><p>​       $T_3(n)=1^3+2^3+3^3+\dots+n^3=n^2(n+1)^2/4=O(n^4)$</p><ul><li>几何级数（a&gt;1）：与末项同阶</li></ul><p>​       $T_a(n)=a^0+a^1+\dots+a^n=(a^{n+1}-1)/(a-1)=O(a^n)$</p><p>​       $1+2+4+\dots+2^n=2^{n+1}-1=O(2^{n+1})=O(2^n)$</p><ul><li>收敛级数</li></ul><p>​       $1/2/2+1/2/3+1/3/4+\dots+1/(n-1)/n=1-1/n=O(1)$</p><p>​       $1+1/2^2+\dots+1/n^2&lt;1+1/2^2+\dots=\pi^2/6=O(1)$</p><p>​       $1/3+1/7+1/8+1/15+/24+1/26+1/31+1/35+\dots=1=O(1)$</p><p>​       实际上讨论这类分数级数是有必要的，因为在某种意义上，基本操作次数，存储单元数可以看作是分数，例如将某个循环条件执行的概率设为$\lambda$，则其数学期望为：</p><p>​        $(1-\lambda)\cdot[1+2\lambda+3\lambda^2+4\lambda^3+\dots]=1/(1-\lambda)=O(1)，0&lt;\lambda&lt;1$</p><ul><li>某些不收敛但长度有限的级数</li></ul><p>​       $h(n)=1+1/2+1/3+\dots+1/n=\Theta(logn)$                     调和级数</p><p>​       $log1+log2+log3+\dots+logn=log(n!)=\Theta(nlogn)$      对数级数</p><h2 id="循环与级数"><a href="#循环与级数" class="headerlink" title="循环与级数"></a>循环与级数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=n+n+\dots+n=n\cdot n=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131334.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=0+1+\dots+(n-1)=\frac{n(n-1)}{2}=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131338.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j+=<span class="number">2013</span>)</span><br></pre></td></tr></table></figure><p>算术级数：$O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131342.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i&lt;&lt;=<span class="number">1</span>)  <span class="comment">// i&lt;&lt;=1 左移一位，相当于乘2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>几何级数：$1+2+4+\dots+2^{[log<em>2(n-1)]}={\sum}</em>{k=0}^{[log_2(n-1)]}2^k=2^{[log_2(n-1)]}-1=n-1=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131345.png" style="zoom:67%;"></p><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>问题：给定整数子集S，|S| = n &gt;=3，找出元素$a\in S,a\ne max(S)，且 a\ne min(S)  $</p><p>算法：从S中任取三个元素{x, y, z}  //若S以数组形式给出，不妨取前三个；由于S是集合，这三个元素必互异</p><p>​            确定并排除其中的最小者，最大者  //不妨设 x = max{x, y, z},  y = min{x, y, z}</p><p>​            输出剩下的元素z</p><p>无论输入规模n多大，上述算法需要的执行时间不变</p><p>​            $T(n)=常数=O(1)=\Omega(1)=\Theta(1)$</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p><strong>问题</strong>：给定n个整数，将它们按非降序排列</p><p><strong>观察</strong>：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</p><p><strong>扫描交换</strong>：依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；否则，再做一趟交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           <span class="keyword">if</span>(A[i<span class="number">-1</span>] &gt; A[i])&#123;</span><br><span class="line">               swap(A[i<span class="number">-1</span>],A[i]);</span><br><span class="line">               sorted = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑算法的正确性</p><p>问题：该算法必然会结束？至多需迭代多少趟？</p><p><strong>不变性</strong>：经k轮扫描交换后，最大的k个元素必然就位</p><p><strong>单调性</strong>：经k轮扫描交换后，问题规模缩减至n-k</p><p><strong>正确性</strong>：经至多n趟扫描后，算法必然终止，且能给出正确答案</p><p><strong>通过挖掘并且综合算法的不变性和单调性，进而证明算法正确性</strong>的方法是算法分析中的一个基本且重要的方法。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206133211.png" style="zoom: 67%;"></p><h2 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h2><p>除了大$O$记号这种定性的方法，我们在很多时候也需要定量的估算，一种常用的方法是封底估算（Back-of-the-Envelope Calculation）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206134004.png" style="zoom:67%;"></p><h1 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h1><p>To iterate is human, to recurse, divine.</p><p><strong>例子</strong>：<strong>数组求和（迭代）</strong></p><p>问题：计算任意n个整数之和</p><p>实现：逐一取出每个元素，累加之</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumI</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论A[ ]内容如何，都有时间复杂度为：</p><p>​        $T(n)=1+n*1+1=n+2=O(n)=\Omega(n)+\Theta(n)$</p><p>如果把输入参数中的n看作是这个问题的规模，其中最重要的循环部分，每经过一次迭代，有一个数已经统计完毕，而相应的尚未参与统计的元素，即尚未解决的问题的规模就会递减一个元素，这种通过不断削减问题的有效规模的方法就是减而治之。</p><h2 id="减而治之（Decrease-and-conquer）"><a href="#减而治之（Decrease-and-conquer）" class="headerlink" title="减而治之（Decrease-and-conquer）"></a>减而治之（Decrease-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡易解，另一规模缩减；分别求解子问题；由子问题的解，得到原问题的解。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206174923.png" style="zoom:67%;"></p><h3 id="数组求和：线性递归"><a href="#数组求和：线性递归" class="headerlink" title="数组求和：线性递归"></a>数组求和：线性递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>) ? <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归跟踪</strong>（recursion trace）分析：</li></ul><p>​       检查每个递归实例；累计所需时间（调用语句本身，计入对应的子实例）；其总和即算法执行时间</p><ul><li>本例中，单个递归实例自身只需$O(1)$时间</li></ul><p>​        $T(n)=O(1)*(n+1)=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206181824.png" style="zoom:67%;"></p><ul><li>从<strong>递推</strong>的角度看，为求解<code>sum(A, n)</code>，需要</li></ul><p>​                递归求解规模为n-1的问题<code>sum(A,n-1)</code>           //T(n-1)</p><p>​                再累加上A[n-1]                                                   //$O(1)$</p><p>​                递归基：<code>sum(A, 0)</code>                                          //$O(1)$</p><ul><li>递推方程：$T(n)=T(n-1)+O(1)$                     //recurrence</li></ul><p>​                          $T(0)=O(1)$                                            //base</p><ul><li>求解：       $T(n)-n=T(n-1)-(n-1)=\dots=T(2)-2=T(1)-1=T(0)$</li></ul><p>​                          $T(n)=O(1)+n=O(n)$</p><h3 id="数组倒置"><a href="#数组倒置" class="headerlink" title="数组倒置"></a>数组倒置</h3><p>任给数组A[n]，将其前后颠倒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">&#123;</span><br><span class="line">swap(A[lo], A[hi]);</span><br><span class="line">reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由递推方程：$T(n)=T(n-2)+O(1)$可得其时间复杂度为：$O(n)$。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206184350.png" style="zoom:67%;"></p><h2 id="分而治之（Divide-and-conquer）"><a href="#分而治之（Divide-and-conquer）" class="headerlink" title="分而治之（Divide-and-conquer）"></a>分而治之（Divide-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为若干个（通常两个）子问题，规模大体相当；分别求解子问题；由子问题的解，得到原问题的解</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201250.png" style="zoom:67%;"></p><h3 id="数组求和：二分递归"><a href="#数组求和：二分递归" class="headerlink" title="数组求和：二分递归"></a>数组求和：二分递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(A,lo,mi) + sum(A,mi+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201640.png" style="zoom:67%;"></p><p>该算法的正确性毋庸置疑，接下来分析其时间复杂度：</p><ul><li>从<strong>递归跟踪</strong>的角度：</li></ul><p>​       $T(n)=各层递归实例所需时间之和=O(1)\times(2^0+2^1+2^2+\dots+2^{logn})=O(n)$</p><p>​     （几何级数的时间复杂度与末项同阶）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206202116.png" style="zoom: 67%;"></p><ul><li><p>从<strong>递推</strong>的角度：为求解<code>sum(A, lo, hi)</code>，需要</p><p>​        递归求解<code>sum(A, lo, mi)</code>和<code>sum(A, mi+1, hi)</code> ；进而将子问题的解累加</p></li></ul><p>​               递归基：<code>sum(A, lo, lo)</code></p><p>​        递推关系：$T(n)=2*T(n/2)+O(1)$</p><p>​                           $T(1)=O(1)$</p><p>​        求解：        $T(n)=O(n)$</p><h2 id="Max2"><a href="#Max2" class="headerlink" title="Max2"></a>Max2</h2><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]，元素比较的次数，要求尽可能地少.</p><h3 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206204203.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x1 = lo; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[i]) x1 = i;                  <span class="comment">//hi-lo-1 = n-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x2 = lo; i &lt; x1; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//x1-lo-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x1 + <span class="number">1</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//hi-x1-1次比较      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何，该算法的比较次数总是$\Theta(2n-3)$</p><h3 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206205752.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])  swap(x1, x2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = i])</span><br><span class="line">swap(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：$1+(n-2)\times1=n-1$</p><p>最坏情况：$1+(n-2)\times2=2n-3$；就最坏的情况而言，这种算法并没有改进</p><h3 id="递归-分治"><a href="#递归-分治" class="headerlink" title="递归+分治"></a>递归+分治</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206210400.png" style="zoom:67%;"></p><p>将数组二分为左侧和右侧两部分，分别找出最大值和次大值，再进行比较；每一侧又可以继续二分，实现递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">2</span> == hi)&#123;                          <span class="comment">//T(2) = 1</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">3</span> == hi)&#123;                          <span class="comment">//T(3) &lt;= 3</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[lo + <span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = lo + <span class="number">2</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;                                </span><br><span class="line"><span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;    <span class="comment">//divide</span></span><br><span class="line"><span class="keyword">int</span> x1L, x2L;  max2(A, lo, mi, x1L, x2L);</span><br><span class="line"><span class="keyword">int</span> x1R, x2R;  max2(A, mi, hi, x1R, x2R);</span><br><span class="line"><span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">x1 = x1L;</span><br><span class="line">x2 = (A[x2L] &gt; A[x1R]) ? x2L : x1R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = x1R;</span><br><span class="line">x2 = (A[x1L] &gt; A[x2R]) ? x1L : x2R;</span><br><span class="line">&#125;     <span class="comment">//1 + 1 = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度：$T(n)=2*T(n/2)+2\le5n/3-2$</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work, make it right, make it fast.</p><p>前两步work和right可以通过递归解决，而最后一步fast可以通过迭代解决。</p><h2 id="斐波那契数列fib"><a href="#斐波那契数列fib" class="headerlink" title="斐波那契数列fib( )"></a>斐波那契数列fib( )</h2><p>$fib(n)  = fib(n-1) + fib(n-2) : {0, 1, 1, 2, 3, 5, 8, ……}$</p><h3 id="fib-：递归"><a href="#fib-：递归" class="headerlink" title="fib( )：递归"></a>fib( )：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>&gt;n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当n较大时，这个递归算法的计算是很慢的，其<strong>时间复杂度</strong>为：</p><p>$T(0)=T(1)=1;\,T(n)=T(n-1)+T(n-2)+1,\,n&gt;1$</p><p>令：$S(n)=[T(n)+1]/2$</p><p>则：$S(0)=1=fib(1),\,S(1)=1=fib(2)$</p><p>故：$S(n)=S(n-1)+S(n-2)=fib(n+1)$</p><p>​        $T(n)=2*S(n)-1=2\times fib(n+1)-1=O(fib(n+1))=O(\Phi^n)=O(2^n)$  ，</p><p>其中：$\Phi=\frac{1+\sqrt{5}}{2}=1.61803…$，即黄金分割数</p><p>可见该算法的时间复杂度和fib数列的n+1项的值是一个量级的。</p><p>接着对这个$O(\Phi^n)$进行较准确的估算，用<strong>封底估算</strong>的方法有：</p><p>$\Phi^{36}=2^{25},\,\Phi^{43}=2^{30}=10^9flo=1sec$</p><p>$\Phi^{5}=10,\,\Phi^{67}=10^14flo=10^5sec$</p><p>$\Phi^{92}=10^{19}flo=10^{10}sec=10^5day=3century$</p><p>可见这并不是一个好方法。</p><p>从<strong>递归跟踪</strong>的角度来分析：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206221339.png" style="zoom:67%;"></p><p>递归版<code>fib( )</code>低效的根源在于，各地鬼实例均被大量重复地调用</p><p>那么可以使每个实例只能调用一次嘛？答案是可以的。先后出现的递归实例，供给$O(\Phi^n)$个，而去除重复之后，总共不过$O(n)$种。</p><h3 id="fib-：迭代"><a href="#fib-：迭代" class="headerlink" title="fib( )：迭代"></a>fib( )：迭代</h3><p>解决方法A（<strong>记忆</strong>：memoization）：</p><p>​        将已计算过实例的结果指标备查。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206222400.png" style="zoom: 50%;"></p><p>解决方法B（动态规划：dynamic programming）：</p><p>​        颠倒计算方向，由自顶而下递归，改为自底而上迭代。不妨用两个变量f和g，分别来记忆当前我所处的相邻的两个数。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206223053.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;   <span class="comment">//fib(0), fib(1)</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了一个循环，没有其他增加时间复杂度的操作，而且只需要f和g两个存储单元。</p><p>$T(n)=O(n)$，而且仅需要$O(1)$空间！</p><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p><strong>子序列（Subsequence）</strong>：由序列中若干字符，按原相对次序构成（线不能有交叉）。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224303.png" style="zoom:67%;"></p><p><strong>最长公共子序列（Longest Common Subsequence）</strong>：两个序列公共子序列中的最长者。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224308.png" style="zoom:67%;"></p><p>现在考虑一个较简单的问题：如何计算出任意给出的两个序列的最长公共子序列的长度？</p><h3 id="LCS：递归"><a href="#LCS：递归" class="headerlink" title="LCS：递归"></a>LCS：递归</h3><p>对于序列A[0, n]和B[0, m]，LCS(A, B)无非三种情况</p><p>0）若n = -1 或 m = -1，则取空序列（“ ”）                                      //递归基</p><p>1）若A[n] = ‘X’ = B[m]，则取作LCS( A[0, n),  B[0, m) ) + ‘X’          // 减而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230441.png" style="zoom: 67%;"></p><p>2）若A[n] $\ne$ B[m]，则分别计算LCS( A[0, n],  B[0, m) )，与LCS( A[0, n),  B[0, m] )，取更长者。 //分而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230523.png" style="zoom:67%;"></p><p>我们把上述算法中生成的所有递归实例绘制成一个表，每一个横纵坐标所确定的3×3的小方格所组成的一个大方格分别对应于一个子任务或者说是递归实例，可以看到如果是减而治之的情况，对应大方格中的一条对角线；如果是分而治之的情况，则会考虑左侧和上方的子问题，然后取更长者，保留其对应的一条边。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206231904.png" style="zoom:67%;"></p><p>这样的形式可以帮助我们理解整个计算的过程，在这样一张表中我们最终求解的问题必然是右下角的方格对应的子问题，它分别会递归地引发一些更小的子问题，最终收缩到平凡的长度为0的子问题；我们也可以认为，每一个LCS问题的解都是从左上角(0,0)的单元开始一直沿着可行的深色的线通往右下角单元的路径，每一条路径就对应着一个解，这样就能很好地理解多解的情况。</p><p>接下来分析该算法的正确性和时间复杂度：</p><ul><li><p><strong>单调性</strong>：无论如何，每经过一次比对，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位。</p></li><li><p><strong>最好情况</strong>（不出现情况2））下，只需$O(n+m)$时间（线性规模）</p></li><li>但问题在于，在情况2）下原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能<strong>雷同</strong>，与<code>fib( )</code>的递归出现的问题类似，这种重复度往往是超出我们直观想象的。</li></ul><p>​       我们将上面的图表进行局部放大：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206233230.png" style="zoom:67%;"></p><p>为了进行更好的估算，我们不妨从更宏观的角度来重新审视上面的表格，不妨把其中所有的递归实例分别按坐标的形式表示为(n, m)，那么为了计算出最终的递归实例即(n, m)对应的解，我们需要唤醒某一个特定的递归实例(a. b)多少次呢？</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206234248.png" style="zoom:67%;"></p><p>根据图表中路线行进的方向，在最坏的情况下所唤醒的次数应该等于介于这两点之间的通路的条数，每一条通路对应于(a, b)被唤醒一次，即为两点之间所有合法的通路的总长n+m-a-b中挑选出n-a条水平路径的方案数，或挑选出m-b条垂直路径的方案数。</p><p>那么在最坏情况下，LCS( A[0, a],  B[0, b] )出现的次数为：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m-a-b\\n-a\end{pmatrix}=\begin{pmatrix}n+m-a-b\\m-b\end{pmatrix}</script><p>特别地，LCS( A[0],  B[0] )出现的次数多达：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m\\n\end{pmatrix}=\begin{pmatrix}n+m\\m\end{pmatrix}</script><p>当$n=m$时，该算法的时间复杂度为：$O(2^n)$。</p><h3 id="LCS：迭代"><a href="#LCS：迭代" class="headerlink" title="LCS：迭代"></a>LCS：迭代</h3><ul><li><p>与<code>fib( )</code>类似，这里也有大量重复的递归实例（子问题），（最坏情况下）先后共计出现$O(2^n)$个</p></li><li><p>各子问题，分别对应于A和B的某个前缀组合，因此总共不过$O(n*m)$种</p></li><li><p>采用动态规划的策略，只需$O(n*m)$时间即可计算出所有子问题</p></li><li><p>为此，我们只需将所有子问题列成一张表，颠倒计算方向，<strong>从LCS( A[0],  B[0] )出发</strong>，依次计算出所有项。</p><p>填表的规则是：首先初始化，行列都设为0，若遇到减而治之，即字母相同，则对应位置元素为其左上对角线元素+1；若遇到分而治之，即字母不相同，则对应位置元素取其上方和左侧元素中的最大值。</p></li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206235750.png" style="zoom:67%;"></p><p>这样对于每一个子问题，只会出现一次，因此算法的时间复杂度为$O(n*m)$。</p>]]></content>
    
    <summary type="html">
    
      开个新坑
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（7）类和对象</title>
    <link href="http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-04T08:09:38.000Z</published>
    <updated>2020-02-07T14:18:28.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计的基本特点"><a href="#面向对象程序设计的基本特点" class="headerlink" title="面向对象程序设计的基本特点"></a>面向对象程序设计的基本特点</h1><p><strong>抽象</strong>：对同一类对象的共同属性和行为进行概括，形成类。</p><ul><li>首先注意问题的本质及描述，其次是实现过程或细节。</li><li>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</li><li>代码抽象：描述某类对象的共有的行为特征或具有的功能。</li><li>抽象的实现：类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装</strong>：将抽象出的数据，代码封装在一起，形成类。</p><ul><li>目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</li><li>实现封装：类声明中的{ }</li></ul><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174646.png" alt="QQ图片20200204174646" style="zoom: 50%;"></p><p><strong>继承</strong>：在已有类的基础上，进行扩展形成新的类。</p><p><strong>多态</strong>：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。</p><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。</p><p>设计类就是设计类型，需要<strong>关注哪些问题</strong>：</p><ul><li>此类型的“合法值”是什么？</li><li>此类型应该有什么样的函数和操作符？</li><li>新类型的对象该如何被创建和销毁？</li><li>如何进行对象的初始化和赋值？</li><li>对象作为函数的参数如何以值传递？</li><li>谁将使用此类型的对象成员？</li></ul><h3 id="类定义的语法形式"><a href="#类定义的语法形式" class="headerlink" title="类定义的语法形式"></a>类定义的语法形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">           公有成员（外部接口）</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">           私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">           保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour = <span class="number">0</span>, minute = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p><strong>公有类型成员</strong>：在关键字<code>public</code>后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</p><p><strong>私有类型成员</strong>：在关键字<code>private</code>后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字<code>private</code>可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p><p><strong>保护类型成员</strong>：与private类似，其差别表现在继承与派生时对派生类的影响不同。</p><p>类中成员之间直接使用成员名互相访问。</p><p>从类外访问成员使用“ <code>对象名.成员</code>”，来访问公有成员。</p><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类中声明函数原型：</p><ul><li>可以直接在类中给出函数体，形成内联成员函数；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以在类外给出函数体实现，并在函数名前用类名加以限定；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::getArea() &#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line"><span class="keyword">int</span> Rectangle::getPerimeter() &#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br></pre></td></tr></table></figure><ul><li>允许声明重载函数和带默认参数值的函数。</li></ul><p><strong>例子</strong>：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setM</span><span class="params">(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y)</span> </span>&#123; x = _x; y = _y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> _r)</span> </span>&#123; r = _r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * r * r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> *r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Circle myCircle;</span><br><span class="line">myCircle.setM(<span class="number">1.7</span>, <span class="number">3.2</span>);</span><br><span class="line">myCircle.setR(<span class="number">4.2</span>);</span><br><span class="line"><span class="keyword">double</span> myArea = myCircle.getArea();</span><br><span class="line"><span class="keyword">double</span> myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">myCircle.setR(<span class="number">8.4</span>);</span><br><span class="line">myArea = myCircle.getArea();</span><br><span class="line">myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174231.png" alt="QQ图片20200204174231" style="zoom:80%;"></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>当我们定义对象时，如何对对象进行初始化？在定义基本类型的变量时，是可以直接给定初始值的，但是在定义对象时却不是这么简单，因为一个类是我们自己定义的，对类的对象按照什么规则进行初始化，编译器是不会自动知道的，必须由程序员写程序来规定。为此C++中提供了一种特殊的机制：<strong>构造函数</strong>，在构造函数中我们可以描述如何对类的对象进行初始化。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="构造函数的作用"><a href="#构造函数的作用" class="headerlink" title="构造函数的作用"></a>构造函数的作用</h3><ul><li>在对象被创建时使用特点的值构造对象，将对象初始化为一个特定的初始状态</li></ul><p>例如：希望在构造一个Clock类对象时，将初始时间设为0:0:0，就可以通过构造函数来设置</p><h3 id="构造函数的形式"><a href="#构造函数的形式" class="headerlink" title="构造函数的形式"></a>构造函数的形式</h3><ul><li>函数名与类名相同；</li><li>不能定义返回值类型，也不能在函数体有return语句；</li><li>可以有形式参数，也可以没有形式参数；</li><li>可以是内联函数；</li><li>可以是重载；</li><li>可以带默认参数值。</li></ul><h3 id="构造函数的调用时机"><a href="#构造函数的调用时机" class="headerlink" title="构造函数的调用时机"></a>构造函数的调用时机</h3><ul><li>在对象创建时被自动调用，但如果没有定义构造函数就进行初始化，那么编译器就会报错。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Clockk <span class="title">myClock</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>调用时可以不需要实参的构造函数：</p><ul><li>参数表为空的构造函数</li><li>全部参数都有默认值的构造函数</li></ul><p>下面两个都是默认构造函数，如在类中同时出现，将产生编译错误，不是合法的函数重载形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock();</span><br><span class="line">Clock(<span class="keyword">int</span> newH=<span class="number">0</span>, <span class="keyword">int</span> newM=<span class="number">0</span>, <span class="keyword">int</span> newS=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="隐含生成的构造函数"><a href="#隐含生成的构造函数" class="headerlink" title="隐含生成的构造函数"></a>隐含生成的构造函数</h3><p>如果在程序中未定义构造函数，编译器将在需要时自动生成一个<strong>默认的构造函数</strong>：</p><ul><li>参数列表为空，不为数据成员设置初始值；</li><li>如果类内定义了成员的初始值，则使用内类定义的初始值；</li><li>如果没有定义类内的初始值，则以默认方式初始化；</li><li>基本类型的数据默认初始化的值是不确定的。</li></ul><p>如果定义的类的成员不是基本类型的成员，而是其他类的对象，这个就是类组合的情况，其默认的初始化方式由它所属的类决定。</p><h4 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h4><p>如果程序中已定义构造函数，默认情况下编译器就不会再隐含生成默认构造函数。如果此时依然希望编译器隐含生成的默认构造函数，可以使用<code>=default</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Clock() = <span class="keyword">default</span>;</span><br><span class="line">       Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;</span><br><span class="line"></span><br><span class="line">&#125;   <span class="comment">//初始化列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">c.showTime();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS);   <span class="comment">//构造函数</span></span><br><span class="line">    Clock();  <span class="comment">//默认构造函数，如果类要重复使用，一般要提供一个默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;  <span class="comment">//调用有参数的构造函数</span></span><br><span class="line">    Clock c2;          <span class="comment">//调用无参数的默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>当我们在一个类中重载多个构造函数的时候，往往发现这些构造函数它们只是形参表不同，初始化列表不同，而其他都是一样的，初始化算法都是相同的，函数体都是相同的。那么在这种情况下，如果我们写多个函数体来重载，往往就显得重复了，为了避免这种重复，C++11新标准提供了一种新的机制：<strong>委托构造函数</strong>，也就是让一个构造函数可以去委托另一个构造函数去帮它完成初始化功能。</p><p>回顾<code>Clock</code>类的两个构造函数，第一个构造函数是有三个参数的，第二个构造函数是默认构造函数，没有参数。实际上，这两个构造函数进行初始化的方式是完全一样的，只不过第一个构造函数是用参数表里的参数进行初始化，第二个构造函数用默认状态全部用0进行初始化。那么我们其实没有必要写两个类似的重复的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125; </span><br><span class="line">Clock::Clock():hour(<span class="number">0</span>),mintue(<span class="number">0</span>),second(<span class="number">0</span>)&#123;&#125;  <span class="comment">//默认构造函数</span></span><br></pre></td></tr></table></figure><p>委托构造函数使用类的其他构造函数执行初始化过程，我们用委托构造函数的方法重写上面的代码，这里第二个构造函数调用了另外一个有参数的构造函数，将默认的三个初始化参数传给有参数表的Clock构造函数，这样就不用把同样的初始化方法再写一遍了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock::Clock(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM, <span class="keyword">int</span> newS) :hour(newH), minute(newM), second(newS) &#123;&#125;</span><br><span class="line">Clock::Clock():Clock(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>用委托构造函数不仅可以减少重复的工作，其最大的好处是可以<strong>保持代码实现的一致性</strong>，如果想要修改构造函数的初始化算法时，就只需在一处修改，其他的委托这个构造函数来进行初始化的构造函数的算法也就同步修改了。</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>当我们在定义一个基本类型的变量时，经常会用一个已经存在的已经有值的变量去初始化这个变量；我们在定义对象时可会有这样的需求，即用一个存在的对象去初始化一个新的对象，这时要如何实现这种初始化呢？C++中提供了一种特殊的构造函数，叫<strong>复制构造函数</strong>。</p><p>在复制构造函数中我们可以规定如何用一个已经存在的对象去初始化一个新对象，可以用这个已经存在的对象的引用作为构造函数的参数。如果在定义类的时候没有定义复制构造函数，编译器也生成一个默认的复制构造函数，它会实现类的两个对象的数据成员之间一一对应复制，这些功能在很多时候已经能满足需求，那么我们就不需要再写复制构造函数了。</p><h3 id="复制构造函数定义"><a href="#复制构造函数定义" class="headerlink" title="复制构造函数定义"></a>复制构造函数定义</h3><ul><li>复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。</li></ul><p>由于复制构造函数的目的不会是将原有的那个形参对象给修改了，所以最好是在形参引用前加上<code>const</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       类名(形参)； <span class="comment">//构造函数</span></span><br><span class="line">       类名(<span class="keyword">const</span> 类名 &amp;对象名);   <span class="comment">//复制构造函数</span></span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类(<span class="keyword">const</span> 类名 &amp;对象名)      <span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><h3 id="复制构造函数的调用"><a href="#复制构造函数的调用" class="headerlink" title="复制构造函数的调用"></a>复制构造函数的调用</h3><p>除了在定义新对象时，用已有的对象作为参数去初始化它这种情况以外，共有三种情况是典型的要调用复制构造函数的情况：</p><ul><li>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</li><li>如果<strong>函数的**</strong>形参是类的对象**，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</li><li>如果<strong>函数的返回值是类的对象</strong>，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。这种情况也可以通过移动构造避免不必要的复制。</li></ul><h3 id="隐含的复制构造函数"><a href="#隐含的复制构造函数" class="headerlink" title="隐含的复制构造函数"></a>隐含的复制构造函数</h3><ul><li>如果程序员没有为类拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数；</li><li>这个构造函数的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。</li></ul><p>如果类的成员中有指针的时候，很多情况下，默认的复制构造函数其浅层的复制功能就不够用了，这是我们就需定义深层的复制构造。</p><h3 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h3><p>如果我们不希望对象被复制构造，那么可以采用下面的方法:</p><ul><li>C++98做法：将复制构造函数声明为<code>private</code>，并且不提供函数的实现。</li><li>C++11做法：用<code>=delete</code>指示编译器不生成默认复制构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx=<span class="number">0</span>, <span class="keyword">int</span> yy=<span class="number">0</span>) &#123;x=xx; y=yy&#125;  <span class="comment">//构造函数，内联</span></span><br><span class="line">       Point(<span class="keyword">const</span> Point &amp;p) = <span class="keyword">delete</span>;         <span class="comment">//指示编译器不生成默认复制构造函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>当一个对象在存续期间会占用系统资源，当这个对象的生存期结束时，需要进行善后工作将其删除清理掉，C++中提供了这样一种机制：析构函数。当对象被构造时，构造函数会自动调用；当对象要消亡时，其析构函数也会自动调用。</p><ul><li>完成对象被删除前的一些清理工作；</li><li>在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间；</li><li>如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空；</li><li>析构函数的原型：<code>~类名( );</code></li><li>析构函数没有参数，没有返回类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)   <span class="comment">//构造函数</span></span><br><span class="line">       ~Point();               <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br><span class="line">Point::Point(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy)</span><br><span class="line">&#123;</span><br><span class="line">    x=xx; y=yy;</span><br><span class="line">&#125;</span><br><span class="line">Point::~Point()&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      设计程序的过程，就是设计类的过程
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（6）结构体与链表</title>
    <link href="http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-02T09:03:07.000Z</published>
    <updated>2020-02-03T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种特殊形态的类，与类的唯一区别是：类的缺省访问权限是<code>private</code>，结构体的缺省访问权限是<code>public</code>。</p><p>那么什么时候用结构体而不用类：定义主要用来保存数据，没没有什么操作的类型。人们习惯将结构体的数据成员设为公有，这时使用结构体更方便。</p><p>结构体相当于构造了一个新的数据类型，用一组变量描述同一个“事物”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;    <span class="comment">//注意大括号后的" ; "</span></span><br></pre></td></tr></table></figure><p>定义结构体变量的方式：</p><ol><li>直接用已声明的结构体类型定义变量名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student student1, student2;</span><br></pre></td></tr></table></figure><ol><li>在声明类型的同时定义变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;student1,student2;</span><br></pre></td></tr></table></figure><p>结构体数据类型的特性与普通数据类型的特性是一致的，可以赋值，做函数参数，有指向结构体的指针，结构体数组等等。</p><h2 id="定义结构体类型的变量"><a href="#定义结构体类型的变量" class="headerlink" title="定义结构体类型的变量"></a><strong>定义结构体类型的变量</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">mike.id_num = <span class="number">2123000</span> + mike.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202181848.png" alt="QQ图片20200202181848" style="zoom:80%;"></p><h2 id="结构体变量赋值"><a href="#结构体变量赋值" class="headerlink" title="结构体变量赋值"></a><strong>结构体变量赋值</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike1 = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student mike2;</span><br><span class="line">mike2 = mike1;</span><br><span class="line">mike2.id_num = <span class="number">2123000</span> + mike2.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike1.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike1.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike2.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike2.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182213.png" alt="QQ图片20200202182213" style="zoom:80%;"></p><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a><strong>结构体做函数参数</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(student one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">one.id_num = <span class="number">2123000</span> + one.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; one.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">one.name[i] = <span class="built_in">toupper</span>(one.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">renew(mike);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182733.png" alt="QQ图片20200202182733" style="zoom:80%;"></p><h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student *one = &amp;mike;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202183112.png" alt="QQ图片20200202183112" style="zoom:80%;"></p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student myclass[<span class="number">3</span>] = &#123; <span class="number">123</span>,<span class="string">"mike"</span>,<span class="number">133</span>,<span class="string">"tom"</span>, <span class="number">143</span>,<span class="string">"jack"</span>&#125;;</span><br><span class="line">student *one = myclass;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202190921.png" alt="QQ图片20200202190921" style="zoom:80%;"></p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举：如果一个变量只有几种可能的取值，则可以将该变量定义为<strong>枚举类型</strong>。</p><p>枚举类型的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个枚举数据类型weekday</span></span><br><span class="line"><span class="keyword">enum</span> weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; <span class="comment">//花括号内sun,mon,...,sat等称为枚举元素</span></span><br><span class="line"><span class="comment">//定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> weekday workday,weekend;</span><br><span class="line">weekday workday,weekend</span><br><span class="line"><span class="comment">//枚举变量赋值</span></span><br><span class="line">workday = sun; weekend = moon;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>枚举类型按常量处理，不能对它们赋值。<code>sun = mon;</code> （错误）</li><li>枚举类型不能直接输出元素的名字。<code>enum color{red,green,white,black}; color cloth = red; cout&lt;&lt;cloth;  //结果为0。</code></li><li>枚举类型可以比较。<code>if(cloth &gt; white)  count++</code></li><li>一个整型不能直接赋给一个枚举变量。<code>workday = 2;</code> （错误）</li><li>枚举元素有值：<ul><li>定义时枚举元素如未指定值，编译系统按定义顺序取默认值依次为0,1,2,3,….</li><li>也可以给枚举元素指定对应的值，<code>enum day {sun=7,mon=1, tue, wed, thu, fri, sat};</code> 这时有<code>sun=7, mon=1, tue=2, wed=3,......</code></li><li>若要把整数赋给枚举变量应先进行强制类型转换，<code>workday = (enum weekday) 2;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> color&#123;red,yellow, green=<span class="number">3</span>,blue&#125;;</span><br><span class="line"><span class="keyword">enum</span> color cl;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cl = blue;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"red="</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow="</span> &lt;&lt; yellow &lt;&lt; <span class="string">" green="</span> &lt;&lt; green &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"blue="</span> &lt;&lt; blue &lt;&lt; <span class="string">" cl="</span> &lt;&lt; cl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出枚举类型的内容</span></span><br><span class="line"><span class="keyword">switch</span> (cl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> red:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> yellow:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"yellow\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> green:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> blue:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202193831.png" alt="QQ图片20200202193831" style="zoom:80%;"></p><p><strong>例子</strong>：计算工资</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202195012.png" alt="QQ图片20200202195012" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> day&#123;Mon,Tue,Wed,Thu,Fri,Sat,Sun&#125;;</span><br><span class="line">day workDay;</span><br><span class="line"><span class="keyword">double</span> times, wages = <span class="number">0</span>, hourlyPay, hours;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the hourly wages rate."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hourlyPay;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter hours worked daily"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hours;</span><br><span class="line"><span class="keyword">switch</span> ((day)i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Sat:times = <span class="number">1.5</span>*hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Sun:times = <span class="number">2</span> * hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:times = hours;</span><br><span class="line">&#125;</span><br><span class="line">wages = wages + times * hourlyPay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The wages for the week are "</span> &lt;&lt; wages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200510.png" alt="QQ图片20200202200510" style="zoom:80%;"></p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><strong>共用体</strong>：为了节省内存空间，可以将几种不同类型的变量存放到同一段内存单元中，这段内存单元所对应的数据结构称为共用体。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200904.png" alt="QQ图片20200202200904" style="zoom:50%;"></p><p><strong>共用体的定义</strong>：<code>uniom 共用体名{ 成员列表; }变量列表;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;      <span class="comment">// 直接定义</span></span><br><span class="line"></span><br><span class="line">data a,b,c;  <span class="comment">//分开定义</span></span><br></pre></td></tr></table></figure><p>共用体的引用：不能引用共用体变量，只能引用共用体变量中的成员。</p><p><strong>共用体类型数据的特点</strong>：</p><ol><li>同一内存段可以存放几种不同类型的成员，但在同一时刻时只能存放其中一种。</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</li><li>共用体变量的地址和它的各成员的地址都是同一地址，如<code>&amp;a, &amp;a.i, &amp;a.ch, &amp;a.f</code>都是同一地址值。</li><li>共用体不能初始化，不能对整个共用体赋值。</li><li>在函数中，可以使用共用体的指针，但不能使用名字做函数参数。</li><li>共用体的空间是所有成员中最大的一个。</li></ol><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202203319.png" alt="QQ图片20200202203319" style="zoom:50%;"></p><p><strong>例子</strong>：</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202204157.png" alt="QQ图片20200202204157" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> job;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Class;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">position</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;category;</span><br><span class="line">&#125;preson[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是一种非常常用的动态数据结构，可以用来表示顺序访问的线性群体：</p><ul><li>链表头：指向第一个链表结点的指针；</li><li>链表结点：链表中的每一个元素，包括：当前结点的数据，下一个结点的地址；</li><li>链表尾：不再指向其他结点的结点，其地址部分放一个<code>NULL</code>，表示链表到此结束。</li></ul><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202213412.png" alt="QQ图片20200202213412" style="zoom:50%;"></p><h2 id="关于new-amp-delete"><a href="#关于new-amp-delete" class="headerlink" title="关于new &amp; delete"></a>关于new &amp; delete</h2><p><code>new</code>：C++运算符，动态地分配内存空间，并将所分配的内存的地址赋给指针变量。</p><p><code>delete</code>：C++运算符，将动态分配的内存空间归还给系统。</p><p><strong>用法一</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;;   </li></ul><p>​       分配某种类型大小的一片连续内存空间，并将内存空间的首地址赋给指针变量。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202215333.png" alt="QQ图片20200202215333" style="zoom:80%;"></p><p><strong>用法二</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;(初值);   </li></ul><p>​       分配空间，并将初始值存入所分配的空间中。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;[&lt;常量表达式&gt;];   </li></ul><p>​       分配指定类型的数组空间，并将数组的首地址赋给指针变量。</p><ul><li>delete[ ]&lt;指针变量&gt;;</li></ul><p>​       将指针变量所指向一维数组内存空间归还给系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(p+i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202220229.png" alt="QQ图片20200202220229" style="zoom:80%;"></p><p>当new &amp; delete 用于结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;next &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203093844.png" alt="QQ图片20200203093844" style="zoom:80%;"></p><h2 id="逐步建立链表"><a href="#逐步建立链表" class="headerlink" title="逐步建立链表"></a>逐步建立链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094349.png" alt="QQ图片20200203094349" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094355.png" alt="QQ图片20200203094355" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094400.png" alt="QQ图片20200203094400" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094405.png" alt="QQ图片20200203094405" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">student *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">student *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *head, *temp;</span><br><span class="line"><span class="keyword">int</span> num, n = <span class="number">0</span>;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">-1</span>)    <span class="comment">//-1作为结束符？</span></span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">temp-&gt;id = num;</span><br><span class="line">temp-&gt;next = <span class="keyword">new</span> student;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *pointer = create();</span><br><span class="line"><span class="keyword">while</span> (pointer-&gt;next != <span class="literal">NULL</span>)     <span class="comment">//遍历链表的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer-&gt;id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pointer = pointer-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203100110.png" alt="QQ图片20200203100110" style="zoom:80%;"></p><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203101525.png" alt="QQ图片20200203101525" style="zoom:50%;"></p><p><strong>例子</strong>：在链表中将值为n的结点删掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">dele</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *follow;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)   <span class="comment">//head为空时，说明链表为空表</span></span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;id == n)  <span class="comment">//若第一个节点是要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;id != n)  <span class="comment">//寻到要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)          <span class="comment">//若没到找到要删除的目标</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = temp-&gt;next;  <span class="comment">//删除目标结点</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><p>1.将结点unit插入链表的<strong>最前面</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104316.png" alt="QQ图片20200203104316" style="zoom:50%;"></p><p>2.将结点unit插入链表的<strong>中间</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104321.png" alt="QQ图片20200203104321" style="zoom:50%;"></p><p>3.将结点unit插入链表的<strong>最后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104324.png" alt="QQ图片20200203104324" style="zoom:50%;"></p><p>例子：插入结点值为n的结点（按大小顺序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">insert</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *unit, *follow;</span><br><span class="line">temp = head;</span><br><span class="line">unit = <span class="keyword">new</span> student;</span><br><span class="line">unit-&gt;id = n;</span><br><span class="line">unit-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)  <span class="comment">//如果链表为空，直接插入</span></span><br><span class="line">&#123;</span><br><span class="line">head = unit;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((temp-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;id &lt; n))  <span class="comment">//寻找第一个不小于n的结点temp</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == head)     <span class="comment">//如果temp为第一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">unit-&gt;next = head;</span><br><span class="line">head = unit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//如果temp为最后一个结点</span></span><br><span class="line">temp-&gt;next = unit;</span><br><span class="line"><span class="keyword">else</span>                     <span class="comment">//如果temp为一个中间结点</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = unit;</span><br><span class="line">unit-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111706.png" alt="QQ图片20200203111706" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111715.png" alt="QQ图片20200203111715" style="zoom:50%;"></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111959.png" alt="QQ图片20200203111959" style="zoom:50%;"></p><p><strong>删除结点temp</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112004.png" alt="QQ图片20200203112004" style="zoom:50%;"></p><p><strong>将结点unit插入到temp之后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112008.png" alt="QQ图片20200203112008" style="zoom:50%;"></p><h2 id="例子：约瑟夫环问题"><a href="#例子：约瑟夫环问题" class="headerlink" title="例子：约瑟夫环问题"></a>例子：约瑟夫环问题</h2><p><strong>问题描述</strong>：n个孩子围坐成一圈，并按顺时针编号为1,2,3, ……,n，从编号为p的小孩顺时针依次报数，由1报到m，当报到m时，该小孩从圈中出去，然后下一个小孩再从1报数，当报到m时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号（假设小孩的个数不多于300个）。</p><p><strong>关于输入</strong>：n,p,m的值在1行内输入，以空格间隔</p><p><strong>关于输出</strong>：按出圈的顺序输出编号，编号之间以逗号间隔。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203115945.png" alt="QQ图片20200203115945" style="zoom:50%;"></p><p><strong>思路</strong>：</p><p>首先定义结点的结构体，列出需要的函数的，然后再考虑每个函数需要完成的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">Node *next;</span><br><span class="line">Node *ahead;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, P, M = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入人数N，从几号开始P，报到哪个数M："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P &gt;&gt; M;</span><br><span class="line">Node *head = Create(N);       <span class="comment">//创建N个结点的环</span></span><br><span class="line">head = Search(head, P);       <span class="comment">//找到第P个结点</span></span><br><span class="line"><span class="keyword">while</span> (head-&gt;next != head)    <span class="comment">//不断释放第M个元素，直到只剩一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">head = Release(head, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span>            <span class="comment">//创建包含N个结点的双向循环链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">Node *node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;num = n;</span><br><span class="line">Node *head = node;        <span class="comment">//指向第一节点</span></span><br><span class="line">Node *tail = head;        <span class="comment">//指向最后一个节点</span></span><br><span class="line"><span class="keyword">while</span> (n++ &lt; N)</span><br><span class="line">&#123;</span><br><span class="line">node = <span class="keyword">new</span> Node;     <span class="comment">//创建新节点</span></span><br><span class="line">node-&gt;num = n;       <span class="comment">//赋值</span></span><br><span class="line">tail-&gt;next = node;   <span class="comment">//插入新节点</span></span><br><span class="line">node-&gt;ahead = tail;</span><br><span class="line">tail = tail-&gt;next;   <span class="comment">//尾巴后移一个</span></span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = head;</span><br><span class="line">head-&gt;ahead = tail;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span>  <span class="comment">//从head开始寻找第P个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;num != P)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span>  <span class="comment">//释放Head开始的第M个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">Node *temp = head;</span><br><span class="line"><span class="keyword">while</span> (count &lt; M)             <span class="comment">//寻找第M个节点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;ahead-&gt;next = temp-&gt;next;   <span class="comment">//移除第M个节点</span></span><br><span class="line">temp-&gt;next-&gt;ahead = temp-&gt;ahead;  <span class="comment">//移除第M个节点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;num &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">head = temp-&gt;next;                <span class="comment">//释放第M个节点所占的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203134747.png" alt="QQ图片20200203134747" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中结构体与链表的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（5）函数</title>
    <link href="http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/"/>
    <id>http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-30T11:41:22.000Z</published>
    <updated>2020-02-02T04:13:30.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义和声明"><a href="#函数的定义和声明" class="headerlink" title="函数的定义和声明"></a>函数的定义和声明</h2><p>函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）<strong>定义</strong>包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        ret* = val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型是指<strong>函数返回值的数据类型</strong>，若函数类型与return语句中表达式的值不一致，则以函数类型为准，系统自动进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y ? x : y);   <span class="comment">//返回时会转换为整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作<strong>函数原型</strong>（function prototype）。</p><p>建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p><p>需要注意的是：<strong>函数不能嵌套定义</strong>，函数间可以互相调用，但不能调用<code>main</code>函数。</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fact(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5! is"</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130201451.png" alt="QQ图片20200130201451" style="zoom: 50%;"></p><p>一个函数调用的执行过程可以分为3个阶段：</p><ol><li>首先把实参值传入被调用函数形参的对应单元中，中断主调函数当前的执行，并且保存返回地点（称为断点）。</li><li>执行被调用函数语句，直到<code>return</code>语句返回。若被调用函数中没有<code>return</code>语句，则直到其全部语句执行完毕后自动返回到位于主调函数中的断点处。</li><li>从保存的断点处，主调函数继续执行其他剩余语句。</li></ol><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“<strong>值传递</strong>”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130202050.png" alt="QQ图片20200130202050" style="zoom:50%;"></p><p>函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名，</p><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是<code>void</code>，它表示函数不返回任何值。</p><h2 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h2><p>根据变量在程序中作用范围的不同，可以将变量分为：</p><p><strong>局部变量</strong>：在函数内或块内定义，只在这个函数或块内起作用的变量；</p><p><strong>全局变量</strong>：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p><p>当全局变量与局部变量<strong>同名</strong>时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量，即在局部变量的作用范围内，全局变量不起作用。</p><p>需要注意的是，不在必要时不要使用全局变量。因为全局变量在程序的全部指向过程中都占用存储单元；过多地使用全局变量，程序的可读性变差；会增加函数之间的“关联性”，降低了函数的独立性，使函数可移植性降低。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130204440.png" alt="QQ图片20200130204440" style="zoom: 50%;"></p><h2 id="自动对象与局部静态对象"><a href="#自动对象与局部静态对象" class="headerlink" title="自动对象与局部静态对象"></a>自动对象与局部静态对象</h2><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为<strong>自动对象</strong>（automatic object）。</p><p>形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。</p><p>有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。<strong>局部静态对象</strong>（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的函数统计它自己被调用了多少次</span></span><br><span class="line"><span class="keyword">size_t</span> count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cout_calls() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>指针用做函数参数，在函数内部改变指针的值只能改变局部变量，不会影响实参原来的值；在函数内部通过解引用操作改变指针所指内容的值，即实参指针所指内容的值也发生了改变。</p><p><strong>例子</strong>：编写一个函数，使用指针形参交换两个整数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;a, *s = &amp;b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(r, s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/1.png" alt="1" style="zoom:80%;"></p><p>需要注意的是，下面的函数并不能满足要求，因为在函数内部改变指针的值（改变指针所指的地址）只能改变局部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h2><p>我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。</p><p>与值传递（实参的值被拷贝给形参，形参和实参是两个相互独立的变量）不同的是，引用形参是传引用的方式，形参是对应的实参的别名，形参绑定到初始化它的对象，如果改变了形参的值，也就是改变了对应实参的值。</p><p>用引用形参重写上面例子中的程序，引用形参绑定初始化它的对象，p绑定我们传给函数的int对象a，改变p的值也就是改变p所引对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200131142122.png" alt="QQ图片20200131142122" style="zoom:80%;"></p><h3 id="使用引用形参避免拷贝"><a href="#使用引用形参避免拷贝" class="headerlink" title="使用引用形参避免拷贝"></a>使用引用形参避免拷贝</h3><p>拷贝大类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p><p><strong>如果函数无须改变引用形参的值，最好将其声明为常量引用</strong>。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量s的内容；二是限制了该函数所能接受的实参类型，我们无法把<code>const</code>对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string 对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个string对象是否含有大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasUpper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span>  <span class="comment">//无须修改参数的内容，设为常量引用类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串的所有大写字母转成小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeToLower</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为一次返回多个结果提供了有效的途径。（对于引用的操作实际上是作用在引用所引的对象上）</p><p><strong>例子</strong>：定义一个名为find_char的函数，返回string对象中某个指定字符第一次出现的位置，同时能“返回”该字符出现的次数。</p><p>一种思路是定义一个新的数据类型，包含位置和数量两个成员，显然比较复杂；另一种更简单的方法是，给函数传入一个额外的引用实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (decltyoe(ret) i = <span class="number">0</span>; i!=s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret == s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;         <span class="comment">//记录c第一次出现的位置</span></span><br><span class="line">            ++occurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;                 <span class="comment">//出现次数通过occurs隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p>数组有两个特殊性质：不允许拷贝数组，以及使用数组时通常会将其转换成指针。所以我们不能以值传递的方式使用数组参数，当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这三个print函数是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>当编译器处理对<code>print</code>函数的调用时，只检查传入的参数是否是<code>const int*</code>类型；如果我们传给<code>print</code>函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。以数组为形参的函数也必须确保使用数组时不会越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=*p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组名做函数参数"><a href="#多维数组名做函数参数" class="headerlink" title="多维数组名做函数参数"></a>多维数组名做函数参数</h3><p>当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，而多维数组的首元素是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个print等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;   <span class="comment">//（*matrix)的括号不能少</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure><p>例子：求一个$3\times 4$的矩阵的所以元素中的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxvalue</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = p[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(p[i][j] &gt; <span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span> = p[i][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Max value is"</span> &lt;&lt; maxvalue(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参也可以是数组的引用，此时引用形参绑定到对应的实参上，也就是绑定到数组上。但此时函数只能作用于固定大小的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span>    <span class="comment">//只能将函数作用于大小为10的数组，(&amp;arr)的括号不能少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>我们已经知道：函数不能嵌套定义，函数可以嵌套调用。那么一个函数能调用“自己”嘛？答案是可以的</p><p>例子：已知 n，求n的阶乘$n!$</p><script type="math/tex; mode=display">\begin{align*}n!&=(n-1)!*n \\ (n-1)!&=(n-2)!*(n-1) \\ &\dots \\ 2!&=1!*2 \\ 1!&=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);     <span class="comment">//每次调用，数据规模缩小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fact(<span class="number">4</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深入理解递归的过程"><a href="#深入理解递归的过程" class="headerlink" title="深入理解递归的过程"></a>深入理解递归的过程</h2><p>递归调用与普通调用在实质上是一样的。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100341.png" alt="QQ图片20200201100341" style="zoom:50%;"></p><p>通过下面的两个例子来理解递归的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100347.png" alt="QQ图片20200201100347" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100351.png" alt="QQ图片20200201100351" style="zoom:50%;"></p><h2 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h2><h3 id="用递归来完成递推"><a href="#用递归来完成递推" class="headerlink" title="用递归来完成递推"></a>用递归来完成递推</h3><p>递归的关注点放在求解目标上，重在表现第i次与第i+1次的关系，让程序变得简明。必须要确定第1次的返回结果。</p><p><strong>例子</strong>：斐波那契数列</p><script type="math/tex; mode=display">\begin{align*}fab(n)&=fab(n-1)+fab(n-2) \\ fab(1)&=1,\, fab(2)=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>(f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟连续发生的动作"><a href="#模拟连续发生的动作" class="headerlink" title="模拟连续发生的动作"></a>模拟连续发生的动作</h3><p>主要是搞清楚连续发生的动作是什么；搞清楚不同动作之间的关系；搞清楚边界条件是什么。</p><p><strong>例子1</strong>：将一个十进制整数转换成二进制数</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201110807.png" alt="QQ图片20200201110807" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x / <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">convert(x / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">convert(x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong>：汉诺塔问题</p><p>相传在古代印度有位僧人整天把三根柱子上的金盘倒来倒去，他想把64个一个比一个小的金盘从一根柱子上移到另一个柱子上去。移动过程中恪守下述规则：每次只允许移动一只盘，且大盘不得落在小盘上面。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112556.png" alt="QQ图片20200201112556" style="zoom:50%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112717.png" alt="QQ图片20200201112717" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span> <span class="comment">//表示将m个盘子从A经过B移动到C</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//直接可解结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//如果m不为1，则要调用move(m-1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, A, C, B);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, B, A, C);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入盘数n="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"在3根柱子上移"</span> &lt;&lt; n &lt;&lt; <span class="string">"个盘子的步骤为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112602.png" alt="QQ图片20200201112602" style="zoom: 80%;"></p><h3 id="进行“自动的分析”"><a href="#进行“自动的分析”" class="headerlink" title="进行“自动的分析”"></a>进行“自动的分析”</h3><p>先假设有一个函数能给出答案，再利用这个函数分析如何解决问题；搞清楚最简单的情况下答案是什么。</p><p><strong>例子</strong>：放苹果</p><p>把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？注意：5,1,1和1,5,1是同一种分法。</p><p>思路：</p><ol><li><p>假设有一个函数f(m,n)能解决这个问题，那么最简单的情况是<code>m&lt;=1||n&lt;=1</code>，此时只有1种分法。</p></li><li><p>当<code>n&gt;m</code>时，必有盘子会空着，空着的盘子不影响结果，那么有<code>f(m,n)=f(m,m)</code>。</p></li><li><p>当<code>n&lt;=m</code>时，分两种情况：</p><p>(1)如果有盘子空着，那么减少一个盘子也不会影响结果，有<code>f(m,n)=f(m,n-1)</code>。</p><p>(2)如果盘子全满，那么每个盘子至少有1个苹果，那么只需考虑剩下m-n个苹果在n个盘子中的分法，则有</p><p><code>f(m,n)=f(m-n,n)</code>。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">1</span> || n &lt;= <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line"><span class="keyword">return</span> count(m, m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> count(m, n - <span class="number">1</span>) + count(m - n, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count(m, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201114810.png" alt="QQ图片20200201114810" style="zoom:80%;"></p><h3 id="递归问题解法小结"><a href="#递归问题解法小结" class="headerlink" title="递归问题解法小结"></a>递归问题解法小结</h3><p>面对一个问题时：</p><ol><li>假设有一个函数f()可以解决问题；接下来考虑这个函数是什么样的？</li><li>找到f^n()与f^n-1()之间的关系；</li><li>确定f()的参数；</li><li>分析并写出边界条件。</li></ol><p><strong>例子1</strong>：组合问题</p><p>用递归法计算从n个人中选择k个人组成一个委员会，求不同的组合的个数一共是多少？</p><p><strong>思路</strong>：</p><ul><li>由n个人里选k个人的组合数=由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数；</li><li>当n = k或k = 0时，组合数为1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comm</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> comm(n - <span class="number">1</span>, k) + comm(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two integers n and k: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C(n,k) = "</span> &lt;&lt; comm(n, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202104441.png" alt="QQ图片20200202104441" style="zoom:80%;"></p><h2 id="探索式递归"><a href="#探索式递归" class="headerlink" title="探索式递归"></a>探索式递归</h2><p><strong>例子1</strong>：下楼问题</p><p>从楼上走到楼下共有h个台阶，每一步有3种走法：走1个台阶；走2个台阶；走3个台阶。问可以走出多少种方案？将所有的方案输出。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201183838.png" alt="QQ图片20200201183838" style="zoom: 33%;"></p><p><strong>思路</strong>：</p><ol><li><p>既然要列出所有方案，所以需要用一个数组存放每步走的步数，可设为<code>take[99]</code>，步数存放在<code>take[ ]</code>中，满足条件就打印出来；</p></li><li><p>假设有一个函数<code>Try( )</code>能解决问题，接着寻找Try^n^( )与Try^n+1^( )的关系；</p></li><li><p>Try^n^( )代表走完第n步的状态，即已经填完第n个<code>take[ ]</code>；</p></li><li><p>Try^n( )与Try^n+1( )的关系：在走完第n步后，再走第n+1步时，有三种选择（走1、2、3步），每个选择下有三种可能性：</p><ul><li>如果剩下的台阶数小于想要走的步数：返回</li><li>如果剩下的台阶数恰好等于要走的步数：打印输出</li><li>如果剩下的台阶数大于想要走的步数：走下去</li></ul></li><li>Try( )的参数如何确定：Try^n^( )与Try^n+1^( )之间哪些数据是不一样的？而且是需要由Try^n( )传递给Try^n+1^( )的？</li></ol><p>​       Try^n^( )代表走完第n步的情况，Try^n+1^( )代表走完第n+1步的情况；</p><p>​       Try^n^( )需要将走完第 n步后剩余的台阶数传递  给Try^n+1^( )。</p><p>​       因此可以将Try^n^( )定义为：<code>Try(i, s)</code>，<code>i</code>表示剩余的台阶数，<code>s</code>表示步数。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201185823.png" alt="QQ图片20200201185823" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> take[<span class="number">99</span>];    <span class="comment">//记录每一个走的台阶数</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;     <span class="comment">//num记录解决方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Try</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">take[s] = j;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"solution"</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Try(i - j, s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//take[s]=0;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"how many stairs:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">Try(h, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; num &lt;&lt; <span class="string">" solutions."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201191406.png" alt="QQ图片20200201191406" style="zoom:80%;"></p><p><strong>例子2</strong>：字母全排列</p><p>从键盘读入一个英文单词（全部字母小写，且该单词中各个字母均不相同），输出该单词英文字母的所有全排列。</p><p>如输入<code>abc</code>，则打印出<code>abc</code>, <code>acb,</code> <code>bac</code>, <code>bca</code>, <code>cab</code>, <code>cba</code>。</p><p><strong>思路</strong>：</p><p>需要反复做的事情是：选择第n个位置的字母，依次检查每个字母，如果某个字母没被选择过，则进行：</p><ol><li>将该字母放第n个位置；</li><li>标记该字母已经被选择；</li><li>如果全部位置都已选完，打印输出；否则，为下一个位置选择字母；</li><li>把刚刚标记过的字母重新标记为“未选择”；</li></ol><p>假设一个函数<code>ranker( )</code>能够完成上述事情，每次调用之间的区别在于位置n，<code>ranker(1)</code>—&gt;<code>ranker(2)</code>—&gt;<code>ranker(3)</code>……—&gt;<code>ranker(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> in[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">//存放输入的单词</span></span><br><span class="line"><span class="keyword">char</span> out[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//存放准备输出的字符串</span></span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//记录第i个字母是否已经使用过</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;         <span class="comment">//记录输入的单词的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ranker</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==length)       <span class="comment">//如果全部字母已经被选择完，则打印输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)  <span class="comment">//依次查看每个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!used[i])          <span class="comment">//如果某个字母没有被选用</span></span><br><span class="line">&#123;</span><br><span class="line">out[n] = in[i];    <span class="comment">//选入该字母</span></span><br><span class="line">used[i] = <span class="number">1</span>;       <span class="comment">//标记该字母已经被选择</span></span><br><span class="line">ranker(n + <span class="number">1</span>);     <span class="comment">//为下一个位置寻找字母</span></span><br><span class="line">used[i] = <span class="number">0</span>;   <span class="comment">//回溯，标记字母未被使用，让其可重新被选择</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the word: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">length = <span class="built_in">strlen</span>(in);</span><br><span class="line">ranker(<span class="number">0</span>);   <span class="comment">//从第一个字母开始</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201195215.png" alt="QQ图片20200201195215" style="zoom:80%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201201948.png" alt="QQ图片20200201201948" style="zoom: 50%;"></p><p><strong>例子3</strong>：分书问题</p><p>有编号分别为1, 2, 3, 4, 5的五本书，准备分给A，B，C，D，E五个人，每个人阅读兴趣用一个二维数组加以描述。请写一个程序，输出所有分书方案，让人人都能拿到喜欢的书。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201202457.png" alt="QQ图片20200201202457" style="zoom: 50%;"></p><p><strong>思路</strong>：</p><ol><li>假设函数<code>trybook( )</code>可以解决问题，从第0个人开始分书，函数<code>trybook(i)</code>应该要完成：</li><li>试着给第<code>i</code>个人分书，从0号书开始试，当第<code>i</code>个人喜欢第<code>j</code>个书，且<code>j</code>书还没被选走时（因此要建一个数组记录书被选走的状态），那么第<code>i</code>个人就得到第<code>j</code>本书；</li><li>如果不满足上述条件，则什么也不做，返回循环条件；</li><li>若满足条件，则做三件事情：<ul><li>做事：将第<code>j</code>个书分给第<code>i</code>个人，同时记录<code>j</code>书已被选用；</li><li>判断：查看是否将所有5个人所要的书分完，若分完，则输出每个人所得之书；若未分完，去寻找其他解决方案；</li><li>回溯：让第<code>i</code>个人退回<code>j</code>书，恢复<code>j</code>书尚未被选用的状态。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//book[5]记录书是否被选用，选用记为1</span></span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//take[5]记录第i个人领到那本书</span></span><br><span class="line"><span class="keyword">int</span> num;             <span class="comment">//num记录分书方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trybook</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="comment">//第i个人</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">4</span>; j++)  <span class="comment">//第j本书</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((like[i][j] &gt; <span class="number">0</span>) &amp;&amp; (book[j] == <span class="number">0</span>)) <span class="comment">//若第i个人喜欢第j本书，且第j本书还没被选用</span></span><br><span class="line">&#123;</span><br><span class="line">take[i] = j;  <span class="comment">//把第j本书分给第i个人</span></span><br><span class="line">book[j] = <span class="number">1</span>;  <span class="comment">//记录第j本书已经被选用</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">4</span>)   <span class="comment">//如果第5个人已经拿到书，即书已分完，则输出方案</span></span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; num &lt;&lt; <span class="string">"个方案"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k] &lt;&lt; <span class="string">"号书给"</span> &lt;&lt; <span class="keyword">char</span>(k + <span class="number">65</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>       <span class="comment">//如果书没分完，则继续给下一个人分书</span></span><br><span class="line">trybook(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//take[i] = -1;  把第i个人的书退回，实际上可以不加这一条</span></span><br><span class="line">book[j] = <span class="number">0</span>;   <span class="comment">//回溯，把第j本书标记为未选用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">trybook(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202101401.png" alt="QQ图片20200202101401" style="zoom:80%;"></p><h3 id="探索式递归问题的解法"><a href="#探索式递归问题的解法" class="headerlink" title="探索式递归问题的解法"></a>探索式递归问题的解法</h3><p>第n步需要做什么？对于面前的每种选择：</p><ol><li>把该做的事情做了；</li><li>判定是否得到解；</li><li>递归（调用第n+1步）；</li><li>看是否需要回溯。</li></ol>]]></content>
    
    <summary type="html">
    
      复习了C++中函数的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（4）字符数组与字符串</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-01-27T03:08:57.000Z</published>
    <updated>2020-01-27T14:29:00.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127110928.png" alt="QQ图片20200127110928" style="zoom:67%;"></p><h2 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h2><p>只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符-字符数组-字符串的输入与输出"><a href="#字符-字符数组-字符串的输入与输出" class="headerlink" title="字符/字符数组/字符串的输入与输出"></a>字符/字符数组/字符串的输入与输出</h2><h3 id="一个字符的输入"><a href="#一个字符的输入" class="headerlink" title="一个字符的输入"></a>一个字符的输入</h3><h4 id="直接用cin输入字符。"><a href="#直接用cin输入字符。" class="headerlink" title="直接用cin输入字符。"></a>直接用<code>cin</code>输入字符。</h4><p><code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;c)     <span class="comment">//abc def g</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;      <span class="comment">//abcdefg</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用cin-get-函数输入"><a href="#用cin-get-函数输入" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>可以用于读入<strong>一个字符</strong>；有2中形式：</p><p>无参数<code>cin.get()</code>，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( (c=<span class="built_in">cin</span>.<span class="built_in">get</span>())!= EOF )  <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;                    <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>一个参数<code>cin.get(char)</code>     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="comment">//读取一个字符赋给字符变量c</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">cin</span>.<span class="built_in">get</span>(c) )     <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>要注意的是，<code>cin.get()</code>遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1,ch2;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入两个字符："</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();  </span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch2);  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;(<span class="keyword">int</span>)ch2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输入a[Enter]，读取到结束符<code>&#39;/n&#39;</code>，其仍在缓冲区中被存入<code>ch2</code>，在输出a之后，第二次输出<code>&#39;/n&#39;</code>即换行，而输出的第二个ASCII码值为10，即<code>&#39;/n&#39;</code>的ASCII值，说明<code>cin.get()</code>遇到结束符并不会将之删除。</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127172134.png" alt="QQ图片20200127172134" style="zoom: 80%;"></p><h4 id="用getchar-输入字符"><a href="#用getchar-输入字符" class="headerlink" title="用getchar()输入字符"></a>用<code>getchar()</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( c = getchar() )  <span class="comment">//abc def g   不跳过任何字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><h3 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h3><h4 id="直接用cin输入字符"><a href="#直接用cin输入字符" class="headerlink" title="直接用cin输入字符"></a>直接用<code>cin</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127120550.png" alt="QQ图片20200127120550" style="zoom:80%;"></p><h4 id="用cin-get-函数输入-1"><a href="#用cin-get-函数输入-1" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>有三个参数的<code>cin.get()</code>函数：<code>cin.get(ch, 10, &#39;/n&#39;)</code></p><p>读取10-1（10减1=9，最后一个为<code>&#39;/0&#39;</code>）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符<code>&#39;/n&#39;</code>，则提前结束读取（如果第3个参数没有指定，则默认为<code>&#39;/n&#39;</code>），而<strong>结束符仍在缓冲区中</strong>；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。</p><p>还要一点要注意，<code>cin.get(ch, 10, &#39;/n&#39;)</code>，当第一个输入字符为结束符时，缓冲区将无该结束符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1,<span class="number">10</span>,<span class="string">'o'</span>);  <span class="comment">//指定终止符为'o'</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ch2,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127173835.png" alt="QQ图片20200127173835" style="zoom:80%;"></p><p>输入：we are good friends[Enter]，由于遇到结束符 <code>&#39;o&#39;</code> ，首先读入we are g到<code>ch1</code>，此时ood friends仍在缓冲区，当执行<code>cin.get(ch2,10)</code>会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。</p><h4 id="用cin-getline-函数输入"><a href="#用cin-getline-函数输入" class="headerlink" title="用cin.getline()函数输入"></a>用<code>cin.getline()</code>函数输入</h4><p>用法与上面的<code>cin.get()</code>类似，但也有区别：</p><p><code>cin.get()</code>当输入的字符串在结束符之前的长度超过接收长度时，不会引起<code>cin</code>函数的错误，剩余的字符会留在缓冲区，后面若有<code>cin</code>操作，会继续从缓冲区读取；当<code>cin.getline()</code>输入超长时，会引起<code>cin</code>函数的错误，后面的<code>cin</code>操作将不再执行。</p><p><code>cin.get()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符<code>&#39;/n&#39;</code>留在输入队列中，然而<code>cin.getline()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符抛弃。</p><p><code>cin.get()</code>遇到结束符是停止读取，缓冲区指针不移动；<code>cin.getline()</code>遇到结束符时，缓冲区指针移到终止标志字符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(ch1,<span class="number">10</span>,<span class="string">'o'</span>);      <span class="comment">//指定终止符为'o'</span></span><br><span class="line">   <span class="built_in">cin</span>.getline(ch2,<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//注意与上节的区别</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127191238.png" alt="QQ图片20200127191238" style="zoom:80%;"></p><p>一个<strong>需要注意</strong>的地方：<code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但<strong>最后一个Enter会在缓冲区</strong>。而无参数<code>cin.get()</code>，可用于<strong>舍弃输入流中的不需要的字符</strong>，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   <span class="comment">//当执行cin.getline(a[1],10)时，[Enter]被读取到a[1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127192425.png" alt="QQ图片20200127192425" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();     <span class="comment">//用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127193235.png" alt="QQ图片20200127193235" style="zoom:80%;"></p><h3 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h3><h4 id="用cout输出字符数组"><a href="#用cout输出字符数组" class="headerlink" title="用cout输出字符数组"></a>用<code>cout</code>输出字符数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Computer"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220421.png" alt="QQ图片20200127220421" style="zoom:80%;"></p><p>需要注意的是，<code>cout</code>输出有终止条件（一般是碰到<code>&#39;\0&#39;</code>），当用字面值初始化字符数组时，会自动在串尾加上<code>&#39;\0&#39;</code>；当用列表初始化字符数组时，若不在串尾加上’\0’，用<code>cout</code>输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>] = &#123; <span class="string">'C'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>,<span class="string">'p'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220426.png" alt="QQ图片20200127220426" style="zoom:80%;"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.getline(str, <span class="number">200</span>)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'Z'</span>)&#123;</span><br><span class="line">str[i] = <span class="string">'A'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'z'</span>)&#123;</span><br><span class="line">str[i] == <span class="string">'a'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">str[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127203829.png" alt="QQ图片20200127203829" style="zoom:80%;"></p><p>2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数<code>strcat</code>，每个输入的串的长度不超过20。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">40</span>], str2[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str1,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cin</span>.getline(str2, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++);</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++);</span><br><span class="line"><span class="keyword">if</span> (len1 &gt;= len2) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++)</span><br><span class="line">str1[len1++] = str2[len2];   <span class="comment">//后置++，先执行表达式，再len+1</span></span><br><span class="line">str1[len1] = <span class="string">'\0'</span>;   <span class="comment">//必须要加，要不然cout&lt;&lt;str1会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++)</span><br><span class="line">str2[len2++] = str1[len1];</span><br><span class="line">str2[len2] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127213528.png" alt="QQ图片20200127213528" style="zoom:80%;"></p><p>3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127214732.png" alt="QQ图片20200127214732" style="zoom:80%;"></p><p>当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((str[i] &gt;= <span class="string">'A'</span>&amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) || (str[i] &gt;= <span class="string">'a'</span>&amp;&amp;str[i] &lt;= <span class="string">'z'</span>))</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127215300.png" alt="QQ图片20200127215300" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中字符数组与字符串的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（3）数组</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-01-27T03:06:06.000Z</published>
    <updated>2020-01-27T14:32:08.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。</p><h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><p>数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个<strong>常量表达式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;   <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;     <span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];       <span class="comment">// 错误：cnt不是常量表达式</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。</p><h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;             <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><p>当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p>数组能存放大多数类型的对象，可以定义一个<strong>存放指针的数组</strong>；又因为数组本身是对象，所以允许定义<strong>数组的指针及数组的引用</strong>。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];                <span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ？ */</span>      <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;    <span class="comment">//Parray是一个指针，指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;     <span class="comment">//arrRef是一个引用，引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;     <span class="comment">//arry是一个引用，引用一个含有10个指针的数组</span></span><br></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>3.27</strong> 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> ia[buf_size];                <span class="comment">//非法的，因为buf_size不是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">4</span>*<span class="number">7</span><span class="number">-14</span>];                  <span class="comment">//正确，因为4*7-14是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[txt_size()];              <span class="comment">//非法的，因为txt_size没有被定义为常量表达式 constexpr</span></span><br><span class="line"><span class="keyword">char</span> st[<span class="number">11</span>] = <span class="string">"fundamental"</span>      <span class="comment">//非法的，因为用字符串字面值初始化，没有空间存放空字符</span></span><br></pre></td></tr></table></figure><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>与标准库类型<code>vector</code> 和<code>string</code> 一样，数组的元素也能使用范围<code>for</code> 语句或下标运算符来访问。数组的索引从0开始。</p><p>数组下标通常定义为<code>size_t</code>类型，<code>size_t</code>是一种机器相关的无符号类型，在<code>cstddef</code>头文件中定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100</span></span><br><span class="line"><span class="keyword">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;        <span class="comment">//列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>vector</code> 和<code>string</code> 一样，当需要遍历数组的所有元素时，最好的办法是使用范围<code>for</code>语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于scores中的每个计数值输出当前的计数值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>必须要<strong>检查数组下标的值</strong>在合理范围内，下标越界会产生缓冲区溢出。</p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p>3.31编写一段程序，定义一个含有10个<code>int</code>的数组，令每个元素的值就是其下标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> val: a)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.32 将上一题创建的数组拷贝给另外一个数组，利用<code>vector</code>重写程序，实现类似的功能。</p><p>//如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz], b[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz: j++)</span><br><span class="line">        b[j] = a[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//用<code>vector</code>重写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vInt, vInt2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        vInt.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++)</span><br><span class="line">        vInt2.push_back(vInt[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val: vInt2)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>输出100以内的所有素数。</p><p>一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足：</p><script type="math/tex; mode=display">1<c\le \sqrt{n}</script><p>循环结构的N-S图：</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/QQ图片20200126204152.png" alt="QQ图片20200126204152" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="built_in">sqrt</span>(<span class="number">100.0</span>); i++)&#123;</span><br><span class="line">        sum = i;</span><br><span class="line">        <span class="keyword">if</span>(a[sum]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(sum&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                sum = sum + i;</span><br><span class="line">                a[sum] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++中并没有多维数组，通常所说的多维数组其实是数组的数组。按照由内而外的顺序阅读。</p><p>多维数组<strong>初始化</strong>的几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; &#125;;  <span class="comment">//每一行分别用花括号括起来</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">//不标识每行的花括号</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125; &#125;;  <span class="comment">//显示地初始每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;                <span class="comment">//只显示地初始化第1行</span></span><br></pre></td></tr></table></figure><p>多维数组的<strong>下标引用</strong>：如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果是给定类型的元素；如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。</p><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p>某学校有1000位老师，分布在20个不同的学院中，每个学院最多有12个系，请你编写一个程序，输入每位老师的所在院、系的编号（院编号1-20，系编号1-12），打印出各个系老师的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomainp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> teacher[<span class="number">21</span>][<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">int</span> school,department, i, j;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name&gt;&gt;school&gt;&gt;department;</span><br><span class="line">        teacher[school][department]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">21</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;<span class="number">13</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;teacher[i][j];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a><strong>数组的地址</strong></h3><p>在C++语言中，指针和数组有非常紧密的联系。数组名代表数组首元素的地址：数组名是指向数组第一个元素的指针。对于数组a[10]，数组名a代表数组a[10]中第一个元素a[0]的地址，即a与&amp;a[0]等价。需要注意的是，a是地址常量，不是变量，不能给a赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//输出a[0]的地址 0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//输出a[0]的值  10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>若a是指向数组第一个元素的指针，即a相当于<code>&amp;a[0]</code>。</p><ul><li><p>&amp;a是”指向数组“的指针，&amp;a+1将跨越16个字节，&amp;a相当于管辖范围”上升“了一级；</p></li><li><p><em>a是数组的第一个元素a[0]，即 </em>a等价于a[0]， *a相当于管辖范围“下降”了一级。</p></li></ul><p>在一些情况下数组的操作实际上是指针的操作。当使用数组作为一个<code>auto</code>变量的初始值时，得到的类型是指针而非数组。当使用<code>decltype</code>关键字时上述转换不会发生，<code>decltyoe(ia)</code>返回的类型是由整数构成的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;              <span class="comment">//相当于 auto ia2(&amp;ia[0]); ia2是一个整型指针</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//ia是含有整数的数组</span></span><br></pre></td></tr></table></figure><p>C++11新标准引入了<code>begin</code>和<code>end</code>函数，定义在<code>iterator</code>头文件中，这两个函数与容器中的两个同名成员功能类似，但由于数组不是类类型，因此这两个函数不是成员函数，使用时需要将数组作为它们的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure><h3 id="利用指针变量引用数组元素"><a href="#利用指针变量引用数组元素" class="headerlink" title="利用指针变量引用数组元素"></a>利用指针变量引用数组元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *pointer;</span><br><span class="line">pointer = a;         <span class="comment">//等价于 pointer = &amp;a[0];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer+i;   <span class="comment">//等价于a+i；等价于&amp;a[i]；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(pointer+i);<span class="comment">//等价于*(a+i)；等价于a[i];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer[i];  <span class="comment">//等价于*(pointer+i);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>需要注意的是：a++是没有意义的，但p++会引起p的变化。p可以指向数组最后一个元素以后的元素，称为尾后指针，就像尾后迭代器，尾后指针不能执行解引用和递增操作。<strong>指针做加减运算时一定要注意有效的范围</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;   <span class="comment">//a[0]=3</span></span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[-1].dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;   <span class="comment">//damage</span></span><br></pre></td></tr></table></figure><p>根据运算符的优先级有：</p><ul><li><p><code>*++p</code>相当于<code>a[++i]</code>，先将p自加，再做<code>*</code>运算。</p></li><li><p><code>*--p</code>相当于<code>a[--i]</code>，先将p自减，再做<code>*</code>运算。</p></li><li><code>*p++</code>相当于<code>a[i++]</code>，先做<code>*</code>运算，再将p自加。</li><li><code>*p--</code>相当于<code>a[i--]</code>，先做<code>*</code>运算，再将p自减。</li></ul><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针代替数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], i, *p = a;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p++;</span><br><span class="line">    <span class="keyword">for</span>(p--; p&gt;=a; )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; *p--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒置数组元素</span></span><br><span class="line"><span class="comment">//输入：1 2 3 4 5 6 7 8 9 0</span></span><br><span class="line"><span class="comment">//输出：0 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p;</span><br><span class="line">    <span class="keyword">for</span>(p = a, q = a+<span class="number">9</span>; p&lt;q; p++, q--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=*p; *p=*q; *q=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt;*p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的地址"><a href="#二维数组的地址" class="headerlink" title="二维数组的地址"></a>二维数组的地址</h3><p>数组名相当于指向数组第一个元素的指针。</p><ul><li><p>*a等价于a[0]，相当于a下降了一级；</p></li><li><p>&amp;a表示“指向二维数组”的指针，相当于上升了一级。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125; &#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//a是指向数组第一个元素的指针，而数组的第一个元素是一个含有4元素的数组，即a是指向一维数组的指针，     //a相当于一个“包含4个int型元素的一维数组”的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//0x0013FF60  a+1将跨越16个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//0x0013FF60</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//*a是数组的第一个元素，而数组的第一个元素是一个数组，即*a是一个指向整数的指针，</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//0x0013FF50 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF54  *a+1将跨越4个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子1：遍历数组元素"><a href="#例子1：遍历数组元素" class="headerlink" title="例子1：遍历数组元素"></a><strong>例子1：遍历数组元素</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//for (p=&amp;a[0][0]; p&lt;&amp;a[0][0]+12; p++)</span></span><br><span class="line">  <span class="comment">//for (p=a[0]; p&lt;a[0]+12; p++)</span></span><br><span class="line">    <span class="keyword">for</span> (p=*a; p&lt;*a+<span class="number">12</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子2：输入i，j；输出a-i-j"><a href="#例子2：输入i，j；输出a-i-j" class="headerlink" title="例子2：输入i，j；输出a[i] [j]"></a>例子2：输入i，j；输出a[i] [j]</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>], i, j;</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//cout &lt;&lt; setw(4) &lt;&lt; p[i][j];    </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;*(*(p+i)+j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ol><li><p>从<code>p=a</code>开始，a相当于指向<code>a[3][4]</code>的“第一个元素”的指针；所谓“第一个元素”是指一个 “包含4个int型元素的一维数组”；所以，a相当于一个 “包含4个int型元素的一维数组”的地址；因此<strong>p的基类型</strong>应该是 “包含4个int型元素的一维数组”。</p></li><li><p>如何定义一个指向 “包含4个int型元素的一维数组” 的指针变量？ ———- <code>int (*p)[4]</code></p></li><li><p><code>*(*(p+i)+j)</code>是什么？</p><p><code>p</code>指向一个“包含4个int型元素的一维数组”；</p><p><code>p+i</code>  是第<code>i+1</code>个“包含4个Int 型元素的一维数组”的地址；<code>p+i</code>等价于<code>&amp;a[i]</code>；</p></li></ol><p>​       <code>*(p+i)</code>等价于<code>a[i]</code>；<code>*(p+i)+j</code>等价于<code>a[i]+j</code>；</p><p>​       因为：<code>a[i]+j</code>等价于<code>&amp;a[i][j]</code>，所以：<code>*(*(p+i)+j)</code>等价于<code>a[i][j]</code>。</p><ol><li><p><code>p[i][j]</code>是什么？</p><p>p[i]等价于 <code>*(p+i)</code>； <code>p[i][j]</code> 等价于 <code>*(*(p+i)+j)</code>，等价于<code>a[i][j]</code>。</p></li></ol><h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><p>C++11新标准中新增了范围<code>for</code>语句，可以使用范围<code>for</code>语句处理多维数组，为了避免数组被自动转成指针，处理最内层的循环外，其他所有循环的控制变量应该都是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt=<span class="number">3.</span> colCnt=<span class="number">4</span>, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">       col = cnt;</span><br><span class="line">       ++cnt;  </span><br><span class="line">&#125;   <span class="comment">//ia=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;</span></span><br></pre></td></tr></table></figure><p>也可以使用标准库函数<code>begin</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p=<span class="built_in">begin</span>(ia); p!=<span class="built_in">end</span>(ia); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q=<span class="built_in">begin</span>(*p); q!=<span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="string">' '</span>；    <span class="comment">//依次输出ia的元素的值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pc;</span><br><span class="line">    pc = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出hello</span></span><br><span class="line">    pc++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">    pc = <span class="built_in">buffer</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//ABC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中数组的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（2）引用与指针</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/</id>
    <published>2020-01-27T03:02:17.000Z</published>
    <updated>2020-01-27T14:31:11.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><p>复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。</p><p>一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。</p><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成<code>$d</code>的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。</p><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。</p><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号<code>&amp;</code>开头。</p><p>引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;      <span class="comment">//refVal指向ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;            <span class="comment">//错误。引用必须被初始化</span></span><br><span class="line"></span><br><span class="line">refVal = <span class="number">2</span>;              <span class="comment">//把值赋给了ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;   <span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，即ival</span></span><br><span class="line"><span class="keyword">int</span> i = refVal;          <span class="comment">//相当于i = ival</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i, &amp;r2 = i2;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同：</p><p>（1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。</p><p>（2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。</p><p><strong>指针运算符</strong><code>*</code>，<strong>取地址符</strong><code>&amp;</code></p><p>指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p><strong>指针变量</strong>：专门用于存放指针（某个变量的地址）的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer;       <span class="comment">//定义名字为pointer的指针变量</span></span><br><span class="line">pointer = &amp;c;       <span class="comment">//将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c</span></span><br><span class="line"><span class="comment">//pointer = c;      //错误：因为pointer是存放地址的变量，所以只能存放地址</span></span><br></pre></td></tr></table></figure><p>通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer = &amp;c;  <span class="comment">//*pointer为“pointer所指向的存储单元的内容"，即是变量c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;c &lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//取变量c的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;pointer &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//取指针变量c的地址</span></span><br></pre></td></tr></table></figure><p><strong>赋值和指针</strong>：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;         <span class="comment">//pi被初始化</span></span><br><span class="line">pi = &amp;ival;          <span class="comment">//pi所存的地址改变，指向ival</span></span><br><span class="line">*pi = <span class="number">0</span>;             <span class="comment">//ival的值被改变，指针pi所存的地址没有改变</span></span><br></pre></td></tr></table></figure><p><strong>&amp;<code>与</code>*`的运算优先级</strong>：同级</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/QQ图片20200125205145.png" alt="QQ图片20200125205145" style="zoom:50%;"></p><p><strong>空指针</strong>（null pointer）不指向任何对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>     <span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;          <span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;       <span class="comment">//需要首先#include&lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure><p>使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。</p><p><code>void*</code>指针：可用于存放任意对象的地址。利用<code>void*</code>指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个<code>void*</code>指针。不能访问其内存空间中所存的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中引用与指针的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（1）基础语法</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-01-27T02:59:54.000Z</published>
    <updated>2020-01-27T14:11:39.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//变量创建的语法： 数据类型 变量名 = 变量初始值</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量</strong>创建的语法： 数据类型 变量名 = 变量初始值</p><p>定义<strong>常量</strong>的两种方法：</p><ol><li><code>#define</code> 宏常量名 常量值 </li><li><code>const</code> 修饰的变量  <code>const</code> 数据类型 常量名 = 常量值</li></ol><p>定义变量或常量时不要用C++中已经使用的关键字</p><p>C++中给标识符（变量，常量）命名时，要注意：<br>1.标识符不可以是关键字<br>2.标识符只能由字母，数字，下划线组成<br>3.标识符的第一个字母只能是字母或者下划线<br>4.标识符中区分大小写<br>5.给变量命名时最好能做到见名知意，方便阅读</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型存在的意义：给不同类型的变量分配合适的内存空间</p><p><strong>整型</strong>的几种类型：<br>1.短整型    short      2字节   -2^15 - 2^15-1<br>2.整型      int        4字节   -2^31 - 2^31-1   //int最常用<br>3.长整型    long       4字节   -2^31 - 2^31-1<br>4.长长整型  long long  8字节   -2^63 - 2^63-1</p><p><strong><code>sizeof</code></strong> 关键字可以得到数据类型所占的内存的大小<br>语法： <code>sizeof</code>（数据类型/变量名）</p><p><strong>实型/浮点型</strong>：用于表示小数<br>1.单精度 float   4字节  7位有效数字<br>2.双精度 double  8字节  15-16位有效数字</p><p><strong>字符型</strong>：用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><p><strong>字符串型</strong>：用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><p><strong>转义字符</strong>： 用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><strong>布尔类型</strong><code>bool</code>：代表真或假的值   占用1个字节<br><code>bool</code>类型只有两个值：<code>true</code>（本质是1）  <code>false</code>（本质是0）</p><p><strong>数据的输入</strong>：用于从键盘获取数据<br>语法：<code>cin &gt;&gt;</code> 变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">short num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"short所占的内存空间为"</span> &lt;&lt; <span class="keyword">sizeof</span>(num1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;   <span class="comment">//编译器会把小数默认为双精度数，所以要在3.14后加上f                   </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f1="</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d1="</span> &lt;&lt; d1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的  setprecision( ) </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">12.3456789</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 默认以6精度，所以输出为 12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成4精度，所以输出为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">8</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成8精度，所以输出为12.345679</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// fixed和setprecision的作用还在，依然显示12.3457</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::fixed); <span class="comment">// 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">6</span>); <span class="comment">// 恢复成原来的样子，输出为12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">3e2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f2="</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看字符型变量对应的ASCII码 a-97  A-65</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ch = <span class="number">97</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据的输入</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入字符串变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算术运算符</strong>：加+  减-  乘*  除/<br>            取模（取余）%  只有整型变量可以进行取模运算<br>需要注意：<br>1.进行运算的变量类型，如两个整型相除结果仍是整数<br>2.除数不能为0，取模运算除数也不能为0<br>3.只有整型变量可以进行取模运算，小数不可以</p><p><strong>赋值运算符</strong>：用于将表达式的值赋给变量<br>赋值=   加等于+=    减等于-=    乘等于*=    除等于/=     模等于%=</p><p><strong>比较运算符</strong>：用于表达式的比较，并返回一个真值或假值<br>相等于==    不等于!=    小于&lt;     大于&gt;     小于等于&lt;=    大于等于&gt;=</p><p><strong>逻辑运算符</strong>：用于根据表达式的值返回真值或假值<br>非!     与&amp;&amp;     或||</p><p>要注意<strong>运算符</strong>的优先级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a2=11, b2=110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// a3=11, b3=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较运算符</span></span><br><span class="line"> a = <span class="number">10</span>;</span><br><span class="line"> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a != b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构<br>1.顺序结构：程序按顺序执行，不发生跳转<br>2.选择结构：依据条件是否满足，有选择的执行相应功能<br>3.循环结构：依据条件是否满足，循环多次执行某段代码</p><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a><strong>选择结构</strong></h4><p><strong>if语句：</strong><br>1.单行格式if语句：if (条件) { 条件满足执行的语句}<br>2.多行格式if语句：if (条件) { 条件满足执行的语句}  else{条件不满足执行的语句}<br>3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}<br>4.嵌套if语句<br>注意：if条件后面不要加分号</p><p><strong>三目运算符</strong>：实现简单的判断<br>语法：表达式1 ? 表达式2 : 表达式3<br>解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果<br>      如果表达式1的值为假，执行表达式3，并返回表达式3的结果<br>注意：C++中三目运算符返回的是变量，可以继续赋值</p><p><strong>switch语句</strong>：执行多条件分支语句<br>语法：switch(表达式)<br>{<br>    case 结果1：执行语句;break;<br>    case 结果2：执行语句;break;<br>    …<br>    default:执行语句;break;<br>}<br>注意：1. <code>switch</code>语句中的表达式的数据类型只能是整型或字符型</p><pre><code>        2. case里如果没有break，那么程序会一直向下执行        3.对于多条件判断，switch的结构清晰，执行效率高</code></pre><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>while循环结构</strong>：满足循环条件，执行循环结构<br>  语法：while (循环条件) {循环结构}<br>  注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环</p><p><strong>do … while循环语句</strong>：满足循环条件，执行循环语句<br>  语法：do {循环语句} while (循环条件)<br>  注意：do…while先执行一次循环语句，再判断循环条件</p><p><strong>for 循环语句</strong>：满足循环条件<br>  语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句}<br>  注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体</p><p><strong>嵌套循环</strong></p><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p><strong>break 语句</strong>：用于跳出选择结构或者循环结构<br>  使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch<br>                         出现在循环语句中，作用是跳出当前的循环语句<br>                         出现在嵌套循环中，跳出最近的内层循环结构</p><p><strong>continue语句</strong>：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环<br>  注意：continue不会使循环终止，而break会跳出循环</p><p><strong>goto语句</strong>：可以无条件跳转语句<br>  语法：goto 标记<br>             如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br>  注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//嵌套if语句</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了北大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了清华"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了人大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三目运算符</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">0</span>;</span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;         <span class="comment">//b=100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//a=10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//b=100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套循环体</span></span><br><span class="line"><span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++的一些基础语法
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>搭建自己的博客</title>
    <link href="http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-18T03:08:31.000Z</published>
    <updated>2020-01-18T05:42:11.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h1><p>GIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a>，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。</p><h1 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h1><p>在官网选择LTS版本下载安装即可：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>。</p><h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h1><p>在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>启动服务：依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm stall</span><br><span class="line">hexo s</span><br><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>之后每次更新博客内容后都要执行 hexo c —&gt;hexo g —&gt;hexo d，来重新部署。</p><h1 id="4-将Hexo部署到GitHub"><a href="#4-将Hexo部署到GitHub" class="headerlink" title="4.将Hexo部署到GitHub"></a>4.将Hexo部署到GitHub</h1><p>在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.1.jpg" alt="1.1" style="zoom:67%;"></p><p>回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>创建SSH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>打开提示已经创建好的.ssh文件夹，其中<code>id_rsa</code>是私人密钥，<code>id_rsa.pub</code>是公共密钥。在GitHub中打开setting —&gt; New SSH key，将<code>id_rsa.pub</code>里面的信息复制进去。</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.2.jpg" alt="1.2" style="zoom: 50%;"></p><p>在blog文件夹中打开博客配置文件<code>_config.yml</code>，将最后几行修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装deploy-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后重新部署博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这样就可以在  <a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a>  访问自己的博客了。</p><h1 id="5-设置主题"><a href="#5-设置主题" class="headerlink" title="5.设置主题"></a>5.设置主题</h1><p>我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在<code>blog</code>文件夹下右键GIt Bash Here，下载主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>打开<code>blog</code>目录下的博客站点配置文件<code>_config.yml</code>，在开头的<code>Site</code>中添加自己博客的信息，注意将<code>language</code>改为<code>zh-CN</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: # 标题</span><br><span class="line">subtitle: # 副标题</span><br><span class="line">description: # 站点描述</span><br><span class="line">author: # 作者</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>往下拉，将<code>theme</code>改为<code>next</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>重新部署博客即可看到主题已经替换。</p><p>接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。</p><h3 id="设置scheme"><a href="#设置scheme" class="headerlink" title="设置scheme"></a>设置scheme</h3><p>在<code>\blog\themes\next</code>文件夹中打开主题配置文件<code>_config.yml</code>，找到外观<code>scheme</code>，想使用哪一种就把前面的注释符#去掉，我选用的是<code>Mist</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在主题配置文件<code>_config.yml</code>中找到菜单<code>menu</code>，将需要的项前的#去掉，我保留了<code>about</code>关于，<code>categories</code>分类，<code>tags</code>标签，<code>archives</code>归档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>创建菜单需要的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>在<code>\blog\source</code>下就会生成对应的文件夹，打开其中的<code>index.md</code>文件，将type设置为相应的内容，以<code>about</code>为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: about</span><br><span class="line">date: 2020-01-17 20:16:07</span><br><span class="line">type: &quot;about&quot; </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="设置背景动画"><a href="#设置背景动画" class="headerlink" title="设置背景动画"></a>设置背景动画</h3><p>在主题配置文件<code>_config.yml</code>中找到<code>Animation Settings</code>，我使用的是<code>Canvas-nest</code>，将<code>Canvas-nest</code>下的enable状态改为true即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # Display on mobile or not</span><br></pre></td></tr></table></figure><p>——————————————————————————</p><p>到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。</p><p>2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。</p>]]></content>
    
    <summary type="html">
    
      最近想搭建一个自己的博客来记录一下学习过程，也能起到一定的督促作用，于是从网上找了一些教程学习了如何用Hexo+GitHub来搭建个人博客，下面记录一下搭建的过程。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://nekomoon404.github.io/2020/01/12/hello-world/"/>
    <id>http://nekomoon404.github.io/2020/01/12/hello-world/</id>
    <published>2020-01-12T07:14:03.207Z</published>
    <updated>2020-01-12T07:14:03.207Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
