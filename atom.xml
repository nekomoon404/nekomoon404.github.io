<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-02-06T16:01:22.154Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法（1）</title>
    <link href="http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</id>
    <published>2020-02-05T02:32:06.000Z</published>
    <updated>2020-02-06T16:01:22.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>对象：规律，技巧</p><p>目标：高效，低耗</p><p>Computer science should be called called computing science, for the same reason why surgery is not called knife science.</p><p>-E.Dijkstra</p><ul><li>计算 = 信息处理</li></ul><p>​       借助某种工具，遵照一定规则，以明确而机械的形式进行</p><ul><li>计算模型 = 计算机 = 信息处理工具</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>所谓算法，即特定计算模型下，旨在解决特定问题的指令序列</p><p>​        输入：待处理的信息（问题）</p><p>​        输出：待处理的信息（答案）</p><p>​    正确性：的确可以解决指定的问题</p><p>​    确定性：任一算法都可以描述为一个由基本操作组成的序列</p><p>​    可行性：每一基本操作都可以实现，且在常数时间内完成</p><p>​    有穷性：任一算法在执行有限次基本操作之后终止并给出输出</p><ul><li>列子：Hailstone序列</li></ul><script type="math/tex; mode=display">\begin{align*}& 序列Hailstone(n)=\begin{cases}\{1\}     &n\le1\\\{n\}\cup Hailstone(n/2) &n为偶数\\\{n\}\cup Hailstone(3n+1) &n为奇数\end{cases}\\\\&Hailstone(42)=\{ 42,21,64,32,\dots,1\}\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hailstone</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//计算序列Hailstone(n)的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>; <span class="comment">//从1开始递推</span></span><br><span class="line">    <span class="keyword">while</span> (n&lt;<span class="number">1</span>) &#123; (n % <span class="number">2</span>) ? n = <span class="number">3</span> * n + <span class="number">1</span> : n / = <span class="number">2</span>; lenth++; &#125;</span><br><span class="line">    <span class="keyword">return</span> length; <span class="comment">//返回hailstone(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：对于任意的n，总有|Hailstone(n)| &lt;  ∞ ？</p><p>目前还不能证明</p><ul><li>程序不一定是算法</li></ul><h2 id="好算法"><a href="#好算法" class="headerlink" title="好算法"></a>好算法</h2><p>正确：符合语法，能够编译，链接</p><p>​           能够正确处理简单的，大规模的，一般性的，退化的，任意合法的输入</p><p>健壮：能辨别不合法的输入并做适当处理，而不致非正常退出</p><p>可读性：结构化  + 准确命名 + 注释 + …</p><p><strong>效率</strong>：<strong>速度尽可能快 ；存储空间尽可能少</strong>   （最重要的）</p><p>​           Algorithms + Data Structures = Programs         -N. Wirth, 1976</p><p>​          (Algorithms + Data Structures) × Efficiency = Computation</p><h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>好的数据结构和算法才能有高效的计算，从而有好的应用。         </p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>两个主要方面：</p><p>​        正确性：算法功能与问题要求一致？</p><p>​                        数学证明？并不简单</p><p>​        <strong>成本</strong>：    <strong>运行时间</strong>+所需存储空间</p><p>​                        如何度量？如何比较？</p><p>考察：$T_A(P)$ = 算法A求解问题实例P的计算成本。</p><p>​           意义不大，因为可能出现的问题实例太多。那么如何归纳概括？</p><p>观察：问题实例的<strong>规模</strong>，往往是决定计算成本的主要因素。</p><p><strong>特定算法 + 不同实例</strong></p><ul><li>令$T_A(n)$ = 用算法A求解某一问题规模为n的实例，所需的计算成本。</li></ul><p>​         讨论特定算法A（及其对应的问题）时，简记作$T(n)$。</p><ul><li><p>然而这一定义仍有问题，同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别。</p></li><li><p>稳妥起见，取$T(n) = max{ T(P)| |P| = n }$，亦即，在规模同为n 的所有实例中，只关注最坏（成本最高）的实例。</p></li></ul><p><strong>特定问题 + 不同算法</strong></p><ul><li>同一问题通常有多种算法，如何评判其优劣？</li><li>实验统计是最直接的方法，但足以准确反映算法的真正效率？</li><li>但实验统计还是不足够的，还要考虑：<ul><li>不同的算法，可能更适应于不同规模的输入</li><li>不同的算法，可能更适应 与不同类型的输入</li><li>同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现</li><li>同一算法，可能实现并运行与不同的体系结构、操作系统</li></ul></li><li>为给出客观的评判，需要抽象出一个理想的平台或模型<ul><li>不再依赖于上述种种具体的因素</li><li>从而直接而准确地描述，测量并评价算法</li></ul></li></ul><h2 id="图灵机-Turing-Machine"><a href="#图灵机-Turing-Machine" class="headerlink" title="图灵机 Turing Machine"></a>图灵机 Turing Machine</h2><ul><li>Tape：依次均匀地划分为单元格，各注有某一字符，默认为’#’</li><li>Alphabet：字符的种类有限</li><li>Head：总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格</li><li>State：TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态</li><li>Transition Function ：（q,  c;  d,  L/R,  P)</li></ul><p>​        若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；</p><p>​        转入p状态，一旦转入特定的状   态’h’，则停机。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205112701.png" alt="QQ图片20200205112701" style="zoom:67%;"></p><h2 id="RAM-Random-Access-Machine"><a href="#RAM-Random-Access-Machine" class="headerlink" title="RAM:  Random Access Machine"></a>RAM:  Random Access Machine</h2><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114006.png" alt="QQ图片20200205114006" style="zoom:67%;"></p><p>与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台，对算法的效率做出可信的比较与评判。</p><p>在这些模型中：</p><ul><li>算法的运行时间   转化为   算法需要执行的基本操作次数</li><li>$T(n)$  =  算法为求解规模为n的问题，所需执行的基本操作次数</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205114827.png" style="zoom:67%;"></p><h1 id="大-O-记号"><a href="#大-O-记号" class="headerlink" title="大$O$记号"></a>大$O$记号</h1><h2 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h2><ul><li>回到原先的问题：随着问题规模的增长，计算成本如何增长？</li></ul><p>​        注意：这里更关心足够大的问题，注重考察成本的增长趋势</p><ul><li>渐进分析：在问题规模足够大后，计算成本如何增长？</li></ul><p>​       Asymptotic analysis：当n&gt;&gt;2后，对于规模为n输入，算法</p><p>​               需执行的基本操作次数：T(n) = ?</p><p>​               需占用的存储单元数：S(n) = ?         //通常可不考虑</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205124613.png" style="zoom:50%;"></p><h2 id="大-O-记号（big-O-notation）"><a href="#大-O-记号（big-O-notation）" class="headerlink" title="大$O$记号（big-$O$ notation）"></a>大$O$记号（big-$O$ notation）</h2><script type="math/tex; mode=display">\begin{align*}&T(n)=O(\,f(n)\,)\quad if \quad \exists c>0, 当n>>2后，有T(n)<c\cdot f(n)\\\\&例如：\sqrt{5n\cdot[3n\cdot(n+2)+4]+6}<\sqrt{5n\cdot[6n^2+4]+6}<\sqrt{35n^3+6}<6\cdot n^{1.5}=O(n^{1.5})\end{align*}</script><p>与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势</p><ul><li>常系数可忽略：$O(\,f(n)\,)=O(c\times \,f(n)\,)$</li><li>低次数可忽略：$O(n^a+n^b)=O(n^2),\,a&gt;b&gt;0$</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205130742.png" alt="QQ图片20200205130742" style="zoom: 50%;"></p><p><strong>其它记号</strong>：</p><ul><li>$T(n)=\Omega(\,f(n)\,)$：</li></ul><p>​       $ \exists c&gt;0, 当n&gt;&gt;2后，有T(n)&lt;c\cdot f(n)$</p><ul><li>$T(n)=\Theta(\,f(n)\,)$：</li></ul><p>​       $ \exists c_1&gt;c_2&gt;0, 当n&gt;&gt;2后，有c_1\cdot f(n)&gt;T(n)&gt;c_2\cdot f(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200205131613.png" style="zoom:50%;"></p><h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>下面讨论大$O$记号的几种”刻度“：</p><p><strong>$O(1)$</strong></p><ul><li><p>常数（constant function）</p><p>$2=2013=2013\times 2013=O(1)$，甚至$2013^2013=O(1)$</p></li><li><p>这类算法的效率最高</p></li><li><p>什么样的代码对应于常数执行时间？</p><p>一般地，不含循环；不含分支转向；不能有（递归）调用，应具体问题具体分析</p></li></ul><p><strong>$O(log^c n)$</strong></p><ul><li>对数$O(log^c n)$</li><li>常底数无所谓</li></ul><p>​       $\forall a,b&gt;0,\,log_an=log_ab\cdot log_bn=\Theta(logn)$</p><ul><li>常数次幂无所谓</li></ul><p>​       $\forall c&gt;0,\,logn^c=c\cdot logn=\Theta(logn)$</p><ul><li><p>对数多项式（ploy-log function）</p><p>$123\cdot log^{321}n+log^{105}(n^2-n+1)=\Theta(log^{321}n)$</p></li><li><p>这类算法非常有效，复杂度无限接近于常数</p><p>$\forall c&gt;0,\,logn=\Theta(n^c)$</p></li></ul><p><strong>$O(n^c)$</strong></p><ul><li><p>多项式（polynomial function）</p><p>$(100n-500)(20n^2-300n+2013)=O(n\times n^2)=O(n^3)$</p><p>一般地，$a<em>kh^k+a</em>{k-1}n^{k-1}+\dots+a_1n+a_0=O(n^k),\,a_k&gt;0$</p></li><li><p>线性（linear function）：所有$O(n)$函数</p></li><li><p>这门课主要覆盖的范围：从$O(n)$到$O(n^2)$</p></li><li><p>这类算法的效率通常认为已可令人满意</p></li></ul><p><strong>$O(2^n)$</strong></p><ul><li>指数（exponential function）：$T(n)=a^n$</li><li>$\forall c&gt;1,\,n^c=O(2^n);\,n^{1000}=O(1.00001^n)=O(2^n);\,1.00001^n=\Omega(n^{1000})$</li><li>这类算法的计算成本增长极快，通常被认为不可忍受</li><li>从$O(n^c)$到$O(2^n)$，是从有效算法到无效算法的分水岭</li><li>很多问题的$O(2^n)$算法往往显而易见，然而设计出$O(n^c)$算法却极为不易，甚至有时注定只能是徒劳无功。</li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100203.png" style="zoom:50%;"></p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206100207.png" style="zoom:50%;"></p><p><strong>例子</strong>：2-Subset</p><p>S包含n个正整数，$\sum S=2m$，S是否有子集T，满足$\sum T=m$？</p><ul><li>直觉算法：逐一枚举S的每一个子集，并统计其元素的总和</li><li>定理：$|2^s|=2^{|s|}=2^n$，亦即直觉算法需要迭代$2^n$轮，并（在最坏情况下）至少需要花费这么多时的间</li><li>但实际上上述的直觉算法已属最优解，就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法。</li><li>2-Subset is NP-complete</li></ul><h1 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h1><p>两个主要任务 = 正确性（不变形 × 单调性） + 复杂度</p><p>那么为了确定复杂度，真地需要将算法描述为RAM的基本指令，再统计累计的执行次数嘛？答案是不必的。</p><p>C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当：</p><ul><li>分支转向：goto   //算法的灵魂，出于结构化考虑，被隐藏了</li><li>迭代循环：for( )、while( )……  //本质上就是 if + goto</li><li>调用 + 递归（自我调用）  //本质上也是goto</li></ul><p>复杂度分析的主要方法：</p><ul><li>迭代：级数求和</li><li>递归：递归跟踪 + 递推方程</li><li>猜测 + 验证</li></ul><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><ul><li>算数级数：与末项平方同阶</li></ul><p>​       $T(n)=1+2+\dots +n=n(n+1)/2=O(n^2)$</p><ul><li>幂方级数：比幂次高出一阶</li></ul><p>​       $\sum_{k=0}^nk^d\approx \int_0^n x^{d+1}dx=\frac{1}{d+1}x^{d+1}\mid_0^n=\frac{1}{d+1}n^{d+1}=O(n^{d+1})$</p><p>​       $T_2(n)=1^2+2^2+3^2+\dots+n^2=n(n+1)(2n+1)/6=O(n^3)$</p><p>​       $T_3(n)=1^3+2^3+3^3+\dots+n^3=n^2(n+1)^2/4=O(n^4)$</p><ul><li>几何级数（a&gt;1）：与末项同阶</li></ul><p>​       $T_a(n)=a^0+a^1+\dots+a^n=(a^{n+1}-1)/(a-1)=O(a^n)$</p><p>​       $1+2+4+\dots+2^n=2^{n+1}-1=O(2^{n+1})=O(2^n)$</p><ul><li>收敛级数</li></ul><p>​       $1/2/2+1/2/3+1/3/4+\dots+1/(n-1)/n=1-1/n=O(1)$</p><p>​       $1+1/2^2+\dots+1/n^2&lt;1+1/2^2+\dots=\pi^2/6=O(1)$</p><p>​       $1/3+1/7+1/8+1/15+/24+1/26+1/31+1/35+\dots=1=O(1)$</p><p>​       实际上讨论这类分数级数是有必要的，因为在某种意义上，基本操作次数，存储单元数可以看作是分数，例如将某个循环条件执行的概率设为$\lambda$，则其数学期望为：</p><p>​        $(1-\lambda)\cdot[1+2\lambda+3\lambda^2+4\lambda^3+\dots]=1/(1-\lambda)=O(1)，0&lt;\lambda&lt;1$</p><ul><li>某些不收敛但长度有限的级数</li></ul><p>​       $h(n)=1+1/2+1/3+\dots+1/n=\Theta(logn)$                     调和级数</p><p>​       $log1+log2+log3+\dots+logn=log(n!)=\Theta(nlogn)$      对数级数</p><h2 id="循环与级数"><a href="#循环与级数" class="headerlink" title="循环与级数"></a>循环与级数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=n+n+\dots+n=n\cdot n=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131334.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>算术级数：$\sum_{i=0}^{n-1}=0+1+\dots+(n-1)=\frac{n(n-1)}{2}=O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131338.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j+=<span class="number">2013</span>)</span><br></pre></td></tr></table></figure><p>算术级数：$O(n^2)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131342.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i&lt;&lt;=<span class="number">1</span>)  <span class="comment">// i&lt;&lt;=1 左移一位，相当于乘2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br></pre></td></tr></table></figure><p>几何级数：$1+2+4+\dots+2^{[log<em>2(n-1)]}=\sum</em>{k=0}^{[log_2(n-1)]}2^k=2^{[log_2(n-1)]}-1=n-1=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206131345.png" style="zoom:67%;"></p><h2 id="取非极端元素"><a href="#取非极端元素" class="headerlink" title="取非极端元素"></a>取非极端元素</h2><p>问题：给定整数子集S，|S| = n &gt;=3，找出元素$a\in S,a\ne max(S)，且 a\ne min(S)  $</p><p>算法：从S中任取三个元素{x, y, z}  //若S以数组形式给出，不妨取前三个；由于S是集合，这三个元素必互异</p><p>​            确定并排除其中的最小者，最大者  //不妨设 x = max{x, y, z},  y = min{x, y, z}</p><p>​            输出剩下的元素z</p><p>无论输入规模n多大，上述算法需要的执行时间不变</p><p>​            $T(n)=常数=O(1)=\Omega(1)=\Theta(1)$</p><h2 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h2><p><strong>问题</strong>：给定n个整数，将它们按非降序排列</p><p><strong>观察</strong>：有序/无序序列中，任意/总有一对相邻元素顺序/逆序</p><p><strong>扫描交换</strong>：依次比较每一对相邻元素，如有必要，交换之；若整趟扫描都没有进行交换，则排序完成；否则，再做一趟交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">bool</span> sorted = <span class="literal">false</span>; sorted = !sorted; n--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">           <span class="keyword">if</span>(A[i<span class="number">-1</span>] &gt; A[i])&#123;</span><br><span class="line">               swap(A[i<span class="number">-1</span>],A[i]);</span><br><span class="line">               sorted = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑算法的正确性</p><p>问题：该算法必然会结束？至多需迭代多少趟？</p><p><strong>不变性</strong>：经k轮扫描交换后，最大的k个元素必然就位</p><p><strong>单调性</strong>：经k轮扫描交换后，问题规模缩减至n-k</p><p><strong>正确性</strong>：经至多n趟扫描后，算法必然终止，且能给出正确答案</p><p><strong>通过挖掘并且综合算法的不变性和单调性，进而证明算法正确性</strong>的方法是算法分析中的一个基本且重要的方法。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206133211.png" style="zoom: 67%;"></p><h2 id="封底估算"><a href="#封底估算" class="headerlink" title="封底估算"></a>封底估算</h2><p>除了大$O$记号这种定性的方法，我们在很多时候也需要定量的估算，一种常用的方法是封底估算（Back-of-the-Envelope Calculation）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206134004.png" style="zoom:67%;"></p><h1 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h1><p>To iterate is human, to recurse, divine.</p><p><strong>例子</strong>：<strong>数组求和（迭代）</strong></p><p>问题：计算任意n个整数之和</p><p>实现：逐一取出每个元素，累加之</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumI</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论A[ ]内容如何，都有时间复杂度为：</p><p>​        $T(n)=1+n*1+1=n+2=O(n)=\Omega(n)+\Theta(n)$</p><p>如果把输入参数中的n看作是这个问题的规模，其中最重要的循环部分，每经过一次迭代，有一个数已经统计完毕，而相应的尚未参与统计的元素，即尚未解决的问题的规模就会递减一个元素，这种通过不断削减问题的有效规模的方法就是减而治之。</p><h2 id="减而治之（Decrease-and-conquer）"><a href="#减而治之（Decrease-and-conquer）" class="headerlink" title="减而治之（Decrease-and-conquer）"></a>减而治之（Decrease-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为两个子问题：其一平凡易解，另一规模缩减；分别求解子问题；由子问题的解，得到原问题的解。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206174923.png" style="zoom:67%;"></p><h3 id="数组求和：线性递归"><a href="#数组求和：线性递归" class="headerlink" title="数组求和：线性递归"></a>数组求和：线性递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>) ? <span class="number">0</span> : sum(A, n<span class="number">-1</span>) + A[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归跟踪</strong>（recursion trace）分析：</li></ul><p>​       检查每个递归实例；累计所需时间（调用语句本身，计入对应的子实例）；其总和即算法执行时间</p><ul><li>本例中，单个递归实例自身只需$O(1)$时间</li></ul><p>​        $T(n)=O(1)*(n+1)=O(n)$</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206181824.png" style="zoom:67%;"></p><ul><li>从<strong>递推</strong>的角度看，为求解<code>sum(A, n)</code>，需要</li></ul><p>​                递归求解规模为n-1的问题<code>sum(A,n-1)</code>           //T(n-1)</p><p>​                再累加上A[n-1]                                                   //$O(1)$</p><p>​                递归基：<code>sum(A, 0)</code>                                          //$O(1)$</p><ul><li>递推方程：$T(n)=T(n-1)+O(1)$                     //recurrence</li></ul><p>​                          $T(0)=O(1)$                                            //base</p><ul><li>求解：       $T(n)-n=T(n-1)-(n-1)=\dots=T(2)-2=T(1)-1=T(0)$</li></ul><p>​                          $T(n)=O(1)+n=O(n)$</p><h3 id="数组倒置"><a href="#数组倒置" class="headerlink" title="数组倒置"></a>数组倒置</h3><p>任给数组A[n]，将其前后颠倒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo &lt; hi)</span><br><span class="line">&#123;</span><br><span class="line">swap(A[lo], A[hi]);</span><br><span class="line">reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由递推方程：$T(n)=T(n-2)+O(1)$可得其时间复杂度为：$O(n)$。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206184350.png" style="zoom:67%;"></p><h2 id="分而治之（Divide-and-conquer）"><a href="#分而治之（Divide-and-conquer）" class="headerlink" title="分而治之（Divide-and-conquer）"></a>分而治之（Divide-and-conquer）</h2><p>为求解一个大规模的问题，可以将其划分为若干个（通常两个）子问题，规模大体相当；分别求解子问题；由子问题的解，得到原问题的解</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201250.png" style="zoom:67%;"></p><h3 id="数组求和：二分递归"><a href="#数组求和：二分递归" class="headerlink" title="数组求和：二分递归"></a>数组求和：二分递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> A[lo];</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(A,lo,mi) + sum(A,mi+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206201640.png" style="zoom:67%;"></p><p>该算法的正确性毋庸置疑，接下来分析其时间复杂度：</p><ul><li>从<strong>递归跟踪</strong>的角度：</li></ul><p>​       $T(n)=各层递归实例所需时间之和=O(1)\times(2^0+2^1+2^2+\dots+2^{logn})=O(n)$</p><p>​     （几何级数的时间复杂度与末项同阶）</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206202116.png" style="zoom: 67%;"></p><ul><li><p>从<strong>递推</strong>的角度：为求解<code>sum(A, lo, hi)</code>，需要</p><p>​        递归求解<code>sum(A, lo, mi)</code>和<code>sum(A, mi+1, hi)</code> ；进而将子问题的解累加</p></li></ul><p>​               递归基：<code>sum(A, lo, lo)</code></p><p>​        递推关系：$T(n)=2*T(n/2)+O(1)$</p><p>​                           $T(1)=O(1)$</p><p>​        求解：        $T(n)=O(n)$</p><h2 id="Max2"><a href="#Max2" class="headerlink" title="Max2"></a>Max2</h2><p>从数组区间A[lo, hi)中找出最大的两个整数A[x1]和A[x2]，元素比较的次数，要求尽可能地少.</p><h3 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206204203.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x1 = lo; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[i]) x1 = i;                  <span class="comment">//hi-lo-1 = n-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>, x2 = lo; i &lt; x1; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//x1-lo-1次比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x1 + <span class="number">1</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i]) x2 = i;                  <span class="comment">//hi-x1-1次比较      </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何，该算法的比较次数总是$\Theta(2n-3)$</p><h3 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206205752.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])  swap(x1, x2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">2</span>; i &lt; hi; i++)</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[i])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = i])</span><br><span class="line">swap(x1,x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：$1+(n-2)\times1=n-1$</p><p>最坏情况：$1+(n-2)\times2=2n-3$；就最坏的情况而言，这种算法并没有改进</p><h3 id="递归-分治"><a href="#递归-分治" class="headerlink" title="递归+分治"></a>递归+分治</h3><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206210400.png" style="zoom:67%;"></p><p>将数组二分为左侧和右侧两部分，分别找出最大值和次大值，再进行比较；每一侧又可以继续二分，实现递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> &amp;x1, <span class="keyword">int</span> &amp;x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">2</span> == hi)&#123;                          <span class="comment">//T(2) = 1</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (lo + <span class="number">3</span> == hi)&#123;                          <span class="comment">//T(3) &lt;= 3</span></span><br><span class="line"><span class="keyword">if</span> (A[x1 = lo] &lt; A[x2 = lo + <span class="number">1</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">if</span> (A[x2] &lt; A[lo + <span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> (A[x1] &lt; A[x2 = lo + <span class="number">2</span>])</span><br><span class="line">swap(x1, x2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;                                </span><br><span class="line"><span class="keyword">int</span> mi = (lo + hi) / <span class="number">2</span>;    <span class="comment">//divide</span></span><br><span class="line"><span class="keyword">int</span> x1L, x2L;  max2(A, lo, mi, x1L, x2L);</span><br><span class="line"><span class="keyword">int</span> x1R, x2R;  max2(A, mi, hi, x1R, x2R);</span><br><span class="line"><span class="keyword">if</span> (A[x1L] &gt; A[x1R]) &#123;</span><br><span class="line">x1 = x1L;</span><br><span class="line">x2 = (A[x2L] &gt; A[x1R]) ? x2L : x1R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x1 = x1R;</span><br><span class="line">x2 = (A[x1L] &gt; A[x2R]) ? x1L : x2R;</span><br><span class="line">&#125;     <span class="comment">//1 + 1 = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度：$T(n)=2*T(n/2)+2\le5n/3-2$</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>Make it work, make it right, make it fast.</p><p>前两步work和right可以通过递归解决，而最后一步fast可以通过迭代解决。</p><h2 id="斐波那契数列fib"><a href="#斐波那契数列fib" class="headerlink" title="斐波那契数列fib( )"></a>斐波那契数列fib( )</h2><p>$fib(n)  = fib(n-1) + fib(n-2) : {0, 1, 1, 2, 3, 5, 8, ……}$</p><h3 id="fib-：递归"><a href="#fib-：递归" class="headerlink" title="fib( )：递归"></a>fib( )：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>&gt;n) ? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当n较大时，这个递归算法的计算是很慢的，其<strong>时间复杂度</strong>为：</p><p>$T(0)=T(1)=1;\,T(n)=T(n-1)+T(n-2)+1,\,n&gt;1$</p><p>令：$S(n)=[T(n)+1]/2$</p><p>则：$S(0)=1=fib(1),\,S(1)=1=fib(2)$</p><p>故：$S(n)=S(n-1)+S(n-2)=fib(n+1)$</p><p>​        $T(n)=2<em>S(n)-1=2</em>fib(n+1)-1=O(fib(n+1))=O(\Phi^n)=O(2^n)$  ，</p><p>其中：$\Phi=\frac{1+\sqrt{5}}{2}=1.61803…$，即黄金分割数</p><p>可见该算法的时间复杂度和fib数列的n+1项的值是一个量级的。</p><p>接着对这个$O(\Phi^n)$进行较准确的估算，用<strong>封底估算</strong>的方法有：</p><p>$\Phi^{36}=2^{25},\,\Phi^{43}=2^{30}=10^9flo=1sec$</p><p>$\Phi^{5}=10,\,\Phi^{67}=10^14flo=10^5sec$</p><p>$\Phi^{92}=10^{19}flo=10^{10}sec=10^5day=3century$</p><p>可见这并不是一个好方法。</p><p>从<strong>递归跟踪</strong>的角度来分析：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206221339.png" style="zoom:67%;"></p><p>递归版<code>fib( )</code>低效的根源在于，各地鬼实例均被大量重复地调用</p><p>那么可以使每个实例只能调用一次嘛？答案是可以的。先后出现的递归实例，供给$O(\Phi^n)$个，而去除重复之后，总共不过$O(n)$种。</p><h3 id="fib-：迭代"><a href="#fib-：迭代" class="headerlink" title="fib( )：迭代"></a>fib( )：迭代</h3><p>解决方法A（<strong>记忆</strong>：memoization）：</p><p>​        将已计算过实例的结果指标备查。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206222400.png" style="zoom: 50%;"></p><p>解决方法B（动态规划：dynamic programming）：</p><p>​        颠倒计算方向，由自顶而下递归，改为自底而上迭代。不妨用两个变量f和g，分别来记忆当前我所处的相邻的两个数。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206223053.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;   <span class="comment">//fib(0), fib(1)</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">0</span> &lt; n--)&#123;</span><br><span class="line">    g = g + f;</span><br><span class="line">    f = g - f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了一个循环，没有其他增加时间复杂度的操作，而且只需要f和g两个存储单元。</p><p>$T(n)=O(n)$，而且仅需要$O(1)$空间！</p><h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p><strong>子序列（Subsequence）</strong>：由序列中若干字符，按原相对次序构成（线不能有交叉）。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224303.png" style="zoom:67%;"></p><p><strong>最长公共子序列（Longest Common Subsequence）</strong>：两个序列公共子序列中的最长者。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206224308.png" style="zoom:67%;"></p><p>现在考虑一个较简单的问题：如何计算出任意给出的两个序列的最长公共子序列的长度？</p><h3 id="LCS：递归"><a href="#LCS：递归" class="headerlink" title="LCS：递归"></a>LCS：递归</h3><p>对于序列A[0, n]和B[0, m]，LCS(A, B)无非三种情况</p><p>0）若n = -1 或 m = -1，则取空序列（“ ”）                                      //递归基</p><p>1）若A[n] = ‘X’ = B[m]，则取作LCS( A[0, n),  B[0, m) ) + ‘X’          // 减而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230441.png" style="zoom: 67%;"></p><p>2）若A[n] $\ne$ B[m]，则分别计算LCS( A[0, n],  B[0, m) )，与LCS( A[0, n),  B[0, m] )，取更长者。 //分而治之</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206230523.png" style="zoom:67%;"></p><p>我们把上述算法中生成的所有递归实例绘制成一个表，每一个横纵坐标所确定的3×3的小方格所组成的一个大方格分别对应于一个子任务或者说是递归实例，可以看到如果是减而治之的情况，对应大方格中的一条对角线；如果是分而治之的情况，则会考虑左侧和上方的子问题，然后取更长者，保留其对应的一条边。</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206231904.png" style="zoom:67%;"></p><p>这样的形式可以帮助我们理解整个计算的过程，在这样一张表中我们最终求解的问题必然是右下角的方格对应的子问题，它分别会递归地引发一些更小的子问题，最终收缩到平凡的长度为0的子问题；我们也可以认为，每一个LCS问题的解都是从左上角(0,0)的单元开始一直沿着可行的深色的线通往右下角单元的路径，每一条路径就对应着一个解，这样就能很好地理解多解的情况。</p><p>接下来分析该算法的正确性和时间复杂度：</p><ul><li><p><strong>单调性</strong>：无论如何，每经过一次比对，原问题的规模必可减小。具体地，作为输入的两个序列，至少其一的长度缩短一个单位。</p></li><li><p><strong>最好情况</strong>（不出现情况2））下，只需$O(n+m)$时间（线性规模）</p></li><li>但问题在于，在情况2）下原问题将分解为两个子问题，更糟糕的是，它们在随后进一步导出的子问题，可能<strong>雷同</strong>，与<code>fib( )</code>的递归出现的问题类似，这种重复度往往是超出我们直观想象的。</li></ul><p>​       我们将上面的图表进行局部放大：</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206233230.png" style="zoom:67%;"></p><p>为了进行更好的估算，我们不妨从更宏观的角度来重新审视上面的表格，不妨把其中所有的递归实例分别按坐标的形式表示为(n, m)，那么为了计算出最终的递归实例即(n, m)对应的解，我们需要唤醒某一个特定的递归实例(a. b)多少次呢？</p><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206234248.png" style="zoom:67%;"></p><p>根据图表中路线行进的方向，在最坏的情况下所唤醒的次数应该等于介于这两点之间的通路的条数，每一条通路对应于(a, b)被唤醒一次，即为两点之间所有合法的通路的总长n+m-a-b中挑选出n-a条水平路径的方案数，或挑选出m-b条垂直路径的方案数。</p><p>那么在最坏情况下，LCS( A[0, a],  B[0, b] )出现的次数为：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m-a-b\\n-a\end{pmatrix}=\begin{pmatrix}n+m-a-b\\m-b\end{pmatrix}</script><p>特别地，LCS( A[0],  B[0] )出现的次数多达：</p><script type="math/tex; mode=display">\begin{pmatrix}n+m\\n\end{pmatrix}=\begin{pmatrix}n+m\\m\end{pmatrix}</script><p>当$n=m$时，该算法的时间复杂度为：$O(2^n)$。</p><h3 id="LCS：迭代"><a href="#LCS：迭代" class="headerlink" title="LCS：迭代"></a>LCS：迭代</h3><ul><li><p>与<code>fib( )</code>类似，这里也有大量重复的递归实例（子问题），（最坏情况下）先后共计出现$O(2^n)$个</p></li><li><p>各子问题，分别对应于A和B的某个前缀组合，因此总共不过$O(n*m)$种</p></li><li><p>采用动态规划的策略，只需$O(n*m)$时间即可计算出所有子问题</p></li><li><p>为此，我们只需将所有子问题列成一张表，颠倒计算方向，<strong>从LCS( A[0],  B[0] )出发</strong>，依次计算出所有项。</p><p>填表的规则是：首先初始化，行列都设为0，若遇到减而治之，即字母相同，则对应位置元素为其左上对角线元素+1；若遇到分而治之，即字母不相同，则对应位置元素取其上方和左侧元素中的最大值。</p></li></ul><p><img src="/2020/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/QQ图片20200206235750.png" style="zoom:67%;"></p><p>这样对于每一个子问题，只会出现一次，因此算法的时间复杂度为$O(n*m)$。</p>]]></content>
    
    <summary type="html">
    
      开个新坑
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（7）类和对象</title>
    <link href="http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://nekomoon404.github.io/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-02-04T08:09:38.000Z</published>
    <updated>2020-02-04T09:47:51.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="面向对象程序设计的基本特点"><a href="#面向对象程序设计的基本特点" class="headerlink" title="面向对象程序设计的基本特点"></a>面向对象程序设计的基本特点</h2><p><strong>抽象</strong>：对同一类对象的共同属性和行为进行概括，形成类。</p><ul><li>首先注意问题的本质及描述，其次是实现过程或细节。</li><li>数据抽象：描述某类对象的属性或状态（对象相互区别的物理量）。</li><li>代码抽象：描述某类对象的共有的行为特征或具有的功能。</li><li>抽象的实现：类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour, minute, second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装</strong>：将抽象出的数据，代码封装在一起，形成类。</p><ul><li>目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。</li><li>实现封装：类声明中的{ }</li></ul><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174646.png" alt="QQ图片20200204174646" style="zoom: 50%;"></p><p><strong>继承</strong>：在已有类的基础上，进行扩展形成新的类。</p><p><strong>多态</strong>：同一名称，不同的功能实现方式。达到行为标识统一，减少程序中标识符的个数。</p><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>对象是现实中的对象在程序中的模拟；类是同一类对象的抽象，对象是类的实例。定义类的对象，才可以通过对象使用类中定义的功能。</p><p>设计类就是设计类型，需要<strong>关注哪些问题</strong>：</p><ul><li>此类型的“合法值”是什么？</li><li>此类型应该有什么样的函数和操作符？</li><li>新类型的对象该如何被创建和销毁？</li><li>如何进行对象的初始化和赋值？</li><li>对象作为函数的参数如何以值传递？</li><li>谁将使用此类型的对象成员？</li></ul><h3 id="类定义的语法形式"><a href="#类定义的语法形式" class="headerlink" title="类定义的语法形式"></a>类定义的语法形式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">           公有成员（外部接口）</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">           私有成员</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">           保护型成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义类时也可以为数据成员设置类内初始值，用于初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span> newH, <span class="keyword">int</span> newM. <span class="keyword">int</span> newS)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">showTiem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> hour = <span class="number">0</span>, minute = <span class="number">0</span>, second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p><strong>公有类型成员</strong>：在关键字<code>public</code>后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数。</p><p><strong>私有类型成员</strong>：在关键字<code>private</code>后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。如果紧跟在类名称的后面声明私有成员，则关键字<code>private</code>可以省略。如果某个成员前面没有上述关键字，则缺省地被认为是私有成员。</p><p><strong>保护类型成员</strong>：与private类似，其差别表现在继承与派生时对派生类的影响不同。</p><p>类中成员之间直接使用成员名互相访问。</p><p>从类外访问成员使用“ <code>对象名.成员</code>”，来访问公有成员。</p><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>在类中声明函数原型：</p><ul><li>可以直接在类中给出函数体，形成内联成员函数；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>也可以在类外给出函数体实现，并在函数名前用类名加以限定；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个矩形的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rectangle::getArea() &#123; <span class="keyword">return</span> w*h; &#125;</span><br><span class="line"><span class="keyword">int</span> Rectangle::getPerimeter() &#123; <span class="keyword">return</span> <span class="number">2</span>*(w+h); &#125;</span><br></pre></td></tr></table></figure><ul><li>允许声明重载函数和带默认参数值的函数。</li></ul><p><strong>例子</strong>：设计一个圆的类，该类的成员变量为圆心的x轴坐标，y轴坐标，半径长度；该类的成员变量对外都是不可见的；该类的成员函数为：设置圆心坐标，设置圆心半径，计算圆的面积，计算圆的周长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">double</span> r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setM</span><span class="params">(<span class="keyword">double</span> _x, <span class="keyword">double</span> _y)</span> </span>&#123; x = _x; y = _y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">double</span> _r)</span> </span>&#123; r = _r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * r * r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> *r; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Circle myCircle;</span><br><span class="line">myCircle.setM(<span class="number">1.7</span>, <span class="number">3.2</span>);</span><br><span class="line">myCircle.setR(<span class="number">4.2</span>);</span><br><span class="line"><span class="keyword">double</span> myArea = myCircle.getArea();</span><br><span class="line"><span class="keyword">double</span> myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">myCircle.setR(<span class="number">8.4</span>);</span><br><span class="line">myArea = myCircle.getArea();</span><br><span class="line">myPeri = myCircle.getPerimeter();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Area = "</span> &lt;&lt; myArea &lt;&lt; <span class="string">", Perimeter = "</span> &lt;&lt; myPeri &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/Cpp%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/QQ图片20200204174231.png" alt="QQ图片20200204174231" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      设计程序的过程，就是设计类的过程
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（6）结构体与链表</title>
    <link href="http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://nekomoon404.github.io/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-02T09:03:07.000Z</published>
    <updated>2020-02-03T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是一种特殊形态的类，与类的唯一区别是：类的缺省访问权限是<code>private</code>，结构体的缺省访问权限是<code>public</code>。</p><p>那么什么时候用结构体而不用类：定义主要用来保存数据，没没有什么操作的类型。人们习惯将结构体的数据成员设为公有，这时使用结构体更方便。</p><p>结构体相当于构造了一个新的数据类型，用一组变量描述同一个“事物”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;    <span class="comment">//注意大括号后的" ; "</span></span><br></pre></td></tr></table></figure><p>定义结构体变量的方式：</p><ol><li>直接用已声明的结构体类型定义变量名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student student1, student2;</span><br></pre></td></tr></table></figure><ol><li>在声明类型的同时定义变量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stduent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;student1,student2;</span><br></pre></td></tr></table></figure><p>结构体数据类型的特性与普通数据类型的特性是一致的，可以赋值，做函数参数，有指向结构体的指针，结构体数组等等。</p><h2 id="定义结构体类型的变量"><a href="#定义结构体类型的变量" class="headerlink" title="定义结构体类型的变量"></a><strong>定义结构体类型的变量</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">mike.id_num = <span class="number">2123000</span> + mike.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike.name[i] = <span class="built_in">toupper</span>(mike.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202181848.png" alt="QQ图片20200202181848" style="zoom:80%;"></p><h2 id="结构体变量赋值"><a href="#结构体变量赋值" class="headerlink" title="结构体变量赋值"></a><strong>结构体变量赋值</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike1 = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student mike2;</span><br><span class="line">mike2 = mike1;</span><br><span class="line">mike2.id_num = <span class="number">2123000</span> + mike2.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; mike2.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">mike2.name[i] = <span class="built_in">toupper</span>(mike2.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike1.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike1.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mike2.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; mike2.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182213.png" alt="QQ图片20200202182213" style="zoom:80%;"></p><h2 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a><strong>结构体做函数参数</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(student one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">one.id_num = <span class="number">2123000</span> + one.id_num;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; one.name[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">one.name[i] = <span class="built_in">toupper</span>(one.name[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one.id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">renew(mike);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202182733.png" alt="QQ图片20200202182733" style="zoom:80%;"></p><h2 id="指向结构体的指针"><a href="#指向结构体的指针" class="headerlink" title="指向结构体的指针"></a>指向结构体的指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student mike = &#123; <span class="number">123</span>,<span class="string">"mike"</span> &#125;;</span><br><span class="line">student *one = &amp;mike;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202183112.png" alt="QQ图片20200202183112" style="zoom:80%;"></p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id_num;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student myclass[<span class="number">3</span>] = &#123; <span class="number">123</span>,<span class="string">"mike"</span>,<span class="number">133</span>,<span class="string">"tom"</span>, <span class="number">143</span>,<span class="string">"jack"</span>&#125;;</span><br><span class="line">student *one = myclass;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">one++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; one-&gt;id_num &lt;&lt; <span class="string">" "</span> &lt;&lt; one-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202190921.png" alt="QQ图片20200202190921" style="zoom:80%;"></p><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><p>枚举：如果一个变量只有几种可能的取值，则可以将该变量定义为<strong>枚举类型</strong>。</p><p>枚举类型的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个枚举数据类型weekday</span></span><br><span class="line"><span class="keyword">enum</span> weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;; <span class="comment">//花括号内sun,mon,...,sat等称为枚举元素</span></span><br><span class="line"><span class="comment">//定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> weekday workday,weekend;</span><br><span class="line">weekday workday,weekend</span><br><span class="line"><span class="comment">//枚举变量赋值</span></span><br><span class="line">workday = sun; weekend = moon;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>枚举类型按常量处理，不能对它们赋值。<code>sun = mon;</code> （错误）</li><li>枚举类型不能直接输出元素的名字。<code>enum color{red,green,white,black}; color cloth = red; cout&lt;&lt;cloth;  //结果为0。</code></li><li>枚举类型可以比较。<code>if(cloth &gt; white)  count++</code></li><li>一个整型不能直接赋给一个枚举变量。<code>workday = 2;</code> （错误）</li><li>枚举元素有值：<ul><li>定义时枚举元素如未指定值，编译系统按定义顺序取默认值依次为0,1,2,3,….</li><li>也可以给枚举元素指定对应的值，<code>enum day {sun=7,mon=1, tue, wed, thu, fri, sat};</code> 这时有<code>sun=7, mon=1, tue=2, wed=3,......</code></li><li>若要把整数赋给枚举变量应先进行强制类型转换，<code>workday = (enum weekday) 2;</code></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> color&#123;red,yellow, green=<span class="number">3</span>,blue&#125;;</span><br><span class="line"><span class="keyword">enum</span> color cl;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cl = blue;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"red="</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow="</span> &lt;&lt; yellow &lt;&lt; <span class="string">" green="</span> &lt;&lt; green &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"blue="</span> &lt;&lt; blue &lt;&lt; <span class="string">" cl="</span> &lt;&lt; cl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出枚举类型的内容</span></span><br><span class="line"><span class="keyword">switch</span> (cl)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> red:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"red\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> yellow:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"yellow\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> green:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"green\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> blue:  <span class="built_in">cout</span> &lt;&lt; <span class="string">"blue\n"</span>;  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202193831.png" alt="QQ图片20200202193831" style="zoom:80%;"></p><p><strong>例子</strong>：计算工资</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202195012.png" alt="QQ图片20200202195012" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">enum</span> day&#123;Mon,Tue,Wed,Thu,Fri,Sat,Sun&#125;;</span><br><span class="line">day workDay;</span><br><span class="line"><span class="keyword">double</span> times, wages = <span class="number">0</span>, hourlyPay, hours;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the hourly wages rate."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hourlyPay;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter hours worked daily"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; hours;</span><br><span class="line"><span class="keyword">switch</span> ((day)i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Sat:times = <span class="number">1.5</span>*hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Sun:times = <span class="number">2</span> * hours; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:times = hours;</span><br><span class="line">&#125;</span><br><span class="line">wages = wages + times * hourlyPay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The wages for the week are "</span> &lt;&lt; wages &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200510.png" alt="QQ图片20200202200510" style="zoom:80%;"></p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><p><strong>共用体</strong>：为了节省内存空间，可以将几种不同类型的变量存放到同一段内存单元中，这段内存单元所对应的数据结构称为共用体。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202200904.png" alt="QQ图片20200202200904" style="zoom:50%;"></p><p><strong>共用体的定义</strong>：<code>uniom 共用体名{ 成员列表; }变量列表;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;      <span class="comment">// 直接定义</span></span><br><span class="line"></span><br><span class="line">data a,b,c;  <span class="comment">//分开定义</span></span><br></pre></td></tr></table></figure><p>共用体的引用：不能引用共用体变量，只能引用共用体变量中的成员。</p><p><strong>共用体类型数据的特点</strong>：</p><ol><li>同一内存段可以存放几种不同类型的成员，但在同一时刻时只能存放其中一种。</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</li><li>共用体变量的地址和它的各成员的地址都是同一地址，如<code>&amp;a, &amp;a.i, &amp;a.ch, &amp;a.f</code>都是同一地址值。</li><li>共用体不能初始化，不能对整个共用体赋值。</li><li>在函数中，可以使用共用体的指针，但不能使用名字做函数参数。</li><li>共用体的空间是所有成员中最大的一个。</li></ol><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202203319.png" alt="QQ图片20200202203319" style="zoom:50%;"></p><p><strong>例子</strong>：</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202204157.png" alt="QQ图片20200202204157" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> job;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Class;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">position</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;category;</span><br><span class="line">&#125;preson[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是一种非常常用的动态数据结构，可以用来表示顺序访问的线性群体：</p><ul><li>链表头：指向第一个链表结点的指针；</li><li>链表结点：链表中的每一个元素，包括：当前结点的数据，下一个结点的地址；</li><li>链表尾：不再指向其他结点的结点，其地址部分放一个<code>NULL</code>，表示链表到此结束。</li></ul><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202213412.png" alt="QQ图片20200202213412" style="zoom:50%;"></p><h2 id="关于new-amp-delete"><a href="#关于new-amp-delete" class="headerlink" title="关于new &amp; delete"></a>关于new &amp; delete</h2><p><code>new</code>：C++运算符，动态地分配内存空间，并将所分配的内存的地址赋给指针变量。</p><p><code>delete</code>：C++运算符，将动态分配的内存空间归还给系统。</p><p><strong>用法一</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;;   </li></ul><p>​       分配某种类型大小的一片连续内存空间，并将内存空间的首地址赋给指针变量。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202215333.png" alt="QQ图片20200202215333" style="zoom:80%;"></p><p><strong>用法二</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;(初值);   </li></ul><p>​       分配空间，并将初始值存入所分配的空间中。</p><ul><li>delete&lt;指针变量&gt;;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用法三</strong>：</p><ul><li>&lt;指针变量&gt; = new&lt;类型&gt;[&lt;常量表达式&gt;];   </li></ul><p>​       分配指定类型的数组空间，并将数组的首地址赋给指针变量。</p><ul><li>delete[ ]&lt;指针变量&gt;;</li></ul><p>​       将指针变量所指向一维数组内存空间归还给系统。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(p+i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200202220229.png" alt="QQ图片20200202220229" style="zoom:80%;"></p><p>当new &amp; delete 用于结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;next &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203093844.png" alt="QQ图片20200203093844" style="zoom:80%;"></p><h2 id="逐步建立链表"><a href="#逐步建立链表" class="headerlink" title="逐步建立链表"></a>逐步建立链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094349.png" alt="QQ图片20200203094349" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094355.png" alt="QQ图片20200203094355" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094400.png" alt="QQ图片20200203094400" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203094405.png" alt="QQ图片20200203094405" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">student *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">student *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *head, *temp;</span><br><span class="line"><span class="keyword">int</span> num, n = <span class="number">0</span>;</span><br><span class="line">head = <span class="keyword">new</span> student;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">-1</span>)    <span class="comment">//-1作为结束符？</span></span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">temp-&gt;id = num;</span><br><span class="line">temp-&gt;next = <span class="keyword">new</span> student;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *pointer = create();</span><br><span class="line"><span class="keyword">while</span> (pointer-&gt;next != <span class="literal">NULL</span>)     <span class="comment">//遍历链表的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer-&gt;id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pointer = pointer-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203100110.png" alt="QQ图片20200203100110" style="zoom:80%;"></p><h2 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203101525.png" alt="QQ图片20200203101525" style="zoom:50%;"></p><p><strong>例子</strong>：在链表中将值为n的结点删掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">dele</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *follow;</span><br><span class="line">temp = head;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)   <span class="comment">//head为空时，说明链表为空表</span></span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line"><span class="keyword">if</span> (head-&gt;id == n)  <span class="comment">//若第一个节点是要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;id != n)  <span class="comment">//寻到要删除的目标</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>)          <span class="comment">//若没到找到要删除的目标</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"not found"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = temp-&gt;next;  <span class="comment">//删除目标结点</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><p>1.将结点unit插入链表的<strong>最前面</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104316.png" alt="QQ图片20200203104316" style="zoom:50%;"></p><p>2.将结点unit插入链表的<strong>中间</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104321.png" alt="QQ图片20200203104321" style="zoom:50%;"></p><p>3.将结点unit插入链表的<strong>最后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203104324.png" alt="QQ图片20200203104324" style="zoom:50%;"></p><p>例子：插入结点值为n的结点（按大小顺序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">student *<span class="title">insert</span><span class="params">(student *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student *temp, *unit, *follow;</span><br><span class="line">temp = head;</span><br><span class="line">unit = <span class="keyword">new</span> student;</span><br><span class="line">unit-&gt;id = n;</span><br><span class="line">unit-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)  <span class="comment">//如果链表为空，直接插入</span></span><br><span class="line">&#123;</span><br><span class="line">head = unit;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((temp-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (temp-&gt;id &lt; n))  <span class="comment">//寻找第一个不小于n的结点temp</span></span><br><span class="line">&#123;</span><br><span class="line">follow = temp;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp == head)     <span class="comment">//如果temp为第一个结点</span></span><br><span class="line">&#123;</span><br><span class="line">unit-&gt;next = head;</span><br><span class="line">head = unit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)  <span class="comment">//如果temp为最后一个结点</span></span><br><span class="line">temp-&gt;next = unit;</span><br><span class="line"><span class="keyword">else</span>                     <span class="comment">//如果temp为一个中间结点</span></span><br><span class="line">&#123;</span><br><span class="line">follow-&gt;next = unit;</span><br><span class="line">unit-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111706.png" alt="QQ图片20200203111706" style="zoom:50%;"></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111715.png" alt="QQ图片20200203111715" style="zoom:50%;"></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203111959.png" alt="QQ图片20200203111959" style="zoom:50%;"></p><p><strong>删除结点temp</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112004.png" alt="QQ图片20200203112004" style="zoom:50%;"></p><p><strong>将结点unit插入到temp之后</strong></p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203112008.png" alt="QQ图片20200203112008" style="zoom:50%;"></p><h2 id="例子：约瑟夫环问题"><a href="#例子：约瑟夫环问题" class="headerlink" title="例子：约瑟夫环问题"></a>例子：约瑟夫环问题</h2><p><strong>问题描述</strong>：n个孩子围坐成一圈，并按顺时针编号为1,2,3, ……,n，从编号为p的小孩顺时针依次报数，由1报到m，当报到m时，该小孩从圈中出去，然后下一个小孩再从1报数，当报到m时再出去。如此反复，直至所有的小孩都从圈中出去。请按出去的先后顺序输出小孩的编号（假设小孩的个数不多于300个）。</p><p><strong>关于输入</strong>：n,p,m的值在1行内输入，以空格间隔</p><p><strong>关于输出</strong>：按出圈的顺序输出编号，编号之间以逗号间隔。</p><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203115945.png" alt="QQ图片20200203115945" style="zoom:50%;"></p><p><strong>思路</strong>：</p><p>首先定义结点的结构体，列出需要的函数的，然后再考虑每个函数需要完成的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">Node *next;</span><br><span class="line">Node *ahead;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, P, M = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入人数N，从几号开始P，报到哪个数M："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P &gt;&gt; M;</span><br><span class="line">Node *head = Create(N);       <span class="comment">//创建N个结点的环</span></span><br><span class="line">head = Search(head, P);       <span class="comment">//找到第P个结点</span></span><br><span class="line"><span class="keyword">while</span> (head-&gt;next != head)    <span class="comment">//不断释放第M个元素，直到只剩一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">head = Release(head, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; head-&gt;num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Create</span><span class="params">(<span class="keyword">int</span> N)</span>            <span class="comment">//创建包含N个结点的双向循环链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">Node *node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;num = n;</span><br><span class="line">Node *head = node;        <span class="comment">//指向第一节点</span></span><br><span class="line">Node *tail = head;        <span class="comment">//指向最后一个节点</span></span><br><span class="line"><span class="keyword">while</span> (n++ &lt; N)</span><br><span class="line">&#123;</span><br><span class="line">node = <span class="keyword">new</span> Node;     <span class="comment">//创建新节点</span></span><br><span class="line">node-&gt;num = n;       <span class="comment">//赋值</span></span><br><span class="line">tail-&gt;next = node;   <span class="comment">//插入新节点</span></span><br><span class="line">node-&gt;ahead = tail;</span><br><span class="line">tail = tail-&gt;next;   <span class="comment">//尾巴后移一个</span></span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = head;</span><br><span class="line">head-&gt;ahead = tail;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Search</span><span class="params">(Node *head, <span class="keyword">int</span> P)</span>  <span class="comment">//从head开始寻找第P个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (head-&gt;num != P)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">Release</span><span class="params">(Node *head, <span class="keyword">int</span> M)</span>  <span class="comment">//释放Head开始的第M个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">Node *temp = head;</span><br><span class="line"><span class="keyword">while</span> (count &lt; M)             <span class="comment">//寻找第M个节点</span></span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;ahead-&gt;next = temp-&gt;next;   <span class="comment">//移除第M个节点</span></span><br><span class="line">temp-&gt;next-&gt;ahead = temp-&gt;ahead;  <span class="comment">//移除第M个节点</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;num &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">head = temp-&gt;next;                <span class="comment">//释放第M个节点所占的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> temp;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/02/Cpp%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%93%BE%E8%A1%A8/QQ图片20200203134747.png" alt="QQ图片20200203134747" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中结构体与链表的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（5）函数</title>
    <link href="http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/"/>
    <id>http://nekomoon404.github.io/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-30T11:41:22.000Z</published>
    <updated>2020-02-02T04:13:30.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数的定义和声明"><a href="#函数的定义和声明" class="headerlink" title="函数的定义和声明"></a>函数的定义和声明</h2><p>函数是C++程序的基本构成单元，一个C++程序由一个或多个源文件组成，一个源程序文件可以由一个或多个函数组成。一个典型的函数（function）<strong>定义</strong>包括：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。函数执行的操作在语句块，称为函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        ret* = val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的类型是指<strong>函数返回值的数据类型</strong>，若函数类型与return语句中表达式的值不一致，则以函数类型为准，系统自动进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y ? x : y);   <span class="comment">//返回时会转换为整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的名字也必须在使用之前声明，函数只能定义一次，但可以声明多次。函数的声明不包含函数体，所以也就无须形参的名字，但是加上便于理解。函数声明也称作<strong>函数原型</strong>（function prototype）。</p><p>建议变量在头文件中声明，在源文件中定义。与之类似，函数也该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p><p>需要注意的是：<strong>函数不能嵌套定义</strong>，函数间可以互相调用，但不能调用<code>main</code>函数。</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。执行函数的第一步是（隐式地）定义并初始化它的形参。当遇到一条return语句时函数结束执行过程，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = fact(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5! is"</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130201451.png" alt="QQ图片20200130201451" style="zoom: 50%;"></p><p>一个函数调用的执行过程可以分为3个阶段：</p><ol><li>首先把实参值传入被调用函数形参的对应单元中，中断主调函数当前的执行，并且保存返回地点（称为断点）。</li><li>执行被调用函数语句，直到<code>return</code>语句返回。若被调用函数中没有<code>return</code>语句，则直到其全部语句执行完毕后自动返回到位于主调函数中的断点处。</li><li>从保存的断点处，主调函数继续执行其他剩余语句。</li></ol><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>实参是形参的初始值，编译器能以任意可行的顺序对实参求值。实参的类型必须与对应的形参类型匹配。实参与形参具有不同的存储单元，实参与形参变量的数据传递是“<strong>值传递</strong>”（passed by value）；函数调用时，系统给形参分配存储单元，并将实参对应的值传递给形参。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130202050.png" alt="QQ图片20200130202050" style="zoom:50%;"></p><p>函数的形参列表可以为空，但是不能省略，其中每个形参都是含有一个声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来，且任意两个形参都不能同名，</p><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。一种特殊的返回类型是<code>void</code>，它表示函数不返回任何值。</p><h2 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h2><p>根据变量在程序中作用范围的不同，可以将变量分为：</p><p><strong>局部变量</strong>：在函数内或块内定义，只在这个函数或块内起作用的变量；</p><p><strong>全局变量</strong>：在所有函数外定义的变量，它的作用域是从定义变量的位置开始到本程序文件结束。</p><p>当全局变量与局部变量<strong>同名</strong>时，局部变量将在自己作用域内有效，它将屏蔽同名的全局变量，即在局部变量的作用范围内，全局变量不起作用。</p><p>需要注意的是，不在必要时不要使用全局变量。因为全局变量在程序的全部指向过程中都占用存储单元；过多地使用全局变量，程序的可读性变差；会增加函数之间的“关联性”，降低了函数的独立性，使函数可移植性降低。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200130204440.png" alt="QQ图片20200130204440" style="zoom: 50%;"></p><h2 id="自动对象与局部静态对象"><a href="#自动对象与局部静态对象" class="headerlink" title="自动对象与局部静态对象"></a>自动对象与局部静态对象</h2><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它，把只存在于块执行期间的对象称为<strong>自动对象</strong>（automatic object）。</p><p>形参是一种自动对象，我们用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象，分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。</p><p>有时局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义为static类型。<strong>局部静态对象</strong>（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的函数统计它自己被调用了多少次</span></span><br><span class="line"><span class="keyword">size_t</span> count_calls()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cout_calls() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>指针用做函数参数，在函数内部改变指针的值只能改变局部变量，不会影响实参原来的值；在函数内部通过解引用操作改变指针所指内容的值，即实参指针所指内容的值也发生了改变。</p><p><strong>例子</strong>：编写一个函数，使用指针形参交换两个整数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *r = &amp;a, *s = &amp;b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(r, s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/1.png" alt="1" style="zoom:80%;"></p><p>需要注意的是，下面的函数并不能满足要求，因为在函数内部改变指针的值（改变指针所指的地址）只能改变局部变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h2><p>我们知道对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。</p><p>与值传递（实参的值被拷贝给形参，形参和实参是两个相互独立的变量）不同的是，引用形参是传引用的方式，形参是对应的实参的别名，形参绑定到初始化它的对象，如果改变了形参的值，也就是改变了对应实参的值。</p><p>用引用形参重写上面例子中的程序，引用形参绑定初始化它的对象，p绑定我们传给函数的int对象a，改变p的值也就是改变p所引对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySWAP</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = p;</span><br><span class="line">p = q;</span><br><span class="line">q = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mySWAP(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后：a="</span> &lt;&lt; a &lt;&lt; <span class="string">"，b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200131142122.png" alt="QQ图片20200131142122" style="zoom:80%;"></p><h3 id="使用引用形参避免拷贝"><a href="#使用引用形参避免拷贝" class="headerlink" title="使用引用形参避免拷贝"></a>使用引用形参避免拷贝</h3><p>拷贝大类类型对象或者容器对象比较低效，甚至有的类类型不支持拷贝。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p><p><strong>如果函数无须改变引用形参的值，最好将其声明为常量引用</strong>。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做有几个缺陷：一是容易给使用者一种误导，即程序允许修改变量s的内容；二是限制了该函数所能接受的实参类型，我们无法把<code>const</code>对象、字面值常量或者需要进行类型转换的对象传递给普通的引用形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string 对象的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个string对象是否含有大写字母</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasUpper</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span>  <span class="comment">//无须修改参数的内容，设为常量引用类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isupper</span>(c))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把字符串的所有大写字母转成小写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangeToLower</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str)</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用引用形参返回额外信息"><a href="#使用引用形参返回额外信息" class="headerlink" title="使用引用形参返回额外信息"></a>使用引用形参返回额外信息</h3><p>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为一次返回多个结果提供了有效的途径。（对于引用的操作实际上是作用在引用所引的对象上）</p><p><strong>例子</strong>：定义一个名为find_char的函数，返回string对象中某个指定字符第一次出现的位置，同时能“返回”该字符出现的次数。</p><p>一种思路是定义一个新的数据类型，包含位置和数量两个成员，显然比较复杂；另一种更简单的方法是，给函数传入一个额外的引用实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">char</span> c, <span class="built_in">string</span>::size_type &amp;occurs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (decltyoe(ret) i = <span class="number">0</span>; i!=s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret == s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;         <span class="comment">//记录c第一次出现的位置</span></span><br><span class="line">            ++occurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;                 <span class="comment">//出现次数通过occurs隐式地返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><p>数组有两个特殊性质：不允许拷贝数组，以及使用数组时通常会将其转换成指针。所以我们不能以值传递的方式使用数组参数，当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p><p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这三个print函数是等价的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>当编译器处理对<code>print</code>函数的调用时，只检查传入的参数是否是<code>const int*</code>类型；如果我们传给<code>print</code>函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。以数组为形参的函数也必须确保使用数组时不会越界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        total+=*p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    sum(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组名做函数参数"><a href="#多维数组名做函数参数" class="headerlink" title="多维数组名做函数参数"></a>多维数组名做函数参数</h3><p>当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，而多维数组的首元素是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两个print等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;   <span class="comment">//（*matrix)的括号不能少</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span></span>;</span><br></pre></td></tr></table></figure><p>例子：求一个$3\times 4$的矩阵的所以元素中的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxvalue</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = p[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(p[i][j] &gt; <span class="built_in">max</span>)</span><br><span class="line">                <span class="built_in">max</span> = p[i][j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Max value is"</span> &lt;&lt; maxvalue(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>形参也可以是数组的引用，此时引用形参绑定到对应的实参上，也就是绑定到数组上。但此时函数只能作用于固定大小的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span>    <span class="comment">//只能将函数作用于大小为10的数组，(&amp;arr)的括号不能少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>我们已经知道：函数不能嵌套定义，函数可以嵌套调用。那么一个函数能调用“自己”嘛？答案是可以的</p><p>例子：已知 n，求n的阶乘$n!$</p><script type="math/tex; mode=display">\begin{align*}n!&=(n-1)!*n \\ (n-1)!&=(n-2)!*(n-1) \\ &\dots \\ 2!&=1!*2 \\ 1!&=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);     <span class="comment">//每次调用，数据规模缩小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fact(<span class="number">4</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深入理解递归的过程"><a href="#深入理解递归的过程" class="headerlink" title="深入理解递归的过程"></a>深入理解递归的过程</h2><p>递归调用与普通调用在实质上是一样的。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100341.png" alt="QQ图片20200201100341" style="zoom:50%;"></p><p>通过下面的两个例子来理解递归的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100347.png" alt="QQ图片20200201100347" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'\n'</span>)</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">recur();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201100351.png" alt="QQ图片20200201100351" style="zoom:50%;"></p><h2 id="递归的作用"><a href="#递归的作用" class="headerlink" title="递归的作用"></a>递归的作用</h2><h3 id="用递归来完成递推"><a href="#用递归来完成递推" class="headerlink" title="用递归来完成递推"></a>用递归来完成递推</h3><p>递归的关注点放在求解目标上，重在表现第i次与第i+1次的关系，让程序变得简明。必须要确定第1次的返回结果。</p><p><strong>例子</strong>：斐波那契数列</p><script type="math/tex; mode=display">\begin{align*}fab(n)&=fab(n-1)+fab(n-2) \\ fab(1)&=1,\, fab(2)=1\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>(f(n<span class="number">-1</span>)+f(n<span class="number">-2</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟连续发生的动作"><a href="#模拟连续发生的动作" class="headerlink" title="模拟连续发生的动作"></a>模拟连续发生的动作</h3><p>主要是搞清楚连续发生的动作是什么；搞清楚不同动作之间的关系；搞清楚边界条件是什么。</p><p><strong>例子1</strong>：将一个十进制整数转换成二进制数</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201110807.png" alt="QQ图片20200201110807" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((x / <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">convert(x / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">convert(x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2</strong>：汉诺塔问题</p><p>相传在古代印度有位僧人整天把三根柱子上的金盘倒来倒去，他想把64个一个比一个小的金盘从一根柱子上移到另一个柱子上去。移动过程中恪守下述规则：每次只允许移动一只盘，且大盘不得落在小盘上面。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112556.png" alt="QQ图片20200201112556" style="zoom:50%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112717.png" alt="QQ图片20200201112717" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span> <span class="comment">//表示将m个盘子从A经过B移动到C</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//直接可解结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//如果m不为1，则要调用move(m-1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, A, C, B);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move 1# from"</span> &lt;&lt; A &lt;&lt; <span class="string">"to"</span> &lt;&lt; C &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(m - <span class="number">1</span>, B, A, C);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入盘数n="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"在3根柱子上移"</span> &lt;&lt; n &lt;&lt; <span class="string">"个盘子的步骤为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">move</span>(n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201112602.png" alt="QQ图片20200201112602" style="zoom: 80%;"></p><h3 id="进行“自动的分析”"><a href="#进行“自动的分析”" class="headerlink" title="进行“自动的分析”"></a>进行“自动的分析”</h3><p>先假设有一个函数能给出答案，再利用这个函数分析如何解决问题；搞清楚最简单的情况下答案是什么。</p><p><strong>例子</strong>：放苹果</p><p>把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？注意：5,1,1和1,5,1是同一种分法。</p><p>思路：</p><ol><li><p>假设有一个函数f(m,n)能解决这个问题，那么最简单的情况是<code>m&lt;=1||n&lt;=1</code>，此时只有1种分法。</p></li><li><p>当<code>n&gt;m</code>时，必有盘子会空着，空着的盘子不影响结果，那么有<code>f(m,n)=f(m,m)</code>。</p></li><li><p>当<code>n&lt;=m</code>时，分两种情况：</p><p>(1)如果有盘子空着，那么减少一个盘子也不会影响结果，有<code>f(m,n)=f(m,n-1)</code>。</p><p>(2)如果盘子全满，那么每个盘子至少有1个苹果，那么只需考虑剩下m-n个苹果在n个盘子中的分法，则有</p><p><code>f(m,n)=f(m-n,n)</code>。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">1</span> || n &lt;= <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line"><span class="keyword">return</span> count(m, m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> count(m, n - <span class="number">1</span>) + count(m - n, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count(m, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201114810.png" alt="QQ图片20200201114810" style="zoom:80%;"></p><h3 id="递归问题解法小结"><a href="#递归问题解法小结" class="headerlink" title="递归问题解法小结"></a>递归问题解法小结</h3><p>面对一个问题时：</p><ol><li>假设有一个函数f()可以解决问题；接下来考虑这个函数是什么样的？</li><li>找到f^n()与f^n-1()之间的关系；</li><li>确定f()的参数；</li><li>分析并写出边界条件。</li></ol><p><strong>例子1</strong>：组合问题</p><p>用递归法计算从n个人中选择k个人组成一个委员会，求不同的组合的个数一共是多少？</p><p><strong>思路</strong>：</p><ul><li>由n个人里选k个人的组合数=由n-1个人里选k个人的组合数+由n-1个人里选k-1个人的组合数；</li><li>当n = k或k = 0时，组合数为1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comm</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> comm(n - <span class="number">1</span>, k) + comm(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two integers n and k: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"C(n,k) = "</span> &lt;&lt; comm(n, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202104441.png" alt="QQ图片20200202104441" style="zoom:80%;"></p><h2 id="探索式递归"><a href="#探索式递归" class="headerlink" title="探索式递归"></a>探索式递归</h2><p><strong>例子1</strong>：下楼问题</p><p>从楼上走到楼下共有h个台阶，每一步有3种走法：走1个台阶；走2个台阶；走3个台阶。问可以走出多少种方案？将所有的方案输出。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201183838.png" alt="QQ图片20200201183838" style="zoom: 33%;"></p><p><strong>思路</strong>：</p><ol><li><p>既然要列出所有方案，所以需要用一个数组存放每步走的步数，可设为<code>take[99]</code>，步数存放在<code>take[ ]</code>中，满足条件就打印出来；</p></li><li><p>假设有一个函数<code>Try( )</code>能解决问题，接着寻找Try^n^( )与Try^n+1^( )的关系；</p></li><li><p>Try^n^( )代表走完第n步的状态，即已经填完第n个<code>take[ ]</code>；</p></li><li><p>Try^n( )与Try^n+1( )的关系：在走完第n步后，再走第n+1步时，有三种选择（走1、2、3步），每个选择下有三种可能性：</p><ul><li>如果剩下的台阶数小于想要走的步数：返回</li><li>如果剩下的台阶数恰好等于要走的步数：打印输出</li><li>如果剩下的台阶数大于想要走的步数：走下去</li></ul></li><li>Try( )的参数如何确定：Try^n^( )与Try^n+1^( )之间哪些数据是不一样的？而且是需要由Try^n( )传递给Try^n+1^( )的？</li></ol><p>​       Try^n^( )代表走完第n步的情况，Try^n+1^( )代表走完第n+1步的情况；</p><p>​       Try^n^( )需要将走完第 n步后剩余的台阶数传递  给Try^n+1^( )。</p><p>​       因此可以将Try^n^( )定义为：<code>Try(i, s)</code>，<code>i</code>表示剩余的台阶数，<code>s</code>表示步数。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201185823.png" alt="QQ图片20200201185823" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> take[<span class="number">99</span>];    <span class="comment">//记录每一个走的台阶数</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;     <span class="comment">//num记录解决方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Try</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">take[s] = j;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"solution"</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Try(i - j, s + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//take[s]=0;  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"how many stairs:"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">Try(h, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; num &lt;&lt; <span class="string">" solutions."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201191406.png" alt="QQ图片20200201191406" style="zoom:80%;"></p><p><strong>例子2</strong>：字母全排列</p><p>从键盘读入一个英文单词（全部字母小写，且该单词中各个字母均不相同），输出该单词英文字母的所有全排列。</p><p>如输入<code>abc</code>，则打印出<code>abc</code>, <code>acb,</code> <code>bac</code>, <code>bca</code>, <code>cab</code>, <code>cba</code>。</p><p><strong>思路</strong>：</p><p>需要反复做的事情是：选择第n个位置的字母，依次检查每个字母，如果某个字母没被选择过，则进行：</p><ol><li>将该字母放第n个位置；</li><li>标记该字母已经被选择；</li><li>如果全部位置都已选完，打印输出；否则，为下一个位置选择字母；</li><li>把刚刚标记过的字母重新标记为“未选择”；</li></ol><p>假设一个函数<code>ranker( )</code>能够完成上述事情，每次调用之间的区别在于位置n，<code>ranker(1)</code>—&gt;<code>ranker(2)</code>—&gt;<code>ranker(3)</code>……—&gt;<code>ranker(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> in[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;    <span class="comment">//存放输入的单词</span></span><br><span class="line"><span class="keyword">char</span> out[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//存放准备输出的字符串</span></span><br><span class="line"><span class="keyword">int</span> used[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//记录第i个字母是否已经使用过</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;         <span class="comment">//记录输入的单词的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ranker</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==length)       <span class="comment">//如果全部字母已经被选择完，则打印输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; out &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)  <span class="comment">//依次查看每个字母</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!used[i])          <span class="comment">//如果某个字母没有被选用</span></span><br><span class="line">&#123;</span><br><span class="line">out[n] = in[i];    <span class="comment">//选入该字母</span></span><br><span class="line">used[i] = <span class="number">1</span>;       <span class="comment">//标记该字母已经被选择</span></span><br><span class="line">ranker(n + <span class="number">1</span>);     <span class="comment">//为下一个位置寻找字母</span></span><br><span class="line">used[i] = <span class="number">0</span>;   <span class="comment">//回溯，标记字母未被使用，让其可重新被选择</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the word: "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; in;</span><br><span class="line">length = <span class="built_in">strlen</span>(in);</span><br><span class="line">ranker(<span class="number">0</span>);   <span class="comment">//从第一个字母开始</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201195215.png" alt="QQ图片20200201195215" style="zoom:80%;"></p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201201948.png" alt="QQ图片20200201201948" style="zoom: 50%;"></p><p><strong>例子3</strong>：分书问题</p><p>有编号分别为1, 2, 3, 4, 5的五本书，准备分给A，B，C，D，E五个人，每个人阅读兴趣用一个二维数组加以描述。请写一个程序，输出所有分书方案，让人人都能拿到喜欢的书。</p><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200201202457.png" alt="QQ图片20200201202457" style="zoom: 50%;"></p><p><strong>思路</strong>：</p><ol><li>假设函数<code>trybook( )</code>可以解决问题，从第0个人开始分书，函数<code>trybook(i)</code>应该要完成：</li><li>试着给第<code>i</code>个人分书，从0号书开始试，当第<code>i</code>个人喜欢第<code>j</code>个书，且<code>j</code>书还没被选走时（因此要建一个数组记录书被选走的状态），那么第<code>i</code>个人就得到第<code>j</code>本书；</li><li>如果不满足上述条件，则什么也不做，返回循环条件；</li><li>若满足条件，则做三件事情：<ul><li>做事：将第<code>j</code>个书分给第<code>i</code>个人，同时记录<code>j</code>书已被选用；</li><li>判断：查看是否将所有5个人所要的书分完，若分完，则输出每个人所得之书；若未分完，去寻找其他解决方案；</li><li>回溯：让第<code>i</code>个人退回<code>j</code>书，恢复<code>j</code>书尚未被选用的状态。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//book[5]记录书是否被选用，选用记为1</span></span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//take[5]记录第i个人领到那本书</span></span><br><span class="line"><span class="keyword">int</span> num;             <span class="comment">//num记录分书方案的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trybook</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="comment">//第i个人</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=<span class="number">4</span>; j++)  <span class="comment">//第j本书</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((like[i][j] &gt; <span class="number">0</span>) &amp;&amp; (book[j] == <span class="number">0</span>)) <span class="comment">//若第i个人喜欢第j本书，且第j本书还没被选用</span></span><br><span class="line">&#123;</span><br><span class="line">take[i] = j;  <span class="comment">//把第j本书分给第i个人</span></span><br><span class="line">book[j] = <span class="number">1</span>;  <span class="comment">//记录第j本书已经被选用</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">4</span>)   <span class="comment">//如果第5个人已经拿到书，即书已分完，则输出方案</span></span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; num &lt;&lt; <span class="string">"个方案"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; take[k] &lt;&lt; <span class="string">"号书给"</span> &lt;&lt; <span class="keyword">char</span>(k + <span class="number">65</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>       <span class="comment">//如果书没分完，则继续给下一个人分书</span></span><br><span class="line">trybook(i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//take[i] = -1;  把第i个人的书退回，实际上可以不加这一条</span></span><br><span class="line">book[j] = <span class="number">0</span>;   <span class="comment">//回溯，把第j本书标记为未选用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">trybook(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/30/Cpp%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89%E5%87%BD%E6%95%B0/QQ图片20200202101401.png" alt="QQ图片20200202101401" style="zoom:80%;"></p><h3 id="探索式递归问题的解法"><a href="#探索式递归问题的解法" class="headerlink" title="探索式递归问题的解法"></a>探索式递归问题的解法</h3><p>第n步需要做什么？对于面前的每种选择：</p><ol><li>把该做的事情做了；</li><li>判定是否得到解；</li><li>递归（调用第n+1步）；</li><li>看是否需要回溯。</li></ol>]]></content>
    
    <summary type="html">
    
      复习了C++中函数的内容
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（4）字符数组与字符串</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-01-27T03:08:57.000Z</published>
    <updated>2020-01-27T14:29:00.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127110928.png" alt="QQ图片20200127110928" style="zoom:67%;"></p><h2 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h2><p>只可以在数组定义并初始化的时候才可以使用字符串字面值对字符数组初始化，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符-字符数组-字符串的输入与输出"><a href="#字符-字符数组-字符串的输入与输出" class="headerlink" title="字符/字符数组/字符串的输入与输出"></a>字符/字符数组/字符串的输入与输出</h2><h3 id="一个字符的输入"><a href="#一个字符的输入" class="headerlink" title="一个字符的输入"></a>一个字符的输入</h3><h4 id="直接用cin输入字符。"><a href="#直接用cin输入字符。" class="headerlink" title="直接用cin输入字符。"></a>直接用<code>cin</code>输入字符。</h4><p><code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但最后一个Enter会在缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;c)     <span class="comment">//abc def g</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c;      <span class="comment">//abcdefg</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用cin-get-函数输入"><a href="#用cin-get-函数输入" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>可以用于读入<strong>一个字符</strong>；有2中形式：</p><p>无参数<code>cin.get()</code>，可用于舍弃输入流中的不需要的字符，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( (c=<span class="built_in">cin</span>.<span class="built_in">get</span>())!= EOF )  <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;                    <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>一个参数<code>cin.get(char)</code>     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="comment">//读取一个字符赋给字符变量c</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">cin</span>.<span class="built_in">get</span>(c) )     <span class="comment">//abc def g</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><p>要注意的是，<code>cin.get()</code>遇到结束符停止读取，但并不会将结束符从缓冲区丢弃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1,ch2;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入两个字符："</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1);<span class="comment">//或ch1 = cin.get();  </span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch2);  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;ch2&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(<span class="keyword">int</span>)ch1&lt;&lt;<span class="string">" "</span>&lt;&lt;(<span class="keyword">int</span>)ch2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输入a[Enter]，读取到结束符<code>&#39;/n&#39;</code>，其仍在缓冲区中被存入<code>ch2</code>，在输出a之后，第二次输出<code>&#39;/n&#39;</code>即换行，而输出的第二个ASCII码值为10，即<code>&#39;/n&#39;</code>的ASCII值，说明<code>cin.get()</code>遇到结束符并不会将之删除。</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127172134.png" alt="QQ图片20200127172134" style="zoom: 80%;"></p><h4 id="用getchar-输入字符"><a href="#用getchar-输入字符" class="headerlink" title="用getchar()输入字符"></a>用<code>getchar()</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence"</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line"><span class="keyword">while</span>( c = getchar() )  <span class="comment">//abc def g   不跳过任何字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;              <span class="comment">//abc def g</span></span><br></pre></td></tr></table></figure><h3 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h3><h4 id="直接用cin输入字符"><a href="#直接用cin输入字符" class="headerlink" title="直接用cin输入字符"></a>直接用<code>cin</code>输入字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127120550.png" alt="QQ图片20200127120550" style="zoom:80%;"></p><h4 id="用cin-get-函数输入-1"><a href="#用cin-get-函数输入-1" class="headerlink" title="用cin.get()函数输入"></a>用<code>cin.get()</code>函数输入</h4><p>有三个参数的<code>cin.get()</code>函数：<code>cin.get(ch, 10, &#39;/n&#39;)</code></p><p>读取10-1（10减1=9，最后一个为<code>&#39;/0&#39;</code>）个字符（包括空格），赋给指定的字符数组，；如果在读取9个字符之前，遇到指定的终止字符<code>&#39;/n&#39;</code>，则提前结束读取（如果第3个参数没有指定，则默认为<code>&#39;/n&#39;</code>），而<strong>结束符仍在缓冲区中</strong>；读取成功返回非0值（真），如失败（遇到文件结束符）则返回0值（假）。</p><p>还要一点要注意，<code>cin.get(ch, 10, &#39;/n&#39;)</code>，当第一个输入字符为结束符时，缓冲区将无该结束符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch1,<span class="number">10</span>,<span class="string">'o'</span>);  <span class="comment">//指定终止符为'o'</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(ch2,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127173835.png" alt="QQ图片20200127173835" style="zoom:80%;"></p><p>输入：we are good friends[Enter]，由于遇到结束符 <code>&#39;o&#39;</code> ，首先读入we are g到<code>ch1</code>，此时ood friends仍在缓冲区，当执行<code>cin.get(ch2,10)</code>会直接从缓冲区读入ood frien（只能读入9个字符），而不需要申请从键盘输入。</p><h4 id="用cin-getline-函数输入"><a href="#用cin-getline-函数输入" class="headerlink" title="用cin.getline()函数输入"></a>用<code>cin.getline()</code>函数输入</h4><p>用法与上面的<code>cin.get()</code>类似，但也有区别：</p><p><code>cin.get()</code>当输入的字符串在结束符之前的长度超过接收长度时，不会引起<code>cin</code>函数的错误，剩余的字符会留在缓冲区，后面若有<code>cin</code>操作，会继续从缓冲区读取；当<code>cin.getline()</code>输入超长时，会引起<code>cin</code>函数的错误，后面的<code>cin</code>操作将不再执行。</p><p><code>cin.get()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符<code>&#39;/n&#39;</code>留在输入队列中，然而<code>cin.getline()</code>每次读取一整行并把由<code>Enter</code>键生成的换行符抛弃。</p><p><code>cin.get()</code>遇到结束符是停止读取，缓冲区指针不移动；<code>cin.getline()</code>遇到结束符时，缓冲区指针移到终止标志字符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1[<span class="number">20</span>]，ch2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"enter a sentence"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(ch1,<span class="number">10</span>,<span class="string">'o'</span>);      <span class="comment">//指定终止符为'o'</span></span><br><span class="line">   <span class="built_in">cin</span>.getline(ch2,<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; ch2 &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//注意与上节的区别</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127191238.png" alt="QQ图片20200127191238" style="zoom:80%;"></p><p>一个<strong>需要注意</strong>的地方：<code>cin</code>这一输入操作，遇到结束符（Space, Tab, Enter）就会结束，且对于结束符，并不保存到变量中，但<strong>最后一个Enter会在缓冲区</strong>。而无参数<code>cin.get()</code>，可用于<strong>舍弃输入流中的不需要的字符</strong>，或者舍弃回车，弥补三参数的<code>cin.get(ch, 10, &#39;/n&#39;)</code>的不足。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   <span class="comment">//当执行cin.getline(a[1],10)时，[Enter]被读取到a[1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127192425.png" alt="QQ图片20200127192425" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;      <span class="comment">//输入7[Enter]，7存入n，[Enter]仍在缓冲区</span></span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();     <span class="comment">//用cin.get来舍弃缓冲区的[Enter]，就不会出现上面的情况了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line"><span class="built_in">cin</span>.getline(a[i], <span class="number">10</span>);   </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127193235.png" alt="QQ图片20200127193235" style="zoom:80%;"></p><h3 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h3><h4 id="用cout输出字符数组"><a href="#用cout输出字符数组" class="headerlink" title="用cout输出字符数组"></a>用<code>cout</code>输出字符数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = <span class="string">"Computer"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220421.png" alt="QQ图片20200127220421" style="zoom:80%;"></p><p>需要注意的是，<code>cout</code>输出有终止条件（一般是碰到<code>&#39;\0&#39;</code>），当用字面值初始化字符数组时，会自动在串尾加上<code>&#39;\0&#39;</code>；当用列表初始化字符数组时，若不在串尾加上’\0’，用<code>cout</code>输出时就不知道何时停止，可能读到内存里其他随机的位置，显示就会在字符串后面出现乱码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">8</span>] = &#123; <span class="string">'C'</span>,<span class="string">'o'</span>,<span class="string">'m'</span>,<span class="string">'p'</span>,<span class="string">'u'</span>,<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127220426.png" alt="QQ图片20200127220426" style="zoom:80%;"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>1.字符串加密：输入一个字符串，把每个字符变成它后续字符，如果是’Z’或者’z’，则对应变成’A’或者’a’，空格则不变。然后将变换后的字符串输出；要求能够接受连续输入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.getline(str, <span class="number">200</span>)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'Z'</span>)&#123;</span><br><span class="line">str[i] = <span class="string">'A'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'z'</span>)&#123;</span><br><span class="line">str[i] == <span class="string">'a'</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">str[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127203829.png" alt="QQ图片20200127203829" style="zoom:80%;"></p><p>2.字符串连接：输入两个字符串，将其中较短的串接到较长的串的后面。不使用系统函数<code>strcat</code>，每个输入的串的长度不超过20。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">40</span>], str2[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str1,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cin</span>.getline(str2, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++);</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++);</span><br><span class="line"><span class="keyword">if</span> (len1 &gt;= len2) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len2 = <span class="number">0</span>; str2[len2] != <span class="string">'\0'</span>; len2++)</span><br><span class="line">str1[len1++] = str2[len2];   <span class="comment">//后置++，先执行表达式，再len+1</span></span><br><span class="line">str1[len1] = <span class="string">'\0'</span>;   <span class="comment">//必须要加，要不然cout&lt;&lt;str1会出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (len1 = <span class="number">0</span>; str1[len1] != <span class="string">'\0'</span>; len1++)</span><br><span class="line">str2[len2++] = str1[len1];</span><br><span class="line">str2[len2] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127213528.png" alt="QQ图片20200127213528" style="zoom:80%;"></p><p>3.统计单词数：输入一个英文句子（不超过80个字母），统计其中有多少个单词，单词之间用空格分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">' '</span>)</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127214732.png" alt="QQ图片20200127214732" style="zoom:80%;"></p><p>当输入不是很严格时，比如有数字，或输入不规范，比如标号后不加空格等等，上面的程序会多算单词数。可以改成如下的程序，直接判断是不是字母。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">80</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(str, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((str[i] &gt;= <span class="string">'A'</span>&amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) || (str[i] &gt;= <span class="string">'a'</span>&amp;&amp;str[i] &lt;= <span class="string">'z'</span>))</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"字符串中有"</span> &lt;&lt; num &lt;&lt; <span class="string">"个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/QQ图片20200127215300.png" alt="QQ图片20200127215300" style="zoom:80%;"></p>]]></content>
    
    <summary type="html">
    
      复习了C++中字符数组与字符串的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（3）数组</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/</id>
    <published>2020-01-27T03:06:06.000Z</published>
    <updated>2020-01-27T14:32:08.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种类似于标准库类型vector的数据结构，与vector相似的是，数组也是存放类型相同的对象的容器，这些对象需要通过其所在位置访问；与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。</p><h2 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h2><p>数组的声明形如 a[d] ，其中a是数组的名字，d是数组的维度。维度必须是一个<strong>常量表达式</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;   <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *parr[sz];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;     <span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];       <span class="comment">// 错误：cnt不是常量表达式</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。定义数组的时候必须指定数组的类型，不能用auto关键字由初始值的列表推断类型。数组的元素应为对象，因此不存在引用的数组。</p><h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><p>可以对数组的元素进行列表初始化，如果没有指明维度，编译器会根据初始值的数量计算并推测出来；若指明了维度，那么初始值的总数量不应该超出指定的大小；如果维度比提供的初始值数量大，则剩下的元素被初始化成默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;             <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="字符数组的特殊性"><a href="#字符数组的特殊性" class="headerlink" title="字符数组的特殊性"></a>字符数组的特殊性</h4><p>当使用字符串字面值对字符数组初始化（只可以在数组并初始化的时候）时，一定要注意字符串字面值的结尾处还有一个空字符。不能用赋值语句将一个字符串常量或字符数组直接赋给另一个数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;          <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;    <span class="comment">//列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"C++"</span>;                    <span class="comment">//用字符换字面值初始化，自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>           <span class="comment">//错误：没有空间放空字符</span></span><br><span class="line"></span><br><span class="line">str1[] = <span class="string">"China"</span>;     <span class="comment">//错误</span></span><br><span class="line">str1 = <span class="string">"China"</span>;       <span class="comment">//错误</span></span><br><span class="line">str2 = str1;          <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用二维数组存储多个字符串</span></span><br><span class="line"><span class="keyword">char</span> weekday[<span class="number">7</span>][<span class="number">11</span>] = &#123;<span class="string">"Sunday"</span>, <span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>,<span class="string">"Ssturday"</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="不允许拷贝和赋值"><a href="#不允许拷贝和赋值" class="headerlink" title="不允许拷贝和赋值"></a>不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p><h4 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h4><p>数组能存放大多数类型的对象，可以定义一个<strong>存放指针的数组</strong>；又因为数组本身是对象，所以允许定义<strong>数组的指针及数组的引用</strong>。默认情况下，类型修饰符从右向左依次绑定。就数组而言，从数组的名字开始由内向外阅读更容易理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];                <span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ？ */</span>      <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;    <span class="comment">//Parray是一个指针，指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;     <span class="comment">//arrRef是一个引用，引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;     <span class="comment">//arry是一个引用，引用一个含有10个指针的数组</span></span><br></pre></td></tr></table></figure><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><strong>3.27</strong> 设txt_size是一个无参数的函数，它的返回值是int。下列哪些定义是非法的？为什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> ia[buf_size];                <span class="comment">//非法的，因为buf_size不是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">4</span>*<span class="number">7</span><span class="number">-14</span>];                  <span class="comment">//正确，因为4*7-14是一个常量表达式</span></span><br><span class="line"><span class="keyword">int</span> ia[txt_size()];              <span class="comment">//非法的，因为txt_size没有被定义为常量表达式 constexpr</span></span><br><span class="line"><span class="keyword">char</span> st[<span class="number">11</span>] = <span class="string">"fundamental"</span>      <span class="comment">//非法的，因为用字符串字面值初始化，没有空间存放空字符</span></span><br></pre></td></tr></table></figure><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>与标准库类型<code>vector</code> 和<code>string</code> 一样，数组的元素也能使用范围<code>for</code> 语句或下标运算符来访问。数组的索引从0开始。</p><p>数组下标通常定义为<code>size_t</code>类型，<code>size_t</code>是一种机器相关的无符号类型，在<code>cstddef</code>头文件中定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以10分为一个分段统计成绩的数量：0~9.10~19，...，90~99,100</span></span><br><span class="line"><span class="keyword">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;        <span class="comment">//列表初始化，初值为0；若不初始化，在函数内不执行默认初始化。</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">        ++scores[grade/<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>vector</code> 和<code>string</code> 一样，当需要遍历数组的所有元素时，最好的办法是使用范围<code>for</code>语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于scores中的每个计数值输出当前的计数值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>必须要<strong>检查数组下标的值</strong>在合理范围内，下标越界会产生缓冲区溢出。</p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p>3.31编写一段程序，定义一个含有10个<code>int</code>的数组，令每个元素的值就是其下标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> val: a)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.32 将上一题创建的数组拷贝给另外一个数组，利用<code>vector</code>重写程序，实现类似的功能。</p><p>//如果要把数组的内容拷贝给另外一个数组，不能直接对数值使用赋值运算符，而应该逐一拷贝数组的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[sz], b[sz];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        a[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz: j++)</span><br><span class="line">        b[j] = a[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//用<code>vector</code>重写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vInt, vInt2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        vInt.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++)</span><br><span class="line">        vInt2.push_back(vInt[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val: vInt2)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>输出100以内的所有素数。</p><p>一种思路：让2,3,4,5，…，c中的每个数自我相加多次，来获得100之内的所有合数，筛掉合数之后就得到素数。若n为合数，则n的最小正因数c满足：</p><script type="math/tex; mode=display">1<c\le \sqrt{n}</script><p>循环结构的N-S图：</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89%E6%95%B0%E7%BB%84/QQ图片20200126204152.png" alt="QQ图片20200126204152" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        a[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="built_in">sqrt</span>(<span class="number">100.0</span>); i++)&#123;</span><br><span class="line">        sum = i;</span><br><span class="line">        <span class="keyword">if</span>(a[sum]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(sum&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                sum = sum + i;</span><br><span class="line">                a[sum] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++中并没有多维数组，通常所说的多维数组其实是数组的数组。按照由内而外的顺序阅读。</p><p>多维数组<strong>初始化</strong>的几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;, &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125; &#125;;  <span class="comment">//每一行分别用花括号括起来</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">//不标识每行的花括号</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125; &#125;;  <span class="comment">//显示地初始每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;                <span class="comment">//只显示地初始化第1行</span></span><br></pre></td></tr></table></figure><p>多维数组的<strong>下标引用</strong>：如果表达式含有的下标运算符和数组的维度一样多，该表达式的结果是给定类型的元素；如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。</p><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><p>某学校有1000位老师，分布在20个不同的学院中，每个学院最多有12个系，请你编写一个程序，输入每位老师的所在院、系的编号（院编号1-20，系编号1-12），打印出各个系老师的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomainp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> teacher[<span class="number">21</span>][<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">int</span> school,department, i, j;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name&gt;&gt;school&gt;&gt;department;</span><br><span class="line">        teacher[school][department]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">21</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;<span class="number">13</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;teacher[i][j];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="数组的地址"><a href="#数组的地址" class="headerlink" title="数组的地址"></a><strong>数组的地址</strong></h3><p>在C++语言中，指针和数组有非常紧密的联系。数组名代表数组首元素的地址：数组名是指向数组第一个元素的指针。对于数组a[10]，数组名a代表数组a[10]中第一个元素a[0]的地址，即a与&amp;a[0]等价。需要注意的是，a是地址常量，不是变量，不能给a赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//输出a[0]的地址 0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//输出a[0]的值  10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0017F754</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>若a是指向数组第一个元素的指针，即a相当于<code>&amp;a[0]</code>。</p><ul><li><p>&amp;a是”指向数组“的指针，&amp;a+1将跨越16个字节，&amp;a相当于管辖范围”上升“了一级；</p></li><li><p><em>a是数组的第一个元素a[0]，即 </em>a等价于a[0]， *a相当于管辖范围“下降”了一级。</p></li></ul><p>在一些情况下数组的操作实际上是指针的操作。当使用数组作为一个<code>auto</code>变量的初始值时，得到的类型是指针而非数组。当使用<code>decltype</code>关键字时上述转换不会发生，<code>decltyoe(ia)</code>返回的类型是由整数构成的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;              <span class="comment">//相当于 auto ia2(&amp;ia[0]); ia2是一个整型指针</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//ia是含有整数的数组</span></span><br></pre></td></tr></table></figure><p>C++11新标准引入了<code>begin</code>和<code>end</code>函数，定义在<code>iterator</code>头文件中，这两个函数与容器中的两个同名成员功能类似，但由于数组不是类类型，因此这两个函数不是成员函数，使用时需要将数组作为它们的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure><h3 id="利用指针变量引用数组元素"><a href="#利用指针变量引用数组元素" class="headerlink" title="利用指针变量引用数组元素"></a>利用指针变量引用数组元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *pointer;</span><br><span class="line">pointer = a;         <span class="comment">//等价于 pointer = &amp;a[0];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer+i;   <span class="comment">//等价于a+i；等价于&amp;a[i]；</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(pointer+i);<span class="comment">//等价于*(a+i)；等价于a[i];</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pointer[i];  <span class="comment">//等价于*(pointer+i);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>需要注意的是：a++是没有意义的，但p++会引起p的变化。p可以指向数组最后一个元素以后的元素，称为尾后指针，就像尾后迭代器，尾后指针不能执行解引用和递增操作。<strong>指针做加减运算时一定要注意有效的范围</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *iPtr = &amp;a[<span class="number">1</span>];</span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[0]</span></span><br><span class="line">*iPtr = <span class="number">3</span>;   <span class="comment">//a[0]=3</span></span><br><span class="line">iPtr--;      <span class="comment">//iPtr指向a[-1].dangerous</span></span><br><span class="line">*iPtr = <span class="number">6</span>;   <span class="comment">//damage</span></span><br></pre></td></tr></table></figure><p>根据运算符的优先级有：</p><ul><li><p><code>*++p</code>相当于<code>a[++i]</code>，先将p自加，再做<code>*</code>运算。</p></li><li><p><code>*--p</code>相当于<code>a[--i]</code>，先将p自减，再做<code>*</code>运算。</p></li><li><code>*p++</code>相当于<code>a[i++]</code>，先做<code>*</code>运算，再将p自加。</li><li><code>*p--</code>相当于<code>a[i--]</code>，先做<code>*</code>运算，再将p自减。</li></ul><h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用指针代替数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], i, *p = a;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p++;</span><br><span class="line">    <span class="keyword">for</span>(p--; p&gt;=a; )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; *p--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒置数组元素</span></span><br><span class="line"><span class="comment">//输入：1 2 3 4 5 6 7 8 9 0</span></span><br><span class="line"><span class="comment">//输出：0 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; *p;</span><br><span class="line">    <span class="keyword">for</span>(p = a, q = a+<span class="number">9</span>; p&lt;q; p++, q--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=*p; *p=*q; *q=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p = a; p&lt;a+<span class="number">10</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt;*p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组的地址"><a href="#二维数组的地址" class="headerlink" title="二维数组的地址"></a>二维数组的地址</h3><p>数组名相当于指向数组第一个元素的指针。</p><ul><li><p>*a等价于a[0]，相当于a下降了一级；</p></li><li><p>&amp;a表示“指向二维数组”的指针，相当于上升了一级。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125; &#125;;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//a是指向数组第一个元素的指针，而数组的第一个元素是一个含有4元素的数组，即a是指向一维数组的指针，     //a相当于一个“包含4个int型元素的一维数组”的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">//0x0013FF60  a+1将跨越16个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//0x0013FF60</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//*a是数组的第一个元素，而数组的第一个元素是一个数组，即*a是一个指向整数的指针，</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//0x0013FF50 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF50</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0x0013FF50</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *a+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">//0x0013FF54  *a+1将跨越4个字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//0x0013FF54</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子1：遍历数组元素"><a href="#例子1：遍历数组元素" class="headerlink" title="例子1：遍历数组元素"></a><strong>例子1：遍历数组元素</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//for (p=&amp;a[0][0]; p&lt;&amp;a[0][0]+12; p++)</span></span><br><span class="line">  <span class="comment">//for (p=a[0]; p&lt;a[0]+12; p++)</span></span><br><span class="line">    <span class="keyword">for</span> (p=*a; p&lt;*a+<span class="number">12</span>; p++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子2：输入i，j；输出a-i-j"><a href="#例子2：输入i，j；输出a-i-j" class="headerlink" title="例子2：输入i，j；输出a[i] [j]"></a>例子2：输入i，j；输出a[i] [j]</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>], i, j;</span><br><span class="line">    p=a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//cout &lt;&lt; setw(4) &lt;&lt; p[i][j];    </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;*(*(p+i)+j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题分析</strong>：</p><ol><li><p>从<code>p=a</code>开始，a相当于指向<code>a[3][4]</code>的“第一个元素”的指针；所谓“第一个元素”是指一个 “包含4个int型元素的一维数组”；所以，a相当于一个 “包含4个int型元素的一维数组”的地址；因此<strong>p的基类型</strong>应该是 “包含4个int型元素的一维数组”。</p></li><li><p>如何定义一个指向 “包含4个int型元素的一维数组” 的指针变量？ ———- <code>int (*p)[4]</code></p></li><li><p><code>*(*(p+i)+j)</code>是什么？</p><p><code>p</code>指向一个“包含4个int型元素的一维数组”；</p><p><code>p+i</code>  是第<code>i+1</code>个“包含4个Int 型元素的一维数组”的地址；<code>p+i</code>等价于<code>&amp;a[i]</code>；</p></li></ol><p>​       <code>*(p+i)</code>等价于<code>a[i]</code>；<code>*(p+i)+j</code>等价于<code>a[i]+j</code>；</p><p>​       因为：<code>a[i]+j</code>等价于<code>&amp;a[i][j]</code>，所以：<code>*(*(p+i)+j)</code>等价于<code>a[i][j]</code>。</p><ol><li><p><code>p[i][j]</code>是什么？</p><p>p[i]等价于 <code>*(p+i)</code>； <code>p[i][j]</code> 等价于 <code>*(*(p+i)+j)</code>，等价于<code>a[i][j]</code>。</p></li></ol><h4 id="使用范围for语句处理多维数组"><a href="#使用范围for语句处理多维数组" class="headerlink" title="使用范围for语句处理多维数组"></a>使用范围for语句处理多维数组</h4><p>C++11新标准中新增了范围<code>for</code>语句，可以使用范围<code>for</code>语句处理多维数组，为了避免数组被自动转成指针，处理最内层的循环外，其他所有循环的控制变量应该都是引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt=<span class="number">3.</span> colCnt=<span class="number">4</span>, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">       col = cnt;</span><br><span class="line">       ++cnt;  </span><br><span class="line">&#125;   <span class="comment">//ia=&#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;</span></span><br></pre></td></tr></table></figure><p>也可以使用标准库函数<code>begin</code>和<code>end</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p=<span class="built_in">begin</span>(ia); p!=<span class="built_in">end</span>(ia); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q=<span class="built_in">begin</span>(*p); q!=<span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="string">' '</span>；    <span class="comment">//依次输出ia的元素的值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>] = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pc;</span><br><span class="line">    pc = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出hello</span></span><br><span class="line">    pc++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// ello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// e</span></span><br><span class="line">    pc = <span class="built_in">buffer</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pc &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//ABC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中数组的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（2）引用与指针</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/</id>
    <published>2020-01-27T03:02:17.000Z</published>
    <updated>2020-01-27T14:31:11.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h1><p>复合类型（compound type）是指基于其他类型定义的类型，引用和指针是其中的两种。</p><p>一般地，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>当我们使用“引用（reference）”时，指的其实是“左值引用（lvalue reference）”。</p><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成<code>$d</code>的形式来定义引用类型。在定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。引用将和它的初始值对象一直绑定在一起，无法令其绑定到另外一个对象。</p><p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。以引用作为初始值，实际上是以引用绑定的对象作为初始值。</p><p>允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号<code>&amp;</code>开头。</p><p>引用的类型都要和与之绑定的对象严格匹配。引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;      <span class="comment">//refVal指向ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;            <span class="comment">//错误。引用必须被初始化</span></span><br><span class="line"></span><br><span class="line">refVal = <span class="number">2</span>;              <span class="comment">//把值赋给了ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal;   <span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，即ival</span></span><br><span class="line"><span class="keyword">int</span> i = refVal;          <span class="comment">//相当于i = ival</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i, &amp;r2 = i2;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针（pointer）是“指向”另外一种类型的复合类型。指针也实现了对对象的间接访问，但与引用相比也有不同：</p><p>（1）指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内它可以先后指向几个不同的对象。</p><p>（2）指针无须再定义时赋初值。如果没有被初始化，将拥有一个不确定的值。</p><p><strong>指针运算符</strong><code>*</code>，<strong>取地址符</strong><code>&amp;</code></p><p>指针的类型都要和它所指向的对象严格匹配。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p><strong>指针变量</strong>：专门用于存放指针（某个变量的地址）的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer;       <span class="comment">//定义名字为pointer的指针变量</span></span><br><span class="line">pointer = &amp;c;       <span class="comment">//将变量c的地址赋值给指针变量pointer；赋值后称指针变量pointer指向了变量c</span></span><br><span class="line"><span class="comment">//pointer = c;      //错误：因为pointer是存放地址的变量，所以只能存放地址</span></span><br></pre></td></tr></table></figure><p>通过指针变量可以访问“它所指向的变量”。指针变量也是变量，是变量就有地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">int</span> *pointer = &amp;c;  <span class="comment">//*pointer为“pointer所指向的存储单元的内容"，即是变量c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;c &lt;&lt;<span class="built_in">endl</span>;         <span class="comment">//取变量c的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;pointer &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//取指针变量c的地址</span></span><br></pre></td></tr></table></figure><p><strong>赋值和指针</strong>：记住赋值永远改变的是等号左侧的对象，就能分清一条赋值语句是改变了指针还是改变了指针所指的对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="number">0</span>;         <span class="comment">//pi被初始化</span></span><br><span class="line">pi = &amp;ival;          <span class="comment">//pi所存的地址改变，指向ival</span></span><br><span class="line">*pi = <span class="number">0</span>;             <span class="comment">//ival的值被改变，指针pi所存的地址没有改变</span></span><br></pre></td></tr></table></figure><p><strong>&amp;<code>与</code>*`的运算优先级</strong>：同级</p><p><img src="/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88/QQ图片20200125205145.png" alt="QQ图片20200125205145" style="zoom:50%;"></p><p><strong>空指针</strong>（null pointer）不指向任何对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>     <span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;          <span class="comment">//直接将p2初始化为字面常量0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;       <span class="comment">//需要首先#include&lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure><p>使用未经初始化的指针是引发运行时错误的一大原因。因此建议初始化所有的指针，尽量等定义了对象之后再定义指向它的指针。</p><p><code>void*</code>指针：可用于存放任意对象的地址。利用<code>void*</code>指针可以：拿它和别的指针比较，作为函数的输入或输出，或者赋给另外一个<code>void*</code>指针。不能访问其内存空间中所存的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="keyword">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++中引用与指针的知识
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Cpp基础（1）基础语法</title>
    <link href="http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://nekomoon404.github.io/2020/01/27/Cpp%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-01-27T02:59:54.000Z</published>
    <updated>2020-01-27T14:11:39.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//变量创建的语法： 数据类型 变量名 = 变量初始值</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量</strong>创建的语法： 数据类型 变量名 = 变量初始值</p><p>定义<strong>常量</strong>的两种方法：</p><ol><li><code>#define</code> 宏常量名 常量值 </li><li><code>const</code> 修饰的变量  <code>const</code> 数据类型 常量名 = 常量值</li></ol><p>定义变量或常量时不要用C++中已经使用的关键字</p><p>C++中给标识符（变量，常量）命名时，要注意：<br>1.标识符不可以是关键字<br>2.标识符只能由字母，数字，下划线组成<br>3.标识符的第一个字母只能是字母或者下划线<br>4.标识符中区分大小写<br>5.给变量命名时最好能做到见名知意，方便阅读</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型存在的意义：给不同类型的变量分配合适的内存空间</p><p><strong>整型</strong>的几种类型：<br>1.短整型    short      2字节   -2^15 - 2^15-1<br>2.整型      int        4字节   -2^31 - 2^31-1   //int最常用<br>3.长整型    long       4字节   -2^31 - 2^31-1<br>4.长长整型  long long  8字节   -2^63 - 2^63-1</p><p><strong><code>sizeof</code></strong> 关键字可以得到数据类型所占的内存的大小<br>语法： <code>sizeof</code>（数据类型/变量名）</p><p><strong>实型/浮点型</strong>：用于表示小数<br>1.单精度 float   4字节  7位有效数字<br>2.双精度 double  8字节  15-16位有效数字</p><p><strong>字符型</strong>：用于表示单个字符   只占用1个字节，将对应的ASCII码放入存储单元<br>语法：<code>char ch = &#39;a&#39;</code><br>需要注意：<br>1.要用单引号将字符括起来<br>2.单引号内只能有一个字符，不可以是字符串</p><p><strong>字符串型</strong>：用于表示一串字符<br>两种风格：</p><ol><li>C风格字符串：   <code>char</code> 变量名[] = “字符串值”   要用双引号</li><li>C++风格字符串： <code>string</code> 变量名 = “字符串值”   需要加入头文件 <code>#include&lt;string&gt;</code></li></ol><p><strong>转义字符</strong>： 用于表示一些不能显示出来的ASCII字符<br>常用的转义字符：/n 换行，将当前位置移到下一行开头<br>                              /t 水平制表，跳到下一个TAB位置，/t和其前面的内容一共占8个字符<br>                             // 代表一个反斜杠字符</p><p><strong>布尔类型</strong><code>bool</code>：代表真或假的值   占用1个字节<br><code>bool</code>类型只有两个值：<code>true</code>（本质是1）  <code>false</code>（本质是0）</p><p><strong>数据的输入</strong>：用于从键盘获取数据<br>语法：<code>cin &gt;&gt;</code> 变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">short num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"short所占的内存空间为"</span> &lt;&lt; <span class="keyword">sizeof</span>(num1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">3.14f</span>;   <span class="comment">//编译器会把小数默认为双精度数，所以要在3.14后加上f                   </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f1="</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d1="</span> &lt;&lt; d1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//显示小数默认是6位，若要改变可用&lt;iomanip&gt;库中的  setprecision( ) </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">12.3456789</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 默认以6精度，所以输出为 12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成4精度，所以输出为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">8</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 改成8精度，所以输出为12.345679</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// fixed和setprecision的作用还在，依然显示12.3457</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::fixed); <span class="comment">// 去掉了fixed，所以精度恢复成整个数值的有效位数，显示为12.35</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">6</span>); <span class="comment">// 恢复成原来的样子，输出为12.3457</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">3e2</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"f2="</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看字符型变量对应的ASCII码 a-97  A-65</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ch = <span class="number">97</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据的输入</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入字符串变量："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算术运算符</strong>：加+  减-  乘*  除/<br>            取模（取余）%  只有整型变量可以进行取模运算<br>需要注意：<br>1.进行运算的变量类型，如两个整型相除结果仍是整数<br>2.除数不能为0，取模运算除数也不能为0<br>3.只有整型变量可以进行取模运算，小数不可以</p><p><strong>赋值运算符</strong>：用于将表达式的值赋给变量<br>赋值=   加等于+=    减等于-=    乘等于*=    除等于/=     模等于%=</p><p><strong>比较运算符</strong>：用于表达式的比较，并返回一个真值或假值<br>相等于==    不等于!=    小于&lt;     大于&gt;     小于等于&lt;=    大于等于&gt;=</p><p><strong>逻辑运算符</strong>：用于根据表达式的值返回真值或假值<br>非!     与&amp;&amp;     或||</p><p>要注意<strong>运算符</strong>的优先级</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// a2=11, b2=110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// a3=11, b3=100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较运算符</span></span><br><span class="line"> a = <span class="number">10</span>;</span><br><span class="line"> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a == b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a != b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt; b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &gt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (a &lt;= b) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C++支持的三种基本程序运行结构：顺序结构，选择结构，循环结构<br>1.顺序结构：程序按顺序执行，不发生跳转<br>2.选择结构：依据条件是否满足，有选择的执行相应功能<br>3.循环结构：依据条件是否满足，循环多次执行某段代码</p><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a><strong>选择结构</strong></h4><p><strong>if语句：</strong><br>1.单行格式if语句：if (条件) { 条件满足执行的语句}<br>2.多行格式if语句：if (条件) { 条件满足执行的语句}  else{条件不满足执行的语句}<br>3.多条件的if语句：if (条件1) {条件1满足执行的语句} else if(条件2) {条件2满足执行的语句} …….else {条件都不满足执行的语句}<br>4.嵌套if语句<br>注意：if条件后面不要加分号</p><p><strong>三目运算符</strong>：实现简单的判断<br>语法：表达式1 ? 表达式2 : 表达式3<br>解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果<br>      如果表达式1的值为假，执行表达式3，并返回表达式3的结果<br>注意：C++中三目运算符返回的是变量，可以继续赋值</p><p><strong>switch语句</strong>：执行多条件分支语句<br>语法：switch(表达式)<br>{<br>    case 结果1：执行语句;break;<br>    case 结果2：执行语句;break;<br>    …<br>    default:执行语句;break;<br>}<br>注意：1. <code>switch</code>语句中的表达式的数据类型只能是整型或字符型</p><pre><code>        2. case里如果没有break，那么程序会一直向下执行        3.对于多条件判断，switch的结构清晰，执行效率高</code></pre><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>while循环结构</strong>：满足循环条件，执行循环结构<br>  语法：while (循环条件) {循环结构}<br>  注意：在执行循环语句时，程序必须提供跳出循环的窗口，否则出现死循环</p><p><strong>do … while循环语句</strong>：满足循环条件，执行循环语句<br>  语法：do {循环语句} while (循环条件)<br>  注意：do…while先执行一次循环语句，再判断循环条件</p><p><strong>for 循环语句</strong>：满足循环条件<br>  语法： for (起始表达式; 条件表达式; 末尾循环体) {循环语句}<br>  注意： 先判断条件表达式，然后执行循环语句，然后再执行末尾循环体</p><p><strong>嵌套循环</strong></p><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p><strong>break 语句</strong>：用于跳出选择结构或者循环结构<br>  使用的时机：出现在switch条件语句中，作用是终止case或者跳出switch<br>                         出现在循环语句中，作用是跳出当前的循环语句<br>                         出现在嵌套循环中，跳出最近的内层循环结构</p><p><strong>continue语句</strong>：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环<br>  注意：continue不会使循环终止，而break会跳出循环</p><p><strong>goto语句</strong>：可以无条件跳转语句<br>  语法：goto 标记<br>             如果标记的名称存在，执行到goto语句时，会跳转到标记的位置<br>  注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//嵌套if语句</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入考试分数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了一本大学"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了北大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了清华"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了人大"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了二本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我考上了三本大学"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"我未考上本科"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三目运算符</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">0</span>;</span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;         <span class="comment">//b=100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//a=10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//b=100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套循环体</span></span><br><span class="line"><span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continue语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      复习了C++的一些基础语法
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>搭建自己的博客</title>
    <link href="http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://nekomoon404.github.io/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-18T03:08:31.000Z</published>
    <updated>2020-01-18T05:42:11.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h1><p>GIt是目前世界上最先进的分布式版本控制系统，其开发者就是Linux的作者Linus Torvalds。可以到Git的官网下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a>，在安装选项设置页面中勾选Git Bash Here和Git GUI Here。</p><h1 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h1><p>在官网选择LTS版本下载安装即可：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>。</p><h1 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h1><p>在本地磁盘中建立一个文件夹来存储博客的本地文件，如D:\blog。进入blog文件夹，单机右键，菜单中选择Git Bash Here。在命令框中依次执行以下命令安装Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>启动服务：依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm stall</span><br><span class="line">hexo s</span><br><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>浏览器打开本地访问页面 ，使用ctrl+c可关闭服务。若不能访问可尝试用以下命令解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>之后每次更新博客内容后都要执行 hexo c —&gt;hexo g —&gt;hexo d，来重新部署。</p><h1 id="4-将Hexo部署到GitHub"><a href="#4-将Hexo部署到GitHub" class="headerlink" title="4.将Hexo部署到GitHub"></a>4.将Hexo部署到GitHub</h1><p>在GitHub中创建一个新的repository，repository name必须是 用户名.github.io 的格式</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.1.jpg" alt="1.1" style="zoom:67%;"></p><p>回到Git Bash中，部署用户名和邮箱，其中yourname输入GitHub用户名，youremail输入GitHub的登陆邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>创建SSH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>打开提示已经创建好的.ssh文件夹，其中<code>id_rsa</code>是私人密钥，<code>id_rsa.pub</code>是公共密钥。在GitHub中打开setting —&gt; New SSH key，将<code>id_rsa.pub</code>里面的信息复制进去。</p><p><img src="/2020/01/18/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.2.jpg" alt="1.2" style="zoom: 50%;"></p><p>在blog文件夹中打开博客配置文件<code>_config.yml</code>，将最后几行修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装deploy-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后重新部署博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这样就可以在  <a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a>  访问自己的博客了。</p><h1 id="5-设置主题"><a href="#5-设置主题" class="headerlink" title="5.设置主题"></a>5.设置主题</h1><p>我安装的是Next主题，网上有很多教程可以参考，我直接安装最新的v6+版本。在<code>blog</code>文件夹下右键GIt Bash Here，下载主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>打开<code>blog</code>目录下的博客站点配置文件<code>_config.yml</code>，在开头的<code>Site</code>中添加自己博客的信息，注意将<code>language</code>改为<code>zh-CN</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: # 标题</span><br><span class="line">subtitle: # 副标题</span><br><span class="line">description: # 站点描述</span><br><span class="line">author: # 作者</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>往下拉，将<code>theme</code>改为<code>next</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>重新部署博客即可看到主题已经替换。</p><p>接着就是博客的一些具体细节方面的设置，这一部分有很多东西可以学习，我目前只学了一些基础操作。</p><h3 id="设置scheme"><a href="#设置scheme" class="headerlink" title="设置scheme"></a>设置scheme</h3><p>在<code>\blog\themes\next</code>文件夹中打开主题配置文件<code>_config.yml</code>，找到外观<code>scheme</code>，想使用哪一种就把前面的注释符#去掉，我选用的是<code>Mist</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在主题配置文件<code>_config.yml</code>中找到菜单<code>menu</code>，将需要的项前的#去掉，我保留了<code>about</code>关于，<code>categories</code>分类，<code>tags</code>标签，<code>archives</code>归档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>创建菜单需要的页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>在<code>\blog\source</code>下就会生成对应的文件夹，打开其中的<code>index.md</code>文件，将type设置为相应的内容，以<code>about</code>为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: about</span><br><span class="line">date: 2020-01-17 20:16:07</span><br><span class="line">type: &quot;about&quot; </span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="设置背景动画"><a href="#设置背景动画" class="headerlink" title="设置背景动画"></a>设置背景动画</h3><p>在主题配置文件<code>_config.yml</code>中找到<code>Animation Settings</code>，我使用的是<code>Canvas-nest</code>，将<code>Canvas-nest</code>下的enable状态改为true即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # Display on mobile or not</span><br></pre></td></tr></table></figure><p>——————————————————————————</p><p>到这里个人博客就算搭建起来了，但还是比较简陋，之后可以学习将博客完善美化起来。这也是我在这里写下的第一篇文章，使用Typora编辑。</p><p>2020年希望自己能成为一个自律的人，也希望这个博客不会只是自己一时兴起的产物。</p>]]></content>
    
    <summary type="html">
    
      最近想搭建一个自己的博客来记录一下学习过程，也能起到一定的督促作用，于是从网上找了一些教程学习了如何用Hexo+GitHub来搭建个人博客，下面记录一下搭建的过程。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://nekomoon404.github.io/2020/01/12/hello-world/"/>
    <id>http://nekomoon404.github.io/2020/01/12/hello-world/</id>
    <published>2020-01-12T07:14:03.207Z</published>
    <updated>2020-01-12T07:14:03.207Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
