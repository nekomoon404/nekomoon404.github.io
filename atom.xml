<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nekomoon的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nekomoon404.github.io/"/>
  <updated>2020-11-11T11:49:34.793Z</updated>
  <id>http://nekomoon404.github.io/</id>
  
  <author>
    <name>nekomoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法基础（17）</title>
    <link href="http://nekomoon404.github.io/2020/11/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8817%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/11/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8817%EF%BC%89/</id>
    <published>2020-11-10T12:53:20.000Z</published>
    <updated>2020-11-11T11:49:34.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>贪心问题的代码一般较简单，但证明其正确性较难，且没有常规的套路，更不用说常用的模板。（DP问题至少有常用的分析套路）。</p></blockquote><h3 id="1-区间问题"><a href="#1-区间问题" class="headerlink" title="1.区间问题"></a>1.区间问题</h3><h4 id="1-1-区间选点"><a href="#1-1-区间选点" class="headerlink" title="1.1.区间选点"></a>1.1.区间选点</h4><blockquote><p>例题：区间选点（Acwing 905）</p><p>给定N个闭区间$[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。输出选择的点的最小数量。位于区间端点上的点也算作区间内。</p><p>输入格式：第一行包含整数N，表示区间数。接下来N行，每行包含两个整数$a_i,b_i$，表示一个区间的两个端点。</p><p>输出格式：输出一个整数，表示所需的点的最小数量。</p><p>数据范围：$1≤N≤10^5,−10^9≤a_i≤b_i≤10^9$</p></blockquote><p>如下图的四个区间，所需的点的最小数量为2：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201110211056.png" style="zoom: 25%;"></p><p>尝试用排序的思路做：</p><ol><li><p>将每个区间按右端点有小到大排序</p></li><li><p>从前往后依次枚举每个区间（看区间右端点）：</p><p>如果当前区间中已经包含点，则直接pass；</p><p>否则，选择当前区间的右端点</p></li></ol><blockquote><p>每次都是选当前最好的情况（局部最优），走过去，贪心就是按照这种策略，最后可以走到最优解。</p></blockquote><p>证明算法的正确性：每一个区间上都一定包含了一个点，当前选点的方案就是一组合法方案，包含的点数用<code>cnt</code>表示，本题的答案是所有可行方案中的最小值，用<code>ans</code>表示，则有<code>ans &lt;= cnt</code>；考虑第2步的第二种情况，所有没被Pass的区间是什么情况：则需要<code>cnt</code>个相互之间没有交集的区间，若想把每个区间都覆盖掉，则至少需要<code>cnt</code>个点，则所有可行方案的点数都一定大于等于<code>cnt</code>，即<code>ans &gt;= cnt</code>。综合两个不等式，就有<code>ans = cnt</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l ,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Range &amp;w)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;     <span class="comment">//重载小于号，区间要按右端点排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range, range + n);   <span class="comment">//按区间右端点从小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;   <span class="comment">//res存点数，ed存上一次取的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(range[i].l &gt; ed)     <span class="comment">//如果当前区间的左端点严格大于上一次取的点，则选择当前区间的右端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-最大不相交区间的数量"><a href="#1-2-最大不相交区间的数量" class="headerlink" title="1.2.最大不相交区间的数量"></a>1.2.最大不相交区间的数量</h4><blockquote><p>例题：最大不相交区间的数量（Acwing 908）</p><p>给定N个闭区间$[a_i,b_i]$，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。输出可选取区间的最大数量。</p><p>数据范围：$1≤N≤10^5,−10^9≤a_i≤b_i≤10^9$</p></blockquote><p>本题的做法和上题基本是一样的，证明方法也是类似的。（代码完全一样，就不写了）</p><blockquote><p>为什么最大不相交区间数==最少覆盖区间点数呢？因为如果几个区间能被同一个点覆盖，说明它们相交了，所以有几个点就是有几个不相交区间。</p></blockquote><h4 id="1-3-区间分组"><a href="#1-3-区间分组" class="headerlink" title="1.3.区间分组"></a>1.3.区间分组</h4><blockquote><p>例题：区间分组（Acwing 906）</p><p>给定N个闭区间$[a_i,b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。输出最小组数。</p><p>数据范围：$1≤N≤10^5,−10^9≤a_i≤b_i≤10^9$</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201110222435.png" style="zoom: 33%;"></p><blockquote><p> 区间贪心的问题基本都是先按照左/右端点从小到大排序。</p></blockquote><p>本题的思路：</p><ol><li><p>将所有区间按左端点从小到大排序；</p></li><li><p>从前往后处理每个区间：</p><p>判断能否将其放到某个现有的组中，就是判断当前区间的左端点是否小于等于组中最大的右端点，<code>L[i]&lt;=Max_r</code>，若小于等于则说明当前区间与组中区间有交集；若严格大于，则说明当前区间与组中区间没有交集，可放入组中。</p><p>1）如果不存在这样的组，则开新组，然后再将其放进去；</p><p>2）如果存在这样的组，将其放进去，并更新当前组的Max_r（随便挑一个放进去）</p></li></ol><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111113056.png" style="zoom: 33%;"></p><p>算法正确性的证明：</p><blockquote><p>证明：1. Ans &lt;= cnt； 2，Ans &gt;= cnt，即证：Ans == cnt</p></blockquote><p>这样选出来的方案一定是一种合法方案，每个组内的区间两两之间都没有交集，则有最小组数&lt;=当前方案数，即<code>Ans &lt;= cnt</code>；当在开第<code>cnt</code>个组时，说明当前区间与前<code>cnt - 1</code>个组都有交集，在这些组中都可以找到一个区间，使得当前区间的左端点<code>Li</code>在区间上（左端点小于<code>Li</code>，右端点大于<code>Li</code>），即这<code>cnt</code>个区间有一个公共点<code>Li</code>，因此不管怎么分，这<code>cnt</code>个区间中每一个区间都必须在一个单独的组中，因此所有可行方案中的区间数一定大于等于<code>cnt</code>，即<code>Ans &gt;= cnt</code>，即证<code>Ans = cnt</code>。</p><p>对于当前区间如何判断是否存在一个组的<code>Max_r &gt; L[i]</code>呢，可以把所有组的Max_r存入一个小根堆中（优先级队列），若其中最小的<code>Max_r</code>小于<code>L[i]</code>，则找到了满足条件的区间；若最小的<code>Max_r</code>都大于等于<code>L[i]</code>，则不存在这样的区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l ,r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Range &amp; w) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range, range + n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;   <span class="comment">//定义一个小根堆，来存每组中区间的最右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span>(heap.empty() || heap.top() &gt;= r.l)    <span class="comment">//如果小根堆为空，或者每组右端点最小值都大于当前区间的左端点</span></span><br><span class="line">            heap.push(r.r);      <span class="comment">//说明当前区间与每组都重合，必须开一个新的组</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//否则，则说明存在一个组的Max_r小于当前区间左端点，当前区间可以放入该组中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int t = heap.top();</span></span><br><span class="line">            heap.pop();</span><br><span class="line">            heap.push(r.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-区间覆盖"><a href="#1-4-区间覆盖" class="headerlink" title="1.4.区间覆盖"></a>1.4.区间覆盖</h4><blockquote><p>例题：区间覆盖（Acwing 907）</p><p>给定N个闭区间$[a_i,b_i]$以及一个线段区间$[s,t]$，请你<strong>选择尽量少的区间，将指定线段区间完全覆盖</strong>。输出最少区间数，如果无法完全覆盖则输出-1。</p><p>输入格式：第一行包含两个整数s和t，表示给定线段区间的两个端点。第二行包含整数N，表示给定区间数。接下来N行，每行包含两个整数$a_i,b_i$，表示一个区间的两个端点。</p><p>输出格式：输出一个整数，表示所需最少区间数。如果无解，则输出-1。</p><p>数据范围：$1≤N≤10^5,−10^9≤a_i≤b_i≤10^9,−10^9≤s≤t≤10^9$。</p></blockquote><p>本题的思路是：</p><ol><li>将所有区间按左端点从小到大排序；</li><li>从前往后依次枚举每个区间，在所有能覆盖线段开始的位置<code>start</code>的区间当中，选择右端点最大的区间，然后将<code>start</code>更新成这个右端点的最大值。</li></ol><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111153115.png" style="zoom: 33%;"></p><p>证明算法的正确性：</p><p>本题可以直接证明相等，如下图分别是最小区间数，和用上面算法选出来的区间，对于最优解一定可以替换为算法得出来的解，即<code>Ans = cnt</code>。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111153144.png" style="zoom: 25%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Range &amp; w)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; w.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st, ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(range, range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i, r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= st)  <span class="comment">//双指针，找到能覆盖start（即左端点小于start）的所有区间的右端点的最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r, range[j].r);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r &lt; st)   <span class="comment">//如果找到的r小于线段的左端点，说明没有能覆盖线段的区间方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)  <span class="comment">//如果找到的r大于等于线段的右端点，说明已经找到了方案，跳出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;   <span class="comment">//有可能循环结束了还没有覆盖完线段，所有要找个标志来判断是否已经找到方案</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!flag)  res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Huffman树"><a href="#2-Huffman树" class="headerlink" title="2.Huffman树"></a>2.Huffman树</h3><blockquote><p>例题：合并果子（Acwing 148）</p><p>在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。达达决定把所有的果子合成一堆。每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。</p><p>达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以达达总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。</p><p>输入格式：输入包括两行，第一行是一个整数$n$，表示果子的种类数。第二行包含$n$个整数，用空格分隔，第$i$个整数$a_i$是第$i$种果子的数目。</p><p>输出格式：输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于$2^31$。</p><p>数据范围：$1≤n≤10000,1≤a_i≤20000$</p></blockquote><p>Huffman树是一颗完全二叉树，如下图，叶子结点是所有要合并的点，合并的代价是$3a+3b+3c+3d+2e+2f$，我们要在这一点的完全二叉树中选择出合并代价最小的一棵，并输出最小的代价。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111161103.png" style="zoom:33%;"></p><p>做法：每次都是挑选最小的两堆合并（寻找局部最优），即每一步都贪心地选择局部最优解，就可以得到最优解。</p><blockquote><p>注意本题与合并石子的区别：本题可以合并任意两堆果子，而合并石子只能合并相邻的两堆石子</p></blockquote><p>证明：</p><ol><li>最优解中，权值最小的两个点，一定在树中深度最深，且可以互为兄弟；（也可以这样理解：因为深度最深的点要计算最多次，所以在其位置用权值最小的点才会比较好）</li><li>贪心式的合并能否得到最优解，n-1堆合并的最优解不一定是n堆合并的最优解，如下图一次合并<code>a</code>和<code>b</code>，之后合并剩下<code>n-1</code>个点的某个方案的代价设为<code>f(n-1)</code>，则相应的合并<code>n</code>个点的方案的代价为<code>f(n) = f(n-1) + a + b</code>，我们的目标是求出<code>f(n)</code>的最小值，这些方案的第一步都是合并<code>a</code>和<code>b</code>，这样问题就转化为求<code>f(n-1)</code>的最小值，即转化为<code>n-1</code>个点的Huffman问题，则可以继续找权值最小的两个点合并。</li></ol><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111163345.png" style="zoom: 33%;"></p><blockquote><p>每次求权值最小的两个点，可以用优先级队列的小根堆。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; heap;  <span class="comment">//小根堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        heap.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = heap.top();  heap.pop();</span><br><span class="line">        <span class="keyword">int</span> b = heap.top();  heap.pop();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.push(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-排序不等式"><a href="#3-排序不等式" class="headerlink" title="3.排序不等式"></a>3.排序不等式</h3><blockquote><p>例题：排队打水（Acwing 913）</p><p>有 n 个人排队到 1 个水龙头处打水，第$ i $个人装满水桶所需的时间是$ t_i$，请问如何安排他们的打水顺序才能<strong>使所有人的等待时间之和最小</strong>？</p><p>输入格式：第一行包含整数 n。第二行包含 n 个整数，其中第$ i $个整数表示第$ i $个人装满水桶所花费的时间$ t_i$。</p><p>输出格式：输出一个整数，表示最小的等待时间之和。</p><p>数据范围：$1≤n≤10^5,1≤t_i≤10^4$。</p></blockquote><p>如打水顺序是：$3,6,1,4,2,5,7$，则等待的总时间就等于$3<em>6+6</em>5+1<em>4+4</em>3+2<em>2+5</em>1=73$。若打水顺序是：$t_1,t_2,t_3,\dots,t_n$，则总的等待时间是$t_1<em>(n-1)+t_2</em>(n-2)+t_3<em>(n-3)+\dots+t_{n-1}</em>1$。</p><p>直觉的做法是让打水时间长的人尽量靠后，让打水时间短的人靠前，即让所有人按打水时间从小到大排队，则总的等待时间是最小的。</p><p>如何证明：反证法，如果最优解不是按照从小到大排好序的，那一定有两个相邻的人有$t_i&gt;t_{i+1}$，让这两人位置交换。交换前等待总时间中两项对应的时间为$t_i<em>(n-i)+t_{i+1}</em>(n-i-1)$，交换后为$t_{i+1}<em>(n-i)+t_i</em>(n-i-1)$，则后$-$前$=(n-i)<em>(t_{i+1}-t_i)+(n-i-1)</em>(t_i-t_{i+1})=t_{i+1}-t_i&lt;0$，则说明交换后的总等待时间比当前小，则当前解不是最优解，因此可证按打水时间从小到大排序得到的是最优解。</p><blockquote><p>贪心问题的证明方法一般从反证法；“夹逼”：由<code>ans &lt;= cnt</code>，<code>ans &gt;= cnt</code>，得<code>ans = cnt</code>；数学归纳法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">    </span><br><span class="line">    sort(t, t + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  res += t[i] * (n - i - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-绝对值不等式"><a href="#4-绝对值不等式" class="headerlink" title="4.绝对值不等式"></a>4.绝对值不等式</h3><blockquote><p>例题：货仓选址（Acwing 104）</p><p>在一条数轴上有 N 家商店，它们的坐标分别为$ A_1~A_N$。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p><p>输入格式：第一行输入整数N。第二行N个整数$A_1~A_N$。</p><p>输出格式：输出一个整数，表示距离之和的最小值。</p><p>数据范围：$1≤N≤100000$</p></blockquote><p>将数轴上商店的地址记为$x_1,x_2,x_3,\dots,x_n$，将仓库的地址记为$x$，则仓库到每家商店的距离之和为：$f(x)=|x_1-x|+|x_2-x|+|x_3-x|+\dots|x_n-x|$。</p><p>直接的做法是将仓库放在中位数的位置，若商店有奇数个，仓库就放在中位数；若商店有偶数个，仓库就放在两个中位数的中间任意位置（包括端点）。</p><p>求$f(x)$的最值，将数分成两组：</p><script type="math/tex; mode=display">\begin{align*}f(x)&=|x_1-x|+|x_2-x|+|x_3-x|+\dots|x_n-x| \\&=(|x_1-x|+|x_n-x|)+(|x_2-x|+|x_{n-1}-x|)+\dots \\&\ge x_n-x_1+x_{n-1}-x_2+\dots\end{align*}</script><p>单看每一个括号中值，即求$|a-x|+|b-x|$的最小值，当$x\in [a,b]$时，取得最小值$b-a$，所以有$f(x)\ge x_n-x_1+x_{n-1}-x_2+\dots$，那等号能不能取到呢，即看等号对于每个括号内的项能不能同时取到，则$x$只要取到中位数（奇数个商店），或中间的两个数（偶数个商店）之间，上式就能取到等号。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201111190230.png" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  res += <span class="built_in">abs</span>(a[i] - a[n / <span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-推公式"><a href="#5-推公式" class="headerlink" title="5.推公式"></a>5.推公式</h3><blockquote><p>例题：耍杂技的牛（Acwing 125）</p><p>农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。奶牛们不是非常有创意，只提出了一个杂技表演：叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。</p><p>这N头奶牛中的每一头都有着自己的重量$W_i$以及自己的强壮程度$S_i$。一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。</p><p>您的任务是确定奶牛的排序，<strong>使得所有奶牛的风险值中的最大值尽可能的小</strong>。</p><p>输入格式：第一行输入整数N，表示奶牛数量。接下来N行，每行输入两个整数，表示牛的重量和强壮程度，第$i$行表示第$i$头牛的重量$W_i$以及它的强壮程度$S_i$。</p><p>输出格式：输出一个整数，表示最大风险值的最小可能值。</p><p>数据范围：$1≤N≤50000,1≤W_i≤10,000,1≤S_i≤1,000,000,000$</p></blockquote><p>每个牛的危险系数等于它上面牛的重量之和减去它自己的强壮程度。</p><p>本题的做法是：按照$W_i+S_i$从小到大的顺序排序（从上到下，上面的牛最小），最大的危险系数一定是最小的。</p><p>证明：</p><ol><li>贪心得到的答案 &gt;= 最优解（显然）</li><li>贪心得到的答案 &lt;= 最优解：若叠牛罗汉的最优解不是按照$w_i+s_i$从小到大排序的，那么必存在一个逆序对，使$w_i+s_i &gt; w_{i+1}+s_{i+1}$，将第$i$个位置的牛和第$i+1$位置的牛交换，交换前后的危险系数对比为：</li></ol><div class="table-container"><table><thead><tr><th></th><th>第$i$个位置上的牛的危险系数</th><th>第$i+1$个位置上的牛的危险系数</th></tr></thead><tbody><tr><td>交换前</td><td>$w_1+w_2+\dots+w_{i-1}-s_i$</td><td>$w_1+w_2+\dots+w_{i}-s_{i+1}$</td></tr><tr><td>交换后</td><td>$w_1+w_2+\dots+w_{i-1}-s_{i+1}$</td><td>$w_1+w_2+\dots+w_{i-1}+w_{i+1}-s_i$</td></tr></tbody></table></div><p>将上面各式都减去一个$w_i+w_2+\dots+w_{i-1}$，再加上一个$s_i+s_{i+1}$，就会变成：</p><div class="table-container"><table><thead><tr><th></th><th>第$i$个位置上的牛的危险系数</th><th>第$i+1$个位置上的牛的危险系数</th></tr></thead><tbody><tr><td>交换前</td><td>$s_{i+1}$</td><td>$w_i+s_i$</td></tr><tr><td>交换后</td><td>$s_i$</td><td>$w_{i+1}+s_{i+1}$</td></tr></tbody></table></div><p>因为上式各项都是$\ge 1$的，所以$w_i+s_i&gt;s_i$，又有$w_i+s_i &gt; w_{i+1}+s_{i+1}$，所以有$\max(s_i, w_{i+1}+s_{i+1})&lt;w_i+s_i$，即有$\max(s_i, w_{i+1}+s_{i+1})&lt; \max(s_{i+1}, w_i+s_i)$。则逆序对交换顺序后，两个位置上危险系数的最大值一定比交换前小，那么整体的危险系数的最大值一定小于等于交换前的，若把所有的逆序对都变成顺序，即用贪心得到的答案，那它的危险系数的最大值一定是小于等于最优解的（即交换前的）。</p><p>综上，就证明了贪心得到的答案就是最优解。</p><blockquote><p>贪心问题可以先推出问题的公式（？），再运用一些数学中的不等式来解题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">PII cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;s);</span><br><span class="line">        cow[i] = &#123;w + s, s&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(cow, cow + n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-2e9</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = cow[i].second, w = cow[i].first - s;</span><br><span class="line">        res = <span class="built_in">max</span>(res, sum - s);</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第六章的内容：贪心（区间问题）
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（16）</title>
    <link href="http://nekomoon404.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8816%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8816%EF%BC%89/</id>
    <published>2020-11-01T06:10:58.000Z</published>
    <updated>2020-11-04T11:46:11.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-计数类DP"><a href="#1-计数类DP" class="headerlink" title="1.计数类DP"></a>1.计数类DP</h3><blockquote><p>例题：整数划分（Acwing 900）</p><p>一个正整数$n$可以表示成若干个正整数之和，形如：$n=n_1+n_2+…+n_k$，其中$n_1≥n_2≥…≥n_k,k≥1$。我们将这样的一种表示称为正整数$n$的一种划分。现在给定一个正整数$n$，请你求出$n$共有多少种不同的划分方法。由于答案可能很大，输出结果请对$10^9+7$取模。</p><p>数据范围：$1\le n \le 1000$</p></blockquote><p>因为题中的划分方案不考虑数字的顺序，因此我们可以把要划分的数$n$看作是一个体积为$n$的背包，有体积有$1,2,3,\dots,n$的物品，可取用的个数是无限个，我们要求的是恰好装满背包的方案数，即抽象成<strong>完全背包问题</strong>。</p><ul><li>状态表示<code>f(i,j)</code>：<ul><li>集合：所有从$1\sim i$中选，总体积恰好为$j$的选法的集合</li><li>属性：上述选法的数量</li></ul></li><li>状态计算：<ul><li>集合的划分：<code>f(i,j)</code>可以分为选了0个第<code>i</code>个物品<code>f(i-1,j)</code>，选了1个第<code>i</code>个物品<code>f(i-1,j-i)</code>，选了两个第<code>i</code>个物品<code>f(i-1,j-2*i)</code>，……选了s个第<code>i</code>个物品<code>f(i-1,j-s*i)</code>；</li><li>状态转移方程为：<code>f(i,j)=f(i-1,j)+f(i-1,j-i)+f(i-1,j-2*i)...+f(i-1,j-s*i)</code>，时间复杂度为$O(n^2 \log n)$（状态数为$n^2$，状态计算量为$\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+\dots\frac{n}{n}=\log n$。</li><li>按照完全背包问题的思路做进一步优化：将<code>f(i,j)</code>的方程与<code>f(i,j-i)</code>的方程作对比，<code>f(i,j-i)=f(i-1,j-i)+f(i-1,j-2*i)+...+f(i-1,j-s*i)</code>，则有：<code>f(i,j)=f(i-1,j)+f(i-1,j-i)</code>；同时可以在空间上优化，用一维数组表示，即<code>f[j]=f[j]+f[j-1]</code>，体积从小到大循环。这样时间复杂度为$O(n^2)$</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//初始化：当没有数时，j=0有一种方案，即i=0；其余f[j]都是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j ++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解法：</p><ul><li><p>状态表示<code>f[i,j]</code>：</p><ul><li>集合：所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的选法；</li><li>属性：数量，上述选法的数量</li></ul></li><li><p>状态计算：</p><ul><li>集合划分：<code>f[i,j]</code>可以分为两大类：方案中最小值是1——若把所有方案中的最小值1去掉，就可以变成总和是<code>i-1</code>，恰好分成<code>j-1</code>个数的方案，即<code>f[i-1,j-1]</code>；方案中最小值大于1——若把方案中每个数都减去1，就可以变成总和是<code>i-j</code>，恰好分成<code>j</code>个数的方案，即<code>f[i-j,j]</code>。</li><li>则状态转移方程：<code>f[i,j]=f[i-1,j-1]+f[i-j,j]</code>，最后的答案是<code>ans=f[n,1]+f[n,2]+...+f[n,n]</code></li></ul></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201101151335.png" style="zoom:60%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//初始化：当没有数时，j=0有一种方案，即i=0；其余f[j]都是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  res = (res + f[n][i]) % mod; </span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数位统计DP"><a href="#2-数位统计DP" class="headerlink" title="2.数位统计DP"></a>2.数位统计DP</h3><blockquote><p>例题：计数问题（Acwing 338）</p><p>给定两个整数$a$和$b$，求$a$和$b$之间的所有数字中0~9的出现次数。例如，a=1024，b=1032，则 a 和 b 之间共有9个数如下：1024 1025 1026 1027 1028 1029 1030 1031 1032,其中‘0’出现10次，‘1’出现10次，‘2’出现7次，‘3’出现3次等等…</p><p>输入格式：输入包含多组测试数据。每组测试数据占一行，包含两个整数 a 和 b。当读入一行为0 0时，表示输入终止，且该行不作处理。</p><p>输出格式：每组数据输出一个结果，每个结果占一行。每个结果包含十个用空格隔开的数字，第一个数字表示‘0’出现的次数，第二个数字表示‘1’出现的次数，以此类推。</p><p>数据范围：$0&lt;a,b&lt;100000000$</p></blockquote><p>显然暴力做法是不可取的，以下做法中最重要的思路是：分情况讨论。直接求从<code>[a,b]</code>中0~9出现的次数是不好求的，我们可以先求<code>count(n,x)</code>，即$1 \sim n$中<code>x</code>出现的次数，再用求前缀和的思路来求<code>[a,b]</code>中<code>x</code>出现的次数，即<code>count(b,x)-count(a-1,x)</code>。</p><p>以<code>count(n,1)</code>为例，设当前数字为<code>abcdefg</code>，思路是分别求出1在每一位上出现的次数，如求1在第4位出现的次数，即有多少形如<code>xxx1yyy</code>的数，满足<code>1 &lt;= xxx1yyy &lt;= abcdedfg</code>，分情况讨论：</p><ol><li><p>前三位，<code>xxx = 000~abc-1</code>时，后三位可以取到<code>yyy=000~999</code>，一共有<code>abc * 1000</code>次数；</p></li><li><p>前三位，<code>xxx=abc</code>：</p><p>(2.1) <code>d &lt; 1</code>，<code>abc1yyy &gt; abc0defg</code>，共0次数；</p><p>(2.2) <code>d = 1</code>，后三位可以取到<code>yyy=000~efg</code>，共<code>efg+1</code>次数；</p><p>(2.3) <code>d &gt; 1</code>，后三位可以取到<code>yyy=000~999</code>，共1000次数</p></li></ol><p>把所有情况加到一起就是1出现在第4位上的次数。时间复杂度$10<em>2</em>8*10=1600$，（0~9十个数，计算2个<code>count()</code>，数字共8位，）。考虑一些边界情况：所求数字在第一位出现的次数——没有情况1；求0在某一位出现的次数，如在第4位，前三位<code>abc</code>不能取<code>000</code>，既不能有前导0，即<code>000123</code>不是一个合法的写法，应直接写成是<code>123</code>，这样就不会有0的次数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">001~abc-1, 999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">    1. num[i] &lt; x, 0</span></span><br><span class="line"><span class="comment">    2. num[i] == x, 0~efg</span></span><br><span class="line"><span class="comment">    3. num[i] &gt; x, 0~999</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>    <span class="comment">//取出num中从l到r位的数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt;= r; i -- ) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power10</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//求10的x次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x -- ) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(n % <span class="number">10</span>);    <span class="comment">//将n的每一位存入vector num</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">get</span>(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * power10(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= power10(i);    <span class="comment">//若x是0，则有去掉前几位都是0的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += <span class="built_in">get</span>(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[i] &gt; x) res += power10(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b , a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; count(b, i) - count(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-状态压缩DP"><a href="#3-状态压缩DP" class="headerlink" title="3.状态压缩DP"></a>3.状态压缩DP</h3><blockquote><p>例题1：蒙德里安的梦想（Acwing 291）</p><p>求把$N<em>M$的棋盘分割成若干个1</em>2的的长方形，有多少种方案。例如当N=2，M=4时，共有5种方案。当N=2，M=3时，共有3种方案。如下图所示：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201103210738.png" alt></p><p>数据范围：$1≤N,M≤11$</p></blockquote><p>上面的问题可以理解为：在下面$1*1$的网格中，我们把所有的横向长方形放完之后，纵向长方形的摆放只有一个方案，因此问题总的方案数就等于摆放横着的小长方形的方案数。</p><p>我们可以按列来求，每一列用一个状态<code>f[i,j]</code>来表示，第<code>i</code>列，上一列“伸出”的小长方形的行的状态用<code>j</code>表示，用二进制表示状态数，如共有5行，那<code>j</code>的状态数就是$0 \sim 31$，即<code>j</code>表示上一列有哪些行“伸出”了小长方形，如下图所示$j=(10010)_2$。</p><p>若当前要算的状态是第<code>i</code>列的<code>j=00001</code>，前一列<code>k=10010</code>，这两列伸出的小长方形不能冲突，即<code>(j &amp; k) == 0</code>，第<code>i-1</code>列所有空白行的个数必须是偶数，因为我们枚举完第<code>i</code>列后，第<code>i-1</code>列剩下的空白必须要用竖着的小长方形来填，其长度为2，因此<code>j | k</code>（j 或k ）不能有连续奇数个0，可以先预处理出来。</p><p>状态转移方程：<code>f[i,j] += f(i - 1, k)</code>，时间复杂度：$2 \times 2^{11} \times 2^{11}=4 \times 10^7 $， 满足要求。</p><blockquote><p>用二进制去表示状态，是个思维上的难点。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201103215715.png" style="zoom:875%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;  <span class="comment">// n行，m列</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N][M];  </span><br><span class="line"><span class="keyword">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)   <span class="comment">//预处理单列中所有状态是不是存在连续奇数个0，即摆放完横的了，还能不能再摆竖的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">// cnt 表示单列中连续一段的0的个数</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)    <span class="comment">//若当前这一位是1，说明这一段中横着的已经放好了，就判断一下上一段中是否有奇数个0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)  st[i] = <span class="literal">false</span>;   <span class="comment">// 如果cnt是奇数，则不行</span></span><br><span class="line">                    cnt = <span class="number">0</span>;   <span class="comment">// 遇到1了，说明连续一段结束了，cnt 归为0</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)  st[i] = <span class="literal">false</span>;   <span class="comment">// 最后再判断一下最后一段的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;    <span class="comment">// 第一列，只有j是0时，才有一种方案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)   <span class="comment">//枚举第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++)    <span class="comment">//枚举第i列的所有状态</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; k ++)    <span class="comment">//枚举第i - 1列的所有状态</span></span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])   <span class="comment">//如果j与上k=0，且j|k不存在连续奇数个0</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];     <span class="comment">//状态转移方程</span></span><br><span class="line">                        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//第m-1列必须没有“伸出”任何横着的小长方形，即f[m][0]就是所求方案数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题2：最短Hamilton路径</p><p>给定一张$ n $个点的带权无向图，点从$ 0 \sim n-1$标号，求起点$ 0 $到终点$ n-1 $的最短Hamilton路径。 Hamilton路径的定义是从$ 0 $到$ n-1 $不重不漏地经过每个点恰好一次。</p><p>输入格式：第一行输入整数n。接下来n行每行n个整数，其中第$i$行第$j$个整数表示点$i$到$j$的距离（记为$a[i,j]$）。对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。</p><p>数据范围：$1≤n≤20, 0≤a[i,j]≤10^7$</p></blockquote><p>暴力做法：枚举要走的点的顺序，$n!$；再求路径的长度，$n$；时间复杂度就是$20!*20$，大概有20位数字，肯定不满足要求了。考虑用状态压缩DP来做：</p><ul><li>状态表示<code>f[i,j]</code>：<ul><li>集合：所有从0走到j，走过的所有点是<code>i</code>的所有路径；走过的点存在<code>i</code>之中，用二进制数表示所有点的状态</li><li>属性：MIn，求最短Hamilton路径</li></ul></li><li>状态计算：<ul><li>集合划分：以倒数第二个点来分类，分为倒数第二个点是$0,1,2,\dots,n-1$；设倒数第二个值为$k$，<code>a[k][j]</code>表示点<code>k</code>到点<code>j</code>的距离，从0走到点<code>k</code>的所有点就等于从0走到点<code>j</code>的所有点减去点<code>j</code>，即<code>i-{j}</code>；</li><li>则状态转移方程为：<code>f[i,j]=min(f[i,j], f[i-{j}, k]) + a[k][j]</code>，$k=0,1,2\dots,n-1$</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> w[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; w[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++)   <span class="comment">//枚举所有点有没有被经过的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)    <span class="comment">//枚举路径中最后一个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)             <span class="comment">//如果i的二进制表示中的第j位是1，即当前路径中经过了j</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++)      <span class="comment">//枚举路径中倒数第二个点</span></span><br><span class="line">                    <span class="keyword">if</span>((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>)  <span class="comment">//如果当前路径经过的点的状态减去点j的状态，即从0到倒数第二个点的路径中有经过点k</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);    <span class="comment">//则可以状态转移</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//最后应该输出从0到点n-1，且所有点都有经过的路径的最短长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-树形DP"><a href="#4-树形DP" class="headerlink" title="4.树形DP"></a>4.树形DP</h3><blockquote><p>例题：没有上司的舞会（Acwing 285）</p><p>Ural大学有N名职员，编号为1~N。他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数$ H_i $给出，其中$ 1≤i≤N$。现在要召开一场周年庆宴会，不过，<strong>没有职员愿意和直接上司一起参会</strong>。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。</p><p>输入格式：第一行一个整数$N$。接下来$N$行，第$ i $行表示$ i $号职员的快乐指数$H_i$。接下来$N-1$行，每行输入一对整数$L, K$,表示$K$是$L$的直接上司。</p><p>输出格式：输出最大的快乐指数。</p><p>数据范围：$1≤N≤6000,−128≤H_i≤127$</p></blockquote><ul><li><p>状态表示：</p><ul><li>集合：<code>f[u,0]</code>表示所有从以<code>u</code>为根的子树中选择，并且不选<code>u</code>这个点的方案；<code>f[u,1]</code>表示所有从以<code>u</code>为根的子树中选，并且选择<code>u</code>这个点的方案；</li><li>属性：Max，求方案中点值之和的最大值</li></ul></li><li><p>状态计算：</p><ul><li>对于<code>f[u,0]</code>，不选点<code>u</code>，则其孩子节点可以选或者不选，则$f[u,0]=\sum \max(f[s_i,0], f[s_i,1])$；</li><li><p>对于<code>f[u,1]</code>，选了点<code>u</code>，则其孩子节点不可以选，则$f[u,1]=\sum \max(f[s_i,0])+h_u$  </p></li><li><p>时间复杂度：每个状态在计算时要枚举它的孩子节点，所以节点的孩子的总数就是树中边的个数，即$n-1$，因此时间复杂度为$O(n)$</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> happy[N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;   <span class="comment">//用邻接表存树</span></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> has_father[N];    <span class="comment">//本题中没有告诉根节点是谁，需要自己判断，根节点即是没有父节点的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>    <span class="comment">//递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];   <span class="comment">// j是u的某一个子节点</span></span><br><span class="line">        dfs(j);</span><br><span class="line">        </span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;happy[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        has_father[a] = <span class="literal">true</span>;   <span class="comment">// b是a的父节点</span></span><br><span class="line">        add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root])  root ++;  <span class="comment">//没有父节点的就是根节点</span></span><br><span class="line">    </span><br><span class="line">    dfs(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-记忆化搜索"><a href="#5-记忆化搜索" class="headerlink" title="5. 记忆化搜索"></a>5. 记忆化搜索</h3><p>前面求解每种状态是用到了循环，这个题来看一下怎么用递归的方法来做DP问题。</p><blockquote><p>给定一个R行C列的矩阵，表示一个矩形网格滑雪场。矩阵中第$ i $行第$ j $列的点表示滑雪场的第$ i $行第$j $列区域的高度。一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p><p>下面给出一个矩阵作为例子：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201104180646.png" style="zoom:80%;"></p><p>在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成最长滑雪轨迹，并输出其长度(可经过最大区域数)。</p><p>数据范围：$1≤R,C≤300,0≤$矩阵中整数$≤10000$。</p></blockquote><ul><li><p>状态表示<code>f[i.j]</code>：</p><ul><li>集合：<code>f[i,j]</code>表示所有从$(i,j)$开始滑的路径</li><li>属性：Max</li></ul></li><li><p>状态计算：</p><ul><li>集合划分：把<code>f[i,j]</code>的所有路径分为四类：向上，下，左，右滑，<code>f[i,j]</code>应等于四类取值的最大值；当然每一类并不一定存在，需要其高度低于当前点的高度。（图必须是拓扑图，即不存在环，本题的状态中显然是不存在环的，因为高度递减，一定是无环的。</li></ul></li></ul><blockquote><p>记忆化搜索的好处是“代码复杂度”低，思路简单，代码好写。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N][N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">//上、右、下、左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;v = f[x][y];   <span class="comment">// 引用</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>)  <span class="keyword">return</span> v;   <span class="comment">// 如果dp(x,y)已经算过了，就直接返回其值就行</span></span><br><span class="line">    </span><br><span class="line">    v = <span class="number">1</span>;   <span class="comment">// v的最小值是1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a &gt;=<span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(v, dp(a, b) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      计数类DP，数位统计DP，状态压缩DP，树形DP，记忆化搜索
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（15）</title>
    <link href="http://nekomoon404.github.io/2020/10/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8815%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8815%EF%BC%89/</id>
    <published>2020-10-28T01:45:47.000Z</published>
    <updated>2020-10-29T07:11:24.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h3><p>线性DP是指状态转移的递推方程有明显的线性关系，有一维线性或二维线性。</p><h4 id="1-数字三角形"><a href="#1-数字三角形" class="headerlink" title="1.数字三角形"></a>1.数字三角形</h4><blockquote><p>例题1：数字三角形（Acwing 898）</p><p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201028100208.png" alt></p><p>数据范围：$1≤n≤500, −10000≤$三角形中的整数$≤10000$。</p></blockquote><ul><li>状态表示$f[i,j]$：<ul><li>集合：所有从起点走到$(i,j)$的路径</li><li>属性：Max，所有路径上的数字之和的最大值</li></ul></li><li>状态计算：<ul><li>把所有从起点到当前点$(i,j)$的路径分成两类，一类是从当前点左上方来的，可以用$f[i-1,j-1]+a[i,j]$来表示；一类是从右上方来的，可以用$f[i-1,j]+a[i.j]$来表示；</li><li>则状态转移方程为：$f[i,j]=\max(f[i-1,j-1], f[i-1,j])+a[i,j]$。</li></ul></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201028101853.png" style="zoom:67%;"></p><blockquote><p>关于DP问题代码下标的小Tip：若涉及到<code>i-1</code>这种下标，那让<code>i&gt;=1</code>，即下标从1开始比较好；若没涉及到，那从0开始也无所谓。</p><p>分析动态规划的时间复杂度一般可以用：状态数量 * 转移计算量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N][N];   <span class="comment">//存三角形中的数字</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];   <span class="comment">//存状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; j ++)   <span class="comment">//注意初始化时遍历列，要到i+1</span></span><br><span class="line">            f[i][j] = -INF;    <span class="comment">//先将f[i][j]初始化为负无穷</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)     <span class="comment">//遍历最底层找到最大值</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, f[n][j]);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意，在初始化<code>f[i][j]</code>为负无穷的时候，在每一行中遍历时要多初始化一个，即<code>j&lt;=i+1</code>。因为枚举到每行最右边的数时，它的最大值要看它左上和右上两个数，其右上的数在<code>a[][]</code>中不存在，但是其状态我们会用到，所以也必须初始化为负无穷；如枚举到<code>f[2][2]</code>，其右上的数为<code>f[1][2]</code>，因此在初始化<code>i=1</code>行时，要初始化<code>f[1][1]</code>和<code>f[1][2]</code>，即<code>j&lt;=i+1</code>。</p><h4 id="2-最长上升子序列（LIS）"><a href="#2-最长上升子序列（LIS）" class="headerlink" title="2.最长上升子序列（LIS）"></a>2.最长上升子序列（LIS）</h4><blockquote><p>例题2：最长上升子序列（Acwing 895）</p><p>给定一个长度为$N$的数列，求<strong>数值严格单调递增</strong>的<strong>子序列</strong>的长度最长是多少。</p><p>如数列$3,1,2,1,8,5,6$，最长上升子序列可以取$1,2,5,6$，长度为4。</p><p>数据范围：$1≤N≤1000，−10^9≤$数列中的数$≤10^9$。</p></blockquote><ul><li>状态表示<code>f[i]</code>：<ul><li>集合：所有以第<code>i</code>个数结尾的上升子序列；</li><li>属性：Max，集合中每一个上升子序列的长度的最大值 </li></ul></li><li>状态计算：<ul><li>集合的划分：以$a_i$结尾的上升子序列可以按其前一个数$a_j$来分，即按其前一个上升子序列的结尾来分，按$a_j$是第0个数，第1个数，第2个数，……，第$i-1$个数来分，当然这些分的情况并不一定存在，必须要满足$a_j&lt;a_i$；</li><li>则状态转移方程为：$f[i]=\max(f[j]+1)$，其中$j=0,1,2,\dots,i-1$。时间复杂度为$O(n\cdot n)=O(n^2)$</li></ul></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201028112507.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;  <span class="comment">//以a[i]结尾的上升子序列至少有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不仅想求最长子序列的长度，还要<strong>输出所求的最长子序列是什么</strong>，则可以用一个数组把“状态转移记住”，即保存让<code>f[i]</code>更新的那个<code>j</code>，这样就可以反推回方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;  <span class="comment">//以a[i]结尾的上升子序列至少有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])</span><br><span class="line">                <span class="keyword">if</span>(f[i] &lt; f[j] + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">                    g[i] = j;   <span class="comment">//g[i]存的是i的状态是从j转移来的</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(f[k] &lt; f[i])</span><br><span class="line">            k = i;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[k] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//f[k]即是最长子序列的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; LIS;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, len = f[k]; i &lt; len; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        LIS.push_back(a[k]);</span><br><span class="line">        k = g[k];      <span class="comment">//现在是倒着存的，之后需要翻转一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(LIS.<span class="built_in">begin</span>(), LIS.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : LIS)  <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题3：最长上升子序列II（Acwing 896）</p><p>给定一个长度为$N$的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p>数据范围：$1≤N≤100000，10^9≤$数列中的数$≤10^9$。</p></blockquote><p>例题3和例题2的区别是，数列长度N的范围变大了，为10万，若用题2的代码，时间复杂度为$O(n^2)$，$100000^2=10^{10}$，则会超时，因此需要在题2的代码上做优化，可以优化到$O(n \log n)$。</p><p>之前的思路是：分别求以每个数字结尾的最长上升子序列的长度。考虑每次求的时候有没有冗余：对于样例$3,1,2,1,8,5,6$，考虑长度为1的子序列，若第$i$个数可以接到3后面，那一定可以接到第二个数$1$后面，那3就没有必要存了，因为1比3小，适用范围更广。</p><p>一般地，在长度为$k$的子序列中，我们只需存结尾的数最小的那个子序列。那我们可以把数$a_i$前面这些所有不同长度的上升子序列结尾的最小值存到一个数组<code>q[]</code>，可证明这些上升子序列的长度越长，其结尾的数越大，即这个数组<code>q[]</code>是严格单调递增的。</p><p>若求以$a_i$结尾的最长上升子序列，因为$a_i$可以接到比自己小的数的末尾，因此要在数组中找到最大的小于$a_i$的数，不妨设是<code>q[4]</code>，$a_i$接到其后面长度就是5；又因为<code>q[5] &gt;= a[i]</code>，所以<code>a[i]</code>一定不可能接到一个长度大于等于5的LIS后面，因此以<code>a[i]</code>结尾的LIS的长度最大是$4+1=5$。做完这步之后要更新<code>q[5]=a[i]</code>。</p><p>如何在有序序列<code>q[]</code>中找到小于<code>a[i]</code>的最大的数？用简单的二分就可以了，时间复杂度为$O(\log n)$，因此算法总的时间复杂度为$O(n \log n)$。</p><blockquote><p>这种做法其实更像贪心。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], q[N];   <span class="comment">//存所有不同长度的上升子序列的结尾的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;     <span class="comment">//存当前找到的最长上升子序列的长度</span></span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">-2e9</span>;     <span class="comment">//当作哨兵，一定小于所有的a[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len;    <span class="comment">//套用二分模板即可</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt; a[i])  l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);    <span class="comment">//r是找到a[i]该接哪的末尾，因此LIS的长度就是r+1</span></span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-最长公共子序列（LCS）"><a href="#3-最长公共子序列（LCS）" class="headerlink" title="3.最长公共子序列（LCS）"></a>3.最长公共子序列（LCS）</h4><blockquote><p>例题4：最长公共子序列（LCS）（Acwing 897)</p><p>给定两个长度分别为N和M的字符串A和B，求既是A的子序列又是B的子序列的字符串长度最长是多少。</p><p>数据范围：$1 \le N, M \le 1000$</p></blockquote><p>如字符串<code>acbd</code>和<code>abedc</code>的最长公共子序列是<code>abd</code>。</p><ul><li>状态表示<code>f[i,j]</code>：<ul><li>集合：所有在第一个序列的前<code>i</code>个字母中出现，且在第二个序列的前<code>j</code>个字母中出现的子序列</li><li>属性：Max，最长的公共子序列</li></ul></li><li>状态计算：<ul><li>以<code>a[i]</code>和<code>b[j]</code>是否出现在子序列中，来划分集合；<code>a[i]</code>和<code>b[j]</code>是否出现在子序列中有四种情况：00表示都不选，01表示只选<code>b[j]</code>，10表示只选<code>a[i]</code>，11表示都选（要求<code>a[i]=b[j]</code>）。<code>f[i,j]</code>表示的所有公共子序列一定可以不重不漏的分到这四种情况当中，<code>f[i,j]</code>的最大值就是这四种情况的最大值再取max</li><li>00——<code>f[i-1][j-1]</code>，11——<code>f[i-1][j-1]+1</code>，中间两种情况比较难表示，如01不能简单地用<code>f[i-1][j]</code>来表示，因此<code>f[i-1][j]</code>不一定包含<code>b[j]</code>，但<code>f[i-1][j]</code>是严格包含01这种情况的，那<code>f[i-1][j]</code>的最大值是大于等于01集合的最大值的，那在计算集合最大值时就能用<code>f[i-1][j]</code>来代替01，同理可以用<code>f[i][j-1]</code>来代替10。这样做还有个好处：00——<code>f[i-1][j-1]</code>这种情况是包含在<code>f[i-1][j]$$\cup$$f[i][j-1]</code>中的，因此只需计算三种情况：<code>f[i-1][j]</code>，<code>f[i][j-1]</code>，<code>f[i-1][j-1]+1</code>。</li><li>则状态转移方程为：$f[i,j=\max(f[i-1,j],f[i,j-1],f[i-1,j-1]+1)$，时间复杂度为$O(n^2)$</li></ul></li></ul><blockquote><p>求全局的最大值时，不需要子集合元素不重复，只要不漏就行；若求数量，则要求子集合元素不重复。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201029100730.png" style="zoom:75%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])  f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4.编辑距离"></a>4.编辑距离</h4><blockquote><p>例题5：最短编辑距离（Acwing 902）</p><p>给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：</p><ol><li>删除–将字符串A中的某个字符删除。</li><li>插入–在字符串A的某个位置插入某个字符。</li><li>替换–将字符串A中的某个字符替换为另一个字符。</li></ol><p>现在请你求出，<strong>将A变为B至少需要进行多少次操作</strong>。</p><p>数据范围：$1≤n,m≤1000$</p></blockquote><ul><li>状态表示<code>f[i,j]</code>：<ul><li>集合：所有将<code>a[1~i]</code>变成<code>b[1~j]</code>的操作方式</li><li>属性：Min，所有操作方式的操作次数的最小值</li></ul></li><li>状态计算：<ul><li>类似的思路，我们以最后一步采用了什么操作将集合<code>f[i,j]</code>划分为三个子集：<ol><li>若最后一步是删除操作，即删除了<code>a[i]</code>后，<code>a[1~i-1]</code>与<code>b[1~j]</code>相等，则这一子集的操作数为<code>f[i-1,j]+1</code>；</li><li>若最后一步是插入操作，即<code>a[i]</code>后插入一个数后，<code>a[1~i+1]</code>与<code>b[1~j]</code>相等，则之前是<code>a[1~i]</code>与<code>b[1~j-1]</code>相等，则这一子集的操作数为<code>f[i,j-1]+1</code>；</li><li>若最后一步是修改操作，即<code>a[i]</code>修改后，<code>a[1~i]</code>与<code>b[1~j]</code>相等，则之前是<code>a[1~i-1]</code>与<code>b[1~j-1]</code>相等，则这一子集的操作数为<code>f[i-1,j-1]+1</code>（<code>a[i]!=b[j]</code>，需要修改），或<code>f[i-1,j-1]</code>（<code>a[i]=b[j]</code>，不需要修改）；</li></ol></li><li>则状态转移方程为：$f[i,j]=\min(f[i-1,j]+1,\, f[i,j-1]+1,\, f[i-1,j-1]+1/0)$，时间复杂度为$O(n^2)$（状态数为$n^2$，每次状态转移计算量为3）</li></ul></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201029112150.png" style="zoom:70%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i ++)  f[<span class="number">0</span>][i] = i;  <span class="comment">//若要把a[]的前0个字母变成b[]的前i个字母，就要插入i次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)  f[i][<span class="number">0</span>] = i;  <span class="comment">//若要把a[]的前i个字母变成b[]的前0个字母，就要删除i次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])  f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span>  f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题6：编辑距离（Acwing 899）</p><p>给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。对于每次询问，请你求出给定的n个字符串中有多少个字符串可以<strong>在上限操作次数内经过操作变成询问给出的字符串</strong>，每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><p>数据范围：$1≤n,m≤1000$。字符串中只包含小写字母，且长度均不超过10。</p></blockquote><p>这道题其实就把最短编辑距离重复若干次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">char</span> str[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit_dis</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lb; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= la; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lb; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[N];</span><br><span class="line">        <span class="keyword">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s + <span class="number">1</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (edit_dis(str[i], s) &lt;= limit)</span><br><span class="line">                res ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-区间DP"><a href="#2-区间DP" class="headerlink" title="2.区间DP"></a>2.区间DP</h3><blockquote><p>例题7：石子合并（Acwing 282）</p><p>设有N堆石子排成一排，其编号为1，2，3，…，N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。每次只能合并相邻的两堆，<strong>合并的代价</strong>为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。</p><p>例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。</p><p>问题是：找出一种合理的方法，<strong>使总的代价最小</strong>，输出最小代价。</p><p>数据范围：$1 \le N \le 300$。</p></blockquote><p>区间DP问题在考虑状态表示时是用某一个区间。</p><ul><li>状态表示<code>f[i,j]</code>（第<code>i</code>堆石子到第<code>j</code>堆石子这个区间）：<ul><li>集合：所有将第<code>i</code>堆到第<code>j</code>堆石子合并成一堆石子合并成一堆石子的合并方式</li><li>属性：MIn，所有合并方式的代价的最小值，<code>f[1,n]</code>就是所求答案</li></ul></li><li>状态计算：<ul><li>将第<code>i</code>堆到第<code>j</code>堆石子合并成一堆石子合并成一堆，最后一步一定是将两堆合并为一堆，那我们可以<strong>以最后一次合并的“分界线”的位置来分类</strong>：对于区间$[i,j]$，可以分为左边一堆为$[i,k]$，右边一堆为$[k+1,j]$ 。</li><li>计算这种合并方式的代价可以用左边一堆的代价<code>f[i,k]</code>，加上右边一堆的代价<code>f[k+1,j]</code>，再加上合并左右两堆需要的代价，即区间<code>[i,j]</code>内元素的代价和。而求某一个区间内的元素和可以用之前学过的前缀和来计算（秒啊）</li><li>则状态转移方程为：$f[i,j=\min (f[i,k]+f[k+1,j]+S[j]-S[i-1])$，$k=i\sim j-1$，时间复杂度为$O(n^2 \cdot n)=O(n^3)$（状态数量为$n^2$，每次状态计算量，需要枚举$k$，为$n$）</li></ul></li></ul><blockquote><p>写区间DP的代码要留意下循环的写法，要保证算每个<code>f[i][j]</code>时用到的状态都已经是计算好的，因此要留意下枚举的顺序，这题我们可以枚举区间长度（这里指的是区间中元素的个数，并不是数学上区间的长度），从小到大，从2开始即可，因为$len=1$表示一个石子，合并代价为0（自己和自己合并）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> s[N];     <span class="comment">//表示前缀和</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;    <span class="comment">//求最小值，千万要记得将状态初始化为INF</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k ++)</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/126546914" target="_blank" rel="noopener">力扣DP问题汇总</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      线性DP，区间DP
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（14）</title>
    <link href="http://nekomoon404.github.io/2020/10/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8814%EF%BC%89/</id>
    <published>2020-10-26T11:39:13.000Z</published>
    <updated>2020-10-26T12:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>动态规划（Dynamic Programming，DP）的常见模型：背包问题，其核心在于状态的表示和状态的转移。</p><p><strong>背包问题</strong>：有$N$个物品和一个容量为$V$的背包，每个物品有重量$v_i$和价值$w_i$两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p><blockquote><p>可参考：<a href="https://oi-wiki.org/dp/knapsack/" target="_blank" rel="noopener">OI Wiki-背包DP</a></p></blockquote><h4 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1. 01背包"></a>1. 01背包</h4><p>01背包问题的特点是每件物品最多只能用一次</p><blockquote><p>例题：01背包问题（Acwing 2）</p><p>有$N $件物品和一个容量是$V$的背包。每件物品只能使用一次。第$i$件物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p>数据范围：$0&lt;N,V≤1000,0&lt;v_i,w_i≤1000$。</p></blockquote><p>DP问题一般从两个角度来考虑：</p><ul><li><p><strong>状态表示</strong>：背包问题有两维，$f(i, j)$，再进一步：</p><ul><li>$f(i,j)$表示的集合是什么，表示所有选法，需满足两个条件：（1）只从前$i$个物品中选，（2）选出的物品的总体积$\le j$</li><li>集合的属性是什么，（最大值，最小值，元素的数量），对于背包问题显然是：所有选法的价值的最大值</li></ul></li><li><p><strong>状态计算</strong>：对应集合的划分，考虑$f(i,j)$可以怎样计算出来，把当前的集合能划分成若干个更小的子集，每个子集都可以用前面更小的子集表示出来。对于背包问题，我们把$f(i,j)$分为两个子集：</p><ul><li><strong>不含$i$</strong>；只从前$i-1$个物品中选，且总体积$\le j$，即$f(i-1,j)$；</li><li><strong>含$i$</strong>：从前$i$个物品中选，且总体积$\le j$，且要包含物品$i$；这里需要绕个弯，每种选法中都有物品$i$，那我们可以从每种选法中减去$i$，即总体积$\le j - v_i$，且这样不会影响不同选法中的最大值是哪个，即问题转化成立从前$i-1$个物品中选，且总体积$j - v_i$，最后再加上物品$i$的价值，即$f(i-1, j -v_i)+w_i$。</li></ul><p>集合的划分一般遵循两个原则：（1）不重；（2）不漏</p></li></ul><p>DP的优化一般是对DP问题的代 码或计算方程作等价变形，所以做DP问题时一定要把基本的方程形式写出来，再做优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;   <span class="comment">//n表示物品数量，m表示背包容积</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从f[0][0]到f[0][m]都是0，因为没选任何物品；全局变量已经是0了，所以下面从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];    <span class="comment">//不含i的子集一定存在</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])             <span class="comment">//当j大于v[i]时，含i的子集才存在  </span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是用二维的<code>f[i][j]</code>来表示状态的，其实那可以<strong>进一步优化</strong>，用<strong>一维数组</strong>来做。$f(i,j)$这一层的计算只用到了$f(i-1,)$，$f(,j)$只用到了$f(,j)$和$f(,j-v_i)$，都是$\le j$的。下面对代码进行等价变形即可：</p><ol><li><p>将二维的<code>f[N][N]</code>变为一维的<code>f[N]</code>；</p></li><li><p><code>f[i][j] = f[i - 1][j];</code> 等价为<code>f[j] = f[j];</code>  可以直接删掉；</p></li><li><p><code>if(j &gt;= v[i])</code>  等价于让<code>j</code>直接从<code>j = v[i]</code> 开始循环；</p></li><li><p>如果直接把<code>f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);</code>改成<code>f[j] = max([j], f[j - v[i]] + w[i]);</code>，是不对的；因为<code>j-v[i]</code>是小于<code>j</code>的，在第<code>i</code>层中，计算到这里时它已经在层内被更新过了，<code>f[j-v[i]]</code>存的其实是第<code>i</code>层的<code>f[j-v[i]]</code>。而我们实际需要的是第<code>i-1</code>层的<code>f[j-v[i]]</code>，因此要在第<code>i</code>层计算到它时在层内还没有被更新过。为此我们只需要把<code>j</code>从大到小遍历，即<code>for(int j = m; j &gt;= v[i]; j --)</code>。（太妙了）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;   <span class="comment">//n表示物品数量，m表示背包容积</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j --)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2. 完全背包"></a>2. 完全背包</h4><p>完全背包问题的特点是每件物品有无限个，即可以在背包中放多个相同物品。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201026194346.png" style="zoom:70%;"></p><blockquote><p>例题：完全背包问题（ACwing 3）</p><p>有$ N $种物品和一个容量是$ V $的背包，每种物品都有无限件可用。第$ i $种物品的体积是$ v_i$，价值是$ w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p>数据范围：$0&lt;N,V≤1000,0&lt;v_i,w_i≤1000$</p></blockquote><p><strong>朴素做法</strong>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k ++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化：</strong>比较计算<code>f[i,j]</code>和<code>f[i,j-v]</code>的状态方程，<code>f[i,j-v]</code>的每一项与<code>f[i,j]</code>的对应项很相似，只是少了一个<code>w</code>，则橙色框中的最大值就等于<code>f[i,j-v]+w</code>，因此有<code>f[i,j]=max(f[i-1,j], f[i,j-v]+w)</code>，这样在计算<code>f[i,j]</code>时就只需枚举两个状态，而不是<code>k</code>个状态</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201026195800.png" style="zoom:67%;"></p><blockquote><p>比较01背包问题的方程：<code>f[i,j]=max(f[i-1][j], f[i-1, j-v]+w[i])</code>，只有一点不同。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])  f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再优化：</strong>同样地，完全背包问题也可以优化到用一维数组做，用01背包问题相同的思路即可，而且完全背包的方程：<code>f[i,j]=max(f[i-1,j], f[i,j-v]+w)</code>，是用第<code>i</code>层的数据更新，因此遍历<code>j</code>时从小到大遍历即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i]; j &lt;= m; j ++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3.多重背包"></a>3.多重背包</h4><p>多重背包问题的特点是每件物品有有限个数，既不是1件也不是无限件，它有个确定的数值。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201026195801.png" style="zoom:75%;"></p><p>状态转移方程：<code>f[i][j]=max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);  k = 0,1,2,...,s[i]</code></p><blockquote><p>例题：多重背包问题I（Acwing 4）</p><p>有$N$种物品和一个容量是$V$的背包。第$i$种物品最多有$s_i$件，每件体积是$ v_i$，价值是$ w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。</p><p>数据范围：$0&lt;N,V≤100,0&lt;v_i,w_i,s_i≤100$</p></blockquote><p><strong>朴素做法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这道题的数据范围比较小，所以暴力做法也不会超时。若是将数据范围改为：</p><p>$0&lt;N≤1000,0&lt;V≤2000,0&lt;v_i,w_i,s_i≤2000$，（Awcing 5 多重背包问题2）</p><p>大约要算$1000<em>2000</em>2000=40$亿次，暴力做法一定会超时（c++一秒大约能算一亿次，即$10^9$次）</p></blockquote><p><strong>优化：</strong>同样从<code>f[i,j]</code>和<code>f[i,j-v]</code>的状态转移方程入手</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201026205837.png" style="zoom:80%;"></p><p>发现两式的中间一部分是相似的，但<code>f[i,j-v]</code>中最后有一项<code>f[i-1, (s+1)v]+sw</code>，因此无法直接使用完全背包的优化思路来解决。比如我们已知了1到n个数的最大值和第n个数的值，要求前1到n-1个数的最大值，是无法求出来的，即<code>max()</code>函数无法做“减法”，所以我们不能直接用完全背包的优化问题来优化这个多重背包的问题（？不太懂）。</p><p>那要如何优化呢，这里用到了一种“二进制”的方法。假设第<code>i</code>个物品有$s=1023$个，我们想去求它放入背包后的最大值，那真的需要去从0枚举到1023嘛，其实是没必要的。我们可以<strong>把这个物品“打包”成若干组</strong>，每组分别有$1,2,4,8,\dots,512$，<strong>每一组最多只能选一次</strong>，我们可以用这10组来拼凑出$1 \sim 1023$中的任何一个数；这样每组背包有选或不选两种状态，就可以<strong>转化为01背包问题</strong>中的一个物品（只能选一次），我们枚举新的物品选或不选，就可以拼凑出第<code>i</code>个物品的所有方案了。原来需要枚举1024次，现在只需枚举10次，这样就把朴素代码中第18行中，$O(n)$的复杂度优化为了$O(\log n)$。</p><p>对于一个一般的$s$，可以这样分组：$1, 2, 4, 8, \dots, 2^k, c$，其中$2^k \le s, c &lt; 2^{k+1}$，从$1$到$2^k$可以凑出$0 \sim 2^{k+1} -1$中任意的数，加上$c$后可以凑出$c \sim 2^{k+1}-1+c$中任意的数，则$2^{k+1}-1+c=s$。而区间$[0,2^{k+1}-1]$和$[c,s]$一定有交集，即合并起来没有“空隙”，因为$c$是严格小于$2^{k+1}$的。</p><p>理一下思路：对于第$i$个物品有$s_i$个，我们把它分为$\log s_i$组（上取整），转化为01背包问题，这样就把朴素做法的时间复杂度从$O(n\cdot v \cdot s)$优化到了$O(n \cdot v \cdot \log s_i)$。对于本题的数据范围：$1000 <em> 2000 </em>\log 2000=2*10^7$，是满足要求的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;   <span class="comment">// 1000 * log 2000 = 12000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;   <span class="comment">//记录分组后的新的“物品”的序号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, s;    <span class="comment">//物品i的体积，价值，个数</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//套用01背包问题代码即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-分组背包"><a href="#4-分组背包" class="headerlink" title="4.分组背包"></a>4.分组背包</h4><p>分组背包问题的特点是由若干组物品，每一组中最多只能选一个物品。</p><blockquote><p>例题：分组背包问题（Acwing 9）</p><p>有 $N $组物品和一个容量是 $V$ 的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$ v_{ij}$，价值是$ w_{ij}$，其中$ i $是组号，$j$ 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。</p><p>数据范围：数据范围：$0&lt;N,V≤100,0&lt;S_i≤100,0&lt;v_{ij},w_{ij}≤100$</p></blockquote><p>分析的思路和前面的类似，也是从状态表示和状态计算两个角度来分析。完全背包问题枚举的是第$i$个物品选几个，分组背包问题是枚举第$i$组物品选哪个。</p><blockquote><p>背包问题的小Tip：若在状态转移时，用的上一层的状态就从大到小枚举体积；若是用的本层的状态就从小到大枚举体积。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201026221106.png" style="zoom:75%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> v[N][N], w[N][N], s[N];   <span class="comment">//s[]存每一组的个数</span></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++)   <span class="comment">//枚举第i组物品中所有的选择</span></span><br><span class="line">                <span class="keyword">if</span>(v[i][k] &lt;= j)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第五章 动态规划的内容：背包问题
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（13）</title>
    <link href="http://nekomoon404.github.io/2020/10/22/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/22/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8813%EF%BC%89/</id>
    <published>2020-10-22T06:30:00.000Z</published>
    <updated>2020-10-23T11:26:31.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>回顾中学学过的韦恩图（Venn diagram）：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201022144522.png" style="zoom:67%;"></p><p>将三个集合推广到n个集合，设 U 中元素有 n 种不同的属性，而第 i 种属性称为$P_i$  ，拥有属性$P_i$的元素构成集合$S_i$ 那么：</p><script type="math/tex; mode=display">\begin{align*}\left| \bigcup\limits_{i=1}^n S_i\right|=& \sum\limits_{i=1}\left| S_i\right|-\sum\limits_{i<j}\left| S_i \cap S_j\right| + \sum\limits_{i<j<k}\left| S_i \cap S_j \cap S_k\right|-\dots\\&+(-1)^{m-1}\sum\limits_{a_i<a_{i+1}}\left| \bigcap\limits^m_{i=1} S_{a_i}\right|+\dots+(-1)^{n-1}\left| S_i \cap \dots \cap S_n\right|\\\\=& \sum\limits^n_{m=1}(-1)^{m-1}\sum\limits_{a_i<a_{i+1}}\left| \bigcap\limits^m_{i=1} S_{a_i}\right|\end{align*}</script><blockquote><p>关于容斥原理的相关知识可以参考：<a href="https://oi-wiki.org/math/inclusion-exclusion-principle/" target="_blank" rel="noopener">OI Wiki-容斥原理</a></p></blockquote><p>简单证明一下：设$x$在$k$个集合中出现过，则$x$在上式中被计算的次数：</p><script type="math/tex; mode=display">cnt=C_k^1-C_k^2+C_k^3+\dots +(-1)^{k-1}C_k^k</script><p>又因为：</p><script type="math/tex; mode=display">C_k^0(-1)^k+C_k^1(-1)^{k-1}+C_k^2(-1)^{k-2}+\dots +C_k^k=-1+cnt=(1-1)^k=0</script><p>所以$x$在上式中共被计算了一次。</p><p>性质：上式有多少项：</p><script type="math/tex; mode=display">C_n^1+C_n^2+C_n^3+\dots +C_n^n</script><p>补一项$C_n^0$，则有：</p><script type="math/tex; mode=display">C_n^0+C_n^1+C_n^2+C_n^3+\dots +C_n^n=(1+1)^n=2^n</script><p>因此上式中一共有$2^n-1$项。</p><blockquote><p>例题：能被整除的数（Acwing 890）</p><p>给定一个整数$n$和$m$个不同的质数$p_1,p_2,…,p_m$。请你求出1~n中能被$p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。</p><p>数据范围：$1 \le m \le 16, 1\le n,p_i  \le 10^9$</p></blockquote><p>暴力做法的时间复杂度是$O(mn)$，一定会超时，考虑用容斥原理做，时间复杂度为$O(2^m)$，$2^{16}=65536&lt;10^7$（每秒大约能算$10^7 \sim 10^8$），以n = 10, m=2, 3为例，集合$S_2$表示能被2整数的数的集合，题目是要求两个集合的并集的元素个数。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201022152519.png" style="zoom:67%;"></p><p>$|S_p|$如何求：$|S_p|$表示$1 \sim n$中$p$的倍数的个数，即$\lfloor \frac{n}{p} \rfloor$；$|S_{p_1} \cap S_{p_2}\dots\cap S_{p_k}|$如何求：因为$p_1, p_2, \dots, p_k$是互质的数，所以$|S_{p_1} \cap S_{p_2}\dots\cap S_{p_k}|$就是$1 \sim n$中$p_1p_2\dots p_k$的公倍数的个数，即$\lfloor \frac{n}{p_1p_2 \dots p_k} \rfloor$，计算这一项的时间复杂度就是$O(k)$，则算法总的时间复杂度就是$O(2^m\cdot k)=O(2^m \cdot m)=O(2^{16} \cdot 16)=O(2^{20})=10^6$。</p><p><strong>Tips</strong>：<strong>枚举$2^n-1$种选法时可以采用位运算的方式</strong>，从$1 \sim 2^{n}-1$枚举<code>i</code>，把<code>i</code>看成n位的二进制数，每一位对应一个集合，是1就表示这个集合被选了，是0就表示这一个集合没有被选，因此就可以用二进制数来枚举所有选法了 。确认二进制数的每一位上的数是不是1，就可以用<code>i &gt;&gt; k &amp; 1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)  <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++)   <span class="comment">//1 &lt;&lt; m 表示2的m次方</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>, cnt = <span class="number">0</span>;   <span class="comment">//t 表示当前几个质数的乘积，cnt表示当前选法中几个集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)    <span class="comment">//若当前位是1，表示该位对应的集合有被选中</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span>((LL) t * p[j] &gt; n)   <span class="comment">//若质数的乘积大于n了，就直接跳出</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t *= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt % <span class="number">2</span>)  res += n / t;  <span class="comment">//若选中集合个数为奇数，就加上n / t</span></span><br><span class="line">            <span class="keyword">else</span>  res -= n / t;         <span class="comment">//若是偶数就减去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h3><p>首先来看一些相关的定义：</p><blockquote><p>可参考：<a href="https://oi-wiki.org/math/game-theory/" target="_blank" rel="noopener">OI Wiki-博弈论</a></p></blockquote><p><strong>公平组合游戏ICG</strong>：若一个游戏满足：</p><ol><li><p>由两名玩家交替行动</p></li><li><p>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</p></li><li>不能行动的玩家判负；</li></ol><p>则称该游戏为一个公平组合游戏。</p><blockquote><p>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p></blockquote><p><br></p><p><strong>NIM游戏：</strong>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p><blockquote><p>我们把这种游戏称为<strong>NIM博弈</strong>。<strong>把游戏过程中面临的状态称为局面</strong>。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败.</p><p>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为<strong>必胜</strong>。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。</p><p>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p></blockquote><p><strong>先手必胜状态</strong>与<strong>先手必败状态</strong>：</p><ul><li><p>先手必胜状态：拿完之后，剩下的状态是必败状态，即可以把当前的状态变成先手必败状态；</p></li><li><p>先手必败状态：拿完之后，剩下的所有状态都是先手必胜状态。</p></li></ul><p>定理： NIM博弈先手必胜，当且仅当$ a_1 \oplus a_2 \oplus \dots\oplus a_n \ne 0 $ （$\oplus$表示异或）</p><p>简单证明一下：</p><ol><li><p>若当前不能进行任何操作，即每堆中物品都是0，$ 0\oplus 0 \oplus \dots\oplus 0 = 0 $；</p></li><li><p>若当前异或值不是0，$ a_1 \oplus a_2 \oplus \dots\oplus a_n =x\ne 0 $，则一定能通过一次操作从某一堆里拿走若干个物品，让剩下的异或值变成0，证明：</p></li></ol><p>设$x$的二进制表示中最高的一位1在第$k$位，则在$a_1 \sim a_n$中必然存在一个数$a_i$，$a_i$的第$k$位是1，则有：</p><script type="math/tex; mode=display">a_i \oplus x < a_i</script><p> 那么我们可以从$a_i$这一堆中拿走$a_i-(a_i \oplus x)$，即把$a_i$变成了$(a_i \oplus x)$，那现在所有数的异或值就变为：</p><script type="math/tex; mode=display">a_1 \oplus a_2 \oplus \dots\oplus a_i \oplus x \dots \oplus a_n =x \oplus x=0</script><p>即证明了若当前异或值不为0，则可以通过一次操作使得剩下的数的异或值为0。</p><ol><li>若当前的异或值是0，即$ a_1 \oplus a_2 \oplus \dots\oplus a_n \ne 0 $ ，进行任何一次操作后，剩下的数的异或值不会是0，证明：</li></ol><p>反证法，若对$a_i$这个堆拿走一些物品后，剩下的个数为$a_i’$，剩下的数的异或值为0，则有：</p><script type="math/tex; mode=display">a_1 \oplus a_2 \oplus \dots\oplus a_i‘ \dots \oplus a_n =0</script><p>把上式和原式合起来取异或，则有$a_i \oplus a_i’=0$，即$a_i=a_i’$，然而操作必须是要拿走若干物品，不能不拿，即必有$a_i’&lt;a_i$，因此就矛盾，假设错误，即证。</p><p>可见，如果最开始各堆$a_i$的异或值不是0，先手状态的异或值一定不是0，后手的状态异或值一定是0，则先手必胜；否则若最开始各堆$a_i$的异或值是0， 则先手必败。</p><blockquote><p>例题1：<strong>NIm游戏</strong>（Acwing 891）</p><p>给定$n$堆石子，<strong>两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿）</strong>，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><p>数据范围：$1 \le n \le10^5$，$1 \le $每堆石子数$ \le 10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        res ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res)  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);   <span class="comment">//若最开始各堆a_i的异或值不是0，则先手必胜</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题2：台阶-Nim游戏（Acwing 892）</p><p>现在，有一个n级台阶的楼梯，每级台阶上都有若干个石子，其中第$i$级台阶上有$a_i$个石子($i≥1$)。两位玩家轮流操作，<strong>每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）</strong>。已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><p>数据范围：$1≤n≤10^5, 1≤a_i≤10^9$。</p></blockquote><p>考虑一个样例，共三级台阶，每级的石子个数是2，1， 3，则先手有必胜策略。我们先手从第3级拿下1个到第2级，让第1级和第3级的石子都保持一致，都是2个；然后根据对手的操作，我们始终让1，3级台阶的石子个数一致：若对手从第3级往下拿几个，我们就从第一级往下拿几个；若对手从第1级往下拿几个，我们就从第三级往下拿几个；若对手从第2级往下拿几个，我们就从第1级往下拿几个。这样对手看的1,3级台阶石子个数永远是1致的，我看的到永远是不一致的，则对手会先遇到0,0的情况，即我是必胜的。</p><p>推广到一般的情况：我们只需要关注奇数级台阶上石子的个数，若其异或值$ a_1 \oplus a_3 \oplus \dots\oplus a_n \ne 0 $ ，则先手必胜；若为0则先手必败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span>)   <span class="comment">//只取奇数台阶，求异或值</span></span><br><span class="line">            res ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题3：<strong>集合-Nim游戏</strong>（Acwing 983）</p><p>给定$n$堆石子以及一个由$k$个不同正整数构成的数字集合$S$。现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合$S$，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><p>数据范围：$1≤n,k≤100,1≤s_i,h_i≤10000$</p></blockquote><p>解这道题前先了解几个概念：</p><p><strong>Mex运算：</strong>设$S$表示一个非负整数集合。定义mex(S)为求出不属于集合$S$的最小非负整数的运算，即：mex(S) = min{x}，$x$属于自然数（从0开始），且$x$不属于$S$。</p><p><strong>SG函数</strong>：在有向图游戏中，对于每个节点$x$，设从$x$出发共有$k$条有向边，分别到达节点$y_1, y_2, …, y_k$，定义$SG(x)$为$x$的后继节点$y_1, y_2, …, y_k$ 的SG函数值构成的集合再执行mex(S)运算的结果，即：</p><script type="math/tex; mode=display">SG(x) = mex(\{SG(y_1), SG(y_2), ..., SG(y_k)\})</script><p>特别地，<strong>整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值</strong>，即SG(G) = SG(s)。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201022193227.png" style="zoom: 67%;"></p><p><strong>有向图游戏的和：</strong>设$G_1, G_2, …, G_m$ 是$m$个有向图游戏。定义有向图游戏$G$，它的行动规则是任选某个有向图游戏$G_i$，并在$G_i$上行动一步。$G$被称为有向图游戏$G_1, G_2, …, G_m$的和。</p><p><strong>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和</strong>，即：</p><script type="math/tex; mode=display">SG(G) = SG(G_1) \oplus SG(G_2) \oplus ... \oplus SG(G_m)</script><p>定理：</p><ul><li><p><strong>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0</strong>。</p></li><li><p><strong>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0</strong>。</p></li></ul><blockquote><p>上面定理证明的思路和第一个Nim游戏是一样的，用$SG(x_i)$代替$a_i$即可。</p></blockquote><p>通过SG函数，把n个图的局面通过异或的方式判断出必胜或必败的局面，把指数级的状态（n维）变成1维状态。</p><p>（以下图为例，设每次可取的石子数为2，5，共三堆石子，每堆中个数分别为10，7， 5。则求解过程是，把每一堆当作一个有向图游戏，求出每堆的SG值，最后再取异或值$SG(10) \oplus SG(7) \oplus SG(5)$，若结果不为0，则先手必胜，否则先手必败。） </p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201022193513.png" style="zoom:67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s[N], SG[M];   <span class="comment">//s[]表示每堆中石子的个数，SG[]表示有向图的SG[]值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sg</span><span class="params">(<span class="keyword">int</span> x)</span>    <span class="comment">//用记忆化搜索来求有向图的SG值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(SG[x] != <span class="number">-1</span>)  <span class="keyword">return</span> SG[x];   <span class="comment">//如果当前局面已经计算过了，就不需要重复计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;   <span class="comment">//用哈希表来存当前可以达到的局面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)    <span class="comment">//枚举可取的石头数</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= s[i])  S.insert(sg(x - s[i]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ; i ++)    <span class="comment">//求当前点的SG值</span></span><br><span class="line">        <span class="keyword">if</span>(!S.count(i))</span><br><span class="line">            <span class="keyword">return</span> SG[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;   <span class="comment">//可以取的石子的方案数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;   <span class="comment">//石子的堆数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(SG, <span class="number">-1</span>, <span class="keyword">sizeof</span> SG);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)   <span class="comment">//每一堆石子看成一个有向图游戏，最后求出所有堆SG的异或值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        res ^= sg(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res)  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题4：<strong>拆分—Nim游戏</strong></p><p>给定n堆石子，两位玩家轮流操作，<strong>每次操作可以取走其中的一堆石子，然后放入两堆规模更小的石子（新堆规模可以为0，且两个新堆的石子总数可以大于取走的那堆石子数）</strong>，最后无法进行操作的人视为失败。问如果两人都采用最优策略，先手是否必胜。</p><p>数据范围：$1≤n,a_i≤100$</p></blockquote><p>拆分—Nim游戏可以用$SG$函数来做，求出每堆石子的$SG$值，最后再求异或。对于每一个局面$a_i$，假设它可以变成局面$(b_1, b_2)$，则它们的$SG$值的关系为$SG(b_1, b_2)=SG(b_1) \oplus SG(b_2)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sg</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != <span class="number">-1</span>)  <span class="keyword">return</span> f[x];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">            S.insert(sg(i) ^ sg(j));</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!S.count(i))</span><br><span class="line">            <span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        res ^= sg(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res)  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      容斥原理，简单博弈论
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（12）</title>
    <link href="http://nekomoon404.github.io/2020/10/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8812%EF%BC%89/</id>
    <published>2020-10-20T07:50:22.000Z</published>
    <updated>2020-10-21T07:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元解线性方程组：线性代数里面很基础的一个知识点，算法步骤：</p><p>枚举每一列c：</p><ol><li>找到当前列绝对值最大的一行</li><li>用初等行变换(2) 把这一行换到最上面（未确定阶梯型的行，并不是第一行）</li><li>用初等行变换(1) 将该行的第一个数变成 1（其余所有的数字依次跟着变化）</li><li>用初等行变换(3) 将下面所有行的当前列的值变成 0</li></ol><blockquote><p>高斯消元解线性方程组（Acwing 883）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i++)    <span class="comment">//找到当前列绝对值最大的一行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c]) &lt; eps)  <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c; i &lt; n + <span class="number">1</span>; i ++)  swap(a[t][i], a[r][i]);  <span class="comment">//把这一行换到最上面（未确定阶梯型的行，并不是第一行）</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= c; i --) a[r][i] /= a[r][c];    <span class="comment">// 将该行的第一个数变成 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++)  <span class="comment">//将下面所有行的当且列的值变成0（其余的数也要跟着变化）</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n] &gt; eps))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;     <span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//多解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)   <span class="comment">//有唯一解，计算出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> t = gauss();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)  <span class="built_in">puts</span>(<span class="string">"Infinite group solutions"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No solution"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>高斯消元解异或线性方程组（Acwing 884）</p></blockquote><p>思路和用高斯消元解普通的线性方程组相同，只需在相应的步骤换成异或运算即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span>(c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++)   <span class="comment">//找到当前列中绝对值最大的一行，本题中最大值即是1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c])  t = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!a[t][c])  <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = c; i &lt;= n; i ++)  swap(a[r][i], a[t][i]);  <span class="comment">//把这一行换到最上面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c])</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= c; j --)</span><br><span class="line">                    a[i][j] ^= a[r][j];</span><br><span class="line">                    </span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][n])     <span class="comment">//0 等于 非0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;   <span class="comment">//无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;           <span class="comment">//有多解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)   <span class="comment">//有唯一解，倒着计算出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">            a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> res = gauss();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)  <span class="built_in">cout</span> &lt;&lt; a[i][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(res == <span class="number">1</span>)  <span class="built_in">puts</span>(<span class="string">"Multiple sets of solutions"</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">"No solution"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h3><blockquote><p>求组合数I（Acwing 885）：</p><p>给定n组询问，每组询问给定两个整数$a,b$，请你输出$C^b_a\, mod \, (10^9+7)$的值。</p><p>数据范围：$1 \le n \le 10000, 1 \le b \le a \le 2000$</p><p>关于组合数的相关知识可以参考：<a href="https://oi-wiki.org/math/combination/" target="_blank" rel="noopener">排列组合</a>；组合数学</p></blockquote><p>组合数的公式：</p><script type="math/tex; mode=display">C^b_a=\frac{a!}{b!(a-b)!}</script><p>本题中$a$和$b$的数据范围是$1 \le b \le a \le 2000$，需要计算的$C_a^b$总数不超过400万，因此我们可以先处理出所有$C^b_a$的值，它有下面的递推公式：</p><script type="math/tex; mode=display">C^b_a=C^b_{a-1} + C^{b-1}_{a-1}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N][N];   <span class="comment">//c[i][j] 表示 C_i^j，即从i个不同的东西从抽出j个的组合数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求组合数II（Acwing 886）</p><p>给定n组询问，每组询问给定两个整数$a,b$，请你输出$C^b_a\, mod \, (10^9+7)$的值。</p><p>数据范围：$1 \le n \le 10000, 1 \le b \le a \le 10^5$</p></blockquote><p>第二题和第一题的区别是$a$和$b$的数据范围是$1 \le b \le a \le 10^5$，没办法将$C_a^b$全预处理完。那我们可以预处理出所有的$a!$，记为<code>fact[i]</code>，又$(a/b) \,mod \,p \ne (a \, mod \, p)/(b \, mod\, p)$，需要将除法转化为乘法，即转化为计算逆元$a/b \equiv a <em> x(mod \, x)$，记为<code>infact[i]</code>，那么$C_a^b$就等于`fact[a] </em> infanct[b-a] * infact[b]`。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>   <span class="comment">//求快速幂， 利用快速幂求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL) res * a % p;</span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = (LL) fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL) infact[i - <span class="number">1</span>] * qmi(i, mod - <span class="number">2</span>, mod) % mod;  <span class="comment">//求逆元</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL) fact[a] * infact[b] % mod * infact[a - b] % mod);  <span class="comment">//注意这里乘两个数之后就要取一次模，防止溢出LL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>求组合数III（Acwing 887）</p><p>给定n组询问，每组询问给定两个整数$a,b,p$，其中$p$是质数，请你输出$C^b_a\, mod \, p$的值。</p><p>数据范围：$1 \le n \le 20, 1 \le b \le a \le 10^{18}, 1 \le p \le 10^5$。</p></blockquote><p>第三题的查询数$n$很小，但$a, b$的值都爆大有$10^{18}$，这时可以使用<strong>卢卡斯定理</strong>：</p><script type="math/tex; mode=display">C^b_a \equiv C_{a \, mod \, p}^{b \, mod \, p} \cdot C_{a /p}^{b/p}(mod \, p)</script><p>这时的时间复杂度为$O(\log_p N \cdot p \cdot \log p)=O(p \log N \log p)$。</p><blockquote><p>关于卢卡斯定理的证明可以参考：<a href="https://oi-wiki.org/math/lucas/" target="_blank" rel="noopener">卢卡斯定理</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span>   <span class="comment">//快速幂，利用快速幂求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( k &amp; <span class="number">1</span>)  res = (LL) res * a % p;    <span class="comment">//计算a! / (a - b)! (mod p) </span></span><br><span class="line">        a = (LL) a * a % p;    <span class="comment">////计算 1 / b! (mod p)</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>   <span class="comment">//计算C_a^b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i++, j--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL) res * j % p;</span><br><span class="line">        res = (LL) res * qmi(i, p - <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p)  <span class="keyword">return</span> C(a, b);</span><br><span class="line">    <span class="keyword">return</span> (LL) C(a % p, b % p) * lucas(a / p, b / p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;   <span class="comment">//注意这里要用LL 存a, b，数据范围是1到10^18</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lucas(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入$a,b$，求$C^b_a$的值。注意结果可能很大，需要使用高精度计算。</p><p>数据范围：$1 \le b \le a \le 5000$</p></blockquote><p>第四题从定义出发，不要求结果取模，而是用高精度表示，我们需要实现高精度乘法和高精度除法，但是直接计算效率比较低，一般是要先将$a, b$分解质因数，这样只需要高精度乘法就可以了。</p><script type="math/tex; mode=display">\begin{align*}C_a^b = \frac{a!}{b!(a-b)!}=p_1^{\alpha_1} \cdot p_2^{\alpha_2} \dots p_k^{\alpha_k} \end{align*}</script><p>如何计算$a!$中$p_i$的次数，可以用下面的公式：</p><script type="math/tex; mode=display">a!中p的次数=\lfloor\frac{a}{p} \rfloor + \lfloor\frac{a}{p^2} \rfloor + \lfloor\frac{a}{p^3} \rfloor + \dots</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;   <span class="comment">//cnt 存质因数的个数</span></span><br><span class="line"><span class="keyword">int</span> sum[N];   <span class="comment">//存a分解质因数后，a!中p_i的指数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">//线性筛求质因数</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])  primes[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span>   <span class="comment">//求a分解质因数后，a!中p的指数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        res += a / p;</span><br><span class="line">        a /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)    <span class="comment">//高精度乘法，一个很大的数，乘一个较小的数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;     <span class="comment">//这里不需要处理前导0，因为本题中不会乘0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    get_primes(a);   <span class="comment">//求a的质因数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = primes[i];</span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(a - b, p) - <span class="built_in">get</span>(b, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.push_back(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++)</span><br><span class="line">            res = mul(res, primes[i]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><blockquote><p>满足条件的01序列（Acwing 889）</p><p>给定$n$个0和$n$个1，它们将按照某种顺序排成长度为$2n$的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。输出的答案对$10^9+7$取模。</p><p>数据范围：$1 \le n \le 10^5$。</p></blockquote><p>如$n=3$时，序列可以是：000111，001101， 001011， 010011， 010101。</p><p>这个问题可以抽象成另一个问题，即从原点走路径的问题 ，从(0,0)走到(6,6)，把每种序列转化为一种路径，0表示右走一格，1表示向上走一格。这道题目要求任意前缀序列中0的个数都不少于1的个数，对应到路径问题上，即是路径上任意一个位置都要满足$x \ge y$（在红色边下面），也就是任意一条路径不能经过红边。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201021110247.png" style="zoom:60%;"></p><p>从(0,0)走到(6,6)的路径一共有$C_{12}^6$种走法（12步取6步向上），要减去所有经过红边的路径，对于每条经过红边的路径，取其与红边相交的第一个点，后面部分的路径对红色边做轴对称，其终点(6,6)一定对称到点(5,7)，因此所有经过红边的路径都可以转化到一条从(0,0)到点(5,7)的路径，那么合法的路径总数为$C_{12}^6-C_{12}^5$，即$C_{2n}^n-C_{2n}^{n-1}$。</p><blockquote><p> 这就是著名的卡特兰数，$H_n=C_{2n}^n-C_{2n}^{n-1}$，可参考：<a href="https://oi-wiki.org/math/catalan/" target="_blank" rel="noopener">卡特兰数</a>。很多问题的方案数都是卡特兰数。</p></blockquote><script type="math/tex; mode=display">\begin{align*}C_{2n}^n-C_{2n}^{n-1}&=\frac{(2n)!}{n!\cdot n!}-\frac{(2n)!}{(n-1)!\cdot (n+1)!}\\&=\frac{(2n)!\cdot (n+1)-(2n)!\cdot n}{n!\cdot (n+1)!}\\&=\frac{(2n)!}{n!\cdot (n+1)}=\frac{1}{n+1} \cdot \frac{(2n)!}{n!\cdot n!}\\&=\frac{1}{n+1} \cdot C_{2n}^n\end{align*}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> +<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用快速幂求逆元，这里的mod是质数；若mod不是质数，只能用扩展欧几里得算法求逆元</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)</span><br><span class="line">            res = (LL) res * a % p;</span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span> * n, b = n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用下面两个循环计算C_2n^n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &gt; a - b; i --)   res = (LL)res * i % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i ++)  res = (LL) res * qmi(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    </span><br><span class="line">    res = (LL) res * qmi(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;  <span class="comment">//乘 1/ (n + 1)</span></span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      高斯消元，求组合数，卡特兰数
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（11）</title>
    <link href="http://nekomoon404.github.io/2020/10/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/18/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8811%EF%BC%89/</id>
    <published>2020-10-18T06:12:45.000Z</published>
    <updated>2020-10-21T06:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p><strong>1 ~ N 中与 N 互质的数的个数被称为欧拉函数</strong>，记为$\phi(N)$。若在算数基本定理中，$N=p_1^{a_1}p_2^{a_2}\dots p_k^{a_k}$（分解质因数） ，则：</p><script type="math/tex; mode=display">\phi(N)=N \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k})</script><blockquote><p>互质是公约数只有1的两个整数。</p></blockquote><p>证明利用了<strong>容斥原理</strong>：</p><ol><li><p>从1到N中去掉$p_1,p_2,\dots,p_k$的所有倍数；</p></li><li><p>有些数会被减掉两次，需要再加回来，即加上所有$p_i * p_j$的倍数；</p></li><li>若某些数是$p_1, p_2, p_3$的公倍数，那么它在第一步被减去三次，在第二步被加上三次，相当于是没处理掉，因此要再减去所有$p_i<em>p_j</em>p_k$的倍数；</li><li>按此规律继续下去，加上所有四个质因数的倍数；减去所有5个质因数的倍数；……</li></ol><script type="math/tex; mode=display">\begin{align*}N &-\frac{N}{p_1}-\frac{N}{p_2}\dots-\frac{N}{p_k} \\&+\frac{N}{p_1p_2}-\frac{N}{p_1p_3}\dots-\frac{N}{p_{k-1}p_k} \\&+\frac{N}{p_1p_2p_3}-\frac{N}{p_1p_2p_4}\dots-\frac{N}{p_{k-2}p_{k-1}p_k} \\&-\frac{N}{p_1p_2p_3p_4}-\dots\\&\dots\end{align*}</script><p>而上面两式是相等的，即证。</p><p>用上面的公式计算欧拉数的时间复杂度为$O(\sqrt{n})$，瓶颈在分解质因数，而分解质因数的时间复杂度为$O(\sqrt{n})$。</p><blockquote><p>给定n个正整数$a_i$，请你求出每个数的欧拉函数。</p><p>数据范围：$1  \le n \le 100, 1 \le a_i \le 2∗10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = a;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= a / i; i++)</span><br><span class="line">            <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res / i * (i <span class="number">-1</span>);   <span class="comment">//套用欧拉函数的公式，注意这里要先除再乘，防止int溢出</span></span><br><span class="line">                <span class="keyword">while</span>(a % i == <span class="number">0</span>)</span><br><span class="line">                    a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>)  res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>用筛法求欧拉函数</strong></li></ul><blockquote><p>给定一个正整数n，求1~n中每个数的欧拉函数之和。</p><p>数据范围：$1 \le n \le 10^6$。</p></blockquote><p>若是用上面的公式就1~n中每个数的欧拉函数，那么时间复杂度就是$O(n\sqrt{n})$，若是借用之前讲的筛质数的线性筛的思路，可以将时间复杂度优化到$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;</span><br><span class="line"><span class="keyword">int</span> phi[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_euler</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;      <span class="comment">//i是质数，i的互质数（从1到i之中的）的个数是i - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;      <span class="comment">//primes[j]一定是primes[j] * i的最小质因数</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)  <span class="comment">//如果primes[j]是i的最小质因数</span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  res += phi[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get_euler(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在线性筛法的代码上作添加即可，用<code>phi[i]</code>存数<code>i</code>的欧拉函数（从1到i的互质数的个数）：</p><ol><li>如果<code>st[i]=false</code>，即<code>i</code>是质数，那么<code>i</code>的欧拉函数就是<code>i-1</code>；</li><li>如果$i \, mod \, p_j = 0$，则$p_j$是$i$的最小质因数，也是$p_j<em>i$的最小质因数；而$p_j</em>i$的分解质因数的结果只比$i$分解质因数的结果多了一项：$p_j$，又因为$p_j$是$i$的质因数，因此在$\phi(i)$的公式中已经计算过了$(1-\frac{1}{p_j})$这一项，那么有$\phi(p_j<em>i)= \phi(i) </em> p_j$；</li><li>如果$i \, mod \, p_j \ne 0$，$p_j$是$p_j<em>i$的最小质因数，但不是$i$的最小质因数，若设$\phi(i)= i \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k})$，则$\phi(p_j </em> i)= p_j <em> i \cdot (1-\frac{1}{p_1}) \cdot (1-\frac{1}{p_2})  \dots (1-\frac{1}{p_k}) (1-\frac{1}{p_j})$，那么有$\phi(p_j</em>i)=p_j <em> \phi(i) </em>(1-\frac{1}{p_j})=\phi(i) * (p_j-1)$。</li></ol><p><strong>欧拉函数的一个用处——欧拉定理</strong>：若$a$与$n$互质，则有$a^{\phi(n)}\equiv 1(mod \, n)$。</p><blockquote><p>同余：两个整数$a, b$，若它们除以正整数$m$所得的余数相等，则称$a, b$对于模$m$同余，记作$a \equiv b( \mod m)$。读作$a$同余于$b$模$m$，或读作$a$与$b$关于模$m$同余。</p></blockquote><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><blockquote><p>给定n组$a_i,b_i,p_i$，对于每组数据，求出 $a_i^{b_i} \mod p_i$ 的值。</p><p>数据范围：$1 \le n \le 100000, 1 \le a_i,b_i,p_i \le 2∗10^9$</p></blockquote><p><strong>快速幂可以在$O(\log n)$的时间复杂度，求出$a^k \, mod \,p$的值</strong>，其中$1 \le a, p, k \le 10^9$。</p><p>思路是：预处理出这些值，$a^{2^0} \, mod\, p$，$a^{2^1} \, mod\, p$，$a^{2^2} \, mod\, p$，……，$a^{2^{\log k}} \, mod\, p$，然后让：</p><script type="math/tex; mode=display">a^k=a^{2^{x_1}} \cdot a^{2^{x_2}} \dots a^{2^{x_t}} =a^{2^{x_1}+2^{x_2}+\dots +2^{x_t}}</script><p>而具体的$x_1, x_2, \dots, x_t$则可以由$k$的二进制表示所有为1的位获得，如$(k)_{10}=(110110)_2$， 则有$k=2^1+2^2+2^4+2^5$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;   <span class="comment">//数论中的很多问题都会爆int， 会用到long long </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 a^k mod p 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, k, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;k, &amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qmi(a, k, p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>快速幂求逆元</strong></li></ul><p><strong>乘法逆元</strong>的定义：若整数$b，m$互质，并且对于任意的整数$ a$，如果满足$b|a$，则存在一个整数$x$，使得$a/b≡a∗x(mod \,m)$，则称$x$为$b$的模$m$乘法逆元，记为$b^{−1}(mod \,m)$。$b$存在乘法逆元的充要条件是$b$与模数$m$互质。当模数$m$为质数时，$b^{m−2}$即为$b$的乘法逆元。</p><p>$b \cdot x \equiv 1(mod \, p)$，由费马小定理：$b^{p-1} \equiv 1(mod \, p)$，即$b \cdot b^{p-2} \equiv 1(mod \, p)$，因此我们要求的逆元$x$就是$b^{p-2}$，当然前提是$b$与模数$p$互质，其$p$是质数，这就转换了求快速幂的问题，<code>qmi(a, p - 2, p)</code></p><blockquote><p>给定$n$组$a_i,p_i$，其中$p_i$是质数,求$a_i$模$p_i$的乘法逆元，若逆元不存在则输出impossible。注意：请返回在0∼p−1之间的逆元。</p><p>数据范围：$1 \le n \le 10^5,1 \le a_i,p_i \le 2∗10^9$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 a^k mod p 的结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)  res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = qmi(a, p - <span class="number">2</span>, p);</span><br><span class="line">        <span class="keyword">if</span>(a % p)  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>裴蜀定理：对于任意正整数$a, b$，一定存在非零整数$x, y$，使得$ax+by=(a, b)$。</p><blockquote><p>$(a, b)$表示$a,b$的最大公约数</p></blockquote><p>要证明存在可以使用构造法，扩展欧几里得算法就提供了一种构造的思路。</p><blockquote><p>给定$n$对正整数$a_i,b_i$，对于每对数，求出一组$x_i,y_i$，使其满足$a_i∗x_i+b_i∗y_i=gcd(a_i,b_i)$。</p><p>数据范围：$1 \le n \le 10^5 , 1 \le a_i,b_i \le 2∗10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        exgcd(a, b, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设$a x+by=d $，由欧几里得算法知，$(a, b)=(b, a \,mod \, b)$，则有：$by+(a \, mod \, b)=d$；又因为$(a \, mod\, b)=a-\lfloor\frac{a}{b} \rfloor \cdot b$，代入得：$ax+b(y-\lfloor \frac{a}{b} \rfloor \cdot x)=d$，因此在递归<code>d=exgcd(b, a % b, y, x)</code>后要令<code>y -= a \b * x</code>。</p><p>扩展欧几里得算法的一个应用：<strong>求解线性同余方程</strong></p><blockquote><p>给定$n$组数据$a_i,b_i,m_i$，对于每组数求出一个$x_i$，使其满足$a_i∗x_i≡b_i(mod\,  m_i)$，如果无解则输出impossible。</p><p>数据范围：$1 \le n \le 10^5 , 1 \le a_i,b_i, m_i \le 2∗10^9$</p></blockquote><p>若存在一个$x$，使得$ax \equiv b(mod\, m)$，即是存在一个$y$，使得$ax=my+b$，即$ax-my=b$，令$y’=-y$，则等价于方程$ax+my’=b$有解，这就是扩展欧几里得算法的形式了，上式有解的充分必要条件是$b$是$a$和$m$的最大公约数的倍数，即$(a, m)|b$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span>(b % d)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);   <span class="comment">//如果b不是gcd(a, b)的倍数，那一定无解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>) x * (b / d) % m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><blockquote><p>可参考：<a href="https://oi-wiki.org/math/crt/" target="_blank" rel="noopener">中国剩余定理</a></p></blockquote><p><strong>中国剩余定理</strong> (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中$m_1, m_2,  \dots, m_k$  <strong>两两互质</strong>）：</p><script type="math/tex; mode=display">\begin{cases}x &\equiv a_1(\mod m_1)  \\x &\equiv a_2(\mod m_2)  \\&\dots\\x &\equiv a_k(\mod m_k)  \\\end{cases}</script><p>求解步骤：</p><ol><li>求所有模数的积， $M=m_1m_2\dotsm_k$</li><li>对于第$i$个方程：$M_i=\frac{M}{m_i}$，求$M_i$在模$m_i$的逆元$M_i^{-1}$（可以扩展欧几里得算法解，令$b=1$）</li><li>方程组的唯一解：$a= \sum^k_{i=1} a_iM_iM_i^{-1}(\mod n)$</li></ol><blockquote><p>表达整数的奇怪方式：</p><p>给定 $2n$ 个整数$a_1,a_2,…,a_n$和$m_1,m_2,…,m_n$,求一个最小的非负整数 $x$，满足$∀i∈[1,n],x≡m_i(\mod a_i)$。</p><p>数据范围：$1 \le a_i \le 2^{31}−1 , 0 \le m_i \le a_i, 1 \le n \le 25$。</p></blockquote><p>注意本题中的$a_i, m_i$并没有任何限制，而中国剩余定理中要求$m_1, m_2, \dots,m_k$两两互斥。先来分析前两个式子：</p><script type="math/tex; mode=display">\begin{align*}x &= k_1 * a_1 + m_1 \\x &= k_2 * a_2 + m_2 \\\end{align*}</script><p>因此有：</p><script type="math/tex; mode=display">k_1*a_1-k_2*a_2=m_2-m_1</script><p>由扩展欧几里得算法可知，上式有解，等价于$a_1, a_2$的最大公约数能整除$m_2-m_1$，是$(a_1, a_2)|m_2-m_1$。不定方程的所有解为（假设已求出一组$k_1, k_2$，其中$k$是任意整数）：</p><script type="math/tex; mode=display">\begin{cases}k_1+k \frac{a_1}{d}\\k_2+k\frac{a_2}{d}  \\\end{cases}</script><p>则$x$的所有解为：</p><script type="math/tex; mode=display">\begin{align*}x&=k_1a_1+m_1\\&=(k_1+k \frac{a_1}{d})a_1+m_1\\&=a_1k_1+m_1+k \frac{a_1a_2}{d} (前两项记为m_0，后一项记为ka)\\ &=m_0+ka\end{align*}</script><p>发现前两个方程$x$的解的形式一致，因此通过这个方法可以把两个不定方程合并为一个，若有$n$个不定方程，即通过$n-1$合并可以转化为一个方程$x=m_0+ka$，即$x \, mod\, a \equiv m_0$，即求$m_0 \, mod \, a$的正余数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span>          <span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d =exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> has_answer = <span class="literal">true</span>;</span><br><span class="line">    LL a1, m1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a2, m2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line">        </span><br><span class="line">        LL k1, k2;</span><br><span class="line">        LL d = exgcd(a1, a2, k1, k2);   <span class="comment">//求a1, a2最大公约数，这时已经计算出来k1, k2的解</span></span><br><span class="line">        <span class="keyword">if</span>((m2 - m1) % d)    <span class="comment">//如果a1, a2最大公约数不能整数m2 - m1，则无解</span></span><br><span class="line">        &#123;</span><br><span class="line">            has_answer = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        k1 *= (m2 - m1) / d;</span><br><span class="line">        <span class="comment">//将k1变成方程的最小整数解，防止溢出</span></span><br><span class="line">        LL t = a2 / d;</span><br><span class="line">        k1 = (k1 % t + t) % t;     <span class="comment">//求k1 模 t 的正的余数</span></span><br><span class="line">        </span><br><span class="line">        m1 = a1 * k1 + m1;         <span class="comment">//求合并方程的m</span></span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 / d * a2);     <span class="comment">//求合并方程的a， 即是a1, a2的最小公倍数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(has_answer)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (m1 % a1 + a1) % a1 &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//如有解，则输出</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      欧拉函数，快速幂，扩展欧几里得算法,中国剩余定理
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（10）</title>
    <link href="http://nekomoon404.github.io/2020/10/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%8810%EF%BC%89/</id>
    <published>2020-10-15T13:05:35.000Z</published>
    <updated>2020-10-17T12:43:57.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p>在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者素数。</p><h4 id="1-质数的判定——试除法"><a href="#1-质数的判定——试除法" class="headerlink" title="1.质数的判定——试除法"></a>1.质数的判定——试除法</h4><p>暴力做法，1到$n$遍历——时间复杂度$O(n)$</p><p>优化：n的约数都是成对出现，因此枚举时只枚举其中较小的一个，即2到$\sqrt{n}$，时间复杂度$O(\sqrt{n})$（<strong>推荐写成<code>1 &lt;= n / i</code></strong>，若是<code>i &lt;= sqrt(n)</code>，比较费时间；若是<code>i * i &lt;= n</code>，当n接近<code>int</code>的最大值时，<code>i * i</code>有溢出风险。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">2</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-分解质因数——试除法"><a href="#2-分解质因数——试除法" class="headerlink" title="2.分解质因数——试除法"></a>2.分解质因数——试除法</h4><p>每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的因数，把一个合数用质因数相乘的形式表示出来，叫做分解质因数。如30=2×3×5 。分解质因数只针对合数。</p><blockquote><p>给定n个正整数$a_i$，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的<strong>底数</strong>和<strong>指数</strong>。</p></blockquote><p>暴力做法：从小到大枚举所有数，$O(n)$</p><p>优化：n中最多只包含一个大于$\sqrt{n}$的质因数，最坏情况$O(\sqrt{n})$，最好情况$O(\log n)$（如当$n-2^k$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++)</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)  <span class="comment">// i 一定是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">//求底数的指数</span></span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">n /= i;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%d\n"</span>, i, s);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-筛质数"><a href="#3-筛质数" class="headerlink" title="3.筛质数"></a>3.筛质数</h4><blockquote><p>给定一个正整数n，请你求出1~n中质数的个数。</p></blockquote><p>朴素做法：将所有数从小到大排列，依次把每个数的倍数删掉，剩下的数就是从2到n的质数。（如果p没有被删掉，说明从2到p-1中不存在任何一个p的约数，那p一定是质数。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)  st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n \log n)$</p><script type="math/tex; mode=display">\begin{align*}& \frac{n}{2}+\frac{n}{3}+\dots+\frac{n}{n}\\=&n(\frac{1}{2}+\frac{1}{3}+\dots+\frac{1}{n}) --调和级数\\ =&n(\ln n + c)--c是欧拉常数，\approx0.5772 \\<&n \log n\end{align*}</script><p>优化：并不需要把每个数的倍数删掉，<strong>只需把每个质数的倍数删掉</strong>，代码只需很小的改动。——时间复杂度：$O(n \log \log n)$，很接近$O(n)$了。（1到n中有$n / \ln n$个质数）</p><blockquote><p>埃氏筛法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)  st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：<strong>线性筛法</strong>，也称为欧拉筛法，思路是：<strong>n只会被它的最小质因子筛掉</strong>。当$n=10^7$时，线性筛法大概比埃氏筛法快一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>   <span class="comment">//线性筛法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])   prime[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)  <span class="keyword">break</span>;   <span class="comment">//prime[j]一定是i的最小质因数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>i % prime[j] == 0</code>，<code>prime[j]</code>一定是<code>i</code>的最小质因数，<code>prime[j]</code> 一定是<code>prime[j] * i</code>的最小质因数；如果<code>i % prime[j] != 0</code>，说明<code>prime[j]</code>一定小于<code>i</code>的最小质因数，所以<code>prime[j]</code>也一定是<code>prime[j] * i</code>的最小质因数。</p><p>任何一个合数一定会被筛掉，它一定存在一个最小质因数，设为<code>prime[j]</code>，当<code>i</code>枚举到<code>x / prime[j]</code>时，它就会被筛掉。因为我们是<strong>用最小质因子来筛数，而每个数只有一个最小质因子，因此时间复杂度是线性的，即$O(n)$</strong>。</p><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="1-试除法求约数"><a href="#1-试除法求约数" class="headerlink" title="1.试除法求约数"></a>1.试除法求约数</h4><blockquote><p>给定n个正整数$a_i$，对于每个整数$a_i$,请你按照从小到大的顺序输出它的所有约数。</p></blockquote><p>思路和试除法判断质数相似，从小到大枚举n的约数（只枚举一对中小的那个），时间复杂度为$O(\sqrt{n})$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_divisors(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i != n / i)  res.push_back(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-约数个数"><a href="#2-约数个数" class="headerlink" title="2.约数个数"></a>2.约数个数</h4><p>定理：如果一个数因数分解之后可以写成：$N=p_1^{ \alpha_1} \cdot p_2^{\alpha_2} \cdot \dots p_k^{\alpha_k}$，那么它的<strong>约数个数</strong>为：$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$。</p><p>（数N的约数d一定可以写成：$d=p_1^{ \beta_1} \cdot p_2^{\beta_2} \cdot \dots p_k^{\beta_k}$，其中对每一个$\beta_i$，一定有$0 \le \beta_i \le \alpha_i$；N的每一个约数就对应着一组不同的$\beta_i$的取值，因此N的约数的个数就是$\beta_i$的不同取值的组合数，即$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$。）</p><blockquote><p>冷知识：<code>int</code>范围内的整数，约数个数最多的数，它的约数大约有1500个</p><p>给定n个正整数$a_i$，请你输出这些数的乘积的约数个数，答案对$10^9+7$取模。</p></blockquote><p>题目是让求数$a_1 \cdot a_2 \dots a_n$的乘积的约数的个数，我们可以分别求出每个数的约数的个数，把所有的约数和指数用一个哈希表存起来，然后套用公式即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>)  primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes)  res = res * (prime.second + <span class="number">1</span>) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-约数之和"><a href="#3-约数之和" class="headerlink" title="3.约数之和"></a>3.约数之和</h4><p>定理：如果一个数因数分解之后可以写成：$N=p_1^{ \alpha_1} \cdot p_2^{\alpha_2} \cdot \dots p_k^{\alpha_k}$，那么它的<strong>约数之和</strong>为：$(p_1^{ 0} + p_1^{1}+ \dots p_1^{\alpha_1})(p_2^{ 0} + p_2^{1}+ \dots p_2^{\alpha_2}) \dots (p_k^{ 0} + p_k^{1}+ \dots p_k^{\alpha_k})$。</p><p>（将上式展开，一共有$(\alpha_1+1)(\alpha_2+1)\dots (\alpha_3+1)$项，每一项都是$p_1^{ \beta_1} \cdot p_2^{\beta_2} \cdot \dots p_k^{\beta_k}$，都是N的一个约数，且每个数都不同，则上式就是N的约数之和。）</p><blockquote><p>给定n个正整数$a_i$，请你输出这些数的乘积的约数之和，答案对$10^9+7$取模。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>)  primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> prime : primes)   <span class="comment">//代码和上题基本一样，只需按求约数和的公式改动一下即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = prime.first, a = prime.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a--)   t = (t * p + <span class="number">1</span>) % mod;   <span class="comment">//这一步可以用分治优化到log a的复杂度，但在这个题中其实没必要</span></span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-求最大公约数"><a href="#4-求最大公约数" class="headerlink" title="4.求最大公约数"></a>4.求最大公约数</h4><p>欧几里得算法，也叫辗转相除法。a和b的最大公约数$=$ a模b和b的最大公约数，$(a, b)=(b, a \, mod \,b)$，这样就可以用递归写了，时间复杂度为$O(\log n)$。</p><p>（设$a \,mod\, b=a-c \cdot b$，则$(a, b)=(b, a-c \cdot b)$。由d能整除a，d能整除b，则d能整数ax + by，这证上式成立。）</p><blockquote><p>给定n对正整数$a_i,b_i$，请你求出每对数的最大公约数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;   <span class="comment">//a和0的最大公约数是a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, gcd(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第四章数学知识内容：数论（质数，约数）
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（9）</title>
    <link href="http://nekomoon404.github.io/2020/10/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/14/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%889%EF%BC%89/</id>
    <published>2020-10-14T10:38:41.000Z</published>
    <updated>2020-10-15T13:02:05.366Z</updated>
    
    <content type="html"><![CDATA[<p>第三章 搜索与图论（三）</p><p>定义无向连通图的<strong>最小生成树</strong> （Minimum Spanning Tree，MST）为<strong>边权和最小的生成树</strong>。</p><blockquote><p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p><p>可参考：<a href="https://oi-wiki.org/graph/mst/" target="_blank" rel="noopener">最小生成树</a></p></blockquote><p>最小生成树问题对应的图都是无向图，一般有两种常用的解法：</p><ul><li>Prim算法：（和Dijkstra算法很像）<ul><li>朴素版Prim算法——稠密图，时间复杂度$O(n^2)$；</li><li>堆优化版Prim算法——稀疏图，时间复杂度$O(m \log n)$</li></ul></li><li>Kruskal算法——稀疏图，时间复杂度$O(m \log n)$</li></ul><blockquote><p>算法的选择：如果是稠密图，一般就用朴素版Prim算法；如果是稀疏图，一般就用Kruskal算法。堆优化版Prim算法一般不常用。</p></blockquote><h3 id="朴素版Prim算法"><a href="#朴素版Prim算法" class="headerlink" title="朴素版Prim算法"></a>朴素版Prim算法</h3><p>朴素版Prim算法适用于解决稠密图的最小生成树问题，其思路和Dijkstra算法很像：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化所有距离为正无穷 dist[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">t = 集合s外距离最近的点;        <span class="comment">//集合s表示当前在连通块中的所有的点</span></span><br><span class="line">    用t更新其他点到**集合**的距离;   <span class="comment">//注意这里与Dijkstra算法的区别</span></span><br><span class="line">                                <span class="comment">//点到集合的距离：当前点能连到集合内部的点的边中最短的边的距离；若没有一条边是连到集合内部的，距离就定义为正无穷</span></span><br><span class="line">    s[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">生成树就是：每次选到的t，其距离对应的那条边，所组成的树</span><br></pre></td></tr></table></figure><blockquote><p>例题：Prim算法求最下生成树（Acwing 858)</p><p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><p>输出格式：共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>数据范围：$1 \le n \le 500, 1 \le m \le 10^5$，图中涉及边的边权的绝对值均不超过10000。</p><p>（实际问题：如在城市之间铺路，允许路之间交叉，求铺路总长度的最小值）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];   <span class="comment">//稠密图用邻接矩阵存比较好</span></span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//dist[]表示点到集合的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//st[]存点是否已经在连通块中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//注意题目中给的点的编号，从1开始，那j就从1开始</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))   <span class="comment">//找到集合外距离最近的点t</span></span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF)  <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)   res += dist[t];   <span class="comment">//注意：要先累加再更新，否则会把负的自环更新进来</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)   <span class="comment">//用t更新其他点到集合的距离</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = prim();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Prim算法的堆优化思路和Dijkstra堆优化的思路是一样的：用堆维护上面的dist[]数组，每次找最小值的时间复杂度是$O(1)$，共执行$n$次就是$O(n)$；更新堆中的一个元素是$O(\log n)$，共$m$条边，执行了$m$次就是$O(m \log n)$，所以堆优化版的Prim算法的时间复杂度就是$O(m \log n)$。</p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法适用于解决稀疏图的最小生成树问题，其思路如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将所有边按权重从小到大排序;   <span class="comment">//Kruskal算法的瓶颈，O(mlogm)</span></span><br><span class="line">从小到大枚举每条边 a——b，权重是w</span><br><span class="line">    <span class="keyword">if</span> a,b不连通（边不在集合中）</span><br><span class="line">        将这条边加入到集合中（其实就是将a和b之间连一条边）  <span class="comment">//可以理解为并查集的简单应用</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//不需要用邻接矩阵或邻接表来存图，只需用结构体把每条边存起来即可</span></span><br></pre></td></tr></table></figure><blockquote><p>例题：Kruskla算法求最小生成树（Acwing 858）</p><p>题目和前一道题一样，数据范围变了变：$1 \le n≤10^5, 1 \le m \le 2∗10^5$，显然这是一个稀疏图问题。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];  <span class="comment">//并查集中的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;E) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; E.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//并查集的find函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  p[i] = i;    <span class="comment">//初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a != b)   <span class="comment">//如果a和b在并查集中没有连通</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res  += w;    <span class="comment">//res存最小生成树中边权的总和</span></span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果循环结束后，连通的边数小于n-1，说明n个点没有全部连通，即不存在最小生成树</span></span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>)  <span class="keyword">return</span> INF;   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = kruskal();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p><strong>二分图：节点由两个集合组成，且两个集合内部没有边的图</strong>。换言之，存在一种方案，将节点划分成满足以上性质的两个集合。</p><blockquote><p>可参考：<a href="https://oi-wiki.org/graph/bi-graph/" target="_blank" rel="noopener">二分图</a>，介绍了二分图的概念和性质</p></blockquote><p>二分图，通常有两类问题：</p><ul><li>染色法判定二分图，（DFS），时间复杂度$O(n+m)$</li><li>匈牙利算法，最坏情况下时间复杂度$O(nm)$，但实际运行时间一般远小于$O(nm)$</li></ul><p>二分图的性质：<strong>一个图是二分图，当且仅当图中不含奇数环</strong>。<strong>抽象为染色问题</strong>，一点为黑色，那连通块中与它相邻的点一定为白色；若连通块中一个点的颜色确定了，整个连通块中点的颜色就确定了。<strong>由于图中不含有奇数环，所以整个染色过程一定是没有矛盾的</strong>。</p><p>染色法判定二分图的思路如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  遍历所有点</span><br><span class="line">    <span class="keyword">if</span> i 没被染色</span><br><span class="line">        dfs(i, <span class="number">1</span>); 用深度优先遍历将i所在的连通块中的点都染色; <span class="number">1</span>表示点i当前的颜色</span><br></pre></td></tr></table></figure><blockquote><p>例题：染色法判定二分图</p><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。</p><p>输出格式：如果给定图是二分图，则输出“Yes”，否则输出“No”。</p><p>数据范围：$1 \le n\le 10^5, 1 \le m \le 10^5$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;   <span class="comment">//用邻接表存稀疏图</span></span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;       <span class="comment">//给当前点染色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];   </span><br><span class="line">        <span class="keyword">if</span>(!color[j])   <span class="comment">//若当前点未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(j, <span class="number">3</span> - c))  <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//两种颜色1和2， 3 - c 就表示与c不同的另一种颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)  <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果与u相邻的点颜色与其相同，说明冲突了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b), add(b, a);   <span class="comment">//无向图，存两次边</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag)    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法（二分图最大匹配）"><a href="#匈牙利算法（二分图最大匹配）" class="headerlink" title="匈牙利算法（二分图最大匹配）"></a>匈牙利算法（二分图最大匹配）</h3><p><strong>二分图的匹配</strong>：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。</p><p><strong>二分图的最大匹配</strong>：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p><p>匈牙利算法又称为KM算法，可以用来求解解决二分图最大权匹配。</p><blockquote><p>可以参考：<a href="https://oi-wiki.org/topic/graph-matching/bigraph-weight-match/" target="_blank" rel="noopener">二分图最大权匹配</a></p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201015201734.png" style="zoom:50%;"></p><p>（奇妙比喻）匈牙利算法的思路是：遍历左边的男生，第一个，第二个都顺利找到了心仪的且还是单身的女伴，到了第三个男生，发现心仪的女生已经有所属了，但他没有放弃，回去看这位女生所属的男生，发现他还有其他心仪的女生，OK那就交换一下，这样三个男生就都有女伴了。</p><p>时间复杂度：遍历每个男生，n；每个男生找女伴时最多再遍历m边条，因此最坏情况下，时间复杂度为$O(nm)$，但实际运行的复杂度远小于$O(mn)$。</p><blockquote><p>例题：二分图的最大分配（Acwing 861）</p><p>给定一个二分图，其中左半部包含$n_1$个点（编号1~$n_1$），右半部包含$n_2$个点（编号1~$n_2$），二分图共包含m条边。数据保证任意一条边的两个端点都不可能在同一部分中。请你求出二分图的最大匹配数。</p><p>输入格式：第一行包含三个整数 n1、 n2 和 m。接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。</p><p>输出格式：输出一个整数，表示二分图的最大匹配数。</p><p>数据范围：$1 \le n_1,n_2 \le 500, 1 \le u \le n_1, 1 \le v \le n_2, 1 \le m \le 10^5$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会找左边集合中的点指向哪些边</span></span><br><span class="line"><span class="keyword">int</span> n1, n2, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> match[N];  <span class="comment">//右边集合中的点与哪些点相连</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//每次不要重复搜一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])      <span class="comment">//遍历当前男生相连的女生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])     <span class="comment">//如果这个女生之前没找过</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))   <span class="comment">//如果这个女生还没有所属，或者其所属可以找到其他女生，那这次配对就成功了</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)      <span class="comment">//枚举每个男生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i))  res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>图论题的难点是如何把问题抽象成图论问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      求最小生成树（Prim算法，Kruskal算法），二分图（染色法，匈牙利算法）。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（8）</title>
    <link href="http://nekomoon404.github.io/2020/10/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%888%EF%BC%89/</id>
    <published>2020-10-13T08:24:04.000Z</published>
    <updated>2020-10-14T08:39:11.491Z</updated>
    
    <content type="html"><![CDATA[<p>常见的最短路问题：</p><ol><li><p><strong>单源最短路</strong>：求一个点到其他所有点的最短距离，如从1号点到N号点的最短路。又可分为：</p><ul><li><p><strong>所有边的权重都是正数</strong>，一般有两种解法：</p><ul><li>朴素的Dijkstra算法（时间复杂度$O(n^2)）$，适合用于稠密图（$m$接近于$n^2$）；</li><li>堆优化版的Dijkstra算法（时间复杂度$O(m \log n)$），适合用于稀疏图（$m$接近于$n$）；</li></ul><p>（设图中点的数量为$n$，边的数量为$m$）（稠密图用邻接矩阵来存，稀疏图用邻接表来存）</p></li><li><p><strong>存在权重是负数的边</strong>，一般也有两种解法：</p><ul><li>Bellman-Ford算法（时间复杂度$O(nm)$）；</li><li>SPFA算法（一般情况下时间复杂度$O(m)$，最坏情况下$O(nm)$），但并不是所有情况都可用SPFA，如限制经过的边数不超过$k$。</li></ul></li></ul></li><li><p><strong>多源汇最短路</strong>：可能有多个询问，每次询问从其中一个点走到另一点的最短距离，即起点和终点不确定（源点——起点，汇点——终点）：</p><ul><li>Floyd算法（时间复杂度$O(n^3)$）</li></ul></li></ol><p><strong>最短路问题考察的重点难点是：建图，即把原问题抽象成一个最短路问题，如何定义点和边</strong>；重点不在证明算法的正确性上。</p><p>（有向图和无向图的最短路问题其实是没有区别的，无向图可以看作是特殊的有向图，我们可以用有向图的最短路算法来解决无向图的问题。）</p><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化距离 dis[<span class="number">1</span>] = <span class="number">0</span>, dis[i] = 正无穷</span><br><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点</span><br><span class="line">    t加到s中</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">每次循环都可以确定一个点的最短距离，循环n次后就得到了每个点到起点的最短距离</span><br></pre></td></tr></table></figure><blockquote><p>例题：Dijkstra求最短路I（Acwing 849）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出-1。</p><p>数据范围：$1 \le n \le500, 1 \le m \le 105$，图中涉及边长均不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;     </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//找到不在s中的距离最近的点</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))  <span class="comment">//如果dist[t]比dist[j]大的话，那t显然不满足最短路的要求</span></span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;   <span class="comment">//将找到的t存入s中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>回顾一下朴素Dijkstra算法中的各步骤的时间复杂度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点————总共n^<span class="number">2</span>次</span><br><span class="line">    t加到s中————总共n次</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）————总共m次（与边数有关）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见朴素Dijkstra算法中最耗时的是第一步：在<code>st[]=false</code>的点中找到<code>dist[]</code>最小的点，即是t，整个算法的时间复杂度为$O(n^2)$。在一组数中找到最小的数，正是堆擅长做的，在堆中求最小值的时间复杂度为$O(1)$，但这也会影响第三步，在堆中修改一个数的时间复杂度为$O(\log n)$。因此堆优化的Dijkstra算法中各步骤的时间复杂度为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i 从<span class="number">0</span>到n:  （集合S存当前已经确定最短距离的点）</span><br><span class="line">&#123;</span><br><span class="line">    t = 找到不在S中的距离最近的点————总共n次</span><br><span class="line">    t加到s中————总共n次</span><br><span class="line">    用t更新其他点的距离（从t出去的所有边，它组成的路径能不能更新其他点的距离，即dis[x] &gt; dis[t] + w）————总共 m*logn次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见堆优化Dijkstra算法中最耗时的变成了第三步，整个算法的时间复杂度为$O(m \log n)$。</p><p>实现堆有两种方法：手写堆（可以支持修改任意一个元素）；优先级队列（不支持修改任意一个元素，每修改一次就在队列中加一个新的数）。一般来说堆优化版的Dijkstra算法就使用STL中的优先级队列就行了。同时也要注意，稀疏图的存储方式用邻接表要好一些。</p><blockquote><p>例题：Dijkstra求最短路II（Acwing 850）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出-1。</p><p>数据范围：$1 \le n, m \le 1.5 \times 10^5$，图中涉及边长均不小于0，且不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//first存点到起点的距离，second存点的下标（第几个点）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;   <span class="comment">//稀疏图用邻接表存，与之前写过的区别是：多个w[N]来存每条边的权重（边长）</span></span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;  <span class="comment">//小根堆</span></span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())    <span class="comment">//队列中最多只有m个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])  <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])    </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];       <span class="comment">//dist[j] = dist[ver] + w[i];  也是可以的</span></span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>Bellman-Ford算法是用来解决存在权重是负数的边的最短路问题的，它的主要步骤为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n 次：</span><br><span class="line">    <span class="keyword">for</span> 所有边a, b, w:  （a指向b，权重/边长为w）</span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], dist[a] + w);  （和Dijkstra类型，dist[]存点到起点的最短距离）</span><br></pre></td></tr></table></figure><p>Bellman-Ford遍历完所有边后，所有的点都满足：<code>dist[b] &lt;= dist[a] + w</code>（三角不等式），这个更新的过程叫作：松弛操作。</p><p>要注意的是：<strong>若存在负权回路，则最短路不一定是存在的</strong>（若负环是在从起点到终点的某一条路径中，绕负权回路无数圈，最短路就是<strong>负无穷</strong>了）。<strong>Bellman-Ford算法可以求出是否存在负权回路</strong>，其迭代的次数是有实际意义的，如当前迭代了k次，<code>dist[]</code>数组的含义是从起点经过不超过K条边到各个点的最短距离；<strong>迭代完n次，第n次还有更新的话</strong>就表示存在一条最短路径，其含有的边数为n条。如果一条最短路径上有n条边，但只有n-1个点，根据抽屉原理，路径上一定存在环，且又因为第n次更新了，所有环的权重一定是负的，<strong>即存在负权回路</strong>。</p><blockquote><p>例题：有边数限制的最短路（Acwing 853）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。注意：图中可能 存在负权回路 。</p><p>输入格式：第一行包含三个整数n，m，k。接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。如果不存在满足条件的路径，则输出“impossible”。</p><p>数据范围：$1 \le n,k \le 500,1 \le m \le 10000$，任意边长的绝对值不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> dist[N], backup[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;   <span class="comment">//a，b表示边的起点和终点，w表示边的权重</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需要做个特殊的处理：每次遍历前先将dist[]数组备份一下；只用上一次迭代的结果来更新</span></span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//这里的判断条件也要注意一下，防止两个正无穷之间连了条负边，后一个负无穷可能会更新</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m; i++)   <span class="comment">//读入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = bellman_ford();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">-1</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA算法也是用来解决存在权重是负数的边的最短路问题的，它要求路径中没有负环（负权回路），其实大多数最短路题目中都是没有负环的，SPFA算法也算是单源最短路问题中限制最少的算法了。SPFA算法相当于是在Bellman Ford算法的基础上做优化，回顾下Bellman Ford算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n 次：</span><br><span class="line">    <span class="keyword">for</span> 所有边a, b, w:  （a指向b，权重/边长为w）</span><br><span class="line">        dist[b] = <span class="built_in">min</span>(dist[b], dist[a] + w);  （和Dijkstra类型，dist[]存点到起点的最短距离）</span><br></pre></td></tr></table></figure><p>每次迭代要更新<code>dist[b]</code>时如果<code>dist[b]</code>在当前迭代中想要变小，那就要求<code>dist[a]</code>要变小，只要<code>dist[a]</code>变小了，<code>dist[b]</code>才会变小。SPFA就是从这一点作优化，利用宽度优先搜索BFS来做优化，其思路如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">起点放入队列 queue</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空:  (queue存的是所有dist[]变小了的节点)</span><br><span class="line">&#123;</span><br><span class="line"> 取出队头 t = q.fornt();</span><br><span class="line"> q.pop();</span><br><span class="line"> 更新t的所有出边 t-b, 权重为w</span><br><span class="line"> 若更新成功，且队列中没有b，就把b加入队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例题：SPFA求最短路（Acwing 851）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出impossible。数据保证不存在负权回路。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。如果路径不存在，则输出”impossible”。</p><p>数据范围：$1 \le n,m \le 10^5$，图中涉及边长绝对值均不超过10000。</p></blockquote><p>（代码与Dijkstra算法的很像）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;  </span><br><span class="line"><span class="keyword">int</span> dist[N];   <span class="comment">//存点到起点的距离</span></span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())    </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];   <span class="comment">// j表示当前这个点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])   <span class="comment">//当j此前不在对列中，才将j加入到队列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">-1</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SPFA算法也可以用来判断路径中是否存在负环</strong>（判断负环一般用SPFA算法，时间复杂度低）。</p><blockquote><p>例题2：SPFA判断负环（Acwing 852）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你判断图中是否存在负权回路。</p><p>输入格式：第一行包含整数n和m。接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><p>输出格式：如果图中存在负权回路，则输出“Yes”，否则输出“No”。</p><p>数据范围：$1 \le n \le 2000,1 \le m \le 10000$，图中涉及边长绝对值均不超过10000。</p></blockquote><p>用<code>dist[x]</code>数组表示从起点到当前点的最短距离，<code>cnt[x]</code>数组表示当前的最短路中边的数量，每次更新时有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist[x] = dist[x] + w[i];</span><br><span class="line">cnt[x] = cnt[t] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果过程中每一更新后<code>cnt[x] &gt;= n</code>，根据抽屉原理，路径上至少有一个点出现了两次，说明路径上存在一个环，又因为更新成功了，所有环一定是负环。</p><p>（代码只需在前一道题的基础上稍加修改即可）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], w[N], e[N], ne[N], idx;  </span><br><span class="line"><span class="keyword">int</span> dist[N], cnt[N];   </span><br><span class="line"><span class="keyword">bool</span> st[N];    <span class="comment">//存当前已经确定最短路的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为不需要求具体的距离了，所有不需要初始化了</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//负环不一定是从点1开始能到达的，可能出现在以某个点为起点的路径中，所以需要把所有点加入到队列中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())    </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//遍历从t出去的所有边，遍历完后就是遍历了所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];   <span class="comment">// j表示当前这个点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])   <span class="comment">//当j此前不在对列中，才将j加入到队列</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = spfa();</span><br><span class="line">    <span class="keyword">if</span>(spfa())  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p><strong>Floyd算法是用来解决多源汇最短路问题的</strong>，时间复杂度为$O(n^3)$，其思路是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用一个邻接矩阵d[i][j]存储图中所有的边;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"></span><br><span class="line">循环结束之后，d[i][j]存的是从点i到点j的最短路的长度</span><br></pre></td></tr></table></figure><p>Floyd算法是基于动态规划，$d[k, i, j]$表示从点$i$到点$j$，只经过1到$k$这些中间点，的最短距离，更新$d[k, i, j]$时有：</p><script type="math/tex; mode=display">d[k, i, j]= d[k-1, i, k] +d[k-1, k, j]</script><p>（关于动态规划的知识，之后会细讲。）</p><blockquote><p>例题：Floyd算法求最短路（Acwing 854）</p><p>给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。再给定k个询问，每个询问包含两个整数x和y，表示查询从点x到点y的最短距离，如果路径不存在，则输出“impossible”。数据保证图中不存在负权回路。</p><p>输入格式：第一行包含三个整数n，m，k。接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。接下来k行，每行包含两个整数x，y，表示询问点x到点y的最短距离。</p><p>输出格式：共k行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出“impossible”。</p><p>数据范围：$1 \le n \le 200, 1 \le k \le n^2, 1 \le m \le 20000$，图中涉及边长绝对值均不超过10000。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> d[N][N];  <span class="comment">//用矩阵d存两点间的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;   <span class="comment">//循环结束之后，d[i][j]就存的是点i到点j之间的最短距离了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)        <span class="comment">//初始化距离矩阵d</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i == j)  d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)   <span class="comment">//读取各边及其长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        </span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], w);   <span class="comment">//可能出现重边，只需保留其最小值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    floyd();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; INF / <span class="number">2</span>)  <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最短路（Dijkstra，bellman-ford，spfa，Floyd）
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（7）</title>
    <link href="http://nekomoon404.github.io/2020/10/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%887%EF%BC%89/</id>
    <published>2020-10-11T08:09:19.000Z</published>
    <updated>2020-10-12T08:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三章  搜索与图论</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>深度优先搜索—DFS，宽度优先搜索—BFS</strong></p><div class="table-container"><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th></th></tr></thead><tbody><tr><td>DFS</td><td>栈stack</td><td>$O(h)$</td><td>不具有最短性</td></tr><tr><td>BFS</td><td>队列queue</td><td>$O(2^h)$</td><td>“最短路”</td></tr></tbody></table></div><p>DFS中关键的两点是：<strong>回溯</strong>和<strong>剪枝</strong>，DFS可以从<strong>搜索树</strong>的角度来考虑。DFS解题最重要的考虑搜索的<strong>顺序</strong>。</p><blockquote><p>DFS例题1：排列数字（Acwing 842）</p><p>给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。</p><p>输入格式：共一行，包含一个整数n。</p><p>输出格式：按字典序输出所有排列方案，每个方案占一行。</p><p>数据范围：$1 \le n \le 7$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201011170111.png" style="zoom: 50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)   <span class="comment">//注意i从1开始，因为要枚举的数是从1到n</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS例题2：n-皇后问题（Acwing 843）</p><p>n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数n，请你输出所有的满足条件的棋子摆法。</p><p>输入格式：共一行，包含整数n。</p><p>输出格式：每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。输出方案的顺序任意，只要不重复且没有遗漏即可。</p><p>数据范围：$1 \le n \le 9$。</p></blockquote><p>思路1：搜索顺序类似于全排列，从第一行开始，枚举皇后可以放到哪。可以提前判断当前方案一定是不合法的，就不用继续向下搜索了，直接回溯即可，这一过程就是“<strong>剪枝</strong>”。（时间复杂度：$O(n \cdot n!)$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> col[N], dg[<span class="number">2</span> * N], udg[<span class="number">2</span> * N];  <span class="comment">//分别代表列，对角线，反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">puts</span>(g[i]);  <span class="comment">//打印棋盘的每一行</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//遍历每一列</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">'Q'</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：按棋盘格子开始枚举，放下皇后是一个分支，不放是另一个分支。（时间复杂度：$O(2^{n^2})$）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N], col[N], dg[<span class="number">2</span> * N], udg[<span class="number">2</span> * N];  <span class="comment">//分别代表列，对角线，反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> s)</span>    <span class="comment">//x, y, s分别代表当前遍历的格子的行，列，已经摆好的皇后的个数</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (y == n)  y = <span class="number">0</span>, x ++;   <span class="comment">//遍历完一行后，转向下一行</span></span><br><span class="line">    <span class="keyword">if</span> (x == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个格子不放皇后</span></span><br><span class="line">    dfs(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下一个格子放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        g[x][y] = <span class="string">'Q'</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        dfs(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            g[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>BFS的优势是可以搜索到最短路</strong>。（最短路问题包含DP动态规划问题，DP是没有环的最短路问题。）</p><p><strong>不是所有的问题都是最短路问题，只有当所有边的权重都相同时，才可以用BFS求最短路</strong>，一般情况下都要用专门的最短路算法求。</p><blockquote><p>BFS例题1：走迷宫（Acwing 844）</p><p>给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。</p><p>输入格式：第一行包含两个整数n和m。接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。</p><p>输出格式：输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><p>数据范围：$1 \le n,m \le 100$。</p></blockquote><p>从起点开始搜，第一步把所有距离为1的点搜一遍，第二步把所有距离为2的点搜一遍，……，</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012183018.png" style="zoom:50%;"></p><p>BFS解题的基本框架：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始状态放入队列 queue;</span><br><span class="line"><span class="keyword">while</span><span class="built_in"> queue </span>不空</span><br><span class="line">&#123;</span><br><span class="line">t = 队头;</span><br><span class="line">拓展 t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];  <span class="comment">//存放地图</span></span><br><span class="line"><span class="keyword">int</span> d[N][N];  <span class="comment">//存放每一个点到起点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;PII&gt; q;  <span class="comment">//存每个点的坐标(x, y)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);  <span class="comment">//初始化d，表示没有被搜索过</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//从(0, 0) 开始</span></span><br><span class="line">    q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">//用向量表示搜索的四个方向：上，右，下， 左</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.front();  <span class="comment">//取队头元素</span></span><br><span class="line">        q.pop();  <span class="comment">//将队头元素弹出，队列里保持只有一个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;=<span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.push(&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m <span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS例题2：八数码（Acwing 845）</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201014164329.png" style="zoom:80%;"></p><p>可以把3*3矩阵的一个状态看作图论中的一个点，若从一个状态经过一次操作可以变成另一个状态，就在对应的两个点之间连一条边。</p><p>本题难点：</p><ul><li><p>状态表示复杂，可以将3*3矩阵中的数用一个字符串来表示，如<code>&quot;1234x5678&quot;</code>，<code>queue&lt;string&gt; queue</code>；<code>dist[]</code>数组可以用字典来存，如<code>unordered_map&lt;string, int&gt; dist</code></p></li><li><p>如何记录每个状态的“距离” <code>dist[]</code>数组：（1）3*3矩阵；（2）枚举x能移动的位置；（3）将x移动后的矩阵恢复成字符串</p></li></ul><h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p><strong>树是特殊的图——无环连通图</strong>。<strong>图分为有向图和无向图</strong>，而无向图又可以看作是特殊的有向图，因此我们只需考虑有向图的遍历问题即可。</p><p>有向图的<strong>存储方式</strong>：</p><ol><li><strong>邻接矩阵</strong>：<code>g[a][b]</code>，表示$a \to b$的一条边；</li><li><strong>邻接表</strong>：每个节点上开一个单链表，<strong>存这个点可以走到哪些点</strong>。若有新连接的边，一般在链表的头节点插入新的点。</li></ol><p>树与图的<strong>遍历方式</strong>：</p><ol><li><strong>深度优先遍历</strong> </li><li><strong>宽度优先遍历</strong></li></ol><blockquote><p>深度优先遍历例题：树的重心（Acwing 846）</p><p>给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p>输入格式：第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之间存在一条边。</p><p>输出格式：输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。（树的重心可能不唯一）</p><p>数据范围：$1 \le n \le 10^5$。</p></blockquote><p>在树的深度优先遍历时，可以求出每棵子树中的点的数量。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012201101.png" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;    </span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;  <span class="comment">//idx 存当前的边数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];  <span class="comment">//表示当前点是否已经被搜过了；在深度优先遍历或者宽度优先遍历中每个点只会被遍历一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = N;   <span class="comment">//存最后的结果，即删除重心后，使剩余连通块点的数目的最大值最小 的那个值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span>    <span class="comment">//深度优先遍历，返回以u为根的子树中的点的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;  <span class="comment">//标记当前点已经被搜过了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sum存当前子树中点的数目，res存将当前点删除后，剩余连通块中点的数目的最大值</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = dfs(j);</span><br><span class="line">            res = <span class="built_in">max</span>(res, s);</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);</span><br><span class="line">    </span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b), add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>);   <span class="comment">//搜索的是图中的结点编号，结点编号从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>宽度优先遍历例题：图中点的层次（Acwing 847）</p><p>给定一个n个点m条边的有向图，图中可能存在<strong>重边</strong>和<strong>自环</strong>。所有边的长度都是1，点的编号为1~n。请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。</p><p>输入格式：第一行包含两个整数n和m。接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。</p><p>输出格式：输出一个整数，表示1号点到n号点的最短距离。</p><p>数据范围：$1 \le n,m \le 105$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20201012201600.png" style="zoom: 40%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> d[N], q[N];   <span class="comment">//q[]存 用数组模拟的队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++];    <span class="comment">//取出队头，并弹出队头</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;   <span class="comment">//将下一步能走的点放入队列（其实就是队头，队列中一直只有一个元素）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>图的宽度优先遍历的一个很经典的应用是：<strong>图的拓扑序列</strong>，拓扑序列是针对有向图的。<strong>若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列</strong>。</p><p>也就是说，当把图按照拓扑序排列好后，所有的边都是从前指向后的（点在序列中的顺序）。并不是所有图都有拓扑序列，如存在环的图。<strong>一个有向无环图，一定存在拓扑序列</strong>，因此有向无环图也叫作拓扑图。</p><p>点的<strong>入度</strong>与<strong>出度</strong>：</p><ul><li><p>入度：一个点有多少条边指向自己，就是它的入度；</p></li><li><p>出度：一个点有多少条边从自己出去，就是它的出度。</p></li></ul><p>入度为0的点可以作为起点（当前最前面的位置），一个有向无环图，至少存在一个入度为0的点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">所有入度为<span class="number">0</span>的点入队列 <span class="built_in">queue</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">queue</span> 不空</span><br><span class="line">&#123;</span><br><span class="line">    t = 队头;</span><br><span class="line">    枚举t的所有出边 t-j</span><br><span class="line">    &#123;   删掉t-j, j的入度减<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j的入度为<span class="number">0</span>):</span><br><span class="line">        队头 = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="keyword">int</span> q[N], d[N];   <span class="comment">//d[] 表示一个点的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>)  q[++ tt] = j;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;  <span class="comment">//若所有点已经入队，那队尾就是n-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);</span><br><span class="line">        d[b] ++;    <span class="comment">//d[]表示一个点的入度，注意这里要入度++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(topsort())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);  <span class="comment">//q[]中的次序恰好就是拓扑序列</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第三章内容：深度优先搜索、宽度优先搜索、树与图的存储、树与图的深度优先遍历，树与图的宽度优先遍历，拓扑排序。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（6）</title>
    <link href="http://nekomoon404.github.io/2020/10/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%886%EF%BC%89/</id>
    <published>2020-10-09T10:17:48.000Z</published>
    <updated>2020-10-11T07:14:08.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>主要讲两部分内容：<strong>存储结构</strong>—（开放寻址法，拉链法），<strong>字符串哈希方式</strong></p><p>哈希表的主要作用是把一个比较大的空间映射到一个比较小的空间（如0-N），如$x \in (-10^9,10^9)$，哈希函数$h(x) \in (0,10^5)$。</p><p>如何构造哈希函数：</p><ol><li>直接取模  $x \quad\% \quad 10^5 \in (0,10^5)$；（取模的这个数一般要取成质数，且要离2的几次方尽量远，这样冲突的几率是较小的）</li><li>冲突：直接取模会把不同的数映射到相同的数。处理冲突的方式可以分为：开放寻址法和拉链法</li></ol><p>在算法题中一般不需要在哈希表中进行删除操作，一般只有添加和查找操作。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>拉链法：开一个一维数组<code>h[]</code>来存储所有的哈希值。每一次当把一个$x$映射到某一个数时，假设第$1$个数插入11，,$h(11)=3$，就在3下面拉一条链（单链表），存下11，即<code>e[1]=11; ne[1]=h[3]=0; h[3]=1</code>；如果第$4$次插入另一个数23，$h(23)=3$，就将23插入到h[3]下面这条链表中，插到头节点，即让<code>e[4] = 23; ne[4] = h[3]= 1, ne[23]=4</code>。</p><p>当要查找数11时，先求$h(11)=3$，循环<code>for(i = h[k]; i != -1; i = ne[i])</code>，首先<code>i = h[3] = 4</code>，而<code>e[4]=23</code>不等于11；就让<code>i=ne[4]=1</code>，<code>e[1]=11</code>，因此就找到了11。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201010165518.png" style="zoom: 67%;"></p><blockquote><p>例题1：模拟散列表</p><p>维护一个集合，支持如下几种操作：</p><p>“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；</p><p>现在要进行N次操作，对于每个询问操作输出对应的结果。</p><p>输入格式：第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。</p><p>输出格式：对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。</p><p>数据范围：$1 \le N \le 10^5$，$-10^9 \le x \le 10^9$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;  <span class="comment">//让负数模N的结果也是正数</span></span><br><span class="line">    e[idx] = x;       <span class="comment">//e[]存第idx个插入的数的值</span></span><br><span class="line">    ne[idx] = h[k];   <span class="comment">//ne[]存第idx个插入的数的next节点，每次在拉链上插入都是插入到头节点</span></span><br><span class="line">    h[k] = idx ++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  insert(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>开放寻址法：只开一个数组，但数组长度要开到题目给出的数据范围的2-3倍（经验值）。</p><p>添加：$h(x)=k$，先找到k，从第k个坑位开始找，直到找到第一个空的坑位为止，插入。</p><p>查找：从第k个坑位开始，从前往后找，每一次看当前坑位是否有数，若是x则查找成功；若不是x，就往后找；若坑位没数，则查找失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>;  <span class="comment">//先找到大于200000的最小质数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null = <span class="number">0x3f3f3f3f</span>;   <span class="comment">//找一个数表示坑位没人，要在题目数据范围之外</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x在哈希表中已经存在，就返回x的位置；若x在哈希表中不存在，就返回它应该存储的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N)  k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//按字节来初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h4><p>字符串哈希方式——字符串前缀哈希法</p><p><code>str=&quot;ABCABCDEYXCAcwing&quot;</code>，预处理出所有前缀的哈希，如<code>h[0]=0</code>；<code>h[1]=&quot;A&quot;的哈希值</code>；<code>h[2]=&quot;AB&quot;的哈希值</code>,……</p><p>如何来定义某一个前缀的哈希值：把字符串看成一个P进制的数，如$”ABCD”=(1234)_P=1 \times P^3+ 2 \times P^2 + 3 \times P^2 + 4 \times P^0$，若字符串很长，那转化后的数会很大，因此可以让其模上一个较小的数$Q$，这样就能把字符串映射到$0 $~ $Q-1$之间的数。计算前<code>i</code>个字符的前缀就是：<code>h[i] = h[i-1]* p + str[i]</code></p><p>要注意的是：<strong>不能把一个字母映射到0</strong>；前一小节中哈希数字时可能发生冲突，这里的字符串哈希是假定我们人品够好，<strong>不去考虑冲突的情况</strong>，当然也有经验值：$P=131或13331$，$Q=2^{64}$时，$99.99\%$不会遇到冲突。</p><p>这样做的好处：<strong>可以利用前缀哈希，计算出任意一个子段的哈希值</strong>。</p><p>如已知从1到R的哈希值<code>h[R]</code>，从1到L-1的哈希值<code>h[L-1]</code>，由于左边时高位，右边是低位。先将<code>h[L-1]</code>这一段往左移若干位，让它和<code>h[R]</code>这一段右端点对齐（就是让哈希值位数相等，相当于在<code>h[L]</code>后面补0啦），然后两段哈希值相减，用公式表示就是：</p><script type="math/tex; mode=display">h[R]-h[L-1] \times P^{R-L+1}</script><p>还有一个技巧是：我们最后要模$2^{64}$，那直接可以用<code>unsinged long long</code>来存哈希值<code>h[]</code>，若溢出就等价于模$2^{64}$。</p><p>字符串哈希相较于kmp的独特作用：<strong>快速判断两个区间内的字符串是否相同</strong>。</p><blockquote><p>字符串哈希例题（Acwing 841）</p><p>给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数$l_1,r_1,l_2,r_2$，请你判断$[l_1,r_1]$和$[l_2,r_2]$这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。</p><p>输入格式：第一行包含整数n和m，表示字符串长度和询问次数。第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。接下来m行，每行包含四个整数$l_1,r_1,l_2,r_2$，表示一次询问所涉及的两个区间。注意，字符串的位置从1开始编号。</p><p>输出格式：对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。每个结果占一行。</p><p>数据范围：$1 \le n,m \le 10^5$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];  <span class="comment">//h[N]存字符串的哈希值，p[N]存p的几次方</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l <span class="number">-1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)     <span class="comment">//预处理p[]，即p的几次方；以及h[]，即字符串的前缀哈希值</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p><strong>vector</strong>：<strong>可变数组</strong>，采用倍增的思想——在数组扩展空间使，将其原来的空间再扩大一倍，对空间为n的大小只需扩展$\log (n)$次即可，对每一次的扩展只用$O(1)$来实现。（系统为某一程序分配空间时，所需时间与空间大小无关，与请求次数有关）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个vector</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个vector，指定长度为100，先初始化为1</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求变长数组a的长度，时间复杂度为O(1)；所有容器都有</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断变长数组a是否为空，时间复杂度为O(1)；所有容器都有</span></span><br><span class="line">a.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空变长数组a；.clear()并不是所有容器都有，如队列，就没有.clear( )</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向变长数组a的末尾压入数x</span></span><br><span class="line">a.push_back(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将变长数组a的末尾元素删除</span></span><br><span class="line">a.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取变长数组a的第一个元素和最后一个元素</span></span><br><span class="line">a.front(), a.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取迭代器第一个元素和最后一个元素(指针)</span></span><br><span class="line">a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//三种遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"><span class="comment">//vector &lt;int&gt; :: iterator i;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); ++i) <span class="built_in">cout</span> &lt;&lt; *i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) <span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector是支持比较运算的，按字典序比较</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">4</span>, <span class="number">3</span>), b(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)  <span class="built_in">puts</span>(<span class="string">"a &lt; b"</span>);    <span class="comment">//输出 a &lt; b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二元组：pair &lt;int, int&gt;、pair &lt;int, string&gt;、pair &lt;int, char&gt;等</span></span><br><span class="line"><span class="comment">//在进行排序时先以first的字典序进行排列，后以second的字典序进行排列</span></span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII a;       </span><br><span class="line"><span class="built_in">vector</span> &lt;PII&gt; a;  <span class="comment">//与vector操作类似，但push_back(&#123;x, c&#125;)，注意&#123;&#125;</span></span><br><span class="line"><span class="comment">//向a中添加一个元素</span></span><br><span class="line">a = maek_pair(x, y);</span><br><span class="line">a = &#123;x, y&#125;;</span><br><span class="line"><span class="comment">//取出a中的第一、二个元素</span></span><br><span class="line">a.first, a.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设某个东西有两种不同的属性，这时就可以用pair存；若要按某种属性进行排序，就把这个属性存入pair中的first。</span></span><br></pre></td></tr></table></figure><p><strong>string</strong>： C++封装好的<strong>字符串</strong>，可支持多种操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求字符串的长度</span></span><br><span class="line">s.<span class="built_in">size</span>(), s.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串是否为NULL</span></span><br><span class="line">s.empty();</span><br><span class="line"><span class="comment">//将字符串置为空字符串</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可在字符串末尾添加字符或字符串</span></span><br><span class="line">s += <span class="string">'A'</span>;</span><br><span class="line">s += 'ABCD';</span><br><span class="line"></span><br><span class="line"><span class="comment">//取子串substr(下x, y)(重点)，取下标从x开始的长度为y的子串。</span></span><br><span class="line">s.substr(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回字符串的的首地址</span></span><br><span class="line">s.C_str();</span><br></pre></td></tr></table></figure><p><strong>queue：队列</strong>，先进先出，通常用于广度优先（bfs）等算法，可支持插入队尾，弹出队头等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队尾插入元素x</span></span><br><span class="line">q.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将队头元素弹出</span></span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line">q.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取队头、队尾元素</span></span><br><span class="line">q.front(), q.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是不能使用clear()，若要清空，可以直接建一个新的队列</span></span><br><span class="line">q = <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; ();</span><br></pre></td></tr></table></figure><p><strong>priority_queue：优先队列</strong>（实现原理是堆），队列中的元素按照某种顺序规则排序，<strong>默认是大根堆</strong>，A*算法等是需要用到的。</p><blockquote><p>堆(Heap)分为小根堆和大根堆两种，对于一个小根堆，它是具有如下特性的一棵完全二叉树：<br>    (1)若树根结点存在左孩子，则根结点的值(或某个域的值)小于等于左孩子结点的值(或某个域的值)； </p><p>​     (2)若树根结点存在右孩子，则根结点的值(或某个域的值)小于等于右孩子结点的值(或某个域的值)； </p><p>​     (3)以左、右孩子为根的子树又各是一个堆。 </p><p>大根堆的定义与上述类似，只要把小于等于改为大于等于就得到了。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义成小根堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,  greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向堆中插入一个元素x</span></span><br><span class="line">q.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回堆顶元素</span></span><br><span class="line">q.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出堆顶元素</span></span><br><span class="line">q.pop();</span><br></pre></td></tr></table></figure><p><strong>stack：栈</strong>，与队列类似，区别是先进后出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈顶插入一个元素</span></span><br><span class="line">stk.push(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出栈顶元素</span></span><br><span class="line">stk.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">stk.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line">stk.empty();</span><br></pre></td></tr></table></figure><p><strong>deque：双端队列</strong>，既可以对队头操作，与可以对队尾操作，但是时间复杂度相对较高；双端队列可支持的操作较多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取双端队列大小</span></span><br><span class="line">q.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双端队列是否为NULL</span></span><br><span class="line">q.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空双端队列，无需按q = deque &lt;int&gt; ()重新赋值</span></span><br><span class="line">q.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第一个元素(队头)、最后一个元素(队尾)</span></span><br><span class="line">q.front(), q.back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//队尾插入、弹出一个元素</span></span><br><span class="line">q.push_back(x), q.pop_back();</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头插入、弹出一个元素</span></span><br><span class="line">q.push_front(x), q.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可使用随机寻址 []</span></span><br><span class="line"><span class="comment">//也支持迭代器q.begin()、q.end()</span></span><br></pre></td></tr></table></figure><p><strong>set/multiset，map/multimap，是基于平衡二叉树（红黑树），动态维护有序序列</strong>。</p><p><strong>set/multiset：集合</strong>，集合中的元素是从小至大排好序的。<strong>set里面所有的元素都不可重复</strong>（集合的互异性），自动去重的功能。<strong>multiset里面所有的元素可以重复</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持迭代器，也支持--(前驱)、++(后继)操作，时间复杂度为O(logn)</span></span><br><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; iterator :: it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素x，时间复杂度为O(1)</span></span><br><span class="line">s.insert(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素x，若输入是一个数，就删除所有x，时间复杂度为O(k+logn)；若输入一个迭代器，就删除这个迭代器</span></span><br><span class="line">s.erase(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回集合元素的个数</span></span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回某一个元素的个数</span></span><br><span class="line">s.count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br><span class="line">s.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素x是否在集合中出现，如果不出现则返回s.end()，否则返回对应的迭代器</span></span><br><span class="line">s.<span class="built_in">find</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作: 返回大于等于x的第一个元素（大于等于x的最下的数）的迭代器</span></span><br><span class="line">lower_bound(x);</span><br><span class="line"><span class="comment">//返回大于x的第一个元素的迭代器</span></span><br><span class="line">upper_bound(x);</span><br></pre></td></tr></table></figure><p><strong>map/multimap</strong>： STL的一个<strong>关联容器</strong>，它<strong>提供一对一的hash</strong>。map/multimap 在插入元素时，内部按照key进行从小到大进行排序。核心为映射key - value，支持随机访问[]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">multiimap &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ms;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">p = make_pair(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入的数是一个pair</span></span><br><span class="line">m.insert(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除，输入的参数是pair或者迭代器</span></span><br><span class="line">m.erase(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">m.<span class="built_in">find</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以完全像数组一样来使用map，时间复杂度为O(logn)</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; a;</span><br><span class="line">a[<span class="string">"yxc"</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也支持lower_bound()，upper_bound()</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set，unordered_map，unordered_multiset，unordered_multimap</strong>，哈希表。和上面类似，可以理解为无序版，增删改查的时间复杂度为$O(1)$。但不支持<code>lower_bound()</code>，<code>upper_bound()</code>，迭代器的<code>++</code>，<code>--</code>。</p><p><strong>bitset：压位</strong></p><p>C++中的<code>bool</code>数据类型是占一个字节，如要开一个1024个<code>bool</code>的数组，就要$1024 B=1KB$的空间，bitset可以在一个字节压8位，则就只要$128B$的空间。<strong>bitset</strong>使用的内存是正常的bool数组的八分之一。</p><p>如要存一个10000<em>10000的<code>bool</code>矩阵，那就需要$10^8 B = 100 MB$的空间，若题目限制空间为$64MB$，则可以使用<em>*bitset</em></em>进行压位，就只需12MB的空间了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;10000&gt; s;</span><br><span class="line"><span class="comment">//支持各种位运算操作 </span></span><br><span class="line">~, &amp;, |, ^, </span><br><span class="line">&gt;&gt; , &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line">    </span><br><span class="line">s.count();  <span class="comment">//返回有多少个1</span></span><br><span class="line">s.any();   <span class="comment">//判断是否至少有一个1</span></span><br><span class="line">s.none();  <span class="comment">//判断是否全为0</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">set</span>();       <span class="comment">//把所有位置成1</span></span><br><span class="line">s.<span class="built_in">set</span>(k, v);   <span class="comment">//把第k位变成v</span></span><br><span class="line">s.reset();     <span class="comment">//把所有位置变成0</span></span><br><span class="line">s.flip();      <span class="comment">//等价于~</span></span><br><span class="line">s.flip(k);     <span class="comment">//把第k位取反</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      哈希表，STL
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（5）</title>
    <link href="http://nekomoon404.github.io/2020/10/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/07/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%885%EF%BC%89/</id>
    <published>2020-10-07T12:31:03.000Z</published>
    <updated>2020-10-09T09:20:35.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p><strong>Trie树是用来快速存储和查找字符串集合的数据结构。</strong></p><blockquote><p>Trie树的基础知识可以参考：</p><p>Trie树例题：Trie字符串统计（Acwing 835）</p><p>维护一个字符串集合，支持两种操作：</p><ol><li><p>“I x”向集合中插入一个字符串x；</p></li><li><p>“Q x”询问一个字符串在集合中出现了多少次。</p></li></ol><p>共有N个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。</p><p>输入格式：第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。</p><p>输出格式：对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。</p><p>数据范围：$1 \le N \le 2 \times 10^4$。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007210654.png" style="zoom: 67%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//son[N][26]存Trie树中每个节点的儿子</span></span><br><span class="line"><span class="comment">//cnt[]表示以当前节点为结尾的单词的个数</span></span><br><span class="line"><span class="comment">//idx表示当前用到的下标，注意：下标是0的点，即是根节点，又是空节点</span></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span>  <span class="comment">//插入操作：在当前的Trie树中插入一个字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span>   <span class="comment">//返回字符串出现的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)  insert(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Trie树例题2：最大异或对</p><p>在给定的N个整数$A_1，A_2……A_N$中选出两个进行xor（异或）运算，得到的结果最大是多少？</p><p>输入格式：第一行输入一个整数N。第二行输入N个整数$A_1$～$A_N$。</p><p>输出格式：输出一个整数表示答案。</p><p>数据范围：$1 \le N \le 10^5$，$0 \le A_i  \le 2^31$。</p></blockquote><p>异或运算是按位运算（二进制），相同得0，不同得1。同样先考虑暴力做法，可以用两重循环来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//枚举第一个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)   <span class="comment">//枚举第二个数</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, a[i] ^ a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑用Trie树来优化内层循环，即从$a_0$到$  a_{i-1}$中找到与$a_i$异或最大的数。本题的数据范围是$0 \le a_i \le 2^31$，因此每个数可以看出一个31位的二进制串，假设$a_i=101110…1$，要找到与$a_i$异或最大的数，就要异或结果高位是1比较好，因此按$a_i$的位数从左往右找，在$a_0$到$  a_{i-1}$中，先找第30位是0的数，再从这部分数中找第29位是1的数，依次类推。在Trie树中，对于每个$a_i$，先查找再插入。</p><blockquote><p>Trie树 不光可以存储字符串，也可以存储整数，也可以存储二进制数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">//在Trie树中插入一个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//从最高位开始存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;    <span class="comment">//取二进制的每一位数</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//在当前的树中找出与x异或结果最大的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])          <span class="comment">//优先寻找是否有与当前位数相反的子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + !u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> + u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        insert(a[i]);         <span class="comment">//这里先插入再查找是为了避免处理边界问题，少写判断，即一开始树是空的</span></span><br><span class="line">        <span class="keyword">int</span> t = query(a[i]);</span><br><span class="line">        res = <span class="built_in">max</span>(res, a[i] ^ t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的作用：</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p>并查集可以在近乎$O(1)$的时间内完成这两个操作。</p><p>基本思想：每一个集合用一棵树（不一定是二叉树）来维护，树根的编号就是整个集合的编号，对于每一点都存储其父节点是谁，<code>p[x]</code>表示<code>x</code>的父节点。</p><p>问题1：如何判断树根： <code>if(p[x] == x)</code></p><p>问题2：如何求x的集合编号：<code>while(p[x] != x)  x = p[x];</code></p><p>问题3：如何合并两个集合：设p[x]是x的集合编号，p[y]是y的集合编号，<code>p[x]=y</code></p><p>针对问题2的优化：<strong>路径压缩</strong>。一旦从一个点往上找找到了根节点，就把这条路径上所有的点都指向根节点。</p><blockquote><p>并查集例题1（Acwing 836）：</p><p>一共有n个数，编号是1~n，最开始每个数各自在一个集合中。</p><p>现在要进行m个操作，操作共有两种：</p><ol><li>“M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作</li><li>“Q a b”，询问编号为a和b的两个数是否在同一个集合中；</li></ol><p>输入格式：第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。</p><p>数据范围：$1 \le n, m \le 10^5$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//返回x的祖宗节点 + 路劲压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)  p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  p[i] = i;  <span class="comment">//最开始每个数各自在一个集合中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];  </span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>)  p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);  <span class="comment">//将数a和b所在的两个集合合并，即让find(a)的父节点是find(b)</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);   <span class="comment">//询问数a和b是否在同一个集合内，即find(a)是否等于find(b)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集例题2：连通块中点的数量（Acwing 837）</p><p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。现在要进行m个操作，操作共有三种：</p><ol><li>“C a b”，在点a和点b之间连一条边，a和b可能相等；</li><li>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；</li><li>“Q2 a”，询问点a所在连通块中点的数量。</li></ol><p>输入格式：第一行输入整数n和m。接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p><p>数据范围：$1 \le n, m \le 10^5$</p></blockquote><p>可以发现这道题的前两个操作和并查集是一样的，我们可以用一个集合维护连通块，一个连通块中的点就在一个集合当中。当在两个连通块之间连一条边时，起到的作用就是把两个集合合并。额外的操作是统计一个集合中点的数量。</p><p>用cnt[N]表示每个集合中点的数量，我们只保证根节点的cnt[]是有意义的。将数a和b所在的两个集合合并时，即让find(a)的父节点是find(b)，然后让find(b)的cnt等于find(a)的cnt加上find(b)的cnt。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], cnt[N];  <span class="comment">//size[]存放每个集合中点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//返回x的祖宗节点 + 路劲压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)  p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">//最开始每个数各自在一个集合中</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i; </span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">4</span>];  </span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="keyword">continue</span>;   <span class="comment">//如果a和b在同一个集合中，那么就忽略这次合并操作</span></span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];  <span class="comment">//合并集合时，更新集合中点的数量，即find(b)的size[]</span></span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);  <span class="comment">//将数a和b所在的两个集合合并，即让find(a)的父节点是find(b)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="built_in">puts</span>(<span class="string">"Yes"</span>);   <span class="comment">//询问数a和b是否在同一个集合内，即find(a)是否等于find(b)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[<span class="built_in">find</span>(a)]);  <span class="comment">//询问a所在的集合中点的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集例题3：食物链（Acwing 240）</p><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：</p><p>第一种说法是”1 X Y”，表示X和Y是同类。</p><p>第二种说法是”2 X Y”，表示X吃Y。</p><p>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><p>1） 当前的话与前面的某些真的话冲突，就是假话；</p><p>2） 当前的话中X或Y比N大，就是假话；</p><p>3） 当前的话表示X吃X，就是假话。</p><p>你的任务是根据给定的N和K句话，输出假话的总数。</p><p>输入格式：第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。</p><p>输出格式：只有一个整数，表示假话的数目。</p><p>数据范围：$1 \le N \le 50000, 0 \le K \le100000$。</p></blockquote><p>通过确定每个点与根节点之间的关系，来确定任意两个点之间的关系。由于三种动物的关系是循环被吃，就用每个点到根节点之间的距离来表示它与根节点之间的关系。如果一个点到根节点的距离是1，表示它可以吃根节点；如果一个点到根节点的距离是2，表示它被根节点吃（<strong>1吃根，2吃1，根吃2</strong>）；如果一个点到根节点的距离是3，表示它和根节点是同类…….如此类推，每3个 一循环。因此可以把集合中所有的点归为三类，<strong>用并查集维护每个点到根节点的距离</strong>，按<strong>点到根节点的距离对3取模</strong>：</p><ul><li>余1——可以吃根节点；</li><li>余2——可以被根节点吃；</li><li>余0——与根节点是同类。</li></ul><p>在用并查集维护时，每个点存的是其到父节点的距离，做路径压缩时，就更新为其到根节点的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  p[i] = i;  <span class="comment">//有n个动物，以1-N编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)  res ++;   <span class="comment">//如果x大于n，或者y大于n，则一定是假话；</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);   <span class="comment">//先找到x和y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>)  res ++;   <span class="comment">//当x 和 y 在同一个集合内时，x，y到根节点的距离模3不相等时一定是假话</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)    <span class="comment">//当x 和 y不在同一个集合内时，就要合并,q且要让两者是同类（这时还没法判断，因为不在一个集合内）</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;  <span class="comment">//不妨让x的根节点的父节点 等于 y的根节点的父节点</span></span><br><span class="line">                    d[px] = d[y] - d[x];  <span class="comment">//这样(d[x] + d[px] - d[y]) % 3就等于0了，即x和y是同类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>)  res ++; <span class="comment">//当x和y在同一个集合内时，x到根节点距离模3比y的多1就是真话，否则就是假话</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)   <span class="comment">//当x和y不在同一个集合内时，合并集合，更新距离</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆，要支持的操作：</p><ol><li>插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li><li>删除任意一个元素</li><li>修改任意一个元素</li></ol><p>堆是一棵完全二叉树。小根堆：每个点的值都小于等于左右儿子的。</p><blockquote><p>堆的基础知识可以参考：数据结构与算法（19）优先级队列</p><p>完全二叉树的基础知识可以参考：</p></blockquote><p><strong>用数组模拟堆</strong>，堆的存储方式：用一个一维数组，1号点是根节点（下标从1开始），节点x的左儿子是2x，右儿子是2x+1。有<strong>两个基本操作</strong>：<code>down(x)</code>，把一个节点往下移，如果把一个节点的值变大了，它有可能就要往下移；<code>up(x)</code>，把一个节点往上移，如果把一个数变小了，它有可能就要往上移 。用这两个基本操作就可以实现上面的五个操作：</p><ol><li>插入一个数：<code>heap[++ size] = x; up[x];</code></li><li>求集合当中的最小值：<code>heap[1];</code></li><li>删除最小值：（用堆的最后一个元素覆盖掉堆顶元素）<code>heap[1] = heap[size]; size--; down(1);</code></li><li>删除任意一个元素：<code>heap[k] = heap[size]; size --; down(k); up(k);</code>（每次donw和up只会执行一个）</li><li>修改任意一个元素：<code>heap[k] = x; down(k); up(x);</code></li></ol><blockquote><p>堆例题1：堆排序（Acwing  838）</p><p>输入一个长度为n的整数数列，从小到大输出前m小的数。</p><p>输入格式：第一行包含整数n和m。第二行包含n个整数，表示整数数列。</p><p>输出格式：共一行，包含m个整数，表示整数数列中前m小的数。</p><p>数据范围：$1 \le m, n \le 10^5$，$1 \le 数列中元素 \le 10^9$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;  <span class="comment">//t表示当前节点u，它的左右孩子，三者之间的最小值的下标</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])  t = u * <span class="number">2</span>;    <span class="comment">//t和左孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])  t = u * <span class="number">2</span> + <span class="number">1</span>;   <span class="comment">//t和右孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)   <span class="comment">//当前节点不是最小值时，down操作要求它与左右孩子中的最小值交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u], h[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);   <span class="comment">//下标从1开始</span></span><br><span class="line">    cnt = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建堆，后n / 2 个元素是在最低层的，它们没有左右孩子，保持不动就行；让i = n / 2开始倒着进行down操作即可建堆</span></span><br><span class="line">    <span class="comment">//从 i = n / 2 开始，是保证每次down的时候，下面的孩子节点已经是堆了；这样建堆的时间复杂度是O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span>; i ; i--)  down(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, h[<span class="number">1</span>]);   <span class="comment">//取堆顶元素，即堆中的最小值</span></span><br><span class="line">        <span class="comment">//删除堆顶元素</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆例题2：模拟堆（Acwing 839）</p><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><p>“I x”，插入一个数x；</p></li><li><p>“PM”，输出当前集合中的最小值；</p></li><li><p>“DM”，删除当前集合中的最小值（数据保证此时的最小值唯一）；</p></li><li><p>“D k”，删除第k个插入的数；</p></li><li><p>“C k x”，修改第k个插入的数，将其变为x；</p></li></ol><p>输入格式：第一行包含整数N。接下来N行，每行包含一个操作指令，操作指令为”I x”，”PM”，”DM”，”D k”或”C k x”中的一种。</p><p>输出格式：对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。每个结果占一行。</p><p>数据范围：$1 \le N \le 10^5$，$-10^9 \le x \le 10^9$</p></blockquote><p>这道题的难点在于操作4和5，怎么快速地找到第k个插入的数。这就需要额外维护两个数组，用ph[k]存第k个插入的点在堆中的位置(下标)，hp[k]表示堆中的位置为k的点是第几个插入的点；如ph[j] = k, hp[k] = j; 可以理解为映射。这样例题1代码中普通的<code>swap()</code>操作就要改成这里的堆的特有的交换操作<code>heap_swap()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], cnt;  </span><br><span class="line"><span class="keyword">int</span> ph[N], hp[N]; </span><br><span class="line"><span class="comment">//ph[k]存第k个插入的点在堆中的位置(下标)，hp[k]表示堆中的位置为k的点是第几个插入的点；如ph[j] = k, hp[k] = j; 可以理解为映射</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>  <span class="comment">//a，b是数在堆中的位置，这个需要注意一下</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]], ph[hp[b]]);   </span><br><span class="line">    swap(hp[a], hp[b]);</span><br><span class="line">    swap(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;  <span class="comment">//t表示当前节点u，它的左右孩子，三者之间的最小值的下标</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])  t = u * <span class="number">2</span>;    <span class="comment">//t和左孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])  t = u * <span class="number">2</span> + <span class="number">1</span>;   <span class="comment">//t和右孩子比较</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)   <span class="comment">//当前节点不是最小值时，down操作要求它与左右孩子中的最小值交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u, t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        heap_swap(u / <span class="number">2</span>, u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;  <span class="comment">//m记录插入了多少个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"I"</span>))  <span class="comment">//插入一个数x</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            up(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"PM"</span>)) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h[<span class="number">1</span>]);  <span class="comment">//输出集合中最小的数，即堆顶</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"DM"</span>))  <span class="comment">//删除集合中最小的数，即堆顶</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">"D"</span>))   <span class="comment">//删除插入的第k个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            heap_swap(k, cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            down(k);  up(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//修改第k个插入的数，将其变为x</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            down(k);  up(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Trie树，并查集，堆。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（4）</title>
    <link href="http://nekomoon404.github.io/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/</id>
    <published>2020-10-05T10:30:14.000Z</published>
    <updated>2020-10-07T12:28:52.689Z</updated>
    
    <content type="html"><![CDATA[<p>第二章 数据结构</p><ul><li>链表</li><li>栈与队列</li><li>kmp</li></ul><p>这节课主要讲如何<strong>用数组模拟链表，栈与队列</strong>。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>我们知道链表可以通过结构体+指针来实现，但每次创建一个新节点就要通过<code>new Node;</code> 来实现，这一过程是很慢的，在做笔试题时一般不会采用这样的动态链表的方式，常用的是用数组来模拟链表，又分为两种：</p><ul><li>单链表，其中在算法题中用的最多的是邻接表，它最主要的应用是存储图和树</li><li>双链表，主要作用是优化某些问题</li></ul><blockquote><p>关于链表的基础知识可以参考之前写的 Cpp基础（6）结构体与链表</p></blockquote><p>数组模拟<strong>单链表</strong>：用两个数组<code>e[N]</code>和<code>ne[N]</code>，它们通过下标关联起来，下标从0开始，<code>e[i]</code>用来存放第<code>i</code>个节点的值，<code>ne[i]</code>用来存放第<code>i</code>个节点指向的next节点的下标，空节点的下标用-1来表示。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110923.png" style="zoom: 67%;"></p><ul><li><p>单链表例题（Acwing 826）：</p><p>实现一个单链表，链表初始为空，支持三种操作：</p><p>(1) 向链表头插入一个数；</p><p>(2) 删除第k个插入的数后面的数；</p><p>(3) 在第k个插入的数后插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。</p><p>注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头节点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">//ne[i] 表示节点i的next指针是多少（指向的下一个节点的下标）</span></span><br><span class="line"><span class="comment">//idx 表示当前已经用到了哪个点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标是k的点的后面（下标是k表示第k+1个插入链表中的数，与其位置无关）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点从链表中删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( m-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">'H'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add_to_head(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'D'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k)  head = ne[head];  <span class="comment">//若要删除的节点是头节点</span></span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);   <span class="comment">//下标从0开始，第k个插入的数下标是k-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])  <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双链表</strong>的每个节点有两个指针，一个指向前面的点 ，一个指向后面的点，用数组<code>l[]</code>存放节点左边的点的下标，用数组<code>r[]</code>存放节点右边的点的下标。这里我们偷个懒，让下标是0的点是head，让下标是1的点是tail。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110934.jpg" style="zoom: 40%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201006110939.jpg" style="zoom:42%;"></p><ul><li><p>双链表例题（Acwing 827）</p><p>实现一个双链表，双链表初始为空，支持5种操作：</p><p>(1) 在最左侧插入一个数；</p><p>(2) 在最右侧插入一个数；</p><p>(3) 将第k个插入的数删除；</p><p>(4) 在第k个插入的数左侧插入一个数；</p><p>(5) 在第k个插入的数右侧插入一个数</p><p>现在要对该链表进行M次操作，进行完所有操作后，从左到右输出整个链表。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0表示head， 1表示tail</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;   <span class="comment">//第k的插入的数下标就是k + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标是k的点的右边插入x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx ++;  <span class="comment">//注意这里的顺序不能变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除下标是k的节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"L"</span>)   <span class="comment">//注意这里要用双引号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"R"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            add(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"D"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"IL"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            add(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i])  <span class="built_in">cout</span> &lt;&lt; e[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><ul><li><p><strong>栈：先进后出</strong></p></li><li><p><strong>队列：先进先出</strong></p></li></ul><blockquote><p>栈与队列的基础知识可以参考之前写的 数据结构与算法（7）栈与队列</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//****************栈</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt --;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt &gt; <span class="number">0</span>)  <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh ++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt)  <span class="keyword">not</span> empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然用数组模拟的队列还可以取队尾元素 q[tt];</span></span><br></pre></td></tr></table></figure><ul><li><p>数组模拟栈例题（Acwing 828）</p><p>实现一个栈，栈初始为空，支持四种操作：</p><p>(1) “push x” – 向栈顶插入一个数x；</p><p>(2) “pop” – 从栈顶弹出一个数；</p><p>(3) “empty” – 判断栈是否为空；</p><p>(4) “query” – 查询栈顶元素。</p><p>现在要对栈进行M个操作，其中的每个操作3和操作4都要输出相应的结果。数据范围：$1 \le M \le 100000$，$1 \le x \le 10^9$。所有操作保证合法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"push"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            stk[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"pop"</span>)  tt --;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"empty"</span>)  <span class="built_in">cout</span> &lt;&lt; (tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>数组模拟队列例题（ACwing 829）</p><p>实现一个队列，队列初始为空，支持四种操作：</p><p>(1) “push x” – 向队尾插入一个数x；</p><p>(2) “pop” – 从队头弹出一个数；</p><p>(3) “empty” – 判断队列是否为空；</p><p>(4) “query” – 查询队头元素。</p><p>现在要对队列进行M个操作，其中的每个操作3和操作4都要输出相应的结果。数据范围：$1 \le M \le 100000$，$1 \le x \le 10^9$。所有操作保证合法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"push"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            q[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"pop"</span>)  hh ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">"empty"</span>)  <span class="built_in">cout</span> &lt;&lt; (hh &lt;= tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; q[hh] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h3><p><strong>单调栈</strong>的常见题型：给定一个序列，求序列中每一个数左边离它最近的且比它小的数是多少。</p><ul><li>例题：给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。</li></ul><blockquote><p>保证栈中的数是单调递增的，遍历数列中的数，对于数列中第i个数，若栈非空且栈顶元素大于等于它，就弹出栈顶，直到栈顶比它小，则栈顶即为所求；若栈空，说明不存所求。之后再把第i个数存入栈顶。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;  <span class="comment">//输入数据比较多时还是用scanf比较快</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x)  tt --;</span><br><span class="line">        <span class="keyword">if</span>(tt)  <span class="built_in">cout</span> &lt;&lt; stk[tt] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        </span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每个元素，最多只会进栈一次出栈一次，因此时间复杂度为$O(n)$。</p></blockquote><p>单调队列的常见题型：求滑动窗口中的最大值/最小值</p><ul><li>例题：滑动窗口（Acwing 154）</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007100602.png" style="zoom: 80%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201007103030.png" style="zoom:33%;"></p><blockquote><p>遍历序列中的元素，i表示滑动窗口右端点元素的下标，用一个单调队列来维护当前的滑动窗口，保证队列中的元素是单调递增的，即每插入一个新元素，便判断队尾是否大于等于它，若是就弹出队尾，再把新元素插入队尾，这样每次求滑动窗口中的最小值只需取出队头即可。求滑动窗口中的最大值同理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], q[N];  <span class="comment">//单调队列q[N]，存放下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求滑动窗口中的最小值</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;  <span class="comment">//队头和队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经弹出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])  hh++;  <span class="comment">//每次只会出现一次，因此可以用if</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])  tt--;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求滑动窗口中的最大值</span></span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;  <span class="comment">//队头和队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经弹出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])  hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i])  tt--;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用单调栈或者单调队列解题的思路都是：先用暴力做法求解，再考虑暴力做法的栈或队列中哪些元素是没有用的，删掉这些没用的元素，再看剩下的元素有没有单调性，如果有就可以考虑用栈或队列做优化。</p></blockquote><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>给定一个模式串S（长度为M），以及一个模板串P（长度为N），所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串P在模式串S中多次作为子串出现。求出模板串P在模式串S中所有出现的位置的起始下标。</p><p>数据范围：$1 \le N \le 10^5$，$1 \le M \le 10^6$。</p><blockquote><p>KMP算法的知识可以参考之前写的 数据结构与算法（20）串——3.KMP算法</p></blockquote><p>对于模板串要处理出一个：它的一个以第i个元素为右端点的后缀和一个前缀相等，相等的最大长度是多少。如<code>next[i]=j</code>，则说明<code>p[1,j]=p[i-j+1]</code>。</p><p><img src="/2020/10/05/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%884%EF%BC%89/QQ图片20201007200936.png" style="zoom:80%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> p[N], s[M];</span><br><span class="line"><span class="keyword">int</span> ne[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求模板串P的next[]数组的过程，相当于是把P也当成模式 串，两个P进行kmp匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)  <span class="comment">//每次是s[i]和p[j+1]匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//匹配成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - n);  <span class="comment">//输出模板串P在模式串S中出现的位置的起始下标</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      第二章内容：链表，栈与队列，KMP。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（3）</title>
    <link href="http://nekomoon404.github.io/2020/10/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/10/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%883%EF%BC%89/</id>
    <published>2020-10-02T07:21:03.000Z</published>
    <updated>2020-10-03T15:29:59.894Z</updated>
    
    <content type="html"><![CDATA[<p>第一章 基础算法</p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>算法6：双指针，通常有两种情况：</p><ul><li><p>两个指针分别指向两个序列，如归并排序</p></li><li><p>两个指针指向同一个序列，可以是一个在首一个在尾，两个指针共同维护一段区间，如快速排序</p></li></ul><p>代码结构一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; check(i, j))  <span class="comment">//i和j满足某种性质</span></span><br><span class="line">        j++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面就是每道题目的具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个指针在所有循环中总共移动的次数不超过$n$，双指针算法就是将朴素的两层for遍历（时间复杂度为$O(n^2)$）优化到$O(n)$。</p><p>解题的思路一般是：从朴素做法入手，从中发现一些问题的性质，如<strong>单调性</strong>等，将原来的$O(n^2)$时间复杂度优化到$O(n)$。</p><p>双指针的几个例子：</p><ol><li>读入一行字符串，其中有若干个单词，每个单词中间有一个空格隔开，要求输出每一个单词。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    gets(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; str[j] != <span class="string">' '</span>)  j++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这道题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; j; k++)  <span class="built_in">cout</span> &lt;&lt; str[k];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最长连续不重复子序列：给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</li></ol><blockquote><p><code>i</code>表示一段区间的右边界，<code>j</code>表示这段区间的左边界。遍历<code>i</code>，找到这段区间最左能到多远，即<code>j</code>的位置，当<code>i</code>向右移时，<code>j</code>一定是向右移或者是不动，一定不会向左移，即是这个问题的单调性，<code>i</code>和<code>j</code>在循环走过的长度都不会超过n，因此时间复杂度是$O(n)$。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];  <span class="comment">//s[]用来存放区间内每个数字出现的次数</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span>(s[a[i]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] --;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组元素的目标和：给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。<br>请你求出满足A[i] + B[j] = x的数对(i, j)。数据保证有唯一解。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i] + b[j] &gt; x)  j--;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>算法7：位运算</p><p>算法题中位运算的常用操作：</p><ul><li><p>求一个整数$n$的二进制表示中第$k$位数字是几，如$n=15=(1111)_2$，个位是第0位开始算。</p><ol><li>先把第$k$位移到最后一位，<code>n &gt;&gt; k</code>；</li><li>看个位数字是几，<code>n &amp; 1</code>；两步合并就是：<code>n &gt;&gt; k &amp; 1</code></li></ol></li><li><p><code>lowbit(x)</code>操作：返回<code>x</code>的最后一位1，如<code>x = 1010，lowbit(x) = 10</code>；<code>x = 101000，lowbit(x)=1000</code></p><ul><li><code>lowbit(x)</code>的实现：<code>x &amp; -x</code>，相当于是<code>x &amp; (~x + 1)</code>。（<code>~</code>表示取反）</li><li><code>lowbit(x)</code>的应用：统计<code>x</code>中1的个数。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)  x -= lowbit(x), res++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>算法8：离散化</p><p>这里特指<strong>整数的离散化</strong>，它所针对的问题是：假设有一个数组，其元素个数很少，但元素的值域很大，如<code>a[5]={1, 3, 100, 2000, 500000}</code>，我们又需要以这些元素为下标进行一些其他的操作。再开一个500000长度的数组显然是不明智的，因此就需要离散化，将这些值域很大的数字映射到从0开始的连续的自然数。要进行离散化需要考虑两个问题：</p><ol><li><code>a[]</code>中可能有重复元素 $\to$ 去重；</li><li>如何快速地算出<code>a[i]</code>离散化后的值 $\to$ <code>a[]</code>是有序的，即找到数字的下标即可 $\to$ 二分</li></ol><p>代码模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;  <span class="comment">//存储所有待离散化的值</span></span><br><span class="line">sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());  <span class="comment">//将所有值排序</span></span><br><span class="line">alls.eras(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());  <span class="comment">//去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>   <span class="comment">//找到第一个大于等于x的数的下标 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">//映射到1,2,3,...；若要映射到0, 1, 2, 3, ....就return r;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p><p>数据范围：$-10^9 \le x \le 10^9$，$1\le n, m \le 10^5$，$-10^9 \le l \le r \le 10^9$，$-10000 \le c \le 10000$。</p><blockquote><p>可见相比于整个数轴的范围，要取的数是比较稀疏的，但是跨度很大，这些数的下标就可以用离散化的思想来处理。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;  <span class="comment">//n, l, r分别需要10^5，所以需要用到的下标个数就是300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls;  <span class="comment">//alls存放所要用到的数的下标，包括赋予了值的数的下标，以及待计算的区间的左右边界的下标</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query;  <span class="comment">//add存放取出的数的下标和赋予的值，query存放待计算的区间的左右边界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s[N];   <span class="comment">//a[]存放之前赋予过的值，s[]是a[]的前缀和，方便计算区间和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;   <span class="comment">//映射到1, 2, 3, ......方便后续的前缀和操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//读入n行，每行包含两个整数x和c</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x, c&#125;);</span><br><span class="line">        alls.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对alls序列排序和去重</span></span><br><span class="line">    sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将add中存放的下标和值的数对，下标按照alls排序后的顺序，值填入到数组a[]中，方便后续的前缀和计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理前缀和，到这一步就和之前讲过的前缀和一样了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)  s[i] += s[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理待计算的区间的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以自己实现unique函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span>(!i || a[i] != a[i<span class="number">-1</span>])</span><br><span class="line">            a[j++] = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a[0]~a[j-1]中就存好了a[]中所有不重复的数字</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>算法9：区间合并</p><p> 若两个区间有交集，那就可以把它们合并到一个较长的区间，可以扩展到多个区间。</p><p>例子：给定$n$个区间$[l_i,r_i]$，要求合并所有有交集的区间。<strong>注意如果在端点处相交，也算有交集</strong>。</p><p>输出合并完成后的区间个数。例如：[1,3]和[2,6]可以合并为一个区间[1,6]。</p><p>数据范围：$1\le n \le 100000$，$-10^9 \le l_i \le r_i \le 10^9$。</p><p>解题思路：</p><ol><li>按区间左端点排序；</li><li>扫描整个区间，扫描的过程中把所有有交集的区间合并。每次维护一个当前的区间$[st, ed]$，设已扫描到第$i$个区间$[st_i, ed_i]$，那第$i$个区间和当前的区间的关系有：<ul><li>第$i$个区间在当前的区间的内部；$\to$ 当前区间不变</li><li>第$i$个区间与当前的区间有交集，但不全在其内部；$\to$ 当前区间更新成$[st, ed_i]$</li><li>第$i$个区间与当前的区间没有有交集。$\to$ 当前区间更新成$[st_i, ed_i]$</li></ul></li></ol><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002205419.jpg" style="zoom:40%;"></p><p>（与区间有关的题目的思路大多都是贪心）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;  <span class="comment">//定义一个pair，存放区间的左右端点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    sort(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());   <span class="comment">//sort先按segs.first排序，即先按区间左端点排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;   <span class="comment">//当前维护的区间的左右端点为st, ed</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)      <span class="comment">//第i个区间与当前区间没有交集，则可以把当前区间存入res，然后更新当前区间为第i个区间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>)  res.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);   <span class="comment">//第i个区间与当前区间有交集，那就更新当前区间的右端点为两者右端点的最大值</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.push_back(&#123;st, ed&#125;);  <span class="comment">//加了一个st != -2e9的判断是为了确保开始输入的区间数量不为0，即初始的st已经变化过了</span></span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; segs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge(segs);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      双指针算法，位运算，离散化，区间合并。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（2）</title>
    <link href="http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89/</id>
    <published>2020-09-29T12:27:11.000Z</published>
    <updated>2020-10-03T15:28:54.452Z</updated>
    
    <content type="html"><![CDATA[<p>第一章 基础算法</p><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>算法4：高精度（只有C++需要），一般有四种情况：</p><ol><li>两个大整数相加 A + B，A、B的位数 $\le 10^6$；</li><li>两个大整数相减 A - B，A、B的位数 $\le 10^6$；</li><li>一个大整数乘以一个小整数 A * a，A的位数$\le 10^6$，a$\le 10000$；</li><li>一个大整数除以一个小整数 A / a，A的位数$\le 10^6$，a$\le 10000$；</li></ol><p>首先要考虑的是一个大整数如何存储？方法是可以将其中的每一位保存在一个数组中，为了方便运算，让<code>a[0]</code>存数字的个位，<code>a[1]</code>存数字的十位……依次存高位。如数字以<code>string</code>类型输入<code>a = &quot;123456&quot;</code>，用<code>vector&lt;int&gt;</code>来存储，<code>A=[6,5,4,3,2,1]</code>。</p><p>（1）加法</p><p>两个数组的加法运算就是来模拟人工手算的过程，从个位开始逐位相加，逢十进一。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C = A + B</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())  <span class="keyword">return</span> add(B, A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;   <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t); <span class="comment">//结束后检查下最高位是否需要进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">//a="123456"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = add(A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在空间上做进一步的优化，即进行压位处理，数组中的每一个元素不止存放数字的一位，而是多位。（不常用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % base);</span><br><span class="line">        t /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (a[i] - <span class="string">'0'</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (b[i] - <span class="string">'0'</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; C.back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">"%09d"</span>, C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）减法</p><p>两个数组的减法运算也是来模拟人工手算的过程，从个位开始逐位相减，不够就向前一位借1，加10。</p><p>算法的思路：</p><ul><li>如果A$\ge$B，就计算$A - B$；如果A$&lt;$B，就计算 $-(B - A)$。</li><li>在每一位上，若$A_i-B_i-t \ge 0$，就计算$A_i-B_i-t$；若$A_i-B_i-t &lt; 0$，就计算$A_i-B_i+10-t $，其中$t$代表借位。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有A &gt;= B</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//数组中最后一个元素存放的是数字的最高位，从最高位开始比较</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])  </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C = A - B</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;   <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.push_back( (t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;   <span class="comment">//当前的t小于0，需要借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();   <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;   <span class="comment">//a="123456"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//A=[6,5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cmp(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(A, B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C = sub(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）乘法</p><p>也是模拟手算乘法，区别是：逐位相乘时是乘以整个被乘数b。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200929213523.jpg" style="zoom: 33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mul(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++)   <span class="comment">//注意这里将最高位的进位问题一起处理了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())   t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();  <span class="comment">//当被乘数是0时，要将结果的前导0去掉</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>, C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）除法</p><p>同样的思路，模拟手算的过程，注意区别：除法是从最高位开始除的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; div(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)   <span class="comment">//余数r通过引用传入</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)     <span class="comment">//除法从数字的高位开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除法中C先存的是数字的高位，与定义的先存低位相反，要先翻转一下</span></span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>)  C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  A.push_back(a[i] - <span class="string">'0'</span>);  <span class="comment">//这里一定要记得减去'0'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和，差分"><a href="#前缀和，差分" class="headerlink" title="前缀和，差分"></a>前缀和，差分</h3><p>算法5：前缀和，差分</p><p> 前缀和：设一个数组$a_1,a_2,a_3,\dots,a_n$，（注意下标从1开始），定义其前缀和为$S_i=a_1+a_2+\dots+a_i$，规定$S_0=0$。</p><ul><li>如何求前缀和$S_i$：<code>for</code>遍历即可；</li><li>前缀和的作用：可以方便地求出序列中某一段的和，如求下标区间$[l,r]$内的元素的和，即可用$S_r-S_{l-1}$，时间复杂度为$O(1)$。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];     <span class="comment">//计算前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[r] - s[l - <span class="number">1</span>]);    <span class="comment">//计算区间和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前缀和也可以扩展到二维，求区间和$\to$求子矩阵和。用$S_{ij}$表示左上角的子矩阵的和。如下图若要求以$(x_1,y_1)$为左上角，以$(x_2,y_2)$为右下角的子矩阵的和，那就可以转化成求：</p><script type="math/tex; mode=display">S_{x_2y_2}-S_{x_2y_1-1}-S_{x_1-1y_2}+S_{x_1-1y_1-1}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002102715.jpg" style="zoom:38%;"></p><p>如何求子矩阵和$S_{ij}$：两层<code>for</code>遍历<code>i</code>,<code>j</code>，</p><script type="math/tex; mode=display">S_{ij}=S_{i-1j}+S_{ij-1}-S_{i-1j-1}+a_{ij}</script><blockquote><p>主要的思想就是<a href="https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">容斥原理</a>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>差分是前缀和的逆运算</strong>，设一个数组$a_1, a_2, \dots, a_n$，现构造一个数组$b_1,b_2,\dots, b_n$，使得$a_i=b_1+b_2+\dots+b_n$，即$a$数组的元素是$b$数组的前缀和，$b$数组的元素是$a$数组的<strong>差分</strong>。则有：</p><script type="math/tex; mode=display">\begin{align*}b_1 &= a_1 \\b_2 &= a_2-a_1\\b_3 &= a_3-a_2\\&\dots \\b_n &= a_n-a_{n-1}\end{align*}</script><p>差分的作用：</p><ul><li>若有$b$数组，就可以通过求前缀和的方法求得原数组$a$，时间复杂度$O(n)$。</li><li>若要对$a$数组下标为$[l,r]$区间的一段元素都加上$c$，则要$O(n)$的时间复杂度；若考虑改动$b$数组，那只要改变两个元素，即让$b_l+c$，让$b_{r+1}-c$，则只要$O(1)$的时间复杂度，这样由数组$b$得到的数组$a$的下标为$[l,r]$的一段就都加上了$c$。</li><li>那若有了数组$a$，如何得到数组$b$：可以假设数组$a$初始全部是0，依次在区间[1,1]加上$a_1$，在区间[2,2]加上$a_2$，……，在区间[n,n]加上$a_n$，即转换到对数组$b$的操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        insert(i, i, a[i]);    <span class="comment">//求得数组b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        insert(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += b[i<span class="number">-1</span>];   <span class="comment">//求数组b的前缀和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差分也有二维的形式，原矩阵元素$a_{ij}$，差分矩阵元素$b_{ij}$，使得$a_{ij}$是差分矩阵$b_{ij}$的前缀和。</p><p>其作用也可由上面的一维差分类比过来：给矩阵$a$的某一个子矩阵（左上角为$(x_1,y_1)$，右下角为$(x_2,y_2)$）中的元素全都加上一个数$c$，可以转化成：</p><script type="math/tex; mode=display">\begin{align*}b_{x_1y_1} &+=c\\b_{x_2+1y_1} &-=c\\b_{x_1y_2+1} &-=c\\b_{x_2+1y_2+1} &+=c\end{align*}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201002131539.jpg" style="zoom:38%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">            insert(i, j, i, j, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">        insert(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, b[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Acwing算法基础第一章的内容：高精度加减乘除，前缀和，差分。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法基础（1）</title>
    <link href="http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/"/>
    <id>http://nekomoon404.github.io/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/</id>
    <published>2020-09-29T12:26:56.000Z</published>
    <updated>2020-10-03T15:27:32.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开个新坑( ･´ω`･ )，算法基础系列用来记录自己在Acwing上学习和刷题的过程。共勉。</p></blockquote><p>第一章  基础算法</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法1：<strong>快速排序</strong></p><p>快排用到了<strong>分治</strong>的思想，对一个下标左边界为$l$，下标右边界为$r$的数组，进行快速排序一般可以分为三个步骤：</p><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003221835.jpg" style="zoom:33%;"></p><p>其中最关键的是第二步-<strong>调整区间</strong>。暴力做法虽然时间复杂度是常数，但空间占用比较多（需要开额外的数组）。下面是优化后的方法：</p><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003222346.jpg" style="zoom:33%;"></p><p>在解题中为了避免在处理边界问题上浪费太多时间，可以记一些快排的模板。</p><ul><li>快排模板题：给定你一个长度为$n$的整数数列。请你使用快速排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];   <span class="comment">// x = q[l]，题目的数据加强过，写成x = q[l]会超时</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;   <span class="comment">//先把i, j往外移一位。因为后面要先移位再判断</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)  swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的时间复杂度和空间复杂度：</p><blockquote><p>分析和证明过程可以参考：<a href="https://www.cnblogs.com/HDK2016/p/6876313.html" target="_blank" rel="noopener">【算法】快速排序</a></p></blockquote><div class="table-container"><table><thead><tr><th></th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>$O(n\log n)$</td><td>$O(\log n)$</td></tr><tr><td>最坏</td><td>$O(n^2)$</td><td>$O(n)$</td></tr><tr><td>平均</td><td>$O(n\log n)$</td><td>$O(\log n)$</td></tr></tbody></table></div><ul><li><p>扩展题：<strong>快速选择</strong>。</p><p>第$k$个数：给定一个长度为$n$的整数数列，以及一个整数$k$，请用快速选择算法求出数列从小到大排序后的第$k$个数。</p><p>数据范围：$1 \le n \le 100000$，$1 \le k \le n$。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003224748.jpg" style="zoom:33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速选择，时间复杂度O(2n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( q[ ++ i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>( q[ -- j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>( i &lt; j )  swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( k &lt;= sl ) <span class="keyword">return</span> quick_sort(l, j, k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> quick_sort(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>算法2：<strong>归并排序</strong></p><p>归并排序也用到了分治的思想，通常有三个步骤：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003225129.jpg" style="zoom:33%;"></p><p>归并排序中最关键的是第三步—<strong>归并</strong>，可以使用双指针，使时间复杂度为$O(n)$。</p><ul><li><p>归并排序模板题：给定你一个长度为$n$的整数数列。请你使用归并排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。</p><p>数据范围：$1 \le n \le 100000$.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid+<span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt; q[j])  tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>扩展题：<strong>逆序数对的数量</strong></p><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i &lt; j $且 $a[i] &gt; a[j]$，则其为一个逆序对；否则不是。</p><p>数据范围：$1 \le n \le 100000$。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230124.jpg" style="zoom:33%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230127.jpg" style="zoom:33%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL res = merge_sort(q, l, mid) + merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并的过程</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j])    tmp[K ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k ++] = q[j ++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>算法3：二分查找</p><ul><li>整数的二分查找</li></ul><p><img src="/2020/09/29/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89/QQ图片20201003230519.jpg" style="zoom:33%;"></p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230523.jpg" style="zoom:33%;"></p><p>例题：给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回“-1 -1”。</p><p>数据范围：$1 \le n \le 100000$，$1 \le q \le 10000$，$1 \le k \le 10000$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查找x的左边界，性质是左边界 右面的数都大于等于x</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x)  r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != x)  <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1 -1"</span> &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//判断题目是不是无解</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">" "</span>;    </span><br><span class="line">            <span class="comment">//查找x的右边界，性质是右边界 左面的数都小于等于x </span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>浮点数二分</li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20201003230529.jpg" style="zoom:33%;"></p><p>例题：给定一个浮点数n，求它的三次方根。结果保留6位小数。</p><p>数据范围：$-10000 \le n \le 10000$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据数据范围确定l和r</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)  <span class="comment">//通常要比题目要求的精度多2位 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      开个新坑( ･´ω`･ )，算法基础系列用来记录自己在Acwing上学习和刷题的过程。Acwing算法基础第一章的内容：快速排序，归并排序，二分查找。
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://nekomoon404.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>XGBoost原理简述</title>
    <link href="http://nekomoon404.github.io/2020/09/22/XGBoost%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <id>http://nekomoon404.github.io/2020/09/22/XGBoost%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</id>
    <published>2020-09-22T12:18:46.000Z</published>
    <updated>2020-09-22T13:09:43.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>笔记主要是参考了贪心学院在B站的公开课<a href="https://www.bilibili.com/video/BV1si4y1G7Jb" target="_blank" rel="noopener">XGBoost的技术剖析</a></p><p>这篇博客也讲的十分详细：<a href="https://blog.csdn.net/wuzhongqiang/article/details/104854890" target="_blank" rel="noopener">白话机器学习算法理论+实战番外篇之Xgboost</a>，有一些上面的课程没有讲到的内容，如节点的最优切分点划分，要进行特征遍历，作者没有使用等宽或等频分桶，而是提出了等值percentiles划分算法（Weight Quantile Sketch）。</p><p>集成算法，弱分类器的概念等等就先略去了。</p></blockquote><p>根据各个弱分类器之间有无依赖关系，集成算法可以分为Boosting和Bagging：</p><ul><li>Boosting流派：各分类器之间没有依赖关系，必须串行，比如Adaboost，GBDT，Xgboost；</li><li>Bagging流派：各分类器之间没有依赖关系，可各自并行，比如随机森林。</li></ul><p>为什么XGBoost这么火？</p><ul><li><p>算法可以并行，训练效率高；</p></li><li><p>比起其他算法，世界效果好；</p></li><li><p>由于可控参数（超参数）多，可以灵活调整；</p></li></ul><p>学习路径：</p><ul><li>如何构造目标函数？（XGBoost的目标函数不是连续型的）</li><li>目标函数直接优化难，如何近似？（泰勒级数，Taylor Expansion）</li><li>如何把树的结果引入到目标函数？</li><li>仍然难优化，要不要使用贪心算法？</li></ul><h3 id="1-如何构造目标函数"><a href="#1-如何构造目标函数" class="headerlink" title="1.如何构造目标函数"></a>1.如何构造目标函数</h3><p>回顾如何使用多棵树来预测：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202546.png" style="zoom: 45%;"></p><p>假设已经训练了K颗树，则对于第$i$个样本的（最终）预测值为：</p><script type="math/tex; mode=display">\hat{y_i} = \sum^k_{k=1}f_k(x_i), \, f_k \in \mathcal{F}</script><p>目标函数为：</p><script type="math/tex; mode=display">Obj = \sum^n_{i=1} l(y_i,\hat{y_i}) + \sum^k_{k=1} \Omega(f_k)</script><p>其中前一项为损失函数，$y_i$为真实值，$\hat{y_i}$为预测值，$l(y_i,\hat{y_i})$为针对当前问题的loss；后一项为Penalty，或者称Regulation，控制模型的复杂度，防止过拟合。</p><p>现在的问题是如何给每一个树加上Penalty / Regulation。</p><p>回顾在决策树中如何定义树的复杂度：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202606.png" style="zoom:50%;"></p><p>$\sum^n_{i=1}l(y_i,\hat{y_i})$中计算了所有样本的loss，loss函数包含了不同树模型的loss，这时就可以使用叠加式的训练（Additive Training），当训练第$k$个模型（树）时，前面的第1到第$k-1$颗树是已知的。</p><p>假设现在我们要去构建第$k$颗树，</p><ul><li><p>给定$x_i$；</p></li><li><p>$\hat{y_i}^{(0)} = 0 \gets$  Default case ;</p></li><li>$\hat{y_i}^{(1)} = f_1(x_i) = \hat{y_i}^{(0)} + f_1(x_i)$；</li><li>$\hat{y_i}^{(2)} = f_1(x_i) + f_2(x_i) = \hat{y_i}^{(1)} + f_2(x_i)$；</li><li>$\dots$</li><li>$\hat{y_i}^{(k)} = f_1(x_i) + f_2(x_i) + \dots + f_k(x_i)= \sum^{k-1}_{j=1}f_j(x_i)+f_k(x_i)=\hat{y_i}^{(k-1)} + f_k(x_i)$；</li></ul><p>其中$\hat{y_i}^{(k-1)}$表示前$k-1$颗树的预测值之和，$f_k(x_i)$表示第$k$颗树的预测值，两者之和要和真实值$y_i$越接近越好。</p><p>因为前$k-1$颗树是训练好的，则目标函数可以写成：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k)}) + \sum^k_{k=1}\Omega(f_k)\\    &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \sum^{k-1}_{j=1}\Omega(f_j)+\Omega(f_k)\end{align*}</script><p>其中$\hat{y_i}^{(k-1)}$和$\sum^{k-1}_{j=1}\Omega(f_j)$可以看作是常数，则当训练第$k$颗树时，我们要最小化：</p><script type="math/tex; mode=display">minimize \quad \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k)</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202613.png" style="zoom:50%;"></p><h3 id="2-使用泰勒级数优化目标函数"><a href="#2-使用泰勒级数优化目标函数" class="headerlink" title="2.使用泰勒级数优化目标函数"></a>2.使用泰勒级数优化目标函数</h3><p>由上一节我们可知，构建第$k$颗树时的目标函数是  ：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k)\end{align*}</script><p>回顾泰勒级数Taylor Expansion：</p><script type="math/tex; mode=display">f(x+\Delta x) \approx f(x) + f'(x) \cdot \Delta x + \frac{1}{2} f^{''}(x)\cdot \Delta x^2</script><p>令其中的$f(x) = l(y_i, \hat{y_i}^{(k-1)} )$，$\Delta x= f_k(x_i)$，则有：</p><script type="math/tex; mode=display">\begin{align*}Obj &= \sum^n_{i=1} l(y_i, \hat{y_i}^{(k-1)} + f_k(x_i)) + \Omega(f_k) \\    &= \sum^n_{i=1} \left[ l(y_i, \hat{y_i}^{(k-1)} ) +\partial_{\hat{y_i}^{(k-1)}} l(y_i, \hat{y_i}^{(k-1)} ) \cdot f_k(x_i) + \frac{1}{2}\partial^2_{\hat{y_i}^{(k-1)}} l(y_i, \hat{y_i}^{(k-1)} ) \cdot f^2_k(x_i) \right]+ \Omega(f_k) \\    &= \sum^n_{i=1} \left[ l(y_i, \hat{y_i}^{(k-1)} ) +g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)\end{align*}</script><p>第一项$ l(y_i, \hat{y_i}^{(k-1)} )$是已知的，那么最下化目标函数就等价于：</p><script type="math/tex; mode=display">minimize \sum^n_{i=1} \left[ g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)</script><p>注：当训练第$k$颗树时，$\{h_i, g_i\}$是已知的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202618.png" style="zoom: 50%;"></p><h3 id="3-在树的形状已知的情况下，求目标函数的最小值"><a href="#3-在树的形状已知的情况下，求目标函数的最小值" class="headerlink" title="3.在树的形状已知的情况下，求目标函数的最小值"></a>3.在树的形状已知的情况下，求目标函数的最小值</h3><p>接下来我们要把$f_k(x_i)$和$\Omega(f_k)$参数化。考虑现有如下图的一个树，那我们如何把这颗树用参数化表示出来：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202623.png" style="zoom:50%;"></p><p>定义一个权重变量，或者称leaf value，$w=(w_1, w_2, w_3) = (15, 12, 20)$；</p><p>定义一个函数$q(x)$，表示样本$x$的位置，$q(x_1) =1, q(x_2)=3, q(x_3)= 1, q(x_4) = 2, q(x_5)=3$；</p><p>则有$f_k(x_i) = w_{q(x_i)} $ ，这样就把$f_k(x_i)$参数化了，但有个问题是$w$的下标还是个函数，为此我们还需定义一个函数$I_j=\{i | q(x_i)=j\}$，表示那些样本$x_i$会落在第$j$个位置上，它按叶节点的位置把样本重新组织。$I_1=\{1,3\},I_2=\{4\}, I_3=\{2, 5\}$。</p><p>这样我们原先以样本为单位累加得到$\sum^n_{i=1}  g_i \cdot f_k(x_i)=\sum^n_{i=1}  g_i \cdot w_{q(x_i)}$这一项，就可以换种思路，以叶节点为单位累加，以上图为例：</p><script type="math/tex; mode=display">\begin{align*}&g_1 \cdot w_{q(x_1)}+g_2 \cdot w_{q(x_2)}+g_3 \cdot w_{q(x_3)}+g_4 \cdot w_{q(x_4)}+g_5 \cdot w_{q(x_5)}\\=&g_1 \cdot w_{q(x_1)}+g_3 \cdot w_{q(x_3)}+ \\&g_2 \cdot w_{q(x_2)}+\\&g_4 \cdot w_{q(x_4)}+g_5 \cdot w_{q(x_5)}\\=& g_1 \cdot w_1+g_3 \cdot w_1+ \\&g_2 \cdot w_2+\\&g_4 \cdot w_3+g_5 \cdot w_3\\=&\sum^T_{j=1}(\sum_{i\in I_j } g_i) \cdot w_j\end{align*}</script><p>接着考虑如何定义一颗树的复杂度，可以是树的复杂度 = 叶节点个数 + leaf value，即：</p><script type="math/tex; mode=display">\Omega(f_k) = \gamma T + \frac{1}{2} \lambda \sum^T_{j=1} w_j^2</script><p>其中$T$是叶节点的个数，$w_j$是第$j$个叶节点的leaf value；$\gamma$和$\lambda$控制两部分的权重，是超参数。</p><p>最后将两部分结合起来，得到新的目标函数（<strong>假设树的形状已知</strong>）</p><script type="math/tex; mode=display">\begin{align*}& \sum^n_{i=1} \left[ g_i \cdot f_k(x_i) + h_i \cdot f^2_k(x_i) \right]+ \Omega(f_k)\\=& \sum^n_{i=1} \left[ g_i \cdot w_{q(x_i)} + h_i \cdot w^2_{q(x_i)} \right]+ \gamma T + \frac{1}{2} \lambda \sum^T_{j=1} w_j^2  \\=& \sum^T_{j=1} \left[(\sum_{i\in I_j } g_i) \cdot w_j  + \frac{1}{2}(\sum_{i\in I_j } h_i + \lambda) \cdot w^2_j\right] + \gamma T\end{align*}</script><p>令$G_j = \sum_{i\in I_j } g_i$，$H_j = \sum_{i\in I_j } h_i$，则使前一项最小的$w_j$值（回顾一元二次方程）为：</p><script type="math/tex; mode=display">w_j^* = -\frac{G_j}{H_j+\lambda}</script><p>此时目标函数的最小值为：</p><script type="math/tex; mode=display">Obj* = \frac{1}{2} \cdot \sum^T_{j=1} \frac{G_j^2}{H_j+\lambda} + \gamma T</script><p> 那么到目前我们解决了，<strong>在树的形状已知的情况下</strong>，可以求出第$k$树的最小的目标函数值。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202627.png" style="zoom:50%;"></p><p>那接下来我们要做的是在所有可能的形状的树中，寻找出$Obj^*$最小的那颗树。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202633.png" style="zoom:50%;"></p><h3 id="4-寻找树的形状"><a href="#4-寻找树的形状" class="headerlink" title="4.寻找树的形状"></a>4.寻找树的形状</h3><p>寻找树的形状可以用暴力算法（Brute Force Search），但这样做就效率太低了，复杂度也是节点个数的指数级的。 可行的方法是使用<strong>贪心算法</strong>去寻找。</p><p>回顾我们如何去构造一颗决策树。选择特征的依据是使不确定性变小，特征的score = 原（不确定性）- 分之后（不确定性），称为Information Gain（信息增益），每次分支的依据就是使信息增益最大化。那把这里的不确定性（Entropy）换成 $Obj$，就可以完成对有最小的$Obj^*$的树的寻找。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202638.png" style="zoom:50%;"></p><p>通过下面的例子来看一下如何寻找最好的树的形状，即寻找最好的Split。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922202648.png" style="zoom:50%;"></p><p>xgboost贪心建树的思路：遍历所有特征以及所有分割点，每次算最好的那个。但这样做代价太大了，尤其是数据量很大，分割点很多的时候，计算起来非常复杂并且也无法读入内存进行计算。作者提出了一种近似分割的方式（可以理解为分割点分桶的思路），选出一些候选的分裂点，然后再遍历这些较少的分裂点来找到最佳分裂点。</p><p>进行分桶候选分裂点的一般思路是根据特征值的大小进行等宽分桶，或者进行等频分桶。这样做选择出的候选点确实少了很多，但这样划分是没什么依据的，缺乏可解释性。</p><p>作者采用了一种对loss的影响权重的等值percentiles（百分比分位数）划分算法（Weight Quantile Sketch）。考虑的是想让loss在左右子树上分布的均匀一些，而不是样本数量的均匀，因为每个样本对降低loss的贡献可能不一样，按样本均分会导致分开之后左子树和右子树loss分布不均匀，</p><p>其实这里这个损失函数还可以进一步化简的（和上面的化简不一样，上面的化简是把遍历样本转到了遍历叶子上得到基于决策树的目标函数，这里是从目标函数本身出发进行化简）：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/微信图片_20200922205540.png" style="zoom:45%;"></p><p>后面的每一个分类器都是在拟合每个样本的一个残差 $\frac{g_i}{h_i}$，$h_i$可以看做计算残差时某个样本的重要性，即每个样本对降低loss的贡献程度。第一个问题说的听清楚了吧。</p><blockquote><p>Xgboost引入了二阶导之后，相当于在模型降低残差的时候给各个样本根据贡献度不同加入了一个权重，这样就能更好的加速拟合和收敛。GBDT只用到了一阶导数，这样只知道梯度大的样本降低残差效果好，梯度小的样本降低残差不好，但是好与不好的程度在GBDT中无法展现。而xgboost这里就通过二阶导可以展示出来，这样模型训的时候就有数了</p></blockquote>]]></content>
    
    <summary type="html">
    
      学习了XGBoost的原理。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
      <category term="XGBoost" scheme="http://nekomoon404.github.io/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>贷款违约预测（1）赛题理解</title>
    <link href="http://nekomoon404.github.io/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/"/>
    <id>http://nekomoon404.github.io/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/</id>
    <published>2020-09-15T11:05:51.000Z</published>
    <updated>2020-09-28T11:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-赛题概况"><a href="#1-赛题概况" class="headerlink" title="1.赛题概况"></a>1.赛题概况</h3><p>比赛地址：<a href="https://tianchi.aliyun.com/competition/entrance/531830/introduction" target="_blank" rel="noopener">零基础入门金融风控-贷款违约预测</a></p><p>本次比赛以金融风控中的个人信贷为背景，根据贷款申请人的数据信息预测其是否有违约的可能，以此判断是否通过此项贷款，是一个二分类问题。</p><p>赛题的数据来自某信贷平台的贷款记录，包括47列变量信息，其中15列为匿名变量，比赛界面有对应的数据概况介绍，说明列的性质特征。总数据量120万条，其中，训练集80万条，测试集A 20万条，测试集B 20万条。</p><p><strong>预测指标</strong>：采用AUC作为评价指标，AUC越接近1.0，模型的预测性能越好。</p><h3 id="2-二分类问题中常见的评估指标"><a href="#2-二分类问题中常见的评估指标" class="headerlink" title="2.二分类问题中常见的评估指标"></a>2.二分类问题中常见的评估指标</h3><p>1.<strong>混淆矩阵（Confuse Matrix）</strong></p><p>二分类问题的预测结果可以根据情况分成以下四类：</p><p>（1）真正 TP（True Positive）：预测值为1，真实值为1</p><p>（2）假正 FP（False Positive）：预测值为1，真实值为0</p><p>（3）真负 TN（True Negative）：预测值为1，真实值为0</p><p>（4）假负 FN（False Negative）：预测值为0，真实值为1</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915195033.png" style="zoom: 80%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y_pred = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">confusion_matrix(y_true, y_pred)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]], dtype=int64)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tn, fp, fn, tp = confusion_matrix([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).ravel()</span><br><span class="line">(tn, fp, fn, tp)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>2.<strong>准确率（Accuracy）</strong></p><p>分类正确的样本数占总样本数的比例数。准确率在样本不均衡的数据集上不适用。</p><script type="math/tex; mode=display">Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script><p>3.<strong>精确率（Precision）</strong></p><p>又称查准率，正确预测为正样本（TP）占预测为正样本（TP+FP）的比例。</p><script type="math/tex; mode=display">Percision=\frac{TP}{TP+FP}</script><p>4.<strong>召回率（Recall）</strong></p><p>又称查全率，正确预测为正样本（TP）占正样本的（TP+FN）比例。</p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FN}</script><p>5.<strong>F1 - score</strong></p><p>Precision和Recall指标有时是此消彼长的，即精准率高了，召回率就下降，在一些场景下要兼顾精准率和召回率，最常见的方法就是F-Measure，又称F-Score。F-Measure是P和R的加权调和平均，即；</p><script type="math/tex; mode=display">\frac{1}{F_{\beta}}=\frac{1}{1+\beta^2} \cdot \left( \frac{1}{P}+\frac{\beta^2}{R}\right) \\F_{\beta} = \frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P) + R}</script><p>当$\beta=1$时，也就是常见的F1-Score，是P和R的调和平均，当F1较高时，模型的性能越好。</p><script type="math/tex; mode=display">F1-Socre = \frac{2\times P \times R }{P+R}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"></span><br><span class="line">y_true = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y_pred = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'accuracy:'</span>,  metrics.accuracy_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'precision:'</span>, metrics.precision_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'recall:'</span>, metrics.recall_score(y_true, y_pred))</span><br><span class="line">print(<span class="string">'f1-score:'</span>, metrics.f1_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accuracy: <span class="number">0.25</span></span><br><span class="line">precision: <span class="number">0.3333333333333333</span></span><br><span class="line">recall: <span class="number">0.5</span></span><br><span class="line">f1-score: <span class="number">0.4</span></span><br></pre></td></tr></table></figure><p>6.<strong>P-R曲线（Precision-Recall Curve）</strong></p><p>描述精确率/召回率变化的曲线。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915201039.png" style="zoom: 60%;"></p><p>若一个学习器A的P-R曲线被另一个学习器B的P-R曲线完全包住，则称：B的性能优于A。若A和B的曲线发生了交叉，则谁的曲线下的面积大，谁的性能更优。但一般来说，曲线下的面积是很难进行估算的，所以衍生出了“平衡点”（Break-Event Point，简称BEP），即当P=R时的取值，平衡点的取值越高，性能更优。</p><p>7.<strong>ROC曲线（Receiver Operating Characteristic）</strong></p><p>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现<strong>类别不平衡（Class Imbalance）</strong>现象，即负样本比正样本多很多（或者相反），而且测试数据中的正负样本的分布也可能随着时间变化，ROC以及AUC可以很好的消除样本类别不平衡对指标结果产生的影响。</p><p>ROC曲线分别使用下面两个指标作为X轴和Y轴：</p><p>（1）真正率（True Positive Rate , TPR），又称灵敏度（sensitivity）：（其实和召回率一样）</p><script type="math/tex; mode=display">TPR = \frac{TP}{TP+FN}</script><p>（2）假正率（False Positive Rate , FPR），又称特异度（specificity）：</p><script type="math/tex; mode=display">FPR = \frac{FP}{TN+FP}</script><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200915202153.png" style="zoom:50%;"></p><p>8.<strong>AUC（Area Under Curve）</strong></p><p>曲线下面积，是处于ROC Curve下方的那部分面积的大小。对于ROC曲线下方面积越大表明模型性能越好，于是AUC就是由此产生的评价指标。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了模型较好的性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">y_true = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">y_score = np.array([<span class="number">0.1</span>, <span class="number">0.4</span>, <span class="number">0.35</span>, <span class="number">0.8</span>])</span><br><span class="line">fpr, tpr, thresholds = metrics.roc_curve(y_true, y_score, pos_label=<span class="number">2</span>) </span><br><span class="line">auc=metrics.auc(fpr, tpr)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'ROC'</span>)</span><br><span class="line">plt.plot(fpr, tpr,<span class="string">'b'</span>,label=<span class="string">'AUC = %0.4f'</span>% auc)</span><br><span class="line">plt.legend(loc=<span class="string">'lower right'</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'TPR'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'FPR'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/09/15/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3/output_4_1.png" style="zoom:80%;"></p><blockquote><p>参考：<a href="https://www.cnblogs.com/guoyaohua/p/classification-metrics.html" target="_blank" rel="noopener">【机器学习】一文读懂分类算法常用评价指标</a></p></blockquote><hr><p>Task02-Task05:</p><ul><li>数据探索性分析</li><li>特征工程</li><li>建模与调参</li><li>模型融合</li></ul><p>notebook已上传到<a href="https://github.com/nekomoon404/data-mining/tree/master/FinancialRiskControl" target="_blank" rel="noopener">GitHub仓库</a>，线上成绩为0.7360，仍需继续努力。</p>]]></content>
    
    <summary type="html">
    
      Datawhale的0基础入门金融风控之贷款违约预测挑战赛的Task1：赛题理解，后四个Task已放到Github上。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://nekomoon404.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>DL笔记（16）Transfer Learning</title>
    <link href="http://nekomoon404.github.io/2020/08/13/ML%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89Transfer-Learning/"/>
    <id>http://nekomoon404.github.io/2020/08/13/ML%E7%AC%94%E8%AE%B0%EF%BC%8816%EF%BC%89Transfer-Learning/</id>
    <published>2020-08-13T00:51:13.000Z</published>
    <updated>2020-08-13T02:56:46.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>Transfer learning（迁移学习），是属于机器学习的一种研究领域，它专注于存储已有问题的解决模型，并将其利用在其他不同但相关问题上，正如人类可以将一个领域学习到的知识和经验，应用到其他相似的领域中去一样，机器同样也能做到。</p><p>传统的机器学习/数据挖掘只有在训练集数据和测试集数据都来自同一个feature space（特征空间）和统一分布的时候才运行的比较好，这意味着每一次换了数据都要重新训练模型，太麻烦了。比如：</p><p>（1）从数据类型/内容上看，对于新的数据集，获取新的训练数据很贵也很难。</p><p>（2）从时间维度上看，有些数据集很容易过期，即不同时期的数据分布也会不同。</p><blockquote><p>Transfer learning的概念参考了这篇博客<a href="https://cloud.tencent.com/developer/article/1636741" target="_blank" rel="noopener">迁移学习</a></p></blockquote><p><strong>not directly related</strong></p><p>以猫狗识别为例，解释“不直接相关”的含义：</p><ul><li><p>input <strong>domain（域）</strong>是类似的，但task是无关的，比如输入都是动物的图像，但这些data是属于另一组有关大象和老虎识别的task；</p></li><li><p>input domain是不同的，但task是一样的，比如task同样是做猫狗识别，但输入的是卡通类型的图像。</p></li></ul><blockquote><p>domain：包括两部分：1.feature space（特征空间）；2.probability（概率）。所以当我们说domain不同的时候，就得分两种情况。可能是feature space不同，也可能是feature space一样但probability不同。这里指的是前者，即feature space不同。</p></blockquote><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090714.png" style="zoom: 50%;"></p><p><strong>overview</strong></p><p>迁移学习是很多方法的集合，这里介绍一些概念：</p><ul><li>Target Data：和task直接相关的data；</li><li>Source Data：和task没有直接关系的data。</li></ul><blockquote><p>source是用于训练模型的域/任务，target是要用前者的模型对自己的数据进行预测/分类/聚类等机器学习任务的域/任务。</p></blockquote><p>按照labeled data和unlabeled data又可以划分为四种：</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090728.png" style="zoom: 50%;"></p><h3 id="2-labelled-source-data-amp-labeled-target-data"><a href="#2-labelled-source-data-amp-labeled-target-data" class="headerlink" title="2. labelled source data &amp; labeled target data"></a>2. labelled source data &amp; labeled target data</h3><p>这里target data和source data都是带有标签的：</p><ul><li><p>target data：$(x^t,y^t)$，作为有效数据，通常量是很少的。如果target data量非常少，则被称为one-shot learning；</p></li><li><p>source data：$(x^s, y^s)$，作为不直接相关数据，通常量是很多的。</p></li></ul><h4 id="2-1-Model-Fine-tuning"><a href="#2-1-Model-Fine-tuning" class="headerlink" title="2.1. Model Fine-tuning"></a>2.1. Model Fine-tuning</h4><p>Model Fine-tuning（模型微调）的基本思想：用source data去训练一个model，再用target data对model进行fine-tune（微调）。“微调”类似于pre-training，就是把用source data训练出的model参数当做是参数的初始值，再用target data继续训练下去即可，但当直接相关的数据量非常少时，这种方法很容易会出问题。所以训练的时候要小心，有许多技巧值得注意。</p><p><strong>Conservation Training</strong></p><p>如果现在有大量的source data，比如在语音识别中有大量不同人的声音数据，可以拿它去训练一个语音识别的神经网络，而现在你拥有的target data，即特定某个人的语音数据，可能只有十几条左右，如果直接拿这些数据去再训练，肯定得不到好的结果</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090732.png" style="zoom:50%;"></p><p>此时我们就需要在训练的时候加一些限制，让用target data训练前后的model不要相差太多：</p><ul><li>可以让新旧两个model在看到同一笔data的时候，output越接近越好；</li><li>或者让新旧两个model的L2 norm越小越好，参数尽可能接近；</li><li>总之让两个model不要相差太多，防止由于target data的训练导致过拟合。</li></ul><p>这里的限制就类似于做regularization。</p><p><strong>Layer Transfer</strong></p><p>现在我们已经有一个用source data训练好的model，此时把该model的某几个layer拿出来复制到同样大小的新model里，接下来<strong>用target data去训练余下的没有被复制到的layer</strong>。这样做的好处是target data只需要考虑model中非常少的参数，这样就可以避免过拟合。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090735.png" style="zoom:50%;"></p><p>这个对部分layer进行迁移的过程，就体现了迁移学习的思想，那么哪些layer需要被复制迁移，哪些不需要呢？</p><p>值得注意的是，<strong>在不同的task上，需要被复制迁移的layer往往是不一样的</strong>：</p><ul><li><p>在语音识别中，往往迁移的是最后几层layer，再重新训练与输入端相邻的那几层。</p><p>由于人口腔结构不同，同样的发音方式得到的发音是不一样的，NN的前几层会从声音信号里提取出发音方式，再用后几层判断对应的词汇，从这个角度看，NN的后几层是跟特定的人没有关系的，因此可做迁移。</p></li><li><p>在图像处理中，往往迁移的是前面几层layer，再重新训练后面的layer。</p><p>CNN在前几层通常是做最简单的识别，比如识别是否有直线斜线、是否有简单的几何图形等，这些layer的功能是可以被迁移到其它task上通用的。</p></li><li><p>主要还是具体问题具体分析。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090739.png" style="zoom:50%;"></p><h4 id="2-2-Multitask-Learning"><a href="#2-2-Multitask-Learning" class="headerlink" title="2.2. Multitask Learning"></a>2.2. Multitask Learning</h4><p>Fine-tune仅考虑在target data上的表现，而Multitask Learning（多任务学习），则是同时考虑model在source data和target data上的表现。</p><p>如果两个task的输入特征类似，则可以用同一个神经网络的前几层layer做相同的工作，到后几层再分方向到不同的task上，这样做的好处是前几层得到的data比较多，可以被训练得更充分。有时候task A和task B的输入输出都不相同，但中间可能会做一些类似的处理，则可以让两个神经网络共享中间的几层layer，也可以达到类似的效果。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090743.png" style="zoom:50%;"></p><p>以上方法要求不同的task之间要有一定的“共性”，这样才有共用一部分layer的可能性。</p><p><strong>Multilingual Speech Recognition</strong></p><p>多任务学习可以应用在语音识别上，比如可以同时对法语、德语、西班牙语、意大利语训练一个model，它们在前几层layer上共享参数，而在后几层layer上拥有自己各自的参数。在机器翻译上也可以使用同样的思想，比如训练一个同时可以中翻英和中翻日的model。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090746.png" style="zoom:50%;"></p><p>注属于同一个语系的语言翻译，比如欧洲国家的语言，几乎都是可以做迁移学习的；而语音方面则可迁移的范围更广。下图展示了只用普通话的语音数据和加了欧洲语言后的语音数后得到的错误率对比，其中横轴为使用的普通话数据量，纵轴为错误率，可以看出使用了迁移学习后，只需要原先一半的普通话语音数据就可以得到几乎一样的准确率</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090749.png" style="zoom: 50%;"></p><h4 id="2-3-Progressive-Neural-Network"><a href="#2-3-Progressive-Neural-Network" class="headerlink" title="2.3. Progressive Neural Network"></a>2.3. Progressive Neural Network</h4><p>如果两个task完全不相关，硬是把它们拿来一起训练反而会起到负面效果。而在Progressive Neural Network（渐进式神经网络）中，每个task对应model的hidden layer的输出都会被接到后续model的hidden layer的输入上，这样做的好处是：</p><ul><li>task 2的data并不会影响到task 1的model，因此task 1一定不会比原来更差；</li><li><p>task 2虽然可以借用task 1的参数，但可以将之直接设为0，最糟的情况下就等于没有这些参数，也不会对本身的表现产生影响；</p></li><li><p>task 3也做一样的事情，同时从task 1和task 2的hidden layer中得到信息。</p></li></ul><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090753.png" style="zoom:50%;"></p><blockquote><p>论文<a href="https://arxiv.org/pdf/1606.04671.pdf" target="_blank" rel="noopener">arxiv.org/pdf/1606.04671.pdf)</a></p><p>关于Progressive Neural Network可以参考：<a href="https://www.cnblogs.com/wangxiaocvpr/p/6002214.html" target="_blank" rel="noopener">论文笔记之：Progressive Neural Network Google DeepMind</a>；<a href="https://zhuanlan.zhihu.com/p/146454996" target="_blank" rel="noopener">Progressive Neural Network</a></p></blockquote><h3 id="3-labelled-source-data-amp-unlabeled-target-data"><a href="#3-labelled-source-data-amp-unlabeled-target-data" class="headerlink" title="3. labelled source data &amp; unlabeled target data"></a>3. labelled source data &amp; unlabeled target data</h3><p>下面介绍target data不带标签，而source data带标签的情况：</p><ul><li><p>target data：$(x^t)$</p></li><li><p>source data：$(x^s, y^s)$</p></li></ul><h4 id="3-1-Domain-adversarial-Training"><a href="#3-1-Domain-adversarial-Training" class="headerlink" title="3.1. Domain-adversarial Training"></a>3.1. Domain-adversarial Training</h4><p>如果source data是有label的，而target data是没有label的，该怎么处理呢？比如source data是labeled MNIST数字集，而target data则是加了颜色和背景的unlabeled数字集，虽然都是做数字识别，但两者的情况是非常不匹配的。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090756.png" style="zoom:50%;"></p><p>这个时候一般会把source data当做训练集，而target data当做测试集，如果不管训练集和测试集之间的差异，直接训练一个普通的model，得到的结果准确率会相当低。实际上，神经网络的前几层可以被看作是在抽取feature，后几层则是在做classification。如果把用MNIST训练好的model所提取出的feature做t-SNSE降维后的可视化，可以发现MNIST的数据特征明显分为紫色的十团，分别代表10个数字，而作为测试集的数据却是挤成一团的红色点，因此它们的特征提取方式根本不匹配。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090801.png" style="zoom:50%;"></p><p>所以我们希望前面的特征提取器(feature extractor)可以把domain的特性去除掉，不再使红点与蓝点分成两群，而是让它们都混在一起。这样我们就可以将用黑白MNIST训练好的model用在彩色MNIST数据上。</p><p>这里采取的做法是，在特征提取器(feature extractor)之后接一个<strong>域分类器(domain classifier)</strong>，以便分类出这些提取到的feature是来自于MNIST的数据集还是来自于MNIST-M的数据集，这个生成+辨别的架构与GAN非常类似。</p><p>只不过在这里，feature extractor可以通过把feature全部设为0，很轻易地骗过domain classifier，因此还需要给feature classifier增加任务的难度，它不只要骗过domain classifier，还要同时满足label predictor的需求。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090806.png" style="zoom: 50%;"></p><p>此时通过特征提取器得到的feature不仅可以消除不同domain的特性，还要保留原先digit的特性，既可以区分不同类别的数字集，又可以正确地识别出不同的数字。</p><p>通常神经网络的参数都是朝着最小化loss的目标共同前进的，但在这个神经网络里，三个组成部分的参数“各怀鬼胎”：</p><ul><li>对Label predictor，要把不同数字的分类准确率做的越高越好；</li><li>对Domain classifier，要正确地区分某张image是属于哪个domain；</li><li>对Feature extractor，要提高Label predictor的准确率，但要降低Domain classifier的准确率。</li></ul><p>这里可以看出，Feature extractor和Domain classifier的目标是相反的，要做到这一点，只需要在两者之间加一层梯度反转的layer即可（给domain classifier的梯度乘一个$-\lambda$），当NN做backward的时候，两者的参数更新往相反的方向走。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090809.png" style="zoom:50%;"></p><p>注意到，Domain classifier只能接受到Feature extractor给到的特征信息，而无法直接看到图像的样子，因此它最后一定会鉴别失败，所以如何提高Domain classifier的能力，让它经过一番“奋力挣扎”之后才牺牲是很重要的，如果它一直很弱，就无法把Feature extractor的潜能激发到极限。</p><h4 id="3-2-Zero-shot-Learning"><a href="#3-2-Zero-shot-Learning" class="headerlink" title="3.2. Zero-shot Learning"></a>3.2. Zero-shot Learning</h4><p>同样是source data有label，target data没有label的情况，但在Zero-shot Learning中的定义更严格一些，它假设source和target是两个完全不同的task，数据完全不相关。</p><p>在语音识别中，经常会遇到这个问题，毕竟词汇千千万万，总有一些词汇是训练时不曾遇到过的，它的处理方法是不要直接将识别的目标定成word，而是定成phoneme(音素)，再建立文字与phoneme之间的映射表即可。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090812.png" style="zoom:50%;"></p><p>在图像处理中，我们可以把每个类别都用其<strong>属性（attribute）</strong>表示，并且要具备独一无二的属性，在数据集中把每种动物按照特性划分，比如是否毛茸茸、有几只脚等，在训练的时候我们不直接去判断类别，而是去判断该图像的属性，再根据这些属性去找到最契合的类别即可。</p><p>有时候属性的维数也很大，以至于我们对属性要做embedding的降维映射，同样的，还要把训练集中的每张图像都通过某种转换投影到embedding space上的某个点，并且要保证属性投影的$g(y^i)$和对应图像投影的$f(x^i)$越接近越好，这里的$f()$和$g()$可以是两个神经网络。当遇到新的图像时，只需要将其投影到相同的embedding space，即可判断它与哪个属性对应的类别更接近。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813090816.png" style="zoom:50%;"></p><p>但如果我们根本就无法找出每个动物的属性$y^i$是什么，那该怎么办？可以使用word vector，比如直接从维基百科上爬取图像对应的文字描述，再用word vector降维提取特征，映射到同样的空间即可。</p><p>以下这个loss function存在些问题，它会让model把所有不同的x和y都投影到同一个点上：</p><script type="math/tex; mode=display">f^*,g^*=\arg \min\limits_{f,g} \sum\limits_n ||f(x^n)-g(y^n)||_2</script><p>类似用t-SNE的思想，我们既要考虑同一对$x^n$和$y^n$距离要接近，又要考虑不属于同一对的$x^n$与$y^m$距离要拉大(这是前面的式子没有考虑到的)，于是有：</p><script type="math/tex; mode=display">f^*,g^*=\arg \min\limits_{f,g} \sum\limits_n \max(0, k-f(x^n)\cdot g(y^n)+\max\limits_{m\ne n} f(x^n)\cdot g(y^m))</script><p>其中$\max()$项的最小值是0，当：</p><script type="math/tex; mode=display">k-f(x^n)\cdot g(y^n)+\max\limits_{m\ne n} f(x^n)\cdot g(y^m)<0</script><p>即：</p><script type="math/tex; mode=display">f(x^n)\cdot g(y^n)-\max\limits_{m\ne n} f(x^n)\cdot g(y^m)>k</script><p>就表明此时$f(x^n)$和$g(y^n)$的inner product很大，即两者很接近，而$f(x^n)$和其他的$g(y^m)$即差的很远，它们的inner product很小。</p><p><strong>convex combination of semantic embedding</strong></p><p>还有另外一个简单的Zero-Shot learning的方法叫做convex combination of semantic embedding。假设我们现在有一个语音辨识系统，有一个word vector，这两个是从网络上下载下来的，就可以做这件事情。</p><p>我把一张图丢到neural network里面去，它的output没有办法决定是哪一个class，但它觉得有0.5的几率是lion，有0.5的几率是tiger。接下来你在去找lion跟tiger的word vector，然后把lion跟tiger的word vector得到新的vector(用1:1的比例混合,0.5V(tiger)+0.5V(lion))，那你再看哪一个word的vector跟这个混合之后的结果最接近。假设是liger最接近，那这个东西就是liger(狮虎)。这样就省去了Training。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813102225.png" style="zoom: 33%;"></p><p>Zero-shot Learning in Machine Translation</p><p>下面是一个机器翻译的例子，Google Neural Machine Translation。在training的时候，machine看过如何把英文翻译成韩文，知道怎么把韩文翻译为英文，知道怎么把英文翻译为日文，知道怎么把日文翻译为英文。但是它从来没有看过日文翻译韩文的data，但是可以翻，但是它从来没有看过韩文翻译日文的data，但是可以翻。</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813103134.png" style="zoom: 40%;"></p><p>为什么zero-shot在这个task上是可行的呢？如果你今天用同一个model做了不同语言之间的translation以后，machine可以学到的事情是：对不同语言的input 句子都可以project（投影）到同一个space上面。句子在这个space上的位置只跟句子的semantic有关。</p><p>比如现在根据learn好的translation，那个translation有一个encoder，它会把input的句子变成vector，decoder根据这个vector解回一个句子，就是翻译的结果。那把不同语言都丢到这个encoder里面让它变成vector的话，那这些不同语言的不同句子在这个space上面有什么不一样的关系呢？</p><p><img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20200813103139.png" style="zoom: 40%;"></p><p>它发现有日文、英文、韩文这三个句子，这三个句子讲的是同一件事情，通过encoder embedding之后，它们在space上面是差不多的位置。machine做的是发现一个sequence language，每一种不同的语言都先要先转成它知道的sequence language，在用这个sequence language转为另外一种语言。所以对某一个翻译task ，你的input语言和output语言machine没有看过，它也可以透过这种自己学出来的sequence language来做translation。</p><p>——————</p><p>最后简单介绍下Transfer Learning的另外两种情况：</p><ul><li><p>Target data有label，source data没有label:  <strong>Self-taught learning</strong>。它的基本思想是：</p><ul><li>Learning to extract better representation from the source data(unsupervised approach)</li><li>Extracting better representation for target data</li></ul><p>Self-taught learning和semi-supervised learning有些不一样的地方，semi-supervised learning在learning的时候会有一些labelled data和unlabeled data，可以说source data是unlabeled data，target data是label data，所以Self-taught learning也是一种semi-supervised learning。但它和一般的semi-supervised learning有些不一样，一般的semi-supervised learning会假设unlabeled data至少和labelled data是有关系的，但在Self-taught learning中，source data和target data的关系是比较远的。</p></li><li><p>Target label没有label，source data也没有label: <strong>Self-taught clustering</strong>。</p></li></ul><blockquote><p>论文：<a href="http://ai.stanford.edu/~hllee/icml07-selftaughtlearning.pdf" target="_blank" rel="noopener">Self-taught learning</a>；<a href="https://www.cse.ust.hk/~qyang/Docs/2008/dwyakicml.pdf" target="_blank" rel="noopener">Self-taught clustering</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      文本主要介绍了Transfer Learning（迁移学习）的两种类型：labelled source data &amp; labeled target data；labelled source data &amp; unlabeled target data。
    
    </summary>
    
    
      <category term="Deep Learning" scheme="http://nekomoon404.github.io/categories/Deep-Learning/"/>
    
    
      <category term="Transfer Learning" scheme="http://nekomoon404.github.io/tags/Transfer-Learning/"/>
    
      <category term="Model Fine-tuning" scheme="http://nekomoon404.github.io/tags/Model-Fine-tuning/"/>
    
      <category term="Multitask Learning" scheme="http://nekomoon404.github.io/tags/Multitask-Learning/"/>
    
      <category term="Progressive Neural Network" scheme="http://nekomoon404.github.io/tags/Progressive-Neural-Network/"/>
    
      <category term="Domain-adversarial Training" scheme="http://nekomoon404.github.io/tags/Domain-adversarial-Training/"/>
    
  </entry>
  
</feed>
